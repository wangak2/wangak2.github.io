<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>丹青两幻</title>
  
  <subtitle>欢迎~</subtitle>
  <link href="https://wangak.cc/atom.xml" rel="self"/>
  
  <link href="https://wangak.cc/"/>
  <updated>2024-03-04T04:17:10.148Z</updated>
  <id>https://wangak.cc/</id>
  
  <author>
    <name>丹青两幻</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MedSegDiff-v2</title>
    <link href="https://wangak.cc/posts/2d77667e.html"/>
    <id>https://wangak.cc/posts/2d77667e.html</id>
    <published>2024-03-13T16:00:00.000Z</published>
    <updated>2024-03-04T04:17:10.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MedSegDiff-v2"><a href="#MedSegDiff-v2" class="headerlink" title="MedSegDiff-v2"></a>MedSegDiff-v2</h2><p><strong>本文的贡献包括：</strong></p><ul><li>第一个将Transformer集成到基于扩散的通用医学图像分割模型中。 </li><li>提出了具有U-SA(Uncertain Spatial Attention)的Anchor Condition以减小扩散方差。</li><li>提出了具有SS-Former的Semantic Condition，以建模分割噪声和语义特征的相互作用。 </li><li>在包括5种图像模态的20个器官分割任务上实现了SOTA性能。</li></ul><h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构<img src="https://typoraimg.wangak.cc/2023/img/202403041215805.png" alt="image-20240104151754725"></h3><p><strong>条件模型（绿色UNet)：</strong>从原始图像中提取分割特征</p><p><strong>扩散模型（蓝色UNet)：</strong>有两个输入分别是锚点条件（蓝色箭头）和噪声分割信息（黑色箭头）</p><h3 id="锚定条件与U-SA"><a href="#锚定条件与U-SA" class="headerlink" title="锚定条件与U-SA"></a>锚定条件与U-SA</h3><p><strong>锚点条件：</strong>将条件模型的解码分割特征整合到扩散模型的编码器特征中（蓝色箭头）</p><p><strong>U-SA机制</strong>用于从条件模型中提取一个粗糙的锚点特征，并将其整合到扩散模型中，为扩散模型提供了一个正确的预测范围，同时也让它进一步完善了预测结果，具体做法如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403041215835.png" alt="image-20240104161300625" style="zoom:67%;"></p><p><em>注1：<script type="math/tex">f_c^{-1}</script>是来自原始图像的条件分割特征，<script type="math/tex">f_d^0</script>是噪声分割图像的扩散特征</em></p><p><em>注2：<script type="math/tex">k_{Gauss}</script>为高斯卷积核目的是做平滑处理，然后取最大值是为了保留最相关的信息并且消除一些噪声和不必要的细节</em></p><h3 id="语义条件与SS-Former"><a href="#语义条件与SS-Former" class="headerlink" title="语义条件与SS-Former"></a>语义条件与SS-Former</h3><p><strong>SS-Former：</strong>使得模型可以学习条件语义特征与噪声信息的交互。</p><p>具体设计如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403041215516.png" alt="image-20240104164023507"></p><p><strong><script type="math/tex">M=(F(c_0)W_q)(F(e)W_k)^T</script></strong></p><p><em>注1：绿色为语义信息，蓝色为噪声信息</em></p><p><em>注2：<script type="math/tex">W_q</script>和<script type="math/tex">W_k</script>是可学习的权重参数，它们用于线性映射，以调整语义信息和噪声信息之间的关系</em></p><p><strong>NBP-Filter:</strong>将语义信息和噪声信息交互得到的结果M调整到统一的频率范围(扩散模型生成的过程中具有一定的随机性，这种随机性会对数据进行一些扰动，NBP-Filter降低扩散生成过程中引入的随机性的影响)</p><p>NBP-Filter<strong>从坐标图学习权重图，坐标图的每个点代表了不同的频率分量，并且使用两个MLP层将时间信息投影到两个值</strong>，这两个值分别用于缩放和移位，然后使用得到的缩放因子和移位因子去调整坐标图的表示。</p><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p><strong>表1：MedSegDiff-V2在不同图像模态上与SOTA分割方法的比较。灰色背景表示这些方法是为特定任务提出的。</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403041215578.png" alt="image-20240105132907016"></p><p>注：REFUGE2（眼底图像）、BraTs （脑肿瘤分割)、TNMIX(甲状腺结节分割)、ISIC（皮肤病变分割）</p><p><strong>表2：使用Dice分数评估MedSegDiff-V2与SOTA分割方法在AMOS数据集上的比较。最佳结果以粗体表示。</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403041215186.png" alt="image-20240105133848749"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403041215066.png" alt="image-20240105134743328" style="zoom:50%;"></p><p><strong>表3：MedSegDiff-V2在BTCV数据集上与其他先进分割方法的比较结果的表格。Dice Score用于评估模型性能，最佳结果以粗体标注。</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403041215270.png" alt="image-20240105135108153"></p><h3 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a><strong>消融实验</strong></h3><p><img src="https://typoraimg.wangak.cc/2023/img/202403041215511.png" alt="image-20240105135511006"></p><p>提出的U-SA在所有数据集上均优于先前的空间注意力。</p><p>仅使用SS-Former提供了较小的改进，但与NBP-Filter结合使用则带来了显著的改进，证明了提出的SS-Former设计的有效性。</p><h3 id="采样次数对模型效果的影响"><a href="#采样次数对模型效果的影响" class="headerlink" title="采样次数对模型效果的影响"></a>采样次数对模型效果的影响</h3><p>扩散模型具有一定的随机性，所以需要进行多次采样，然后将采样后的结果集成在一起。</p><p><strong>作者评估了各种基于扩散的医学分割模型的采样次数对模型效果的影响</strong><img src="https://typoraimg.wangak.cc/2023/img/202403041215838.png" alt="image-20240105140410979" style="zoom: 67%;"></p><p>最佳性能在大约50个集成后实现</p><p>MedSegDiff-V2其他扩散方法进行比较时，观察到它需要更少的采样次数来收敛。</p><p>MedSegDiff-V2更优越的起始点和更稳定的预测可以导致更高的性能上限</p><p><strong>作者在REFUGE2-Cup数据集上讨论了样本多样性对模型效果的影响</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403041215579.png" alt="image-20240105143354543" style="zoom:67%;"></p><p><strong>CI(置信区间):</strong>置信区间越大，一致性越好。</p><p><strong>GED(广义能量距离)：</strong>GED越低，表示一致性越好。</p><p>U-SA在CI方面较低，而在GED方面较高，表明样本的多样性较大，表明其生成的样本大部分落在目标的不确定性区域内，效果不好。</p><p>而单独使用SS-Former而没有U-SA时，该模型在CI最高、GED最低的情况下达到了最好的一致性，未能充分利用扩散模型的多样性集成能力。</p><p>将U-SA和SS-Former组合成MedSegDiff-V2，性能得到了显著提高，表明SS-Former有助于减轻U-SA中生成的噪声，而U-SA为模型提供了更多的多样性，从而相互改进。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MedSegDiff-v2&quot;&gt;&lt;a href=&quot;#MedSegDiff-v2&quot; class=&quot;headerlink&quot; title=&quot;MedSegDiff-v2&quot;&gt;&lt;/a&gt;MedSegDiff-v2&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文的贡献包括：&lt;/strong&gt;&lt;</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>ConvFormer</title>
    <link href="https://wangak.cc/posts/badf7b43.html"/>
    <id>https://wangak.cc/posts/badf7b43.html</id>
    <published>2024-03-03T16:00:00.000Z</published>
    <updated>2024-03-04T08:16:17.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ConvFormer"><a href="#ConvFormer" class="headerlink" title="ConvFormer"></a>ConvFormer</h2><p><strong>论文：《ConvFormer: Plug-and-Play CNN-Style Transformers for Improving Medical Image Segmentation》（MICCAI 2023）</strong></p><p><strong>以往方法的不足：</strong></p><p>由于训练数据的不足，transformers效果较差（另一方面，医学图像本身的高冗余性）</p><p>在CNN-Transformer混合方法中，一方面，训练数据不足会使得transformers学习到次优的长距离依赖性，另一方面，直接将CNNs与transformers结合会使得网络偏向于学习CNNs，因为与transformers相比，CNNs的收敛性更容易实现，特别是在小规模训练数据上。</p><p>为解决该问题，作者提出了一个名为<strong>ConvFormer</strong>的即插即用模块</p><h3 id="网络结构："><a href="#网络结构：" class="headerlink" title="网络结构："></a><strong>网络结构：</strong></h3><p><img src="/posts/badf7b43.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20240304145207066.png" alt="image-20240304145207066" style="zoom:67%;"></p><p><strong>卷积+池化：</strong></p><p>上图最左边是传统的ViT，用一个个的patch作为自注意力的输入。</p><p>而作者用二维图像直接建立足够长的长程依赖，而不是分割为一堆一维序列，对于一个输入的图像通过卷积和池化来降低分辨率。</p><p><em>注：</em></p><p><em>1.上图中CBR是指卷积、批量归一化和Relu的组合</em></p><p><em>2.d为ViT中的每个patch大小S的对数</em></p><p>在此过程中，<img src="/posts/badf7b43.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20240304150529624.png" alt="image-20240304150529624" style="zoom: 25%;"></p><p>其中，Cm对应于ViT中的嵌入维度</p><p><strong>CNN风格的自关注：</strong>为卷积+池化模块处理后的特征构建了一个自适应的卷积核</p><ul><li><p>利用可学习的矩阵乘上输入进来的特征，得到QKV：</p><p><img src="/posts/badf7b43.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20240304151242512.png" alt="image-20240304151242512" style="zoom:50%;"></p></li><li><p>Q和K按照如下方式进行计算(余弦相似度)，对应于ViT里面的注意力分数计算：</p><p><img src="/posts/badf7b43.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20240304151521415.png" alt="image-20240304151521415" style="zoom: 67%;"></p></li></ul><p><em>注1：Q和K作为分母，这样一来I矩阵的元素就不太容易变成0（如果某些位置的注意力值为0，那么表示模型在计算该位置的输出时不考虑与其他位置的相关性，可能导致模型在捕捉输入序列中重要的依赖关系和特征时出现问题。）</em></p><p><em>注2：<script type="math/tex">c_q</script>对应于ViT中𝑄、𝐾和𝑉的嵌入维度</em></p><ul><li>引入一个可学习的高斯距离图M：</li></ul><p><img src="/posts/badf7b43.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20240304151953190.png" alt="image-20240304151953190" style="zoom: 67%;"></p><p><em>注1：𝜃 ∈ (0, 1) 是一个可学习的网络参数，用于控制𝐴的感受野，𝛼 是一个超参数，用于控制感受野的倾向性。</em></p><p><em>注2：𝜃与感受野成正比。𝛼越大,𝐴越倾向于具有全局感受野。</em></p><p><strong>CFFN：</strong>仅由1 × 1卷积、批处理归一化和Relu两种组合组成。通过替换ViT中的线性投影和层归一化，CFFN使ConvFormer完全基于CNN，避免了CNN-Transformer混合方法在训练过程中CNN和Transformer之间的冲突。</p><h3 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h3><p><img src="/posts/badf7b43.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20240304160737425.png" alt="image-20240304160737425" style="zoom:67%;"></p><p><em>注：ACDC(心脏诊断)、ISIC（皮肤病变）、ICH（血肿分割）</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ConvFormer&quot;&gt;&lt;a href=&quot;#ConvFormer&quot; class=&quot;headerlink&quot; title=&quot;ConvFormer&quot;&gt;&lt;/a&gt;ConvFormer&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;论文：《ConvFormer: Plug-and-Play </summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>智能指针</title>
    <link href="https://wangak.cc/posts/38a918c7.html"/>
    <id>https://wangak.cc/posts/38a918c7.html</id>
    <published>2023-12-27T16:00:00.000Z</published>
    <updated>2023-12-28T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-RAll"><a href="#1-RAll" class="headerlink" title="1.RAll"></a>1.RAll</h3><p>RAII：用于有效地管理资源的获取和释放。</p><p>基本思想：资源的获取应当在对象的构造函数中进行，而资源的释放则应当在对象的析构函数中进行。</p><p><strong>RAII 的主要优势：</strong></p><ul><li>RAII 可以确保资源的正确获取和释放，避免了手动管理资源时可能发生的错误。</li><li>当使用 RAII 时，如果在构造函数中发生异常，对象会在析构函数中自动被销毁，从而保证资源被正确释放。</li></ul><h3 id="2-智能指针"><a href="#2-智能指针" class="headerlink" title="2.智能指针"></a>2.智能指针</h3><h4 id="2-1-普通指针存在的问题"><a href="#2-1-普通指针存在的问题" class="headerlink" title="2.1 普通指针存在的问题"></a>2.1 普通指针存在的问题</h4><p><strong>内存泄漏：</strong> 使用普通指针时，需要手动分配和释放内存，这就需要确保在适当的时候调用 <code>delete</code> 或 <code>delete[]</code> 来释放动态分配的内存，否则会导致会导致内存泄漏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态分配一个整数的内存</span></span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忘记释放内存</span></span><br><span class="line">    <span class="comment">// delete ptr;  // 此行代码注释掉了，导致内存泄漏</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：普通指针不会自动调用析构函数。</em></p><p><strong>悬挂指针：</strong>程序中的某个部分释放了一块动态分配的内存，而其他部分仍然持有指向该内存的指针，并尝试使用或修改这个指针所指向的内存时，就会导致悬挂指针问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">// 分配动态内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ptr;  <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptr 现在是悬挂指针，指向已释放的内存</span></span><br><span class="line">    <span class="comment">// 下面的访问操作是未定义行为</span></span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-std-shared-ptr"><a href="#2-2-std-shared-ptr" class="headerlink" title="2.2 std::shared_ptr"></a>2.2 std::shared_ptr</h4><p><strong><code>std::shared_ptr:</code></strong>共享式智能指针,允许多个指针共享对同一对象的所有权，通过引用计数机制来管理资源的生命周期。</p><p><strong>创建和初始化：</strong></p><ul><li><strong>方法一：使用<code>std::make_shared</code>(好)</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 std::make_shared 创建 shared_ptr</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>方法二：使用构造函数</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用构造函数创建 shared_ptr</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sharedPtr2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br></pre></td></tr></table></figure><p><strong>共享所有权：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass constructed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass destructed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 shared_ptr 共享同一个对象</span></span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; sharedPtr1 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; sharedPtr2 = sharedPtr1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当最后一个 shared_ptr 离开作用域时，对象的析构函数会被调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引用计数：</strong>使用计数器，记录当前有多少个指针（引用）指向该资源。当计数器为零时，表示没有任何指针指向该资源，资源可以被释放。</p><p><em>注：<code>std::shared_ptr</code> 会为每个共享的对象分配一个控制块，这个控制块包含引用计数、指向实际对象的指针等信息。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr2 = sharedPtr1;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; sharedPtr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>std::shared_ptr的问题：循环引用</strong></p><p>循环引用是指两个或多个对象相互引用，形成一个环状结构，导致它们的引用计数永远不会降为零。这种情况可能导致内存泄漏，因为对象的资源（如动态分配的内存）将无法被释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span>;  <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;ClassB&gt; bPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;ClassA&gt; aPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象并建立循环引用</span></span><br><span class="line">    std::shared_ptr&lt;ClassA&gt; aPtr = std::<span class="built_in">make_shared</span>&lt;ClassA&gt;();</span><br><span class="line">    std::shared_ptr&lt;ClassB&gt; bPtr = std::<span class="built_in">make_shared</span>&lt;ClassB&gt;();</span><br><span class="line"></span><br><span class="line">    aPtr-&gt;bPtr = bPtr;  <span class="comment">// ClassA 包含 ClassB</span></span><br><span class="line">    bPtr-&gt;aPtr = aPtr;  <span class="comment">// ClassB 包含 ClassA</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的引用计数永远不会降为零，导致内存泄漏</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决循环引用的方法：</strong></p><ul><li><strong>使用 <code>std::weak_ptr</code> 打破循环引用</strong></li></ul><h4 id="2-3-std-weak-ptr"><a href="#2-3-std-weak-ptr" class="headerlink" title="2.3 std::weak_ptr"></a>2.3 std::weak_ptr</h4><p><code>std::weak_ptr:</code>用于解决循环引用和避免 <code>std::shared_ptr</code> 的引用计数增加导致的内存泄漏问题,通常用于与 <code>std::shared_ptr</code> 共同工作</p><p><code>std::weak_ptr</code> 不会增加对象的引用计数，因此它不会影响对象的生命周期。</p><p><strong>解决循环引用问题：当两个对象相互持有对方的 <code>std::shared_ptr</code> 时，其中一个或两个需要使用 <code>std::weak_ptr</code>，以避免形成循环引用，从而防止内存泄漏。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;ClassB&gt; bPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;ClassA&gt; aWeakPtr;  <span class="comment">// 使用 std::weak_ptr 避免循环引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 shared_ptr1 和 shared_ptr2</span></span><br><span class="line">    std::shared_ptr&lt;ClassA&gt; aPtr = std::<span class="built_in">make_shared</span>&lt;ClassA&gt;();</span><br><span class="line">    std::shared_ptr&lt;ClassB&gt; bPtr = std::<span class="built_in">make_shared</span>&lt;ClassB&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 shared_ptr1 和 shared_ptr2 关联起来</span></span><br><span class="line">    aPtr-&gt;bPtr = bPtr;</span><br><span class="line">    bPtr-&gt;aWeakPtr = aPtr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取 <code>std::shared_ptr</code>：</strong>用 <code>std::weak_ptr</code> 的 <code>lock</code> 成员函数来获取一个指向共享对象的 <code>std::shared_ptr</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">weakPtr</span><span class="params">(sharedPtr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 shared_ptr</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtrCopy = weakPtr.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sharedPtrCopy) &#123;</span><br><span class="line">    <span class="comment">// 共享对象存在</span></span><br><span class="line">    <span class="comment">// 使用 sharedPtrCopy...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 共享对象已销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断对象是否存在：</strong> 可以使用 <code>expired</code> 成员函数检查 <code>std::weak_ptr</code> 引用的对象是否已经被销毁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">weakPtr</span><span class="params">(sharedPtr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!weakPtr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">    <span class="comment">// 共享对象存在</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 共享对象已销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-std-unique-ptr"><a href="#2-4-std-unique-ptr" class="headerlink" title="2.4 std::unique_ptr"></a>2.4 std::unique_ptr</h4><p><strong><code>std::unique_ptr:</code></strong>与 <code>std::shared_ptr</code> 不同，<code>std::unique_ptr</code> 具有“独占”的所有权语义，即同一时刻只能有一个 <code>std::unique_ptr</code> 指向一个特定的对象。当 <code>std::unique_ptr</code> 被销毁或通过 <code>std::move</code> 转移所有权时，它所管理的对象将被销毁。</p><ul><li><strong>创建 <code>std::unique_ptr</code></strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::make_unique 创建 std::unique_ptr</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uniquePtr1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用构造函数创建 std::unique_ptr</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">uniquePtr2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>移动所有权</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uniquePtr1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动所有权</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uniquePtr2 = std::<span class="built_in">move</span>(uniquePtr1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：相对于 <code>std::shared_ptr</code>，<code>std::unique_ptr</code> 是一种更轻量级的智能指针，因为它不需要维护引用计数。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-RAll&quot;&gt;&lt;a href=&quot;#1-RAll&quot; class=&quot;headerlink&quot; title=&quot;1.RAll&quot;&gt;&lt;/a&gt;1.RAll&lt;/h3&gt;&lt;p&gt;RAII：用于有效地管理资源的获取和释放。&lt;/p&gt;
&lt;p&gt;基本思想：资源的获取应当在对象的构造函数中进行，而</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++零碎知识</title>
    <link href="https://wangak.cc/posts/8948f962.html"/>
    <id>https://wangak.cc/posts/8948f962.html</id>
    <published>2023-12-26T16:00:00.000Z</published>
    <updated>2023-12-27T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-静态绑定与动态绑定"><a href="#1-静态绑定与动态绑定" class="headerlink" title="1.静态绑定与动态绑定"></a>1.静态绑定与动态绑定</h3><p>“绑定”指的是将一个名字（例如变量名或函数名）与一个特定的实体（变量或函数）关联起来的过程。</p><p><strong>静态绑定：</strong>在<strong>编译阶段</strong>确定函数调用关系，编译器根据变量的<strong>声明类型</strong>或函数的定义位置来选择调用哪个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用的函数由变量的声明类型所决定</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base obj;</span><br><span class="line">    obj.<span class="built_in">foo</span>();  <span class="comment">// 静态绑定，调用Base类的foo()函数</span></span><br><span class="line"></span><br><span class="line">    Derived obj2;</span><br><span class="line">    obj2.<span class="built_in">foo</span>(); <span class="comment">// 静态绑定，调用Derived类的foo()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态绑定：</strong>在<strong>运行时</strong>确定函数的调用关系，根据对象的<strong>实际类型</strong>调用相应的函数。</p><p><em>注：动态绑定适用于虚函数，通过在基类中声明函数为虚函数，可以在派生类中重写该函数，并在运行时根据<strong>对象的实际类型</strong>调用相应的函数。</em></p><p>动态绑定的条件：</p><ul><li>必须通过指针来调用</li><li>该指针是向上转型的</li><li>调用的是虚函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">foo</span>();  <span class="comment">// 动态绑定，调用Derived类的foo()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：动态绑定与静态绑定相比具有更高的灵活性，但速度也会较慢</em></p><h3 id="2-两种转型"><a href="#2-两种转型" class="headerlink" title="2.两种转型"></a>2.两种转型</h3><h4 id="2-1-向上转型"><a href="#2-1-向上转型" class="headerlink" title="2.1 向上转型"></a>2.1 向上转型</h4><p><strong>向上转型：</strong>派生类向基类转换的过程，是隐式的，不需要显式的类型转换。</p><p><em>注：在向上转型的过程中没有发生对象的拷贝，而是将派生类对象的地址赋给基类指针，基类指针可以访问基类中定义的成员，但不能访问派生类特有的成员。向上转型体现了<strong>指针的多态性</strong>，可以用来实现<strong>动态绑定</strong>。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">baseFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">derivedFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derivedObj;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向上转型，将Derived对象的地址赋给Base指针</span></span><br><span class="line">    Base* basePtr = &amp;derivedObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过基类指针调用基类的成员函数</span></span><br><span class="line">    basePtr-&gt;<span class="built_in">baseFunction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向上转型比较安全，可以由编译器自动完成，不会有数据的丢失，在编译期间转换，如果转换失败会抛出编译错误，所以可以及时地发现错误。</p><p><strong>安全的原因：</strong></p><ul><li>基类指针只能访问基类成员，降低了误用的风险</li><li>向上转型只是将派生类对象的地址赋给基类指针，而不会改变对象本身的内存结构</li><li>在向上转型中，编译器能够静态地检查类型兼容性。如果存在不兼容的类型关系，编译时会发出错误，避免了一些在运行时才能检测到的问题。</li></ul><h4 id="2-2-向下转型"><a href="#2-2-向下转型" class="headerlink" title="2.2 向下转型"></a>2.2 向下转型</h4><p><strong>向下转型：</strong>从基类向派生类转换的过程，是显式的，需要使用类型转换操作符。</p><p><strong>静态转型：</strong><code>static_cast</code></p><p>静态转型是在编译时进行的转型，不提供运行时类型检查。</p><p><em>注：如果静态转型过程中出现错误，可能会导致未定义行为（如数据损坏、程序错误等）</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 static_cast 进行向下转型</span></span><br><span class="line">    Derived* derivedPtr = <span class="built_in">static_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用派生类指针调用派生类成员函数</span></span><br><span class="line">    derivedPtr-&gt;<span class="built_in">bar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态转型：</strong><code>dynamic_cast</code></p><p>动态转型是在运行时进行的转型，提供了类型安全检查。</p><p><em>注：动态转型只能用于含有虚函数的类层次结构，即只能用于多态类型之间的转换。多态类型是指至少有一个虚函数的类或结构体。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 dynamic_cast 进行向下转型</span></span><br><span class="line">    Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (derivedPtr) &#123;</span><br><span class="line">        <span class="comment">// 转型成功，使用派生类指针调用派生类成员函数</span></span><br><span class="line">        derivedPtr-&gt;<span class="built_in">bar</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 转型失败，可能是由于对象不是Derived类型</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dynamic casting failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：如果转型不安全，<code>dynamic_cast</code> 返回空指针（或引用），而不是导致未定义的行为。</em></p><h3 id="3-左值引用与右值引用"><a href="#3-左值引用与右值引用" class="headerlink" title="3.左值引用与右值引用"></a>3.左值引用与右值引用</h3><h4 id="3-1-左值引用"><a href="#3-1-左值引用" class="headerlink" title="3.1 左值引用"></a>3.1 左值引用</h4><p><strong>左值引用:</strong>给变量取别名，可以减少一层拷贝</p><ul><li><p><strong>修改引用对象的值:</strong>左值引用允许对左值进行引用，可以修改其值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp; lvalueRef = x;</span><br><span class="line">lvalueRef = <span class="number">10</span>;  <span class="comment">// 修改 x 的值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>传递引用参数：</strong>使函数直接操作传入的参数，而不是通过复制产生新的对象,避免不必要的对象复制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyValue</span><span class="params">(<span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">    value *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">modifyValue</span>(x);  <span class="comment">// 传递 x 的引用，函数可以修改 x 的值</span></span><br><span class="line">    <span class="comment">// 现在 x 的值为 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>函数返回引用：</strong>可以返回左值引用，避免创建临时对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp; ref = <span class="built_in">getReference</span>();</span><br><span class="line">    ref = <span class="number">10</span>;  <span class="comment">// 修改 x 的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-右值引用"><a href="#3-2-右值引用" class="headerlink" title="3.2 右值引用"></a>3.2 右值引用</h4><p><strong>右值：</strong>一个表达式，通常是一些临时对象、字面常量、表达式的计算结果等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;  <span class="comment">// 函数返回一个右值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;  <span class="comment">// x 是左值</span></span><br><span class="line">    <span class="type">int</span> y = x + <span class="number">5</span>;  <span class="comment">// x + 5 是一个右值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp;&amp; rvalueRef = <span class="built_in">getResult</span>();  <span class="comment">// getResult() 返回的是右值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：左值可以取地址，右值不能被取地址</em></p><p><strong>左值引用只能引用左值，经过const修饰的左值引用，既可以引用左值，也可以引用右值：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; constLvalueRef = <span class="number">42</span>;  <span class="comment">// 常量左值引用引用右值</span></span><br></pre></td></tr></table></figure><p><em>注：右值是不能被修改的值，所以左值引用被const修饰后才能引用右值</em></p><p><strong>右值引用可以引用move以后的左值:</strong>move相当于一个强制转换，将左值转换为右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::move 将左值 x 转换为右值引用</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; rvalueRef = std::<span class="built_in">move</span>(x);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x after std::move: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 输出 x 的值，已经被 std::move 转换过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>右值移动：</strong></p><ul><li><p><strong>移动语义：</strong>旨在提高对对象的资源管理效率，允许在对象资源的<strong>所有权转移（资源窃取）</strong>时，避免昂贵的深拷贝操作，而采用更经济高效的移动操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) : <span class="built_in">data</span>(other.data), <span class="built_in">size</span>(other.size) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        other.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyString source = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数被调用，资源的所有权从 source 转移到 destination</span></span><br><span class="line">    MyString destination = std::<span class="built_in">move</span>(source);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时 source 不再拥有资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>完美转发：</strong>实现一种通用的、保留原参数特性的参数传递机制（即接收左值作为参数，也可以接收右值作为参数）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">MyClass</span>(T&amp;&amp; arg) : <span class="built_in">data</span>(std::forward&lt;T&gt;(arg)) &#123;</span><br><span class="line">        <span class="comment">// 构造函数中的完美转发</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过完美转发调用构造函数</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(x)</span></span>;     <span class="comment">// 左值</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">10</span>)</span></span>;    <span class="comment">// 右值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：<code>std::forward</code>的作用是保留原始参数的左值或右值性质，以及 const 修饰符，实现一种通用的参数传递机制，其位于头文件 <code>&lt;utility&gt;</code> 中，并定义在命名空间 <code>std</code> 中</em></p></li></ul><h3 id="4-模板（泛化、全特化、偏特化）"><a href="#4-模板（泛化、全特化、偏特化）" class="headerlink" title="4.模板（泛化、全特化、偏特化）"></a>4.模板（泛化、全特化、偏特化）</h3><h4 id="4-1-模板泛化"><a href="#4-1-模板泛化" class="headerlink" title="4.1 模板泛化"></a>4.1 模板泛化</h4><p>模板泛化是不关心具体的类型，而是提供了通用的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 泛化的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic process: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-2-全特化"><a href="#4-2-全特化" class="headerlink" title="4.2 全特化"></a>4.2 全特化</h4><p>成员函数的全特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员函数的特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> MyClass&lt;<span class="type">int</span>&gt;::<span class="built_in">process</span>(<span class="type">int</span> data) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Specialized process for int: &quot;</span> &lt;&lt; data * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板全特化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板的特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized implementation for int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-3-偏特化"><a href="#4-3-偏特化" class="headerlink" title="4.3 偏特化"></a>4.3 偏特化</h4><p>模板偏特化是指在泛化的模板基础上，对其中的某一部分进行特化。</p><p><strong>模板参数数量的偏特化：</strong>特化部分参数，还存在一部分参数使用通用的模板定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板，有两个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T first;</span><br><span class="line">    U second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板参数数量的偏特化，对第一个模板参数进行特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;<span class="type">int</span>, U&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> first;</span><br><span class="line">    U second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>模板参数范围的偏特化：</strong>对模板的参数范围进行缩小</p><ul><li><strong>const 特化:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic process: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const 特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">const</span> T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> T data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized process for const type: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>指针特化：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic setValue: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span>&lt;T*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized setValue for pointers: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>左值引用特化:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyReference</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic printValue: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左值引用特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyReference</span>&lt;T&amp;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp; ref)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized printValue for lvalue references: &quot;</span> &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>右值引用特化:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRValueReference</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic printValue: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右值引用特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRValueReference</span>&lt;T&amp;&amp;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp;&amp; rvalue)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized printValue for rvalue references: &quot;</span> &lt;&lt; rvalue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>注：函数模板是不能偏特化的，只有类模板可以进行偏特化。函数模板可以不显式指定类型。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-静态绑定与动态绑定&quot;&gt;&lt;a href=&quot;#1-静态绑定与动态绑定&quot; class=&quot;headerlink&quot; title=&quot;1.静态绑定与动态绑定&quot;&gt;&lt;/a&gt;1.静态绑定与动态绑定&lt;/h3&gt;&lt;p&gt;“绑定”指的是将一个名字（例如变量名或函数名）与一个特定的实体（变量</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>水文</title>
    <link href="https://wangak.cc/posts/aa01fe8.html"/>
    <id>https://wangak.cc/posts/aa01fe8.html</id>
    <published>2023-12-26T16:00:00.000Z</published>
    <updated>2023-12-27T12:28:34.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpectFormer"><a href="#SpectFormer" class="headerlink" title="SpectFormer"></a>SpectFormer</h2><p><strong>论文：《SpectFormer: Frequency and Attention is what you need in a Vision Transformer》（arxiv 2023）</strong></p><p>频域层和多头注意力层结合起来，可以使Transformer能够捕捉到适当的特征表示，提升模型的特征建模能力，从而提升模型的性能。</p><p>频域层由一个快速傅里叶变换层（FFT)和一个逆傅里叶层（IFFT)构成</p><p><em>注：FFT和IFFT的操作，也可使用小波变换和逆小波变换来实现</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312272028245.png" alt="image-20231224161116413" style="zoom:67%;"></p><p>FFT把图像信息转到频域空间，然后可以对频域信号进行操作，使用具有可学习权重参数<script type="math/tex">W_c</script>的门控层来确定每个频率分量的权重，以便适当地捕获图像的线条和边缘，如可以去除低频部分，保留高频部分，用于突出图像的主要特征，然后通过IFFT做一个逆变换，把频域图还原到时域中。频域层之后用层归一化和多层感知器 (MLP) 块用于通道混合。</p><p>SpecFormer考虑了局部特征，这有助于捕获局部频率，以及更深层的全局特征，这有助于捕获长期依赖关系。</p><p>与GFNnet对比：SpecFormer可以更加清晰地捕获局部特征，如图像的线条和边缘</p><p><em>注：GFNet是完全使用频域层来进行建模</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312272028521.png" alt="image-20231224161421871"></p><p><em>频域层和注意力层结合，通过频域层捕获局部信息，注意力层捕获全局信息，同时可以灵活调整频域层和注意力层各自的层数</em></p><p><strong>混合建模形式的实验验证：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312272028064.png" alt="image-20231224163639771" style="zoom:67%;"></p><p><em>注：Inverse SpecFormer是将频域层和注意力层对调，即注意力层在前，频域层在后</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SpectFormer&quot;&gt;&lt;a href=&quot;#SpectFormer&quot; class=&quot;headerlink&quot; title=&quot;SpectFormer&quot;&gt;&lt;/a&gt;SpectFormer&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;论文：《SpectFormer: Frequency</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>窗口与三角形</title>
    <link href="https://wangak.cc/posts/aa216b4c.html"/>
    <id>https://wangak.cc/posts/aa216b4c.html</id>
    <published>2023-12-14T16:00:00.000Z</published>
    <updated>2023-12-15T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-窗口"><a href="#1-窗口" class="headerlink" title="1.窗口"></a>1.窗口</h3><p><strong>创建GLFW窗口对象</strong></p><p><code>GLFWwindow* window = glfwCreateWindow(800, 600, &quot;opengl&quot;,NULL,NULL);</code></p><ul><li>800:width</li><li>600:height</li><li>“opengl”:title</li></ul><p><strong>初始化GLEW</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glewExperimental = true;//设置 GLEW 的实验性模式</span><br><span class="line">if (glewInit() != GLEW_OK)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Init GLEW failed&quot;);</span><br><span class="line">glfwTerminate();</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>窗口渲染框架：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#define GLEW_STATIC</span><br><span class="line">#include&lt;GL/glew.h&gt;</span><br><span class="line">#include&lt;GLFW/glfw3.h&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">void processInput(GLFWwindow* window)</span><br><span class="line">&#123;</span><br><span class="line">if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)//GLFW_KEY_ESCAPE:表示esc键，glfwGetKey：获取窗口中键的状态</span><br><span class="line">&#123;</span><br><span class="line">glfwSetWindowShouldClose(window, true);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">glfwInit();</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">//创建GLFW窗口对象</span><br><span class="line">GLFWwindow* window = glfwCreateWindow(800, 600, &quot;opengl&quot;,NULL,NULL);</span><br><span class="line">glfwMakeContextCurrent(window);//将当前需要渲染的窗口设置为window</span><br><span class="line">//初始化GLEW</span><br><span class="line">glewExperimental = true;//设置 GLEW 的实验性模式</span><br><span class="line">if (glewInit() != GLEW_OK)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Init GLEW failed&quot;);</span><br><span class="line">glfwTerminate();</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glViewport(0, 0, 800, 600);</span><br><span class="line">while (!glfwWindowShouldClose(window))//判断窗口是否被关闭，未关闭则一直循环</span><br><span class="line">&#123;</span><br><span class="line">processInput(window);</span><br><span class="line">glClearColor(0.5f, 0.2f, 0.3f, 1.0f);//定义一种颜色（rgba四通道），每个通道取值为0~1.</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT); </span><br><span class="line">//GL_COLOR_BUFFER_BIT:颜色缓冲,glClear:将颜色缓冲填充成glClearColor设置的颜色</span><br><span class="line">glfwSwapBuffers(window);//交换双缓冲，渲染先在后台缓冲区进行，之后再与前台缓冲区交换</span><br><span class="line">//使用双缓冲是为了避免用户看到不完整的、中间过程的渲染结果</span><br><span class="line">glfwPollEvents();//检查有没有触发什么事件（比如键盘输入、鼠标移动等）</span><br><span class="line">&#125;</span><br><span class="line">glfwTerminate();//释放 GLFW 库分配的资源和清理 GLFW 环境</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-三角形"><a href="#2-三角形" class="headerlink" title="2.三角形"></a>2.三角形</h3><p><strong>图形渲染管线：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312151450311.png" alt="image-20231215095323007" style="zoom:67%;"></p><h4 id="2-1-定义并绑定VAO"><a href="#2-1-定义并绑定VAO" class="headerlink" title="2.1 定义并绑定VAO"></a>2.1 定义并绑定VAO</h4><p><strong>VAO（Vertex Array Object）</strong>：**保存了一系列的VBO配置和顶点属性指针，它负责告诉GPU，VBO中的信息到底该以几个为一组，对VBO起到解释的作用。</p><p><em>注：一个VAO可以对应多个VBO</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312151450544.png" alt="image-20231215093925600" style="zoom:67%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned int VAO;//也可以是unsigned int VAO[n],n为VAO的个数</span><br><span class="line">glGenVertexArrays(1, &amp;VAO);</span><br><span class="line">glBindVertexArray(VAO);</span><br></pre></td></tr></table></figure><h4 id="2-2-定义并绑定VBO"><a href="#2-2-定义并绑定VBO" class="headerlink" title="2.2 定义并绑定VBO"></a>2.2 定义并绑定VBO</h4><p><strong>VBO（Vertex Buffer Object）:</strong>用于存储实际的顶点数据，可以包含顶点坐标、法线、颜色等信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned int VBO;</span><br><span class="line">glGenBuffers(1, &amp;VBO);</span><br><span class="line">//绑定VBO</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">//数据传输到缓冲区，GL_STATIC_DRAW：静态绘制，顶点数据不会被修改</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><h4 id="2-3-创建顶点着色器"><a href="#2-3-创建顶点着色器" class="headerlink" title="2.3 创建顶点着色器"></a>2.3 创建顶点着色器</h4><p><strong>顶点着色器：</strong>对每个输入顶点的坐标进行计算和变换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//vertexShaderSource</span><br><span class="line">const char* vertexShaderSource = &quot;#version 330 core\n&quot;</span><br><span class="line">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span><br><span class="line">&quot;void main()\n&quot;</span><br><span class="line">&quot;&#123;\n&quot;</span><br><span class="line">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span><br><span class="line">&quot;&#125;\0&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建顶点着色器对象</span><br><span class="line">unsigned int vertexShader;</span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">//设置顶点着色器源代码并编译</span><br><span class="line">glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);</span><br><span class="line">glCompileShader(vertexShader);</span><br></pre></td></tr></table></figure><h4 id="2-4-创建片段着色器"><a href="#2-4-创建片段着色器" class="headerlink" title="2.4 创建片段着色器"></a>2.4 创建片段着色器</h4><p><strong>片段着色器：</strong>用于对每个屏幕上的像素（片段）进行处理，决定最终的颜色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//fragmentShaderSource</span><br><span class="line">const char* fragmentShaderSource =</span><br><span class="line">&quot;#version 330 core\n&quot;</span><br><span class="line">&quot;out vec4 FragColor;\n&quot;</span><br><span class="line">&quot;void main()&#123;\n&quot;</span><br><span class="line">&quot;FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);&#125;\n &quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建片段着色器对象</span><br><span class="line">unsigned int fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">//设置源代码并编译</span><br><span class="line">glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);</span><br><span class="line">glCompileShader(fragmentShader);</span><br></pre></td></tr></table></figure><h4 id="2-5-创建着色器程序"><a href="#2-5-创建着色器程序" class="headerlink" title="2.5 创建着色器程序"></a>2.5 创建着色器程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned int shaderProgram;</span><br><span class="line">shaderProgram = glCreateProgram();</span><br><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">//将附加到着色器程序的各个着色器连接在一起，以形成一个完整的着色器程序。</span><br><span class="line">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure><h4 id="2-6-配置顶点属性指针"><a href="#2-6-配置顶点属性指针" class="headerlink" title="2.6 配置顶点属性指针"></a>2.6 配置顶点属性指针</h4><p><strong><code>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 \* sizeof(float), (void\*)0);</code></strong></p><ul><li><code>0</code>: 指定顶点着色器中的顶点属性位置（location）。在顶点着色器代码中，使用 <code>layout(location = 0)</code> 来定义的。</li><li><code>3</code>: 指定每个顶点属性包含的分量数量，这里是3，表示三维坐标x、y、z。</li><li><code>GL_FLOAT</code>: 指定顶点属性的数据类型，这里是浮点数。</li><li><code>GL_FALSE</code>: 指定是否要归一化数据，对于浮点数数据，通常设置为GL_FALSE。</li><li><code>3 * sizeof(float)</code>: 指定相邻顶点属性之间的偏移量（以字节为单位）。这里表示每个顶点的大小为3个浮点数，所以偏移量为3 * sizeof(float)。</li><li><code>(void*)0</code>: void*无类型指针，指定第一个顶点属性在缓冲区中的偏移量。这里表示从缓冲区的开头开始使用。</li></ul><p><strong><code>glEnableVertexAttribArray(0);</code></strong>:启用顶点属性数组，OpenGL会按照之前配置的顶点属性指针从缓冲区中读取数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br></pre></td></tr></table></figure><h4 id="2-7-绘制三角形"><a href="#2-7-绘制三角形" class="headerlink" title="2.7 绘制三角形"></a>2.7 绘制三角形</h4><p><strong><code>glDrawArrays(GL_TRIANGLES, 0, 3);</code></strong>:</p><ul><li><code>GL_TRIANGLES</code> 表示渲染的图元类型，这里是三角形。</li><li><code>0</code> 是起始顶点的索引，表示从顶点数组的第一个顶点开始渲染。</li><li><code>3</code> 是顶点的数量，表示渲染三个顶点。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, 0, 3);</span><br></pre></td></tr></table></figure><h4 id="2-8-绘制多边形"><a href="#2-8-绘制多边形" class="headerlink" title="2.8 绘制多边形"></a>2.8 绘制多边形</h4><p>注意：opengl的绘制顺序是逆时针（右手系），当启用背面剔除时，背面将不可见。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_CULL_FACE);</span><br><span class="line">glCullFace(GL_BACK);</span><br></pre></td></tr></table></figure><p><strong>EBO（索引缓冲对象）：</strong>用于优化和节省内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unsigned int indices[] = &#123;</span><br><span class="line">0, 1, 2, // 第一个三角形</span><br><span class="line">2, 1, 3  // 第二个三角形</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义并绑定EBO</span><br><span class="line">unsigned int EBO;</span><br><span class="line">glGenBuffers(1, &amp;EBO);</span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p><strong>绘制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">/*glDrawArrays(GL_TRIANGLES, 0,3);*/</span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span><br></pre></td></tr></table></figure><h4 id="2-9-线框模式"><a href="#2-9-线框模式" class="headerlink" title="2.9 线框模式"></a>2.9 线框模式</h4><p><strong>启用线框模式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span><br></pre></td></tr></table></figure><p><strong>取消线框模式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-窗口&quot;&gt;&lt;a href=&quot;#1-窗口&quot; class=&quot;headerlink&quot; title=&quot;1.窗口&quot;&gt;&lt;/a&gt;1.窗口&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;创建GLFW窗口对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GLFWwindow* window = </summary>
      
    
    
    
    <category term="图形学" scheme="https://wangak.cc/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="opengl" scheme="https://wangak.cc/tags/opengl/"/>
    
  </entry>
  
  <entry>
    <title>shader</title>
    <link href="https://wangak.cc/posts/fff39e28.html"/>
    <id>https://wangak.cc/posts/fff39e28.html</id>
    <published>2023-12-14T16:00:00.000Z</published>
    <updated>2023-12-15T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-GLSL中向量的数据类型"><a href="#1-GLSL中向量的数据类型" class="headerlink" title="1.GLSL中向量的数据类型"></a>1.GLSL中向量的数据类型</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202312252046456.png" alt="image-20231215145202684"></p><h4 id="2-Uniform"><a href="#2-Uniform" class="headerlink" title="2.Uniform"></a>2.Uniform</h4><p><strong>uniform</strong>是一种在顶点着色器和片段着色器之间进行数据传递的机制，uniform变量是全局的，其值在每个渲染迭代中对所有顶点或片段是一致的。</p><p><strong>变量声明：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniform vec3 cameraPosition;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//返回自窗口初始化以来的秒数</span><br><span class="line">float timeValue = glfwGetTime();</span><br><span class="line">//将timeValue缩放到[0, 1]范围</span><br><span class="line">float greenValue = sin(timeValue) / 2.0f + 0.5f;</span><br><span class="line">//查询uniform ourColor的位置值</span><br><span class="line">int vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);</span><br><span class="line">//设置uniform值</span><br><span class="line">glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);</span><br></pre></td></tr></table></figure><h4 id="3-颜色插值"><a href="#3-颜色插值" class="headerlink" title="3.颜色插值"></a>3.颜色插值</h4><p>OpenGL会自动在顶点着色器和片段着色器之间进行插值</p><p><strong>定义顶点着色器和片段着色器：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">float vertices[] = &#123;</span><br><span class="line">// 位置              // 颜色</span><br><span class="line"> 0.8f, 0.2f, 0.0f,  1.0f, 0.0f, 0.0f,   // 右下</span><br><span class="line"> 0.3f, 0.4f, 0.0f,  0.0f, 1.0f, 0.0f,   // 左下</span><br><span class="line"> 0.0f,  0.1f, 0.0f,  0.0f, 0.0f, 1.0f,    // 顶部</span><br><span class="line"> 0.2f,  0.9f, 0.0f,  0.8f, 0.6f, 1.0f</span><br><span class="line">&#125;;</span><br><span class="line">unsigned int indices[] = &#123;</span><br><span class="line">0,1,2, // 第一个三角形</span><br><span class="line">2,1,3  // 第二个三角形</span><br><span class="line">&#125;;</span><br><span class="line">const char* vertexShaderSource = &quot;#version 330 core\n&quot;</span><br><span class="line">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span><br><span class="line">&quot;layout(location=1) in vec3 aColor;&quot;</span><br><span class="line">&quot;out vec4 vertexColor;\n&quot;</span><br><span class="line">&quot;void main()\n&quot;</span><br><span class="line">&quot;&#123;\n&quot;</span><br><span class="line">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span><br><span class="line">&quot;vertexColor=vec4(aColor.x,aColor.y,aColor.z,1.0f);\n&quot;</span><br><span class="line">&quot;&#125;\0&quot;;</span><br><span class="line"></span><br><span class="line">const char* fragmentShaderSource =</span><br><span class="line">&quot;#version 330 core\n&quot;</span><br><span class="line">&quot;out vec4 FragColor;\n&quot;</span><br><span class="line">&quot;uniform vec4 ourColor; &quot;</span><br><span class="line">&quot;in vec4 vertexColor;\n&quot;</span><br><span class="line">&quot;void main()&#123;\n&quot;</span><br><span class="line">&quot;FragColor = vertexColor;&#125;\n &quot;;</span><br></pre></td></tr></table></figure><p><strong>配置顶点属性指针：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 位置属性</span><br><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line">// 颜色属性</span><br><span class="line">glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));</span><br><span class="line">glEnableVertexAttribArray(1);</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252046360.png" alt="image-20231215170557358" style="zoom:67%;"></p><p><em>注：片段着色器不会直接从 <code>VBO</code> 中读取数据，而是通过与顶点着色器的输出交互，通过插值的方式在片段上进行着色。</em></p><h4 id="4-文件流读取着色器内容"><a href="#4-文件流读取着色器内容" class="headerlink" title="4.文件流读取着色器内容"></a>4.文件流读取着色器内容</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-GLSL中向量的数据类型&quot;&gt;&lt;a href=&quot;#1-GLSL中向量的数据类型&quot; class=&quot;headerlink&quot; title=&quot;1.GLSL中向量的数据类型&quot;&gt;&lt;/a&gt;1.GLSL中向量的数据类型&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://typo</summary>
      
    
    
    
    <category term="图形学" scheme="https://wangak.cc/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="opengl" scheme="https://wangak.cc/tags/opengl/"/>
    
  </entry>
  
  <entry>
    <title>D-LKA Attention</title>
    <link href="https://wangak.cc/posts/bf4c3cab.html"/>
    <id>https://wangak.cc/posts/bf4c3cab.html</id>
    <published>2023-12-14T16:00:00.000Z</published>
    <updated>2023-12-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="D-LKA-Attention"><a href="#D-LKA-Attention" class="headerlink" title="D-LKA Attention"></a>D-LKA Attention</h1><p><strong>论文：《Beyond Self-Attention: Deformable Large Kernel Attention for Medical Image Segmentation》（WACV 2024)</strong></p><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><strong>网络结构：</strong><br>                                            <img src="https://typoraimg.wangak.cc/2023/img/202312252047820.png" alt="image-20231218151015722" style="zoom:67%;"></p><p><strong>LKA：</strong>将卷积分解为三个部分：深度卷积、深度空洞卷积和逐点卷积</p><p>LKA吸收了卷积和self-attention的优点，包括局部结构信息、长依赖性和适应性。</p><p><strong>DW-Conv:</strong>可以利用图像的局部上下文信息</p><p><strong>DW-D-Conv：</strong>捕获LKA中的长程依赖性方面起到了作用</p><p><strong>1×1 Conv：</strong>通道维度中的关系</p><p><strong>2d-LKA的参数量：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047832.png" alt="image-20231218150016851" style="zoom: 67%;"></p><p><em>注：普通卷积kernel大小为K，DW-Conv的kernel为K/d，DW-D-Conv的kernel为(2d-1)</em></p><p><strong>3d-LKA的参数量：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047618.png" alt="image-20231218150455218" style="zoom:67%;"></p><p>d（扩张率）是通过对参数量求导确定的，找使参数量导数为0，即参数量最小的扩张率</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047839.png" alt="image-20231218150728812" style="zoom:67%;"></p><p><strong>D-LKA：</strong>在LKA的基础上，使用可变形深度卷积代替深度卷积，用可变形深度空洞卷积代替空洞卷积</p><p><em>注：可变形卷积提高了捕获不规则形状和大小的物体的能力</em></p><p><strong>D-LKA模块结构：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047842.png" alt="image-20231218152019184" style="zoom: 50%;"></p><h3 id="2-实验"><a href="#2-实验" class="headerlink" title="2.实验"></a>2.实验</h3><p><strong>2d的D-LKA在多器官数据集上的表现：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047330.png" alt="image-20231218154533519" style="zoom:67%;"></p><p><strong>3d的D-LKA在多器官数据集上的表现：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047355.png" alt="image-20231218154633563"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;D-LKA-Attention&quot;&gt;&lt;a href=&quot;#D-LKA-Attention&quot; class=&quot;headerlink&quot; title=&quot;D-LKA Attention&quot;&gt;&lt;/a&gt;D-LKA Attention&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;论文：《Beyond</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>games作业4</title>
    <link href="https://wangak.cc/posts/db707014.html"/>
    <id>https://wangak.cc/posts/db707014.html</id>
    <published>2023-12-09T16:00:00.000Z</published>
    <updated>2023-12-10T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="递归绘制贝塞尔曲线"><a href="#递归绘制贝塞尔曲线" class="headerlink" title="递归绘制贝塞尔曲线"></a>递归绘制贝塞尔曲线</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cv::Point2f recursive_bezier(const std::vector&lt;cv::Point2f&gt; &amp;control_points, float t) </span><br><span class="line">&#123;</span><br><span class="line">    if (control_points.size() == 1) </span><br><span class="line">    &#123;</span><br><span class="line">        return control_points[0];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        std::vector&lt;cv::Point2f&gt; points;</span><br><span class="line">        for (int i = 0; i &lt; control_points.size()-1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cv::Point2f p;</span><br><span class="line">            p.x = (1-t) * control_points[i].x + t * control_points[i + 1].x;</span><br><span class="line">            p.y = (1-t) * control_points[i].y + t * control_points[i + 1].y;</span><br><span class="line">            points.push_back(p);</span><br><span class="line">        &#125;</span><br><span class="line">        return recursive_bezier(points, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bezier(const std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window) </span><br><span class="line">&#123;</span><br><span class="line">    for (float t = 0; t &lt;= 1; t += 0.0001)</span><br><span class="line">    &#123;</span><br><span class="line">        //调用递归贝塞尔曲线计算函数，计算曲线上的点坐标</span><br><span class="line">        cv::Point2f point=recursive_bezier(control_points,t);</span><br><span class="line">        window.at&lt;cv::Vec3b&gt;(point.y, point.x)[1] = 255;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;递归绘制贝塞尔曲线&quot;&gt;&lt;a href=&quot;#递归绘制贝塞尔曲线&quot; class=&quot;headerlink&quot; title=&quot;递归绘制贝塞尔曲线&quot;&gt;&lt;/a&gt;递归绘制贝塞尔曲线&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    <category term="图形学" scheme="https://wangak.cc/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>光线追踪</title>
    <link href="https://wangak.cc/posts/426f6fb6.html"/>
    <id>https://wangak.cc/posts/426f6fb6.html</id>
    <published>2023-12-09T16:00:00.000Z</published>
    <updated>2023-12-10T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Shadow-Mapping"><a href="#1-Shadow-Mapping" class="headerlink" title="1.Shadow Mapping"></a>1.<strong>Shadow Mapping</strong></h3><p><strong>光栅化的问题：</strong>不能很好地表示全局的效果</p><p><strong>Shadow Mapping：</strong> 主要是为了解决点光源的硬阴影的问题</p><p>阴影区域：点对相机可见，而对光源不可见</p><p>Shadow Map记录每个pixel是否在阴影区域， 其生成步骤如下：</p><ul><li><p>1.从光源位置出发找出可见点，记录光源可见点的深度，得到光源深度图。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910765.png" alt="image-20231210115113668" style="zoom:50%;"></p></li><li><p>2.从相机出发，找可见点，如果点可见，坐标变换求此点到光源的距离。如果此距离与光源深度图中此位置的深度一致，说明此点可以被光源照到，是为光源、相机能同时看到点；如果不一致，说明是阴影点。</p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910506.png" alt="image-20231210115203873" style="zoom:50%;"></p><p><strong>硬阴影与软阴影：</strong></p><p>软阴影的形成在于全影和半影的渐变，点光源不存在软阴影问题，出现软阴影一定是光源有大小、不同照射位置有全影和半影这种渐变。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910061.png" alt="image-20231210120318890" style="zoom:50%;"></p><h3 id="2-Whitted-Styled-Ray-Tracing"><a href="#2-Whitted-Styled-Ray-Tracing" class="headerlink" title="2.Whitted-Styled Ray Tracing"></a>2.Whitted-Styled Ray Tracing</h3><p><strong>光线追踪利用的就是光的可逆性</strong></p><p>利用递归的方法进行光线追踪，对每条光线，递归计算其多个弹射点，当前光线所对应的像素值是由全部弹射点共同决定的：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910583.png" alt="image-20231210124837928" style="zoom:50%;"></p><p><strong>光源的定义：起点+方向</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910866.png" alt="image-20231210124958832" style="zoom:50%;"></p><p>于是，光线上的点可表示为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910939.png" alt="image-20231210125038746" style="zoom:50%;"></p><h3 id="3-光线求交点"><a href="#3-光线求交点" class="headerlink" title="3.光线求交点"></a>3.光线求交点</h3><h4 id="3-1-隐式表面"><a href="#3-1-隐式表面" class="headerlink" title="3.1 隐式表面"></a>3.1 隐式表面</h4><p>隐式表面求交点：将光线上的一点代入隐式方程中求解</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910802.png" alt="image-20231210125547229" style="zoom:50%;"></p><h4 id="3-2-显式表面"><a href="#3-2-显式表面" class="headerlink" title="3.2 显式表面"></a>3.2 显式表面</h4><p>显式表面求交点：用光线与三角形求交</p><p><strong>光线与三角形求交：</strong>光线与平面求交+判断交点是否在三角形内</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910771.png" alt="image-20231210130304291" style="zoom:50%;"></p><p>平面的定义：平面上一点+平面的法线</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910972.png" alt="image-20231210130407893" style="zoom:50%;"></p><p>求解交点的过程：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910503.png" alt="image-20231210130538694" style="zoom:50%;"></p><p><strong>Möller Trumbore Algorithm：</strong>三角形的一个点可以使用重心坐标表示</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910163.png" alt="image-20231210130920469" style="zoom:50%;"></p><p><em>注：解上图的方程，若$(1-b_1,b_2)、b_1、b_2$为正数，则交点在三角形内部</em></p><h3 id="4-计算的加速"><a href="#4-计算的加速" class="headerlink" title="4.计算的加速"></a>4.计算的加速</h3><p>每个光线与全部三角形都要进行求交点的计算，会导致计算开销过大，所以需要进行计算的加速。</p><p><strong>包围盒方法：</strong>在物体外面包一个包围盒，如果光线与盒子都没交点，那跟物体里的所有面更不会有交集。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910024.png" alt="image-20231210133306097" style="zoom:50%;"></p><p><strong>一般使用轴对齐包围盒（Axis-Aligned Bounding Box、AABB)</strong></p><p><strong>判断光线和包围盒是否有交点：</strong>通过计算光线进入/离开长方体的三个对面的时间可以判断出，光线和包围盒是否有交点</p><p>立方体有三个对面：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910471.png" alt="image-20231210133558734" style="zoom:50%;"></p><p>进入/离开对面的时间：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910723.png" alt="image-20231210133643427" style="zoom:50%;"></p><p>进入盒、离开盒的时间为：<br><img src="https://typoraimg.wangak.cc/2023/img/202312101910186.png" alt="image-20231210133737225" style="zoom:50%;"></p><p><em>注：光线进入了三个对面则认为光线进入了盒子，而光线离开了任意一个对面，就认为光线离开了盒子。</em></p><p><strong>若$t<em>{enter}&lt;t</em>{exit}且t_{exit}&gt;=0$，则有交点</strong></p><p><em>注：$t_{exit}$&lt;0，表示盒在光源背后，没有交点</em></p><h3 id="5-加速结构"><a href="#5-加速结构" class="headerlink" title="5.加速结构"></a>5.加速结构</h3><h4 id="5-1-均匀空间划分-Uniform-Spatial-Partitions-Grids"><a href="#5-1-均匀空间划分-Uniform-Spatial-Partitions-Grids" class="headerlink" title="5.1 均匀空间划分 Uniform Spatial Partitions (Grids)"></a>5.1 均匀空间划分 Uniform Spatial Partitions (Grids)</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910051.png" alt="image-20231210140725279" style="zoom:50%;"></p><p>判断光线交到的是不是含有物体表面的格子，如果不是的话跳过，是的话和其中的物体求交</p><p><em>注：该方法适合物体分布较均匀的场景</em></p><h4 id="5-2-空间划分"><a href="#5-2-空间划分" class="headerlink" title="5.2 空间划分"></a>5.2 空间划分</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910649.png" alt="image-20231210141331964" style="zoom:50%;"></p><ul><li>Oct-Tree:八叉树</li><li>KD-Tree</li><li>BSP-Tree</li></ul><p><strong>KD-Tree</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910636.png" alt="image-20231210142240300" style="zoom:50%;"></p><p>注：</p><p>1.KD-Tree中一个物体可能存在多个格子中</p><p>2.KD-Tree要计算三角形与盒子的求交，这较为困难</p><h4 id="5-3-物体划分（BVH）"><a href="#5-3-物体划分（BVH）" class="headerlink" title="5.3 物体划分（BVH）"></a>5.3 物体划分（BVH）</h4><p><strong>步骤：</strong></p><p>1.找到一个包围盒</p><p>2.递归地将物体拆成两个部分</p><p>3.两个部分重新计算包围盒</p><p>4.在每个叶子节点中记录实际的物体</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910732.png" alt="image-20231210143955688" style="zoom: 67%;"></p><p><em>注：划分规则：选择最长轴划分，以中间位置的物体进行划分</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Shadow-Mapping&quot;&gt;&lt;a href=&quot;#1-Shadow-Mapping&quot; class=&quot;headerlink&quot; title=&quot;1.Shadow Mapping&quot;&gt;&lt;/a&gt;1.&lt;strong&gt;Shadow Mapping&lt;/strong&gt;&lt;/h3&gt;</summary>
      
    
    
    
    <category term="图形学" scheme="https://wangak.cc/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>辐射度量学</title>
    <link href="https://wangak.cc/posts/9c8d1a2b.html"/>
    <id>https://wangak.cc/posts/9c8d1a2b.html</id>
    <published>2023-12-09T16:00:00.000Z</published>
    <updated>2023-12-12T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="辐射度量学"><a href="#辐射度量学" class="headerlink" title="辐射度量学"></a>辐射度量学</h2><p><strong>Whitted-Styled Ray Tracing的缺陷：</strong></p><ul><li>Whitted-Styled Ray Tracing主要关注的是折射光线和反射光线，而没有对漫反射的光线进行追踪。</li><li>所使用的Blinn-Phong模型是一种简化的模型</li></ul><p>因而引入辐射幅度量学来解决此问题。</p><p><strong>辐射度量学</strong>对光照的一套测量系统和单位，它能够准确的描述光线的物理性质。</p><h3 id="1-物理量的定义"><a href="#1-物理量的定义" class="headerlink" title="1.物理量的定义"></a>1.物理量的定义</h3><h4 id="1-1-辐射能量-Radiant-energy-和辐射通量-Radiant-flux"><a href="#1-1-辐射能量-Radiant-energy-和辐射通量-Radiant-flux" class="headerlink" title="1.1. 辐射能量(Radiant energy)和辐射通量(Radiant flux)"></a>1.1. 辐射能量(Radiant energy)和辐射通量(Radiant flux)</h4><p><strong>辐射能量:</strong>描述在一定时间内，通过某个表面或在空间中传播的电磁辐射的总能量量,以焦耳(J)为单位</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619481.png" alt="image-20231211210954761" style="zoom: 67%;"></p><p><strong>辐射通量（Radiant Flux）：</strong>是指光源辐射出的总功率，是在所有方向上的辐射强度的总和，以瓦特(W)为单位</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619781.png" alt="image-20231211211004923" style="zoom:67%;"></p><h4 id="1-2-辐射强度-Radiant-intensity"><a href="#1-2-辐射强度-Radiant-intensity" class="headerlink" title="1.2 辐射强度(Radiant intensity)"></a>1.2 辐射强度(Radiant intensity)</h4><p><strong>立体角：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619827.png" alt="image-20231211211509949" style="zoom: 67%;"></p><p>注：整个球的立体角为4<script type="math/tex">\pi</script></p><p><strong>微分立体角<script type="math/tex">d\omega</script>与<script type="math/tex">d\theta</script>和<script type="math/tex">d\phi</script>的关系:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619950.png" alt="image-20231212140402409" style="zoom: 67%;"></p><p><strong>辐射强度(Radiant intensity)：</strong>光源向特定方向发射的单位立体角内的功率，反映了光源在特定方向上的亮度。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619264.png" alt="image-20231212141054230" style="zoom:50%;"></p><p><em>注：辐射强度等于辐射通量除以立体角（各向同性）</em></p><h4 id="1-3-irradiance"><a href="#1-3-irradiance" class="headerlink" title="1.3  irradiance"></a>1.3  irradiance</h4><p><strong>irradiance：</strong>每单位照射面积所接收到的光功率</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619651.png" alt="image-20231212141549887" style="zoom:50%;"></p><p>注：当光线斜着照射到平面时，<script type="math/tex">\theta</script>为光线与法线的夹角，该公式变为：<img src="https://typoraimg.wangak.cc/2023/img/202312121621359.png" alt="image-20231212141804496" style="zoom: 67%;"></p><p>当照射点离光源越远时，A（球的表面积）就越大，irradiance就越小：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619417.png" alt="image-20231212142046864" style="zoom:50%;"></p><h4 id="1-4-radiance"><a href="#1-4-radiance" class="headerlink" title="1.4 radiance"></a>1.4 radiance</h4><p><strong>Radiance：</strong>每单位立体角、每单位垂直面积的光功率。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619800.png" alt="image-20231212142754987" style="zoom:67%;"></p><p><em>注：与irradiance的单位照射面积不同，Radiance定义的是单位垂直面积，二者的关系为：dA⊥=dAcosθ</em></p><p><strong>radiance和irradiance的关系如下：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619856.png" alt="image-20231212143220911" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619776.png" alt="image-20231212143324793" style="zoom:67%;"></p><p><em>注:Irradiance是Radiance在整个半球面的立体角上的积累</em></p><h3 id="2-双向反射分布函数-BRDF"><a href="#2-双向反射分布函数-BRDF" class="headerlink" title="2.双向反射分布函数(BRDF)"></a>2.双向反射分布函数(BRDF)</h3><p>空间中的一点（面积微分），在接受到一定方向上的亮度<script type="math/tex">dE(\omega_i)</script>之后，再向不同方向把能量辐射出去<script type="math/tex">dL_r(\omega_r)</script></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619734.png" alt="image-20231212143746031" style="zoom:67%;"></p><p><em>注：能量辐射的过程（即产生<script type="math/tex">dL_r(\omega_r)</script>的过程）受物体表面材质的影响，如光滑表面会完全反射到镜面反射方向，而粗糙表面会反射到所有方向</em></p><p><strong>BRDF：</strong>从特定方向入射的光线经材料表面反射后，沿特定方向散射的相对强度，函数值为反射光的radiance与入射光的irradiance的比值，定义如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619943.png" alt="image-20231212145455775" style="zoom:67%;"></p><h3 id="3-反射方程与渲染方程"><a href="#3-反射方程与渲染方程" class="headerlink" title="3.反射方程与渲染方程"></a>3.反射方程与渲染方程</h3><p><strong>反射方程：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619468.png" alt="image-20231212145941600" style="zoom: 67%;"></p><p>注：</p><p>(1).反射光 <script type="math/tex">Lo(p,ω_r)</script>是由所有不同方向上的入射光线的辐照度 <script type="math/tex">Li(p,ω_i)</script>贡献得到的</p><p>(2).在相机位置不变的情况下，对于一个固定的表面点p，反射方向 <script type="math/tex">ω_r</script>是相对固定的</p><p><strong>渲染方程：</strong>在反射方程的基础上，增加了一个自发光项</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121621807.png" alt="image-20231212150332586" style="zoom:67%;"></p><p><strong>一个点光源和单个物体：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619946.png" alt="image-20231212150513332" style="zoom:50%;"></p><p><em>注：点光源对一个点来说自然只有一个方向有入射光</em></p><p><strong>多个点光源一个物体的情况：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619174.png" alt="image-20231212150612687" style="zoom:50%;"></p><p><em>注：对多个点光源产生的反射光求和即可</em></p><p><strong>面光源的情况：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619863.png" alt="image-20231212150741761" style="zoom:50%;"></p><p><em>注：对面光源所在的立体角的范围积分</em></p><p><strong>考虑场景中其他物体的反射造成的光线交互：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619374.png" alt="image-20231212151116699" style="zoom:50%;"></p><p><em>注：将其他物体当作面光源</em></p><p><strong>使用积分变换矩阵可将其写作：L=E+KL</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619557.png" alt="image-20231212151331626" style="zoom:50%;"></p><p>于是得到L:<br>                                                <img src="https://typoraimg.wangak.cc/2023/img/202312121619933.png" alt="image-20231212151431111" style="zoom: 67%;"></p><p>其中<script type="math/tex">I</script>为单位矩阵，再接着对<script type="math/tex">(I-K)^{-1}</script>使用广义二项式定理得到：<br>                                                <img src="https://typoraimg.wangak.cc/2023/img/202312121619858.png" alt="image-20231212151515813" style="zoom:67%;"></p><p>注：E为自发光项，E+KE为光栅化的结果，即直接光照。对于全局光照,<script type="math/tex">K^2E</script>，即一次弹射的间接照明，<script type="math/tex">K^3E</script>就是两次弹射的间接照明……</p><h3 id="4-蒙特卡洛路径追踪"><a href="#4-蒙特卡洛路径追踪" class="headerlink" title="4.蒙特卡洛路径追踪"></a>4.蒙特卡洛路径追踪</h3><h4 id="4-1-蒙特卡洛积分"><a href="#4-1-蒙特卡洛积分" class="headerlink" title="4.1 蒙特卡洛积分"></a>4.1 蒙特卡洛积分</h4><p><strong>蒙特卡洛积分：</strong>通过对函数进行随机采样来估计积分值的方法，定义如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619771.png" alt="image-20231212154356113" style="zoom:50%;"></p><p>蒙特卡洛的近似正是对积分值的一个无偏估计：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619445.png" alt="image-20231212154446422" style="zoom: 67%;"></p><p><em>注：蒙特卡洛是一种用来求困难积分的方法</em></p><h4 id="4-2-蒙特卡洛路径追踪"><a href="#4-2-蒙特卡洛路径追踪" class="headerlink" title="4.2 蒙特卡洛路径追踪"></a>4.2 蒙特卡洛路径追踪</h4><p>当不考虑自发光项时， 渲染方程：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619268.png" alt="image-20231212155049240" style="zoom:67%;"></p><p>使用蒙特卡洛积分后：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619695.png" alt="image-20231212155138653" style="zoom:67%;"></p><p><em>注：这里取了N个采样方向<script type="math/tex">\omega_i</script></em></p><p>只考虑直接光照时，伪代码如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619297.png" alt="image-20231212155412919" style="zoom:67%;"></p><p>加入间接光照后，使用递归的算法，伪代码如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121620829.png" alt="image-20231212155500528" style="zoom:67%;"></p><p><em>注：这时由于使用递归的算法，每次采样N，这会导致指数爆炸的问题</em></p><p>于是，修改N=1，每次只搜索一条路径，重复多次寻找到多条路径，将多条路径的结果求得平均：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619544.png" alt="image-20231212160230270" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619824.png" alt="image-20231212160403123" style="zoom: 67%;"></p><p><em>注：对经过像素的光线采样多次，而对反射的光线只采样一次</em></p><p>递归出口的设置：RR(俄罗斯轮盘赌)</p><p>设定一个概率P,即每次反射有概率P继续递归，递归的返回值为<script type="math/tex">L_0/P</script>，有（1-P)的概率停止</p><p>使用俄罗斯轮盘赌保证了所得到的Radiance的期望不变：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619719.png" alt="image-20231212160801671" style="zoom:67%;"></p><p>shade函数的伪代码如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619418.png" alt="image-20231212160916559" style="zoom:67%;"></p><p>这样的采样，路径追踪效率非常的低下:</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619630.png" alt="image-20231212161351867" style="zoom:67%;"></p><p>所以，为提高采样的效率，直接对光源进行采样，假设光源的面积为A，dA与<script type="math/tex">d\omega_i</script>的关系如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121620938.png" alt="image-20231212161554373" style="zoom:67%;"></p><p>于是渲染方程可改写为：<br>                                       <img src="https://typoraimg.wangak.cc/2023/img/202312121620560.png" alt="image-20231212161621658" style="zoom:67%;"></p><p>最终伪代码如下，分直接光照和间接光照两部分计算：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121620823.png" alt="image-20231212161812935" style="zoom:67%;"></p><p><em>注：在计算直接光照时，要判断光源与着色点之间是否有物体遮挡</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;辐射度量学&quot;&gt;&lt;a href=&quot;#辐射度量学&quot; class=&quot;headerlink&quot; title=&quot;辐射度量学&quot;&gt;&lt;/a&gt;辐射度量学&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Whitted-Styled Ray Tracing的缺陷：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="图形学" scheme="https://wangak.cc/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>图形学几何</title>
    <link href="https://wangak.cc/posts/e4365916.html"/>
    <id>https://wangak.cc/posts/e4365916.html</id>
    <published>2023-12-08T16:00:00.000Z</published>
    <updated>2023-12-09T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图形学几何"><a href="#图形学几何" class="headerlink" title="图形学几何"></a>图形学几何</h2><h3 id="1-几何的分类"><a href="#1-几何的分类" class="headerlink" title="1.几何的分类"></a>1.几何的分类</h3><p><strong>隐式几何:</strong> 无明确表示，如用函数表示曲面，如点（x, y, z) 满足一定函数f(x, y)关系就在一个曲面上。判断点的位置关系很方便，遍历绘制图形比较困难。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536222.png" alt="image-20231209124852632" style="zoom:67%;"></p><p><strong>显式几何:</strong> 有明确表示方法，直接给出，或通过参数映射给出几何信息，比如一般的点云或网格。遍历绘制图形比较方便， 但判断点的位置关系，如内外、是否在表面上比较困难。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535257.png" alt="image-20231209124540218" style="zoom: 67%;"></p><p><em>注：显式几何的点被直接给出或可通过映射关系得到。</em></p><p><strong>区别：</strong>区别隐式曲面与显示曲面的关键就在于是否可以直接表示出所有的点</p><p><em>注：隐式曲面难以采样曲面上的点，但是可以轻易判断点与曲面的关系，对于显式曲面来可以很轻易的采样到所有的点，但是给予你任意一点却很难判断它与曲面的关系。</em></p><h4 id="1-1-隐式几何的例子"><a href="#1-1-隐式几何的例子" class="headerlink" title="1.1 隐式几何的例子"></a>1.1 隐式几何的例子</h4><ul><li><strong>代数曲面</strong></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535303.png" alt="image-20231209125119599" style="zoom:67%;"></p><ul><li><strong>Constructive Solid Geometry(CSG):</strong>对各种不同的几何做布尔运算，如并，交，差</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535351.png" alt="image-20231209125221199" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535535.png" alt="image-20231209125238367" style="zoom:67%;"></p><ul><li><strong>距离函数:</strong>得到几何体的混合效果</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535344.png" alt="image-20231209125458243" style="zoom:67%;"></p><ul><li><strong>水平集：</strong>找出函数值为0的地方作为曲线</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535748.png" alt="image-20231209125824432" style="zoom:67%;"></p><ul><li><strong>分型几何：</strong>通过迭代、自相似性和尺度不变性来描述复杂的几何形状。</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535549.png" alt="image-20231209125952472" style="zoom: 50%;"></p><h4 id="1-2-显式几何的例子"><a href="#1-2-显式几何的例子" class="headerlink" title="1.2 显式几何的例子"></a>1.2 显式几何的例子</h4><ul><li><p><strong>点云：</strong>（x,y,z）的列表，用点代替面，可用于表示任何空间中的几何</p></li><li><p><strong>多边形面/三角形</strong>（使用的最广泛）</p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535443.png" alt="image-20231209130844203" style="zoom: 33%;"></p><p>用.obj格式的文件保存模型：顶点、法线、纹理坐标</p><p>如下，文件描述了一个立方体：8个顶点、6个法线（右图vn有8个是因为存在冗余）、纹理坐标（vt）</p><p>f:顶点/纹理坐标/法线,定义了哪三个顶点构成三角形</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535311.png" alt="image-20231209131213798" style="zoom:67%;"></p><h3 id="2-曲线"><a href="#2-曲线" class="headerlink" title="2.曲线"></a>2.曲线</h3><h4 id="2-1-贝塞尔曲线"><a href="#2-1-贝塞尔曲线" class="headerlink" title="2.1 贝塞尔曲线"></a>2.1 贝塞尔曲线</h4><p>贝塞尔曲线：用控制点去定义曲线</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535440.png" alt="image-20231209132251079" style="zoom: 33%;"></p><p><strong>de Casteljau Algorithm：</strong>画贝塞尔曲线</p><p>将问题转化为：t点该如何画</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535451.png" alt="image-20231209132632421" style="zoom:50%;"></p><p>由$b_0、b_1$得到$b_0^1$,$b_1、b_2$得到$b_1^1$,由$b_0^1$,$b_1^1$得到$b_0^2$,即为t点</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535890.png" alt="image-20231209132826273" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312100940592.png" alt="image-20231210094017798" style="zoom:50%;"></p><p>四个点的情况：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535312.png" alt="image-20231209133247407" style="zoom: 33%;"></p><p>给出n个控制点可以得到一个n阶的贝塞尔曲线：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535895.png" alt="image-20231209133842896" style="zoom: 50%;"></p><p><strong>伯恩斯坦多项式：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536748.png" alt="image-20231209134013528" style="zoom:50%;"></p><p><em>注：(n,i)是组合数</em></p><p>贝塞尔曲线的性质：</p><p>(1).必定经过起始与终止控制点<br>(2).必定经与起始与终止线段相切<br>(3).具有仿射变换性质，可以通过移动控制点移动整条曲线<br>(4).凸包性质，曲线一定不会超出所有控制点构成的多边形范围</p><p><em>注：将t从0到1进行迭代即可得到完整的贝塞尔曲线</em></p><p><strong>逐段定义贝塞尔曲线：</strong>更易使用控制点去控制曲线（常用四个控制点定义一段贝塞尔曲线）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536926.png" alt="image-20231209135657494" style="zoom:50%;"></p><h4 id="2-2-B样条"><a href="#2-2-B样条" class="headerlink" title="2.2 B样条"></a>2.2 B样条</h4><p>pass</p><h4 id="2-3-NURBS"><a href="#2-3-NURBS" class="headerlink" title="2.3 NURBS"></a>2.3 NURBS</h4><p>pass</p><h3 id="3-曲面"><a href="#3-曲面" class="headerlink" title="3.曲面"></a>3.曲面</h3><p><strong>贝塞尔曲面：</strong>需要有两个参数控制（时间u,v）,分别控制两次贝塞尔曲线的计算</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536201.png" alt="image-20231209142717655" style="zoom: 33%;"></p><h3 id="4-曲面细分"><a href="#4-曲面细分" class="headerlink" title="4.曲面细分"></a>4.曲面细分</h3><h4 id="4-1-Loop细分"><a href="#4-1-Loop细分" class="headerlink" title="4.1 Loop细分"></a>4.1 Loop细分</h4><p><strong>步骤：</strong></p><p><strong>1.生成更多三角形或顶点</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536280.png" alt="image-20231209144613202" style="zoom: 50%;"></p><p><strong>2.调整这些三角形的位置（顶点的位置）</strong></p><p>顶点分为两类，一类是新生成的顶点，一类是老的原来就有的顶点</p><p>对于新生成的顶点：其位置为周围顶点的权重之和</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536826.png" alt="image-20231209145401431" style="zoom:33%;"></p><p>对于旧的顶点：自身以及邻接顶点的权重和，权重的设置与旧的顶点的度有关</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536368.png" alt="image-20231209145809889" style="zoom:50%;"></p><h4 id="4-2-Catmull-Clark细分"><a href="#4-2-Catmull-Clark细分" class="headerlink" title="4.2 Catmull-Clark细分"></a>4.2 Catmull-Clark细分</h4><p>用于处理四边形面和三角面的混合的细分</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536889.png" alt="image-20231209150626897" style="zoom:50%;"></p><p><strong>Non-quad face:</strong>非四边形面</p><p><strong>奇异点:</strong>所有度不为4的顶点</p><p><strong>第一次细分所有面都会变成四边形，增加的奇异点个数为非四边形面的个数，之后再进行细分，奇异点个数不再增加</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536250.png" alt="image-20231209150826085" style="zoom:50%;"></p><p>点位置的调整：所有点分为：边上的点、面上的点、原来的点</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536387.png" alt="image-20231209151144071" style="zoom:50%;"></p><h3 id="5-曲面简化-Mesh-Smplication"><a href="#5-曲面简化-Mesh-Smplication" class="headerlink" title="5.曲面简化(Mesh Smplication)"></a>5.曲面简化(Mesh Smplication)</h3><p><strong>边坍缩：</strong>将一条边的两个顶点合成为一个顶点</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536794.png" alt="image-20231209152028718" style="zoom:50%;"></p><p>如何坍缩：使二次误差度量最小</p><p>二次误差度量：坍缩之后蓝色新顶点所在的位置与原来各个平面的垂直距离之和</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536192.png" alt="image-20231209152333304"></p><p><strong>步骤：</strong>（使用堆结构）</p><p><strong>1 为模型每条边赋值，其值为坍缩这条边之后，代替两个老顶点的新顶点所能得到的最小二次误差度量</strong><br> <strong>2 选取权值最小的边做坍缩，新顶点位置为原来计算得出使得二次误差最小的位置</strong><br> <strong>3 坍缩完之后，与之相连其他的边的位置会改动，更新这些边的权值</strong><br> <strong>4 重复上述步骤，直到到达终止条件</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图形学几何&quot;&gt;&lt;a href=&quot;#图形学几何&quot; class=&quot;headerlink&quot; title=&quot;图形学几何&quot;&gt;&lt;/a&gt;图形学几何&lt;/h2&gt;&lt;h3 id=&quot;1-几何的分类&quot;&gt;&lt;a href=&quot;#1-几何的分类&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="图形学" scheme="https://wangak.cc/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>games作业3</title>
    <link href="https://wangak.cc/posts/4514e5b7.html"/>
    <id>https://wangak.cc/posts/4514e5b7.html</id>
    <published>2023-12-02T16:00:00.000Z</published>
    <updated>2023-11-28T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-透视投影变换"><a href="#1-透视投影变换" class="headerlink" title="1.透视投影变换"></a>1.透视投影变换</h4><p>投影接口的参数是张角fov，横纵比为aspect时，透视投影的变换矩阵如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090851755.png" alt="image-20231203092505302" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar)</span><br><span class="line">&#123;</span><br><span class="line">    Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();</span><br><span class="line">    projection(0, 0) = -(1 / (aspect_ratio * tan(eye_fov / 180.0 * MY_PI)));</span><br><span class="line">    projection(1, 1) = -(1 / (tan(eye_fov / 180.0 * MY_PI)));</span><br><span class="line">    projection(2, 2) = (zNear + zFar) / (zNear - zFar);</span><br><span class="line">    projection(2, 3) = (2 * zFar * zNear) / (zNear - zFar);</span><br><span class="line">    projection(3, 2) = 1;</span><br><span class="line">    projection(3, 3) = 0;</span><br><span class="line">    return projection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-判断点是否在三角形内"><a href="#2-判断点是否在三角形内" class="headerlink" title="2.判断点是否在三角形内"></a>2.判断点是否在三角形内</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static bool insideTriangle(int x, int y, const Vector4f* _v)&#123;</span><br><span class="line">    Eigen::Vector2f AB, BC, CA, AP, BP, CP, p;</span><br><span class="line">    float a, b, c;//用于保存叉乘的结果(是正还是负）</span><br><span class="line">    p &lt;&lt; x ,y;</span><br><span class="line">    AB = _v[1].head(2) - _v[0].head(2);</span><br><span class="line">    AP = p - _v[0].head(2);</span><br><span class="line">    BC = _v[2].head(2) - _v[1].head(2);</span><br><span class="line">    BP = p - _v[1].head(2);</span><br><span class="line">    CA = _v[0].head(2) - _v[2].head(2);</span><br><span class="line">    CP = p - _v[2].head(2);</span><br><span class="line">    //分别计算叉乘，x,y方向为0，故只计算z方向的结果</span><br><span class="line">    a = AB[0] * AP[1] - AB[1] * AP[0];</span><br><span class="line">    b = BC[0] * BP[1] - BC[1] * BP[0];</span><br><span class="line">    c = CA[0] * CP[1] - CA[1] * CP[0];</span><br><span class="line">    if (a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; c &gt; 0)</span><br><span class="line">        return true;</span><br><span class="line">    else if (a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; c &lt; 0)</span><br><span class="line">        return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-光栅化"><a href="#3-光栅化" class="headerlink" title="3.光栅化"></a>3.光栅化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//屏幕空间光栅化</span><br><span class="line">//view_pos：顶点在屏幕空间的坐标</span><br><span class="line">void rst::rasterizer::rasterize_triangle(const Triangle&amp; t, const std::array&lt;Eigen::Vector3f, 3&gt;&amp; view_pos)</span><br><span class="line">&#123;</span><br><span class="line">    auto v = t.toVector4();</span><br><span class="line">    float x_max = std::max(std::max(v[0].x(), v[1].x()), v[2].x());</span><br><span class="line">    float x_min = std::min(std::min(v[0].x(), v[1].x()), v[2].x());</span><br><span class="line">    float y_min = std::min(std::min(v[0].y(), v[1].y()), v[2].y());</span><br><span class="line">    float y_max = std::max(std::max(v[0].y(), v[1].y()), v[2].y());</span><br><span class="line">    for (int i = x_min; i &lt; x_max+1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = y_min; j &lt; y_max+1; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (insideTriangle(i, j, t.v))</span><br><span class="line">            &#123;</span><br><span class="line">                //计算当前像素在三角形内的重心坐标</span><br><span class="line">                auto [alpha, beta, gamma] = computeBarycentric2D(i, j, t.v);</span><br><span class="line"></span><br><span class="line">                //通过重心插值得到深度值z_interpolated</span><br><span class="line">                //w_reciprocal为透视修正系数</span><br><span class="line">                float w_reciprocal = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());</span><br><span class="line">                float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();</span><br><span class="line">                z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">                //Z-Buffer</span><br><span class="line">                if (depth_buf[get_index(i, j)] &gt; z_interpolated)</span><br><span class="line">                &#123;</span><br><span class="line">                    //利用重心坐标插值颜色、法线、纹理、shadingcoords（像素位置）</span><br><span class="line">                    auto interpolated_color = interpolate(alpha, beta, gamma, t.color[0], t.color[1], t.color[2], 1);</span><br><span class="line">                    auto interpolated_normal = interpolate(alpha, beta, gamma, t.normal[0], t.normal[1], t.normal[2], 1);</span><br><span class="line">                    auto interpolated_texcoords = interpolate(alpha, beta, gamma, t.tex_coords[0], t.tex_coords[1], t.tex_coords[2], 1);</span><br><span class="line">                    auto interpolated_shadingcoords = interpolate(alpha, beta, gamma, view_pos[0], view_pos[1], view_pos[2], 1);</span><br><span class="line">                    // 初始化 payload，用于传递给片段着色器</span><br><span class="line">                    fragment_shader_payload payload(interpolated_color, interpolated_normal.normalized(), interpolated_texcoords, texture ? &amp;*texture : nullptr);</span><br><span class="line">                    payload.view_pos = interpolated_shadingcoords;</span><br><span class="line"></span><br><span class="line">                    // 更新深度缓存</span><br><span class="line">                    depth_buf[get_index(i, j)] = z_interpolated;</span><br><span class="line"></span><br><span class="line">                    // 设置像素颜色，调用片段着色器</span><br><span class="line">                    Vector2i temp(i, j);</span><br><span class="line">                    set_pixel(temp, fragment_shader(payload));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Blinn-Phong反射模型"><a href="#4-Blinn-Phong反射模型" class="headerlink" title="4.Blinn-Phong反射模型"></a>4.Blinn-Phong反射模型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector3f phong_fragment_shader(const fragment_shader_payload&amp; payload)</span><br><span class="line">&#123;</span><br><span class="line">    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);//环境光反射率</span><br><span class="line">    Eigen::Vector3f kd = payload.color;//漫反射项系数</span><br><span class="line">    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);//高光项</span><br><span class="line">    //定义了两个光源</span><br><span class="line">    auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line">    auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;;//环境光</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;;//观察点的位置</span><br><span class="line">    float p = 150;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f color = payload.color;</span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f result_color = &#123;0, 0, 0&#125;;</span><br><span class="line">    for (auto&amp; light : lights)</span><br><span class="line">    &#123;</span><br><span class="line">        //计算光源到物体距离的平方r2</span><br><span class="line">        float r2 = (light.position - point).dot((light.position - point));//a.dot(a)=|a|^2</span><br><span class="line"></span><br><span class="line">        Eigen::Vector3f l = (light.position - point).normalized();//光线方向</span><br><span class="line">        Eigen::Vector3f v = (eye_pos - point).normalized();//观察方向</span><br><span class="line">        Eigen::Vector3f h = (l + v).normalized();//半程向量</span><br><span class="line"></span><br><span class="line">        //.cwiseProduct()用于向量对应位置的点相乘</span><br><span class="line">        //漫反射</span><br><span class="line">        Eigen::Vector3f diffuse = kd.cwiseProduct(light.intensity / r2) * std::max(0.0f, normal.normalized().dot(l));</span><br><span class="line">        //环境光</span><br><span class="line">        Eigen::Vector3f ambient = ka.cwiseProduct(amb_light_intensity);</span><br><span class="line">        //高光</span><br><span class="line">        Eigen::Vector3f specular = ks.cwiseProduct(light.intensity / r2) * pow(std::max(0.0f, normal.normalized().dot(h)), p);</span><br><span class="line"></span><br><span class="line">        result_color += ambient + diffuse + specular; </span><br><span class="line">    &#125;</span><br><span class="line">    return result_color * 255.f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-纹理映射"><a href="#5-纹理映射" class="headerlink" title="5.纹理映射"></a>5.纹理映射</h4><p>修改漫反射系数 <code>kd</code>即可，<code>kd</code> 是一个颜色向量，它表示了表面对漫反射光的反应程度，环境光和镜面反射成分通常是不受纹理映射直接影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector3f texture_fragment_shader(const fragment_shader_payload&amp; payload)</span><br><span class="line">&#123;</span><br><span class="line">    Eigen::Vector3f return_color = &#123;0, 0, 0&#125;;</span><br><span class="line">    if (payload.texture)</span><br><span class="line">    &#123;</span><br><span class="line">        //获取纹理坐标处的颜色</span><br><span class="line">        return_color = payload.texture-&gt;getColor(payload.tex_coords.x(), payload.tex_coords.y());</span><br><span class="line">    &#125;</span><br><span class="line">    Eigen::Vector3f texture_color;</span><br><span class="line">    texture_color &lt;&lt; return_color.x(), return_color.y(), return_color.z();</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);</span><br><span class="line">    Eigen::Vector3f kd = texture_color / 255.f;</span><br><span class="line">    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);</span><br><span class="line"></span><br><span class="line">    auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line">    auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;;</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;;</span><br><span class="line"></span><br><span class="line">    float p = 150;</span><br><span class="line">    Eigen::Vector3f color = texture_color;</span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f result_color = &#123;0, 0, 0&#125;;</span><br><span class="line"></span><br><span class="line">    for (auto&amp; light : lights)</span><br><span class="line">    &#123;</span><br><span class="line">        //计算光源到物体距离的平方r2</span><br><span class="line">        float r2 = (light.position - point).dot((light.position - point));//a.dot(a)=|a|^2</span><br><span class="line"></span><br><span class="line">        Eigen::Vector3f l = (light.position - point).normalized();//光线方向</span><br><span class="line">        Eigen::Vector3f v = (eye_pos - point).normalized();//观察方向</span><br><span class="line">        Eigen::Vector3f h = (l + v).normalized();//半程向量</span><br><span class="line"></span><br><span class="line">        //.cwiseProduct()用于向量对应位置的点相乘</span><br><span class="line">        //漫反射</span><br><span class="line">        Eigen::Vector3f diffuse = kd.cwiseProduct(light.intensity / r2) * std::max(0.0f, normal.normalized().dot(l));</span><br><span class="line">        //环境光</span><br><span class="line">        Eigen::Vector3f ambient = ka.cwiseProduct(amb_light_intensity);</span><br><span class="line">        //高光</span><br><span class="line">        Eigen::Vector3f specular = ks.cwiseProduct(light.intensity / r2) * pow(std::max(0.0f, normal.normalized().dot(h)), p);</span><br><span class="line"></span><br><span class="line">        result_color += ambient + diffuse + specular;</span><br><span class="line">    &#125;</span><br><span class="line">    return result_color * 255.f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-凹凸贴图"><a href="#6-凹凸贴图" class="headerlink" title="6.凹凸贴图"></a>6.凹凸贴图</h4><p>pass</p><h4 id="7-位移贴图"><a href="#7-位移贴图" class="headerlink" title="7.位移贴图"></a>7.位移贴图</h4><p>pass</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-透视投影变换&quot;&gt;&lt;a href=&quot;#1-透视投影变换&quot; class=&quot;headerlink&quot; title=&quot;1.透视投影变换&quot;&gt;&lt;/a&gt;1.透视投影变换&lt;/h4&gt;&lt;p&gt;投影接口的参数是张角fov，横纵比为aspect时，透视投影的变换矩阵如下：&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="图形学" scheme="https://wangak.cc/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>纹理映射</title>
    <link href="https://wangak.cc/posts/df375b66.html"/>
    <id>https://wangak.cc/posts/df375b66.html</id>
    <published>2023-12-01T00:00:00.000Z</published>
    <updated>2023-12-01T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-纹理映射"><a href="#1-纹理映射" class="headerlink" title="1.纹理映射"></a>1.纹理映射</h3><p><strong>纹理映射：</strong>用于增强渲染的真实感和细节，允许在三维模型表面上贴附二维图像，以模拟材质、颜色、光照等细节。</p><p>纹理坐标的伪代码表示：<br><img src="https://typoraimg.wangak.cc/2023/img/202312090856218.png" alt="image-20231201125433593" style="zoom:50%;"></p><p>​        即通过对每个光栅化的屏幕坐标算出它的纹理坐标（u,v)(利用三角形顶点重心坐标插值),再利用这个u,v坐标去查询texture上的颜色，把这个颜色信息当作漫反射系数Kd。</p><h4 id="1-1-纹理过小的问题"><a href="#1-1-纹理过小的问题" class="headerlink" title="1.1 纹理过小的问题"></a>1.1 纹理过小的问题</h4><p><strong>问题：</strong>例如，有一张大小为100x100像素的纹理贴图，然后将这个贴图应用到一个500x500像素的屏幕上，这样多个像素点可能会映射到纹理贴图的相同区域，这使得纹理像素的信息被多个屏幕像素所共享。</p><p>​        如果只是简单地使用最近的纹理坐标点，即离目标点最近的(u, v)坐标，取样不足以准确反映屏幕上多个像素的信息，会导致渲染结果出现严重的走样问题。</p><p><strong>解决方法：</strong>使用更复杂的纹理过滤技术，如双线性插值，考虑周围像素的颜色信息，从而在渲染过程中更加平滑地处理纹理映射，减少走样的影响。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090856478.png" alt="image-20231201130205648" style="zoom:50%;"></p><p><em>注：Bicubic：双三次插值是利用三次方程来进行两次插值，但是计算开销过</em>大</p><h4 id="1-2-纹理过大的问题"><a href="#1-2-纹理过大的问题" class="headerlink" title="1.2 纹理过大的问题"></a>1.2 纹理过大的问题</h4><p><strong>现象：</strong><br><img src="https://typoraimg.wangak.cc/2023/img/202312090855369.png" alt="image-20231201130738219" style="zoom: 67%;"></p><p><strong>近处出现锯齿，远处出现摩尔纹</strong></p><p><strong>原因：</strong>根据近大远小，远处的一张完整的贴图可能在屏幕空间中仅仅是几个像素的大小，屏幕空间的一个像素对应了纹理贴图上的一片范围的点，而用一个点采样的结果代替纹理空间一片范围的颜色信息，必然会导致严重失真</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090855975.png" alt="image-20231201131153194" style="zoom:50%;"></p><p>如上图，一个屏幕空间的蓝色像素点离相机越远，对应在texture空间的范围也就越大</p><p><strong>解决方法：</strong>超采样（计算开销过大，不好）、MipMap</p><p><strong>纹理足迹（Texture Footprint）：</strong> 当纹理贴图映射到几何体表面时，每个像素在纹理空间中的足迹描述了纹理在几何体上的分布。</p><h4 id="1-3-MipMap"><a href="#1-3-MipMap" class="headerlink" title="1.3 MipMap"></a>1.3 MipMap</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202312090856328.png" alt="image-20231201132206220" style="zoom:50%;"></p><p>level 0代表的是原始texture，也是精度最高的纹理，随着level的提升，每提升一级将4个相邻像素点求均值合为一个像素点，因此越高的level也就代表了更大的footprint的区域查询。接下来要做的就是根据屏幕像素的footprint大小选定不同level的texture，再进行点查询即可，而这其实就相当于在原始texture上进行了区域查询。</p><p><em>注：通过MipMap将区域查询的问题，再次转换为点查询。使用MipMap仅将纹理map的大小扩大了1/3</em></p><p><strong>确定level：</strong>利用屏幕像素的相邻像素点估算footprint大小再确定level</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090856671.png" alt="image-20231201132617242" style="zoom: 67%;"></p><p>在屏幕空间中取当前像素点的右方和上方的两个相邻像素点(4个全取也可以)，分别查询得到这3个点对应在Texture space的坐标，计算出当前像素点与右方像素点和上方像素点在Texture space的距离，二者取最大值得到L,再通过L得到D。</p><p><strong>D算出的是一个连续值而不是整数的解决办法：</strong><br>（1）四舍五入取得最近的那个level D（纹理之间可能存在突变，不连续，故不好）</p><p>（2）利用D值在向下和向上取整的两个不同level进行三线性插值（即将level连续化），如下图。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090856929.png" alt="image-20231201133041710" style="zoom:50%;"></p><p>三线性插值的MipMap的效果：远处出现了过曝的现象<br><img src="https://typoraimg.wangak.cc/2023/img/202312090856355.png" alt="image-20231201133122841" style="zoom: 50%;"></p><p><em>出现该问题的原因是屏幕空间中的正方形的像素，在纹理空间中的形状可能是不规则的矩形</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090856608.png" alt="image-20231201133312851" style="zoom:50%;"></p><h4 id="1-4-各向异性过滤Mipmap"><a href="#1-4-各向异性过滤Mipmap" class="headerlink" title="1.4 各向异性过滤Mipmap"></a>1.4 各向异性过滤Mipmap</h4><p>各向异性的过滤：<img src="https://typoraimg.wangak.cc/2023/img/202312090856102.png" alt="image-20231201133512182" style="zoom:50%;"></p><p>将纹理分为水平方向上的level和竖直方向的level</p><h3 id="2-凹凸贴图"><a href="#2-凹凸贴图" class="headerlink" title="2.凹凸贴图"></a>2.凹凸贴图</h3><p><strong>凹凸贴图的原理:</strong>  利用凹凸贴图来改变原本光滑的平面的法线, 使原本光滑的平面产生凹凸感。</p><p> pass</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-纹理映射&quot;&gt;&lt;a href=&quot;#1-纹理映射&quot; class=&quot;headerlink&quot; title=&quot;1.纹理映射&quot;&gt;&lt;/a&gt;1.纹理映射&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;纹理映射：&lt;/strong&gt;用于增强渲染的真实感和细节，允许在三维模型表面上贴附二维图像，以</summary>
      
    
    
    
    <category term="图形学" scheme="https://wangak.cc/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>games作业框架</title>
    <link href="https://wangak.cc/posts/b46ced9d.html"/>
    <id>https://wangak.cc/posts/b46ced9d.html</id>
    <published>2023-11-30T16:00:00.000Z</published>
    <updated>2023-12-01T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Triangle类"><a href="#1-Triangle类" class="headerlink" title="1.Triangle类"></a>1.Triangle类</h3><h4 id="1-1-Triangle-hpp：类的声明"><a href="#1-1-Triangle-hpp：类的声明" class="headerlink" title="1.1 Triangle.hpp：类的声明"></a>1.1 Triangle.hpp：类的声明</h4><p><strong>定义了一个名为 <code>Triangle</code> 的类</strong></p><ul><li>三角形顶点的齐次坐标：（x,y,z,w)</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312090858570.png" alt="image-20231203094213284"></p><p><em>注：w=0时表示该点在无穷远处</em></p><ul><li><strong>ifndef</strong>：防止头文件的重复包含，确保在编译时，同一个头文件不会被多次包含，从而避免因重复包含导致的重定义报错。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TEST_H</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">...... #内容</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line">头文件结尾写上一行：</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><em>注：__TEST_H为标识符，通常是大写形式</em></p><ul><li><strong>void setNormals(const std::array<Vector3f, 3>&amp; normals)</Vector3f,></strong>：利用normals设置三角形顶点的法向量normal[3]<ul><li>std::array：标准库中的容器</li><li>Vector3f（元素类型）、3（数组大小）</li><li>const:保证normals不会被修改,&amp;:传递引用类型，避免对象的拷贝，提高执行效率</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#ifndef RASTERIZER_TRIANGLE_H</span><br><span class="line">#define RASTERIZER_TRIANGLE_H</span><br><span class="line"></span><br><span class="line">#include&lt;eigen3/Eigen/Eigen&gt;</span><br><span class="line">#include&quot;Texture.hpp&quot;//项目内的头文件用&quot;&quot;</span><br><span class="line">using namespace Eigen;</span><br><span class="line">class Triangle&#123;</span><br><span class="line">Vector4f v[3];//三角形三个顶点的其次坐标（x,y,z,w)</span><br><span class="line">Vector3f color[3];//顶点的颜色</span><br><span class="line">Vector2f tex_coords[3];//顶点的纹理坐标</span><br><span class="line">Vector3f normal[3];//顶点的法向量</span><br><span class="line"></span><br><span class="line">Texture* tex = nullptr;//指向其纹理信息的指针</span><br><span class="line"></span><br><span class="line">Triangle();//默认构造函数</span><br><span class="line"></span><br><span class="line">//获取三个顶点的坐标</span><br><span class="line">Eigen::Vector4f a() const &#123; return v[0]; &#125;</span><br><span class="line">Eigen::Vector4f b() const &#123; return v[1]; &#125;</span><br><span class="line">Eigen::Vector4f c() const &#123; return v[2]; &#125;</span><br><span class="line"></span><br><span class="line">//设置第i个顶点的坐标</span><br><span class="line">void setVertex(int ind,Vector4f ver);//将第i个顶点的坐标设置为ver</span><br><span class="line">//设置法向量</span><br><span class="line">void setNormal(int ind, Vector3f ver);</span><br><span class="line">//设置颜色</span><br><span class="line">void setColor(int ind, float r, float g, float b);</span><br><span class="line">//设置所有顶点的法向量</span><br><span class="line">void setNormals(const std::array&lt;Vector3f, 3&gt;&amp; normals);</span><br><span class="line">//设置所有顶点的颜色</span><br><span class="line">void setColors(const std::array&lt;Vector3f, 3&gt;&amp; colors);</span><br><span class="line">//设置第i个顶点的纹理</span><br><span class="line">void setTexCoord(int ind, Vector2f uv);</span><br><span class="line"></span><br><span class="line">std::array&lt;Vector4f, 3&gt; toVector4() const;//定义toVector4()函数，将齐次坐标（x,y,z,w)转换为（x/w,y/w,z/w,1)的形式</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">#endif // !RASTERIZER_TRIANGLE_H</span><br></pre></td></tr></table></figure><h4 id="1-2-Triangle-cpp：类的实现"><a href="#1-2-Triangle-cpp：类的实现" class="headerlink" title="1.2 Triangle.cpp：类的实现"></a>1.2 Triangle.cpp：类的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;Triangle.hpp&quot;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;array&gt;</span><br><span class="line"></span><br><span class="line">//构造函数的实现</span><br><span class="line">Triangle::Triangle() &#123;</span><br><span class="line">v[0] &lt;&lt; 0, 0, 0, 1;</span><br><span class="line">v[1] &lt;&lt; 0, 0, 0, 1;</span><br><span class="line">v[2] &lt;&lt; 0, 0, 0, 1;</span><br><span class="line">color[0] &lt;&lt; 0.0, 0.0, 0.0;</span><br><span class="line">color[1] &lt;&lt; 0.0, 0.0, 0.0;</span><br><span class="line">color[2] &lt;&lt; 0.0, 0.0, 0.0;</span><br><span class="line">tex_coords[0] &lt;&lt; 0.0, 0.0;</span><br><span class="line">tex_coords[1] &lt;&lt; 0.0, 0.0;</span><br><span class="line">tex_coords[2] &lt;&lt; 0.0, 0.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置指定索引的纹理</span><br><span class="line">void Triangle::setTexCoord(int ind, Vector2f uv) &#123;</span><br><span class="line">tex_coords[ind] = uv;</span><br><span class="line">&#125;</span><br><span class="line">//设置顶点</span><br><span class="line">void Triangle::setVertex(int ind, Vector4f ver) &#123;</span><br><span class="line">v[ind] = ver;</span><br><span class="line">&#125;</span><br><span class="line">//设置法线</span><br><span class="line">void Triangle::setNormal(int ind, Vector3f n) &#123;</span><br><span class="line">normal[ind] = n;</span><br><span class="line">&#125;</span><br><span class="line">//设置颜色</span><br><span class="line">void Triangle::setColor(int ind, float r, float g, float b) &#123;</span><br><span class="line">if ((r &lt; 0.0) || (r &gt; 255.) ||</span><br><span class="line">(g &lt; 0.0) || (g &gt; 255.) ||</span><br><span class="line">(b &lt; 0.0) || (b &gt; 255.)) &#123;</span><br><span class="line">fprintf(stderr, &quot;ERROR! Invalid color values&quot;);</span><br><span class="line">fflush(stderr);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">color[ind] = Vector3f((float)r / 255., (float)g / 255., (float)b / 255.);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//将顶点坐标转换为标准的四维齐次坐标</span><br><span class="line">std::array&lt;Vector4f, 3&gt; Triangle::toVector4() const</span><br><span class="line">&#123;</span><br><span class="line">std::array&lt;Vector4f, 3&gt; res;</span><br><span class="line">std::transform(std::begin(v), std::end(v), res.begin(), [](auto&amp; vec) &#123; return Vector4f(vec.x(), vec.y(), vec.z(), 1.f); &#125;);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">void Triangle::setNormals(const std::array&lt;Vector3f, 3&gt;&amp; normals)</span><br><span class="line">&#123;</span><br><span class="line">// 设置法向量</span><br><span class="line">normal[0] = normals[0];</span><br><span class="line">normal[1] = normals[1];</span><br><span class="line">normal[2] = normals[2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Triangle::setColors(const std::array&lt;Vector3f, 3&gt;&amp; colors)</span><br><span class="line">&#123;</span><br><span class="line">// 设置颜色</span><br><span class="line">auto first_color = colors[0];</span><br><span class="line">setColor(0, colors[0][0], colors[0][1], colors[0][2]);</span><br><span class="line">setColor(1, colors[1][0], colors[1][1], colors[1][2]);</span><br><span class="line">setColor(2, colors[2][0], colors[2][1], colors[2][2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Triangle类&quot;&gt;&lt;a href=&quot;#1-Triangle类&quot; class=&quot;headerlink&quot; title=&quot;1.Triangle类&quot;&gt;&lt;/a&gt;1.Triangle类&lt;/h3&gt;&lt;h4 id=&quot;1-1-Triangle-hpp：类的声明&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="图形学" scheme="https://wangak.cc/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>SG-Former</title>
    <link href="https://wangak.cc/posts/c53f4cce.html"/>
    <id>https://wangak.cc/posts/c53f4cce.html</id>
    <published>2023-11-29T16:00:00.000Z</published>
    <updated>2023-11-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SG-Former"><a href="#SG-Former" class="headerlink" title="SG-Former"></a>SG-Former</h2><p><strong>论文：《SG-Former: Self-guided Transformer with Evolving Token Reallocation》（ICCV 2023)</strong></p><h4 id="1-探究动机"><a href="#1-探究动机" class="headerlink" title="1.探究动机"></a>1.探究动机</h4><p>ViT使用全局的自注意力机制，但带来了较高的计算成本。</p><p>Swin Transformer设计了窗口注意力，而牺牲了建模全局信息的能力。</p><p><strong>提出SG-Fomer（Self-guided Transformer):</strong>利用<strong>显著性</strong>图，根据每个区域的显著性来分配token，将更多的token分配给显著性区域以获取细粒度的注意力，而将更少的token分配给次要的区域以换取计算效率和全局的感受野。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145871.png" alt="image-20231130202913356"></p><p><em>注：在显著性区域（狗脸）分配更多的token</em></p><h4 id="2-网络设计"><a href="#2-网络设计" class="headerlink" title="2.网络设计"></a>2.网络设计</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145135.png" alt="image-20231130203138889" style="zoom:80%;"></p><p><strong>Hybrid-Scale Transformer blocks:</strong>提取多尺度的信息并为Self-Guided Transformer Block提供显著性图</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145630.png" alt="image-20231129153810548" style="zoom: 67%;"></p><p>把H个注意力头分成h组，在第j组的注意力头有一个尺度因子<script type="math/tex">S_j</script>,即对于K,V的每<script type="math/tex">S_j*S_j</script>个token合并为一个token，把K、V的窗口大小设为M,Q的窗口大小设为<script type="math/tex">S_jM*S_jM</script>(使Q中token与K、V中的token对齐）</p><p><em>注：</em></p><p><em>（1）K,V的窗口大小在所有组中都是固定的，均为M,而Q的窗口大小还和$S_j$有关</em>，每一组的输出均为N*M,N为token序列的长度</p><p><em>（2）token的合并是通过卷积实现的</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145504.png" alt="image-20231130205331048" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145396.png" alt="image-20231130205438728" style="zoom: 67%;"></p><p>Token 的重要性被视为所有 Token 和当前 Token 的乘积之和：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145068.png" alt="image-20231129153230302" style="zoom: 67%;"></p><p><em>注：S是对所有的$S_i$求和的结果，即为最终的注意力图，用于混合尺度引导</em></p><p><strong>Self-Guided Transformer Block：</strong></p><p>为了降低计算成本，同时保持计算后特征映射的大小不变，固定Q的大小，使用IAM（importance guided aggregation module)对K和V的token进行聚合</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145350.png" alt="image-20231130211007377" style="zoom: 80%;"></p><p><em>注：S为显著性图，r为合并比率</em></p><p>将S平均分为n个子区域S1，S2,……Sn,每个区域设置不同的合并比率r1,r2,……，rn,子区域越重要，合并比率越小，输入特征X按X1,X2,……,Xn分组，每组有不同的合并比率</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145872.png" alt="image-20231130212526902" style="zoom: 67%;"></p><p><em>注：token的合并通过全连接层实现</em></p><h4 id="3-实验"><a href="#3-实验" class="headerlink" title="3.实验"></a>3.实验</h4><p>与其他结构在语义分割任务中的对比：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312010859765.png" alt="image-20231130215028355" style="zoom: 50%;"></p>]]></content>
    
    
    <summary type="html">记录了SG-Former的网络结构及实验结果</summary>
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>局部光照模型及着色方法</title>
    <link href="https://wangak.cc/posts/af9d8c8.html"/>
    <id>https://wangak.cc/posts/af9d8c8.html</id>
    <published>2023-11-29T16:00:00.000Z</published>
    <updated>2023-11-28T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-局部光照模型"><a href="#1-局部光照模型" class="headerlink" title="1.局部光照模型"></a>1.局部光照模型</h3><p><strong>光线的简单分类：</strong></p><ul><li><p><strong>镜面反射</strong></p></li><li><p><strong>漫反射</strong></p></li></ul><ul><li><strong>环境光</strong></li></ul><h4 id="1-1-泛光模型"><a href="#1-1-泛光模型" class="headerlink" title="1.1 泛光模型"></a>1.1 泛光模型</h4><p>泛光模型即<strong>只考虑环境光</strong>，这是最简单的<strong>经验</strong>模型，只会去考虑环境光的影响，并且不会去精确的描述，而只是用一个简单的式子表示：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952046.png" alt="image-20231130091038413" style="zoom:50%;"></p><script type="math/tex; mode=display">注：K_a表示物体表面对环境光的反射率，I_a代表入射环境光的亮度，I_{env}存储结果，即人眼所能看到从物体表面反射的环境光的亮度。</script><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952312.png" alt="image-20231130091806017" style="zoom: 67%;"></p><h4 id="1-2-Lambert漫反射模型"><a href="#1-2-Lambert漫反射模型" class="headerlink" title="1.2 Lambert漫反射模型"></a>1.2 Lambert漫反射模型</h4><ul><li><p>在泛光模型的基础之上增加了<strong>漫反射项</strong></p><ul><li>每个不同方向反射的光的强度相等</li><li>产生漫反射的原因是物体表面的粗糙</li></ul></li><li><p><strong>漫反射光照强度与光线照射方向和表面法线之间的夹角余弦成正比</strong></p><p><em>注：漫反射与观察方向无关，光线照射方向和表面法线之间的夹角反应了对于光照的接受率</em></p></li><li><p><strong>公式表示：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952975.png" alt="image-20231130091906700" style="zoom:50%;"></p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952973.png" alt="image-20231130091824267"></p><h4 id="1-3-Blinn-Phong反射模型"><a href="#1-3-Blinn-Phong反射模型" class="headerlink" title="1.3 Blinn-Phong反射模型"></a>1.3 Blinn-Phong反射模型</h4><p>Blinn-Phong反射模型是Phong光照模型的一种改进，在模拟高光方面表现更为自然。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952864.png" alt="image-20231130092346846" style="zoom: 50%;"></p><p>注：$k_s$为镜面反射系数， I为入射光强， r为光源到入射点距离,指数p加速衰减(用于减小可以看到高光的角度）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952037.png" alt="image-20231130092850361" style="zoom:50%;"></p><p>注：使用半程向量简化了反射向量与人眼观察夹角的计算（Phong光照模型，即下图中R与v的夹角的计算）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952906.png" alt="image-20231130092457821" style="zoom:50%;"></p><p><strong>整体计算公式：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952426.png" alt="image-20231130092944573" style="zoom:50%;"></p><p><em>注：L=泛光（环境光）+漫反射项+高光</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953544.png" alt="image-20231130093045061" style="zoom:50%;"></p><h3 id="2-着色方法-频率"><a href="#2-着色方法-频率" class="headerlink" title="2.着色方法(频率)"></a>2.着色方法(频率)</h3><h4 id="2-1-Flat-Shading（面着色）"><a href="#2-1-Flat-Shading（面着色）" class="headerlink" title="2.1 Flat Shading（面着色）"></a>2.1 Flat Shading（面着色）</h4><p>模型数据大多以很多个三角面进行存储，因此也就记录了每个面的法线向量，利用每个面的法线向量进行一次Blinn-Phong反射光照模型的计算，将该颜色赋予整个面。</p><p>效果如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953328.png" alt="image-20231130093503703" style="zoom:50%;"></p><h4 id="2-2-Gouraud-Shading（顶点着色）"><a href="#2-2-Gouraud-Shading（顶点着色）" class="headerlink" title="2.2 Gouraud Shading（顶点着色）"></a>2.2 Gouraud Shading（顶点着色）</h4><p>Gouraud Shading会对每个三角形的顶点进行一次着色</p><p><strong>点法线：将所有共享这个点的面的法线向量加起来求均值，最后再标准化</strong></p><p><strong>三角形内部的每一个点：</strong>利用<strong>重心坐标来插值</strong></p><p>重心坐标：给定的三角形ABC和其中的一个点P，其重心坐标$(w_a,w_b,w_c)$满足以下条件：</p><ul><li>$w_a+w_b+w_c=1$</li><li>$P=w_a⋅A+w_b⋅B+w_c⋅C$</li></ul><p>重心坐标可以通过面积的比值求出：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312010916393.png" alt="image-20231130134307989" style="zoom:50%;"></p><p>注：三角形的重心为（1/3，1/3，1/3），其将三角形分为了面积相等的三份。</p><p>重心坐标一般的表达式：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312010916494.png" alt="image-20231130134715691" style="zoom:50%;"></p><p>重心插值公式如下:</p><p>$P_{interpolated}=w_a⋅P_A+w_b⋅P_B+w_c⋅P_C$</p><p><em>注：$P_A、P_B、P_C$分别是三个顶点上的属性值</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953992.png" alt="image-20231130094402265" style="zoom:50%;"></p><p><em>注：重心坐标经过投影之后可能会改变，在三维空间中插值一些属性时，要计算三维空间中重心的坐标。</em></p><h4 id="2-3-Phong-Shading-像素着色"><a href="#2-3-Phong-Shading-像素着色" class="headerlink" title="2.3 Phong Shading(像素着色)"></a>2.3 Phong Shading(像素着色)</h4><p>要对每个点都进行光照计算，三角形内部的每一个点的法线向量如插值颜色一样得到：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953798.png" alt="image-20231130094638524" style="zoom:50%;"></p><p><em>注：$n_0,n_1,n_2$分别是三角形三个顶点的法线向量,α,β,γ为三角形面内点的重心坐标</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953475.png" alt="image-20231130094743068" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-局部光照模型&quot;&gt;&lt;a href=&quot;#1-局部光照模型&quot; class=&quot;headerlink&quot; title=&quot;1.局部光照模型&quot;&gt;&lt;/a&gt;1.局部光照模型&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;光线的简单分类：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;str</summary>
      
    
    
    
    <category term="图形学" scheme="https://wangak.cc/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Transformation</title>
    <link href="https://wangak.cc/posts/ac17f787.html"/>
    <id>https://wangak.cc/posts/ac17f787.html</id>
    <published>2023-11-25T16:00:00.000Z</published>
    <updated>2023-11-26T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h2><h3 id="1-2D变换"><a href="#1-2D变换" class="headerlink" title="1. 2D变换"></a>1. 2D变换</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207409.png" alt="image-20231126190707151" style="zoom:50%;"></p><h4 id="1-1-缩放-scaling"><a href="#1-1-缩放-scaling" class="headerlink" title="1.1 缩放(scaling)"></a>1.1 缩放(scaling)</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207653.png" alt="image-20231126190747793" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207767.png" alt="image-20231126190853847" style="zoom: 50%;"></p><h4 id="1-2-镜像变换"><a href="#1-2-镜像变换" class="headerlink" title="1.2 镜像变换"></a>1.2 镜像变换</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207557.png" alt="image-20231126191121990" style="zoom:50%;"></p><h4 id="1-3-切变（Shear-Matrix）"><a href="#1-3-切变（Shear-Matrix）" class="headerlink" title="1.3 切变（Shear Matrix）"></a>1.3 切变（Shear Matrix）</h4><p>如下图，变换过程中y坐标始终不变</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207966.png" alt="image-20231126192230389" style="zoom:50%;"></p><h4 id="1-4-旋转-Rotate"><a href="#1-4-旋转-Rotate" class="headerlink" title="1.4 旋转(Rotate)"></a>1.4 旋转(Rotate)</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208542.png" alt="image-20231126192327264" style="zoom:50%;"></p><h4 id="1-5-齐次坐标"><a href="#1-5-齐次坐标" class="headerlink" title="1.5 齐次坐标"></a>1.5 齐次坐标</h4><p><strong>平移：</strong><br><img src="https://typoraimg.wangak.cc/2023/img/202311271208287.png" alt="image-20231126193641073" style="zoom:50%;"></p><p><strong>为了表示平移操作引入了第三维坐标：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208639.png" alt="image-20231126193653818" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208486.png" alt="image-20231126193714639" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208369.png" alt="image-20231126193731535" style="zoom:50%;"></p><p><em>注：<strong>point+point</strong>的结果为两个点的中点</em></p><p><strong>仿射变换的两种形式：</strong><br><img src="https://typoraimg.wangak.cc/2023/img/202311271208436.png" alt="image-20231126194003729" style="zoom:50%;"></p><p><em>注：齐次坐标变换矩阵中的a,b,c,d与线性变换中的变换矩阵是对应的</em></p><h4 id="1-6-逆变换"><a href="#1-6-逆变换" class="headerlink" title="1.6 逆变换"></a>1.6 逆变换</h4><p><strong>逆变换：</strong>变换矩阵为原变换的逆矩阵</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208337.png" alt="image-20231126194715152" style="zoom:50%;"></p><h3 id="2-3D变换"><a href="#2-3D变换" class="headerlink" title="2. 3D变换"></a>2. 3D变换</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208498.png" alt="image-20231126195736702" style="zoom:50%;"></p><h4 id="2-1-仿射变换"><a href="#2-1-仿射变换" class="headerlink" title="2.1 仿射变换"></a>2.1 仿射变换</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208171.png" alt="image-20231126195828157" style="zoom:50%;"></p><p><em>注：该表示方法是先做线性变换，然后再平移</em></p><h4 id="2-2-旋转"><a href="#2-2-旋转" class="headerlink" title="2.2 旋转"></a>2.2 旋转</h4><ul><li><strong>在轴上</strong></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033304.png" alt="image-20231127122527405" style="zoom:50%;"></p><ul><li><p><strong>一般的旋转</strong>：可以将任意的旋转分为在三个轴上的旋转，其中在三个轴上的旋转角度称为欧拉角</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033703.png" alt="image-20231127122758750" style="zoom:50%;"></p></li></ul><p>​    <strong>罗德里格斯公式(Rodrigues’ Rotation Formula):</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033828.png" alt="image-20231127123545604"></p><p>注：四元数的应用</p><h3 id="2-3-视图-相机变换（View-Camera-Transformation）"><a href="#2-3-视图-相机变换（View-Camera-Transformation）" class="headerlink" title="2.3 视图/相机变换（View / Camera Transformation）"></a>2.3 视图/相机变换（View / Camera Transformation）</h3><p><strong>相机的参数：</strong>初始位置、观看角度（向量）、竖直角度（向量）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033677.png" alt="image-20231127125538822"></p><p><strong>标准化：</strong>观看位置为原点、观看角度为-Z、向上方向为Y</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033142.png" alt="image-20231127125835234" style="zoom:50%;"></p><p>变换的方法：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033832.png" alt="image-20231127125907343" style="zoom:50%;"></p><p>由于正向变换比较复杂，考虑<strong>通过其逆矩阵来实现</strong>：R为旋转变换矩阵、T为平移变换矩阵、M为整个过程的变换矩阵</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033482.png" alt="image-20231127130030303" style="zoom:50%;"></p><p><em>注：旋转矩阵为正交矩阵，逆矩阵即是其转置</em></p><p><em>注：视图变换变换的是相机，其他的物体随着相机一起变换</em></p><h3 id="3-投影变换"><a href="#3-投影变换" class="headerlink" title="3 投影变换"></a>3 投影变换</h3><h4 id="3-1-正交投影变换"><a href="#3-1-正交投影变换" class="headerlink" title="3.1 正交投影变换"></a>3.1 正交投影变换</h4><p><strong>正交投影变换：</strong>平移+压缩</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033623.png" alt="image-20231127131958838" style="zoom:50%;"></p><p><em>注：l,r为x轴上的距离，b,t为y轴上的距离</em></p><h4 id="3-2-透视投影变换"><a href="#3-2-透视投影变换" class="headerlink" title="3.2 透视投影变换"></a>3.2 透视投影变换</h4><p>透视投影类似人眼所看东西的方式，遵循近大远小,平行线也会变得不平行</p><p><strong>用正交变换表示透视投影变换：</strong><script type="math/tex">M_{ortho}M_{persp->ortho}</script></p><p>将透视变换压成投影<script type="math/tex">M_{persp->ortho}</script></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033023.png" alt="image-20231127212210693" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033371.png" alt="image-20231127212333846" style="zoom:50%;"></p><p><em>注：其中n是近平面，f是远平面，在公式推导的过程中是<strong>默认n、f</strong>均为负数</em></p><p>因而透视投影矩阵为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311301248538.png" alt="image-20231130123159569" style="zoom: 67%;"></p><p>又当投影接口的参数是张角fov，横纵比为aspect，近平面到原点的距离为near,远平面到原点的距离为far</p><p>由于长方体视窗体是轴对称，故有l=−r,b=−t,从原点看向−z方向看去，有n=−near,f=−far<br>                                                                    <img src="https://typoraimg.wangak.cc/2023/img/202311301247698.png" alt="image-20231130124140613" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311301248703.png" alt="image-20231130124220304" style="zoom:67%;"></p><p>所以透视投影矩阵可化简为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311301248469.png" alt="image-20231130124301880" style="zoom: 67%;"></p><h3 id="4-视口变换"><a href="#4-视口变换" class="headerlink" title="4.视口变换"></a>4.视口变换</h3><p><strong>视口变换</strong>用于将标准平面映射到屏幕的分辨率范围之内（缩放+平移），变换矩阵如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033944.png" alt="image-20231128150643474" style="zoom:50%;"></p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>将虚拟世界中以(x,y,z)为坐标的物体变换到以一个个像素位置(x,y) 来表示的屏幕坐标系之中(2维)的步骤：</p><ul><li><strong>模型变换(modeling tranformation)：</strong>这一步的目的是将虚拟世界中或者更具体点，游戏场景中的物体调整至他们应该在的位置</li><li><strong>摄像机变换(camera tranformation)：</strong>在游戏中我们真正在乎的是摄像机(或者说眼睛)所看到的东西，也就是需要得到物体与摄像机的相对位置</li><li><strong>投影变换(projection tranformation)：</strong>根据摄像机变换得到了所有可视范围内的物体对于摄像机的相对位置坐标(x,y,z)之后，便是根据是平行投影还是透视投影，将三维空间投影至标准二维平面([-1,1]^2)之上 （tips：这里的z并没有丢掉，为了之后的遮挡关系检测）</li><li><strong>视口变换(viewport transformation)：</strong>将处于标准平面映射到屏幕分辨率范围之内，即[-1,1]^2→[0,width]*[0,height], 其中width和height指屏幕分辨率大小</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Transformation&quot;&gt;&lt;a href=&quot;#Transformation&quot; class=&quot;headerlink&quot; title=&quot;Transformation&quot;&gt;&lt;/a&gt;Transformation&lt;/h2&gt;&lt;h3 id=&quot;1-2D变换&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="图形学" scheme="https://wangak.cc/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>光栅化及深度测试</title>
    <link href="https://wangak.cc/posts/499d8707.html"/>
    <id>https://wangak.cc/posts/499d8707.html</id>
    <published>2023-11-25T16:00:00.000Z</published>
    <updated>2023-11-28T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p><strong>光栅化（Rasterization）</strong>是图形学中一种常用的渲染技术，用于将三维场景中的图形对象转换为二维像素表示，以便在计算机屏幕上显示，即将图形对象（通常是三角形）映射到屏幕上的像素格子，并确定每个像素的颜色值。</p><p><strong>选择三角形作为渲染的基本图元的原因：</strong></p><ul><li>因为三角形是最简单的几何形状之一，任意三个点可以确定一个平面上的三角形</li><li><p>任意多边形都可以被分解为若干个三角形，这种分解使得处理复杂的多边形图形变得更加容易。</p></li><li><p>三角形在仿射变换下保持平面性，对三角形的变换相对简单，而不会引入复杂的扭曲。</p></li></ul><h3 id="1-直线光栅化算法"><a href="#1-直线光栅化算法" class="headerlink" title="1.直线光栅化算法"></a>1.直线光栅化算法</h3><h4 id="1-1-DDA数值微分算法"><a href="#1-1-DDA数值微分算法" class="headerlink" title="1.1 DDA数值微分算法"></a>1.1 DDA数值微分算法</h4><p>通过两点确定一条直线的斜率（k)，若|k|&lt;=1,选择x方向作为步长（选择变换快的方向），若|k|&gt;1,选择y方向作为步长。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033642.png" alt="image-20231128195221236" style="zoom:50%;"></p><p>注：在所选的步长方向上，从起始点 <code>(x0, y0)</code> 开始，计算每个下一个点的坐标 <code>(xi, yi)</code>。对于x方向的步长，使用 <code>xi+1 = xi + 1</code>；对于 y 方向的步长，使用 <code>yi+1 = yi + m</code>。(y的结果要四舍五入)</p><h4 id="1-2-Bresenham直线绘制算法"><a href="#1-2-Bresenham直线绘制算法" class="headerlink" title="1.2 Bresenham直线绘制算法"></a>1.2 Bresenham直线绘制算法</h4><p>Bresenham直线绘制算法通过在每个步骤中选择最接近理想路径上的点来逐步绘制线段，从而避免了使用浮点数运算，提高了计算效率。</p><p><strong>pass</strong></p><h3 id="2-三角形光栅化算法"><a href="#2-三角形光栅化算法" class="headerlink" title="2.三角形光栅化算法"></a>2.三角形光栅化算法</h3><p><strong>每一个像素进行采样:</strong>判断像素中心是否在三角形内部</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034020.png" alt="image-20231128200407428" style="zoom: 50%;"></p><p><strong>判断一个点在三角形内部的方法：</strong>利用叉乘的性质</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034363.png" alt="image-20231128200536862" style="zoom:50%;"></p><p>​        分别计算 $P_0P_1×P_0Q、 P_1P_2×P_1Q、P_2P_0×P_2Q$，如果三者同号则代表点P在三条线段的同一边，那么必然处于三角形内部，如果不同号则代表该点一定在三角形外部<br><strong>利用bouding box减少点的计算：</strong>三角形通常只占屏幕很小的一部分，只对该bounding box内的点进行采样测试</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034364.png" alt="image-20231128201223186" style="zoom:50%;"></p><p><strong>锯齿现象：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034128.png" alt="image-20231128201443202" style="zoom:50%;"></p><p>产生的原因：只用了有限的采样点去逼近连续的三角形</p><h3 id="3-解决走样的方法"><a href="#3-解决走样的方法" class="headerlink" title="3.解决走样的方法"></a>3.解决走样的方法</h3><h4 id="3-1超采样反走样-Super-Sampling-AA"><a href="#3-1超采样反走样-Super-Sampling-AA" class="headerlink" title="3.1超采样反走样(Super Sampling AA)"></a>3.1超采样反走样(Super Sampling AA)</h4><p>用更多的采样点去逼近连续的三角形</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034872.png" alt="image-20231128201847832" style="zoom:50%;"></p><p>对着四个采样点分别计算颜色值，将这四个点的采样点的颜色值取均值，如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034448.png" alt="image-20231128202001340" style="zoom:50%;"></p><p><em>注：超采样的缺点是对计算资源的更高要求</em></p><h4 id="3-2多采样反走样-Multi-Sampling-AA"><a href="#3-2多采样反走样-Multi-Sampling-AA" class="headerlink" title="3.2多采样反走样(Multi-Sampling AA)"></a>3.2多采样反走样(Multi-Sampling AA)</h4><p>MSAA是对SSAA的改进，不再为每个采样点都计算颜色值，而只计算像素中采样点被覆盖的比例，而后在中心点处计算颜色值。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034470.png" alt="image-20231128202605057" style="zoom:50%;"></p><h4 id="3-3-先模糊（滤波），再采样"><a href="#3-3-先模糊（滤波），再采样" class="headerlink" title="3.3 先模糊（滤波），再采样"></a>3.3 先模糊（滤波），再采样</h4><p>通过在采样前进行滤波，可以去除信号中的高频分量，从而在采样时避免混叠效应，减少走样。</p><p>在频域中限制高频成分的影响，有助于避免走样问题</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034171.png" alt="image-20231128203246227" style="zoom:50%;"></p><h3 id="4-深度测试"><a href="#4-深度测试" class="headerlink" title="4.深度测试"></a>4.深度测试</h3><p>深度测试是指在渲染图像时确定像素的深度值（或称为Z值）以确定哪些像素应该显示在屏幕上。</p><p><em>注：深度测试是一种解决图形学中遮挡关系的技术，确保在屏幕上只显示最前面的像素，而将被遮挡的像素隐藏起来，从而呈现出正确的三维场景。</em></p><h4 id="Z-Buffer（深度缓冲）算法"><a href="#Z-Buffer（深度缓冲）算法" class="headerlink" title="Z-Buffer（深度缓冲）算法"></a>Z-Buffer（深度缓冲）算法</h4><p><strong>算法的基本思想：</strong>每个采样点（像素）存储当前的最小深度值，假设深度值（z值）始终为正值。如果一个像素的深度值较小，表示它离观察者更近；反之，如果深度值较大，则表示它离观察者更远。<strong>帧缓冲用于存储屏幕上每个像素的颜色信息，深度缓冲专门用于存储每个像素的深度值</strong>，如果当前像素的深度值较小（即更接近观察者），则更新深度缓冲和帧缓冲中的值；否则，将其视为被遮挡，不进行更新。</p><p>伪代码如下:</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312011217448.png" alt="image-20231130085326419" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312011217183.png" alt="image-20231130085351796" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;光栅化&quot;&gt;&lt;a href=&quot;#光栅化&quot; class=&quot;headerlink&quot; title=&quot;光栅化&quot;&gt;&lt;/a&gt;光栅化&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;光栅化（Rasterization）&lt;/strong&gt;是图形学中一种常用的渲染技术，用于将三维场景中的图形对象转换为</summary>
      
    
    
    
    <category term="图形学" scheme="https://wangak.cc/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>SPM</title>
    <link href="https://wangak.cc/posts/236d2982.html"/>
    <id>https://wangak.cc/posts/236d2982.html</id>
    <published>2023-11-18T06:23:40.209Z</published>
    <updated>2023-11-28T12:35:31.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SPM"><a href="#SPM" class="headerlink" title="SPM"></a>SPM</h2><p><strong>论文：《Learning with Explicit Shape Priors for Medical Image Segmentation》（TMI 2023)</strong></p><p><strong>探索形状先验(shape priors)对分割性能的影响</strong></p><p>基于unet的医学图像分割模型的局限性:cnn的感受野有限，无法利用器官或组织之间的远距离和全局空间关系，无法实现精细的形状表示。（注意力模块扩大模型的感受野，隐式地捕获形状信息）</p><p><em>注：通过设计特定的损失函数，而不是Dice损失或交叉熵损失，将明确的形状先验集成到分割框架中。但这些损失函数是特定于任务的，不能很容易地扩展到不同的数据集</em></p><p>提出了显式形状模型（SPM），以形状先验作为额外的输入来增强模型的形状表示能力。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436431.png" alt="image-20231120152537182" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436712.png" alt="image-20231120163304452" style="zoom:67%;"></p><p>其中F代表模型的前向传播，S代表构造图像I和标签L之间映射的形状先验。</p><p><strong>注意力图：</strong>生成的形状先验在推断阶段充当了注意力图，用于定位感兴趣的区域，并抑制背景区域</p><p><strong>SPM模块：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436670.png" alt="image-20231120153357914" style="zoom:67%;"></p><p>SPM模块由the self-update block (SUB)、cross-update block (CUB)</p><p><strong>the self-update block (SUB)：</strong>以形状先验作为输入，用于生成全局形状先验</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436041.png" alt="image-20231120154358605" style="zoom:50%;"></p><p>SUB的结构缺乏对局部视觉结构的建模，全局形状先验不具有精确的形状和轮廓信息。</p><p><strong>cross-update block (CUB)：</strong>建模局部形状先验</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436616.png" alt="image-20231120160130787" style="zoom: 50%;"></p><p><script type="math/tex">C_{map}</script>:一个C × N矩阵,用于评估C通道特征映射Fo和N通道形状先验之间的关系。</p><p>下采样<script type="math/tex">F_e</script>生成局部形状先验<script type="math/tex">S_L</script>:</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436429.png" alt="image-20231120160808202" style="zoom:50%;"></p><p>增强的形状先验融合了SUB生成全局形状先验及CUB生成的局部形状先验</p><h3 id="实验部分："><a href="#实验部分：" class="headerlink" title="实验部分："></a>实验部分：</h3><p><strong>与其他方法的对比：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436022.png" alt="image-20231120202559717" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436614.png" alt="image-20231120202723390" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436085.png" alt="image-20231120202732327" style="zoom: 67%;"></p><p><strong>消融实验：</strong>在BRATS 2020（脑肿瘤）、<strong>VerSe2019</strong>(脊柱)、ACDC（心脏）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436828.png" alt="image-20231120201045294" style="zoom: 80%;"></p><p>表明SPM有增强模型对相对规则的形状区域的表示能力</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SPM&quot;&gt;&lt;a href=&quot;#SPM&quot; class=&quot;headerlink&quot; title=&quot;SPM&quot;&gt;&lt;/a&gt;SPM&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;论文：《Learning with Explicit Shape Priors for Medical Image </summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
</feed>
