<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>丹青两幻</title>
  
  <subtitle>欢迎~</subtitle>
  <link href="https://wangak.cc/atom.xml" rel="self"/>
  
  <link href="https://wangak.cc/"/>
  <updated>2025-04-07T16:00:00.000Z</updated>
  <id>https://wangak.cc/</id>
  
  <author>
    <name>丹青两幻</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STL面试</title>
    <link href="https://wangak.cc/posts/ea5b5bc.html"/>
    <id>https://wangak.cc/posts/ea5b5bc.html</id>
    <published>2025-04-07T16:00:00.000Z</published>
    <updated>2025-04-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="STL面试"><a href="#STL面试" class="headerlink" title="STL面试"></a>STL面试</h2><h4 id="1-vector迭代器失效的问题？"><a href="#1-vector迭代器失效的问题？" class="headerlink" title="1.vector迭代器失效的问题？"></a>1.vector迭代器失效的问题？</h4><p>vector中的插入/删除会改变元素的位置或数量，从而导致迭代器失效。对vector进行连续插入或者删除操作（insert/erase)，一定要更新迭代器。</p><h4 id="2-array和vector的区别？"><a href="#2-array和vector的区别？" class="headerlink" title="2.array和vector的区别？"></a>2.array和vector的区别？</h4><ul><li><p><strong>大小是否可变：</strong></p><ul><li><strong><code>std::array</code></strong>在<strong>编译时确定大小</strong>，运行时无法更改。</li><li><strong><code>std::vector</code></strong>可在运行时动态调整大小</li></ul></li><li><p><strong>底层实现：</strong></p><ul><li><strong><code>std::array</code>：</strong> 基于普通数组（连续存储）实现，直接存储在栈上（除非它是某个堆对象的一部分）。</li><li><strong><code>std::vector</code>：</strong> 基于动态数组实现，数据存储在堆上。（在使用vector这个结构的时候，如果vector在函数内部直接定义，则对象存储在栈上，数据存储在堆上；而通过new动态创建时，指针在栈上，对象和数据都在堆上。</li></ul></li><li><p><strong>性能：</strong> <strong><code>vector</code></strong>插入或删除元素时可能需要重新分配内存和复制数据，导致性能下降。</p><p>注：如果提前预留足够的容量（通过 <code>reserve()</code> 方法），可以减少动态分配的次数。</p></li><li><p><strong>容器大小：</strong></p><ul><li><strong><code>std::array</code>：</strong> 返回的是编译时固定的大小</li><li><strong><code>std::vector</code></strong>：返回当前存储的元素数量</li></ul></li><li><p><strong>迭代器失效</strong>：<code>array</code>迭代器永远不会失效，除非整个容器被销毁。</p></li></ul><h4 id="3-描述一下vetcor动态内存的基本原理"><a href="#3-描述一下vetcor动态内存的基本原理" class="headerlink" title="3.描述一下vetcor动态内存的基本原理"></a>3.描述一下vetcor动态内存的基本原理</h4><p><strong>内存分配策略：</strong></p><ul><li><strong>分配更大的内存块</strong>：通过<strong>增长因子</strong>将容量翻倍（例如，从 4 → 8 → 16 → 32…）</li><li><strong>复制原有数据</strong>： 将原有数据从旧内存块复制到新内存块</li><li><strong>释放旧内存</strong>： 在完成数据迁移后，旧的内存块会被释放</li><li><strong>更新内部状态</strong>： 更新 <code>capacity</code> 和指向新内存块的指针。</li></ul><h4 id="4-介绍一下deque的底层结构"><a href="#4-介绍一下deque的底层结构" class="headerlink" title="4.介绍一下deque的底层结构"></a>4.介绍一下deque的底层结构</h4><p><code>std::deque</code>结合了数组和链表的特性</p><p><strong>底层实现：分块存储</strong></p><ul><li><strong>主数组（Map 或索引数组）:</strong> 指针数组，存储指向各个小块（chunk）的指针。</li><li><strong>小块（Chunk）:</strong> 固定大小的连续内存区域，用于存储 <code>std::deque</code> 的实际数据。</li><li><strong>头部和尾部标记:</strong> <code>std::deque</code> 内部维护两个标记，分别指向当前数据的起始位置和结束位置。</li></ul><p><strong><em>注：deque支持随机访问</em></strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202504102134400.png" alt="image-20250407170801444" style="zoom:50%;"></p><h4 id="5-list的底层结构是什么？"><a href="#5-list的底层结构是什么？" class="headerlink" title="5.list的底层结构是什么？"></a>5.list的底层结构是什么？</h4><p>双向循环链表</p><h4 id="6-容器适配器有哪些？底层结构是什么？"><a href="#6-容器适配器有哪些？底层结构是什么？" class="headerlink" title="6.容器适配器有哪些？底层结构是什么？"></a>6.容器适配器有哪些？底层结构是什么？</h4><ul><li><strong><code>stack</code>： </strong>底层默认使用 <code>std::deque</code></li><li><strong><code>queue</code>:</strong>  底层默认使用 <code>std::deque</code></li><li><strong><code>priority_queue:</code></strong> 底层默认使用<code>std::vector</code>。队列中的元素根据优先级排序，默认是大根堆。入队时进行排序，出队时排出优先级最高的元素，并对剩下的元素重新排序</li></ul><p><em>容器适配器没有自己的数据结构，它的方法全部由底层依赖的容器进行实现</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;STL面试&quot;&gt;&lt;a href=&quot;#STL面试&quot; class=&quot;headerlink&quot; title=&quot;STL面试&quot;&gt;&lt;/a&gt;STL面试&lt;/h2&gt;&lt;h4 id=&quot;1-vector迭代器失效的问题？&quot;&gt;&lt;a href=&quot;#1-vector迭代器失效的问题？&quot; class</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>智能指针面试题</title>
    <link href="https://wangak.cc/posts/1be7b917.html"/>
    <id>https://wangak.cc/posts/1be7b917.html</id>
    <published>2025-04-07T16:00:00.000Z</published>
    <updated>2025-04-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="智能指针面试题"><a href="#智能指针面试题" class="headerlink" title="智能指针面试题"></a>智能指针面试题</h3><h4 id="1-介绍一下shared-ptr的底层实现"><a href="#1-介绍一下shared-ptr的底层实现" class="headerlink" title="1.介绍一下shared_ptr的底层实现"></a>1.介绍一下shared_ptr的底层实现</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504081029173.png" alt="image-20250408093323071" style="zoom:67%;"></p><p><code>std::shared_ptr</code>的底层结构分为两部分：</p><ul><li><p><strong>控制块（Control Block）</strong>：一个动态分配的小型数据结构，用于存储引用计数和其他元信息。</p><ul><li><strong>强引用计数（Strong Reference Count）</strong>：记录有多少个 <code>shared_ptr</code> 引用了该对象。</li><li><strong>弱引用计数（Weak Reference Count）</strong>：记录有多少个 <code>std::weak_ptr</code> 引用了该对象（用于支持 <code>std::weak_ptr</code>）。</li><li><strong>删除器（Deleter）</strong>：可选的自定义函数，用于释放对象时执行特定操作。</li><li><strong>分配器（Allocator）</strong>：可选的自定义分配器，用于管理内存分配和释放。</li></ul></li><li><p><strong>原始指针（Raw Pointer）</strong>：保存一个指向实际对象的原始指针</p></li></ul><h4 id="2-介绍一下shared-ptr的引用计数的操作"><a href="#2-介绍一下shared-ptr的引用计数的操作" class="headerlink" title="2.介绍一下shared_ptr的引用计数的操作"></a>2.介绍一下shared_ptr的引用计数的操作</h4><p><strong>增加引用计数</strong>：当一个 <code>shared_ptr</code> 被拷贝（通过拷贝构造函数或赋值操作符）时，控制块中的强引用计数加 1。</p><p><strong>减少引用计数</strong>：当一个 <code>shared_ptr</code> 被销毁或重置时，控制块中的强引用计数减 1。</p><ul><li><strong>强引用计数变为 0：</strong><ul><li>调用删除器（如果有）来释放原始指针指向的对象。</li><li>如果<strong>弱引用计数也为 0</strong>，则释放控制块本身。</li></ul></li></ul><h4 id="3-weak-ptr能直接访问对象吗"><a href="#3-weak-ptr能直接访问对象吗" class="headerlink" title="3.weak_ptr能直接访问对象吗"></a>3.weak_ptr能直接访问对象吗</h4><p><code>std::weak_ptr</code> 本身<strong>不能直接访问对象</strong>，<code>std::weak_ptr</code> 可以通过检查控制块的状态来<strong>判断对象是否仍然有效</strong>。</p><p><strong>间接访问：</strong></p><ul><li><p><strong>检查对象是否仍然有效：</strong> 调用 <code>std::weak_ptr::lock()</code> 方法，尝试将 <code>std::weak_ptr</code> 提升为一个 <code>std::shared_ptr</code></p><ul><li>强引用计数为 0（即对象已经被销毁），<code>lock()</code> 返回一个空的 <code>std::shared_ptr</code></li><li>强引用计数大于 0（即对象仍然有效），<code>lock()</code> 返回一个新的 <code>std::shared_ptr</code>，并增加强引用计数。</li></ul></li><li><p><strong>提升为 <code>std::shared_ptr</code>：</strong> 如果 <code>std::weak_ptr::lock()</code> 成功返回一个有效的 <code>std::shared_ptr</code>，则可以通过这个 <code>std::shared_ptr</code> 访问对象。</p></li></ul><h4 id="4-shared-ptr和unique-ptr的区别"><a href="#4-shared-ptr和unique-ptr的区别" class="headerlink" title="4.shared_ptr和unique_ptr的区别"></a>4.shared_ptr和unique_ptr的区别</h4><ul><li><p><strong>所有权：</strong></p><ul><li><strong><code>std::unique_ptr</code></strong>：实现了独占所有权语义。</li><li><strong><code>std::shared_ptr</code></strong>：实现了共享所有权语义。</li></ul></li><li><p><strong>性能与内存开销：</strong></p><ul><li><strong><code>std::unique_ptr</code></strong>：性能较高，因为它不需要额外的内存开销来存储引用计数或其他元数据。</li><li><strong><code>std::shared_ptr</code></strong>：性能较低，因为每次增加或减少引用计数都需要原子操作。还需要额外的控制块来存储引用计数和其他信息。</li></ul></li><li><p><strong>移动语义 vs 复制语义：</strong></p><ul><li><strong><code>std::unique_ptr</code></strong>：支持移动语义，但不支持复制语义。</li><li><strong><code>std::shared_ptr</code></strong>：支持复制和赋值操作。</li></ul></li></ul><h4 id="5-shared-ptr的循环引用问题是什么？如何解决？"><a href="#5-shared-ptr的循环引用问题是什么？如何解决？" class="headerlink" title="5.shared_ptr的循环引用问题是什么？如何解决？"></a>5.shared_ptr的循环引用问题是什么？如何解决？</h4><p><strong>循环引用:</strong> <code>std::shared_ptr</code> 的循环引用问题是指两个或多个对象通过 <code>std::shared_ptr</code> <strong>相互持有对方</strong>，导致它们的强引用计数永远不会降为 0，从而无法释放内存。</p><p><strong>解决方案：用 <code>std::weak_ptr</code> 替代部分 <code>std::shared_ptr</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr; <span class="comment">// A 持有 B 的 shared_ptr</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A is destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;A&gt; a_ptr; <span class="comment">// 使用 weak_ptr 持有 A，此处如果是shared_ptr就变成了循环引用</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B is destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    <span class="keyword">auto</span> b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">    a-&gt;b_ptr = b; <span class="comment">// A 持有 B</span></span><br><span class="line">    b-&gt;a_ptr = a; <span class="comment">// B 使用 weak_ptr 持有 A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时 a 的强引用计数为 1，b 的强引用计数为 2</span></span><br><span class="line">&#125; <span class="comment">// 离开作用域后，a 和 b 的局部变量被销毁，引用计数降为 0，对象被正确释放</span></span><br></pre></td></tr></table></figure><h4 id="6-shared-ptr是否线程安全？"><a href="#6-shared-ptr是否线程安全？" class="headerlink" title="6.shared_ptr是否线程安全？"></a>6.shared_ptr是否线程安全？</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504081029981.png" alt="image-20250408100616337" style="zoom:50%;"></p><h4 id="7-shared-ptr的构造方法有哪几种，为什么尽量使用make-shared"><a href="#7-shared-ptr的构造方法有哪几种，为什么尽量使用make-shared" class="headerlink" title="7.shared_ptr的构造方法有哪几种，为什么尽量使用make_shared?"></a>7.shared_ptr的构造方法有哪几种，为什么尽量使用make_shared?</h4><p><strong>构造方法：</strong></p><ul><li><p><strong>默认构造函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr; <span class="comment">// 空 shared_ptr</span></span><br></pre></td></tr></table></figure></li><li><p><strong>从原始指针构造</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* rawPtr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(rawPtr)</span></span>; <span class="comment">// 用裸指针初始化 shared_ptr</span></span><br></pre></td></tr></table></figure><p><em>注：这种方式需要手动分配内存（如 <code>new</code>），容易导致资源泄漏或双重释放。</em></p></li><li><p><strong>使用 <code>std::make_shared</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用删除器：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>), [](<span class="type">int</span>* p) &#123; <span class="keyword">delete</span> p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>为什么尽量使用make_shared:</strong></p><ul><li><p><strong>减少内存分配次数</strong>：裸指针需要两次内存分配,而 <code>std::make_shared</code> 将对象和控制块合并到一次内存分配中，减少了内存分配的开销。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用裸指针构造 shared_ptr</span></span><br><span class="line"><span class="type">int</span>* rawPtr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>); <span class="comment">// 分配对象</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(rawPtr)</span></span>; <span class="comment">// 分配控制块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 make_shared</span></span><br><span class="line"><span class="keyword">auto</span> ptr2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 合并对象和控制块的一次分配</span></span><br></pre></td></tr></table></figure></li><li><p><strong>异常安全性:</strong> 在分配对象后、构造 <code>std::shared_ptr</code> 前抛出异常，则会导致内存泄漏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用裸指针可能引发异常安全性问题</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span>* rawPtr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>); <span class="comment">// 分配对象</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error&quot;</span>); <span class="comment">// 抛出异常，rawPtr 未被管理</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(rawPtr)</span></span>; <span class="comment">// 这行代码不会被执行</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 内存泄漏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 make_shared 是安全的</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 单步完成分配和管理</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error&quot;</span>); <span class="comment">// 异常安全，ptr 会正确释放资源</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 资源被正确释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504081029670.png" alt="image-20250408101900500" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;智能指针面试题&quot;&gt;&lt;a href=&quot;#智能指针面试题&quot; class=&quot;headerlink&quot; title=&quot;智能指针面试题&quot;&gt;&lt;/a&gt;智能指针面试题&lt;/h3&gt;&lt;h4 id=&quot;1-介绍一下shared-ptr的底层实现&quot;&gt;&lt;a href=&quot;#1-介绍一下shared</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Muduo库</title>
    <link href="https://wangak.cc/posts/70fda4f8.html"/>
    <id>https://wangak.cc/posts/70fda4f8.html</id>
    <published>2025-04-06T16:00:00.000Z</published>
    <updated>2025-04-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="非阻塞IO-IO复用"><a href="#非阻塞IO-IO复用" class="headerlink" title="非阻塞IO+IO复用"></a>非阻塞IO+IO复用</h4><p><strong>Event Loop：</strong> <strong>一个不断监听事件的发生，并调用相应回调函数的机制。</strong>处理<strong>异步</strong>I/O操作的编程模式，通过一个无限循环监听和分发事件。</p><p>注：在Event Loop中，应用首先注册感兴趣的事件处理器（如网络连接、文件I/O等），然后进入一个循环，等待这些事件的发生，并在事件发生时调用相应的处理器来响应事件。</p><p><strong>Non-Blocking 几乎总是和 I/O 多路复用一起使用：</strong></p><ul><li>单用Non-Blocking需要<strong>轮询</strong>检测I/O状态，会浪费CPU资源。</li><li><strong>I/O多路复用不能与阻塞I/O共存：</strong>I/O 多路复用判断某个 socket 可能处于某种状态（如“可读”或“可写”），但这并不保证后续的阻塞 I/O 操作一定能够成功完成。<ul><li>对于“可读”状态，可能只是表示内核缓冲区中有一些数据，但实际的数据量可能不足以满足 <code>read()</code> 请求（比如请求读取 100 字节，但缓冲区只有 50 字节）。</li><li>对于“可写”状态，可能只是表示内核缓冲区有空间，但如果你尝试写入大量数据，可能会超出缓冲区容量，导致 <code>write()</code> 阻塞。</li></ul></li></ul><p><strong><em>注：阻塞 I/O 会导致线程被挂起，从而无法处理其他 socket 上的事件。</em></strong></p><h4 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h4><p><strong>Reactor模型：</strong>是一个<strong>异步</strong>I/O模型，它不会阻塞程序的执行等待某个I/O操作完成，而是通过<strong>事件驱动</strong>的方式来处理I/O操作。Reactor设计模式是用于处理服务请求的事件处理模式，由一个或多个输入同时传递给服务处理程序，服务处理程序然后对传入的请求进行<strong>解复用</strong>，并将它们<strong>同步分派</strong>给关联的请求处理程序。</p><p><strong>Reactor模式的核心概念：事件分发和处理分离</strong></p><ul><li><strong>事件驱动</strong>：在Reactor模型中，所有输入（如客户端连接请求、数据到达等）都被视为事件。这些事件由Reactor负责监听和分发。</li><li><strong>解复用</strong>：当多个输入同时到达服务端时，Reactor会将这些输入进行解复用（demultiplexing），即<strong>根据事件类型将它们分类</strong>。例如，连接请求和数据接收是两种不同的事件类型，会被分配给不同的处理器处理。</li><li><strong>同步分派</strong>：一旦事件被解复用后，Reactor会同步地将这些事件分派给对应的事件处理器（EventHandler）。这里的“同步”意味着<strong>Reactor以同步方式分派事件。</strong></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504071032961.png" alt="image-20250407100736409" style="zoom: 50%;"></p><p><strong>一个Reactor模型的网络服务器交互流程：</strong></p><ul><li><strong>注册感兴趣的事件和回调函数：</strong> 将感兴趣的事件及预置的回调函数Handler注册到Reactor反应堆上</li><li><p><strong>启动Reactor反应堆：</strong> 一旦所有的事件都注册完毕，Reactor 就开始监听这些事件的发生。</p></li><li><p><strong>启动事件分发器：</strong>持续等待直到有事件发生，一旦事件分发器检测到某个事件已经准备好，就会通知 Reactor。</p></li><li><strong>处理事件并响应:</strong>  Reactor会通过map表找到Event事件对应的事件处理器来读取用户请求</li></ul><p><strong>Main Reactor 和 Sub Reactors：</strong>为了提高系统的可扩展性（连接和读写请求相分离）和性能（负载均衡）</p><ul><li><p>当有新的客户端连接请求到达时，Main Reactor 调用 <code>accept()</code> 接受连接，<strong>并获取客户端的 socket 文件描述符</strong>，将其分配给某个 Sub Reactor。</p><p><em>注：这里一般是Main Reactor 直接调用<code>accept()</code> ，而不用事件处理器。因为接受新连接的逻辑简单且高效</em></p></li><li><p>Sub Reactors 的任务是<strong>监听已经建立的连接</strong>（即客户端的 socket），并处理（调用对应的事件处理器）这些连接上的 I/O 事件，比如数据到达、可写等。</p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504071033850.png" alt="image-20250407101911108" style="zoom:67%;"></p><h4 id="ET模式与LT模式"><a href="#ET模式与LT模式" class="headerlink" title="ET模式与LT模式"></a>ET模式与LT模式</h4><p><strong>LT模式：</strong> 当 <code>epoll_wait</code> 检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用 <code>epoll_wait</code>时，还会再次向应用程序通告此事件，直到该事件被处理。</p><p><strong>ET模式：</strong>当<code>epoll_wait</code>检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的<code>epoll_wait</code>调用将不再向应用程序通知这一事件。所以 ET 模式在很大程度上<strong>降低了同一个<code>epoll</code>事件被重复触发的次数</strong>，因此一半了来说效率比 LT 模式高。</p><p><strong>实际上muduo库采用的为LT模式，主要好处如下：</strong></p><ul><li><strong>不会丢失数据或者消息：</strong> 应用没有读取完数据，内核是会不断上报的。</li><li><strong>低延迟处理：</strong> 每次读数据只需要一次系统调用；照顾了多个连接的<strong>公平性</strong>，不会因为某个连接上的数据量过大而影响其他连接处理消息。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;非阻塞IO-IO复用&quot;&gt;&lt;a href=&quot;#非阻塞IO-IO复用&quot; class=&quot;headerlink&quot; title=&quot;非阻塞IO+IO复用&quot;&gt;&lt;/a&gt;非阻塞IO+IO复用&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Event Loop：&lt;/strong&gt; &lt;strong&gt;一</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="网络" scheme="https://wangak.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux项目相关</title>
    <link href="https://wangak.cc/posts/a61c879f.html"/>
    <id>https://wangak.cc/posts/a61c879f.html</id>
    <published>2025-04-01T16:00:00.000Z</published>
    <updated>2025-04-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-平均负载？"><a href="#1-平均负载？" class="headerlink" title="1.平均负载？"></a><strong>1.平均负载？</strong></h4><p><strong>平均负载：</strong> 单位时间内活跃的进程数</p><p><strong>eg:</strong></p><p><strong>平均负载为 2 时，意味着什么呢？</strong></p><ul><li>系统有2个CPU：所有的CPU都刚好被完全占用。</li><li>系统有4个CPU： CPU有50%的空闲。</li><li>系统有1个CPU：一半的进程竞争不到CPU，会有进程切换</li></ul><h4 id="2-记录了1分钟、5分钟、15分钟的平均负载，到底怎么参考？"><a href="#2-记录了1分钟、5分钟、15分钟的平均负载，到底怎么参考？" class="headerlink" title="2.记录了1分钟、5分钟、15分钟的平均负载，到底怎么参考？"></a>2.记录了1分钟、5分钟、15分钟的平均负载，到底怎么参考？</h4><p><strong>负载平衡：</strong>1 分钟、5 分钟、15 分钟的三个值基本相同</p><p><strong>1 分钟的值远小于 15 分钟的值：</strong> 在14分钟的时间里系统的负载情况是有一点问题的</p><p><strong>1 分钟的值远大于 15 分钟的值：</strong> 这种增加有可能只是临时性的，需要持续观察</p><p><strong>1 分钟的平均负载接近或超过了 CPU 的个数：</strong> 系统正在发生过载的问题，就需要分析具体的问题，并进行优化了</p><p>当平均负载高于 CPU 数量 70% 的时候，你就应该分析排查负载高的问题了。</p><h4 id="3-平均负载与-CPU-使用率的区别"><a href="#3-平均负载与-CPU-使用率的区别" class="headerlink" title="3.平均负载与 CPU 使用率的区别"></a>3.平均负载与 CPU 使用率的区别</h4><p><strong>平均负载：</strong> 代表的是活跃进程数，指单位时间内，处于可运行状态和不可中断状态的进程数。</p><p><strong>CPU 使用率：</strong> 单位时间内 CPU 繁忙情况的统计。</p><p><strong>平均负载和CPU使用率未必是一致的：</strong></p><ul><li><strong>CPU 密集型进程</strong>，使用大量 CPU 会导致平均负载升高，此时这两者是一致的</li><li><strong>I/O 密集型进程</strong>，等待 I/O 也会导致平均负载升高，但 CPU 使用 率不一定很高</li></ul><h4 id="4-什么是中断？"><a href="#4-什么是中断？" class="headerlink" title="4.什么是中断？"></a>4.什么是中断？</h4><p><strong>中断其实是一种异步的事件处理机制，可以提高系统的并发处理能力</strong>，中断处理程序会打断其他进程的运行。</p><p><strong><em>注：中断处理程序在响应中断时，还会临时关闭别的中断（中断屏蔽）。这就会导致上一次中断处理完成之前，其他中断都不能响应，也就是说中断有可能会丢失。（中断队列的容量限制）</em></strong></p><h4 id="5-什么是软中断？"><a href="#5-什么是软中断？" class="headerlink" title="5.什么是软中断？"></a>5.什么是软中断？</h4><p>为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部：</p><ul><li>上半部用来快速处理中断，它<strong>在中断禁止模式下运行</strong>，主要处理跟硬件紧密相关的或时间敏感的工作。</li><li>下半部用来延迟处理上半部未完成的工作，通常以<strong>内核线程</strong>的方式运行</li></ul><p>从上半部到下半部的切换是通过<strong>软中断信号</strong>实现的</p><ul><li><p>上半部直接处理<strong>硬件请求</strong>，也就是我们常说的<strong>硬中断</strong>，特点是快速执行；</p></li><li><p>下半部则是由<strong>内核触发</strong>，也就是我们常说的软中断，特点是延迟执行。</p></li></ul><p><em>注1：软中断不只包括了硬件设备中断处理程序的下半部，一些内核自定义的事件也属于软中断</em></p><p><em>注2：同一种中断在不同 CPU 上的累积次数应该差不多。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-平均负载？&quot;&gt;&lt;a href=&quot;#1-平均负载？&quot; class=&quot;headerlink&quot; title=&quot;1.平均负载？&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.平均负载？&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;平均负载：&lt;/strong&gt; 单位时间内活跃的进程</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议</title>
    <link href="https://wangak.cc/posts/51aeee82.html"/>
    <id>https://wangak.cc/posts/51aeee82.html</id>
    <published>2025-03-31T16:00:00.000Z</published>
    <updated>2025-03-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么是TCP网络分层？"><a href="#1-什么是TCP网络分层？" class="headerlink" title="1.什么是TCP网络分层？"></a>1.什么是TCP网络分层？</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504012024749.png" alt="image-20250328205930579" style="zoom:67%;"></p><p>客户端：发送HTTP数据包</p><ul><li>应用层：根据HTTP协议组装数据包</li><li>传输层：增加TCP头部（包含端口号、序列号等）</li><li>网络层：增加IP头部（包含源IP地址等）</li><li>网络接口层：增加以太网头部（包含MAC地址等）</li></ul><p>服务端：接收HTTP数据包</p><ul><li>应用层：HTTP报文解析</li><li>传输层：TCP报文解析</li><li>网络层：IP报文解析，传送数据包、确定路由</li><li>网络接口层：根据MAC地址判断包是不是发给自己的</li></ul><h4 id="2-TCP协议的三次握手为什么不能是两次？为什么不能是四次？"><a href="#2-TCP协议的三次握手为什么不能是两次？为什么不能是四次？" class="headerlink" title="2.TCP协议的三次握手为什么不能是两次？为什么不能是四次？"></a>2.TCP协议的三次握手为什么不能是两次？为什么不能是四次？</h4><p><strong>三次握手：</strong></p><ul><li>客户端向服务端发送连接请求：客户端发送请求报文将 SYN = 1 同步序列号和初始化序列号 seq = x 发送给服务端，发送完之后客户端处于 <code>SYN_Send</code> 状态 (确认客户端的发送能力、服务端的接收能力)</li><li>服务端向客户端确认：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，此时服务器处于<code>SYN_RCVD</code> 的状态(确认服务端的发送能力、客户端的接收能力)</li><li>客户端收到 SYN 报文之后，会发送⼀个 ACK 报文，当然，也是⼀样把服务器的 ISN + 1 作为ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <code>ESTABLISHED</code> 状态。服务器收到 ACK 报文之后，也处于 <code>ESTABLISHED</code>状态，此时，双方已建立起了连接 (客户端向服务端建立连接)</li></ul><h4 id="3-TCP为什么是四次挥手？"><a href="#3-TCP为什么是四次挥手？" class="headerlink" title="3.TCP为什么是四次挥手？"></a>3.TCP为什么是四次挥手？</h4><p><strong>四次挥手：</strong></p><ul><li>第一次挥手：客户端请求断开(客户端发送FIN)</li><li>第二次挥手：服务端许可客户端断开连接（服务端回ACK，缓冲区写入<code>EOF</code>文件结束符，read读到<code>EOF</code>会返回0，进入<code>close_wait</code>状态）</li><li>第三次挥手：服务器请求断开(服务端发送FIN)</li><li>第四次挥手：客户端许可服务端断开连接(发送ACK)</li></ul><p><em>注：使用close（读写端都关闭）没有四次挥手，只有使用shutdown（关闭写端）时才有四次挥手</em></p><p><strong>为什么不能是三次？</strong></p><p>​    因为TCP的连接是全双工的，每个方向上的关闭都需要单独进行确认，否则一方关闭，另一方还在继续发送数据，会导致数据的丢失。</p><p><strong>为什么第二次挥手和第三次挥手不能合成一次？</strong></p><p>​    因为服务器上可能还有尚未处理完的数据，只有等数据都处理完毕之后，才能发出断开连接的请求</p><p><strong>如果发生数据包丢失，会发生什么？</strong></p><p>​    FIN包会重传，如果超出了所设置的最大重传次数，会直接断开。而ACK不会重传，ACK丢失会导致发送FIN包的一端不断重传，直至断开。</p><h4 id="4-四次挥手为什么要有time-wait的状态？"><a href="#4-四次挥手为什么要有time-wait的状态？" class="headerlink" title="4.四次挥手为什么要有time_wait的状态？"></a>4.四次挥手为什么要有time_wait的状态？</h4><ul><li><p><strong>防止旧数据包干扰新连接：</strong>如果一个 TCP 连接关闭后立即重新使用相同的源 IP、源端口、目标 IP 和目标端口（即相同的四元组）建立新的连接，那么之前滞留在网络中的旧数据包可能会被错误地认为是新连接的数据包。</p><ul><li><code>TIME_WAIT</code> 状态的作用是等待足够长的时间（通常是 2 倍的 MSL，Maximum Segment Lifetime），以确保所有可能的旧数据包都从网络中消失。</li><li>MSL 是指一个数据包在网络中能够存活的最长时间，通常设置为 30 秒到 2 分钟。因此，<code>TIME_WAIT</code> 的持续时间一般为 2MSL（大约 1~4 分钟）。</li></ul></li><li><p><strong>确保对方收到最后的 ACK</strong></p><ul><li>在 TCP 四次挥手中，主动关闭连接的一方（通常是客户端）会发送最后一个 ACK 来确认对方的 FIN 包。然而，这个 ACK 可能会在网络中丢失。如果对方没有收到这个 ACK，它会重传 FIN 包。</li></ul></li></ul><h4 id="5-为什么TIME-WAIT是-2MSL？"><a href="#5-为什么TIME-WAIT是-2MSL？" class="headerlink" title="5.为什么TIME_WAIT是 2MSL？"></a>5.<strong>为什么TIME_WAIT是 2MSL？</strong></h4><ul><li><strong>第一个 MSL</strong>：用于确保最后一个 ACK 能够到达对方。如果对方没有收到 ACK，它会重传 FIN 包。</li><li><strong>第二个 MSL</strong>：用于确保对方重传的 FIN 包能够到达本方，并得到处理。</li></ul><h4 id="6-为什么SYN-FIN不包含数据却需要消耗一个序列号？"><a href="#6-为什么SYN-FIN不包含数据却需要消耗一个序列号？" class="headerlink" title="6.为什么SYN/FIN不包含数据却需要消耗一个序列号？"></a>6.为什么SYN/FIN不包含数据却需要消耗一个序列号？</h4><p><strong>在TCP协议中，SYN（同步）和FIN（结束）标志位的报文虽然不包含应用层数据，但它们仍然需要消耗一个序列号。</strong></p><p>这是因为:</p><p><strong>凡是需要对端的确认，一定消耗TCP报文的序列号：</strong>TCP通过序列号和确认号来检测丢包并触发重传。如果无法区分重复的SYN或FIN报文。例如，如果网络中存在延迟的SYN报文，接收方可能会错误地认为这是一个新的连接请求。</p><h4 id="7-什么是半连接队列？什么是SYN-Flood攻击？"><a href="#7-什么是半连接队列？什么是SYN-Flood攻击？" class="headerlink" title="7.什么是半连接队列？什么是SYN Flood攻击？"></a>7.什么是半连接队列？什么是SYN Flood攻击？</h4><p><strong>半连接队列：</strong>客户端<strong>伪造IP发送SYN包</strong>，而服务端回复的ACK+SYN去到了一个未知的IP地址，这会造成大量的连接无法正常建立，这样的连接会处于半连接状态，而服务器会在半连接队列中记录这样的尚未完成的连接请求。</p><p><strong>SYN Flood（洪泛攻击）：</strong> 服务器的半连接队列大小是有限的，如果半连接队列满，会无法处理正常的请求。</p><h4 id="8-说说TCP快速打开-TCP-Fast-Open-TFO-原理"><a href="#8-说说TCP快速打开-TCP-Fast-Open-TFO-原理" class="headerlink" title="8.说说TCP快速打开(TCP Fast Open, TFO)原理"></a>8.说说TCP快速打开(TCP Fast Open, TFO)原理</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504012024295.png" alt="image-20250329141017329" style="zoom:50%;"></p><p><strong>TCP快速打开（TCP Fast Open, TFO）</strong>是一种旨在减少TCP连接建立时间，从而加速网络数据传输的机制。</p><p><strong>传统的TCP的缺陷：</strong>三次握手在每次建立连接时都需要完整地进行，这会引入一定的延迟，特别是在处理小数据量的请求时这种延迟尤为明显。</p><p><strong>TFO的工作流程：</strong></p><p><strong>阶段一：首次连接（无TFO，获取Cookie）</strong></p><ul><li><strong>客户端发送SYN并请求Cookie</strong>：普通SYN包，无数据，首选项表明支持TFO。</li><li><strong>服务端生成Cookie并发送至客户端</strong>：服务端生成一个加密的Cookie（基于客户端IP、密钥等），通过<code>SYN-ACK</code>的TFO选项返回。</li><li><strong>客户端存储Cookie</strong>：客户端保存该Cookie，用于后续连接。</li></ul><p><strong>阶段二：后续连接（启用TFO，加速握手）</strong></p><ul><li><p><strong>客户端发送SYN + 数据 + Cookie</strong>：</p></li><li><p>在SYN包中直接携带应用数据（如HTTP请求）和之前存储的Cookie。</p></li><li><p><strong>服务端验证Cookie</strong>：</p><ul><li>若Cookie有效，服务端立即处理数据并返回<code>SYN-ACK</code>（同时携带响应数据）。</li><li>若无效，则回退到普通三次握手，丢弃SYN中的数据。</li></ul></li><li><p><strong>客户端确认</strong>：发送<code>ACK</code>（若服务端已返回响应数据，此ACK可能已无实际数据，仅为确认连接的可靠性，否则退化为三次握手）</p></li></ul><p><strong>TFO性能收益:</strong></p><ul><li><strong>延迟降低</strong>：短连接场景可减少1 RTT，平均延迟下降20%~30%。</li></ul><h4 id="9-TCP时间戳的作用？"><a href="#9-TCP时间戳的作用？" class="headerlink" title="9.TCP时间戳的作用？"></a>9.TCP时间戳的作用？</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504012024595.png" alt="image-20250329143009627" style="zoom: 50%;"></p><p><strong>核心作用: </strong></p><ul><li><strong>计算往返时间</strong></li><li><strong>防止序列号回绕: </strong>时间戳作为序列号的扩展，即使序列号回绕，接收方通过比较时间戳（严格递增）可区分新旧数据包，<strong>丢弃过期的重复包</strong>。</li></ul><h4 id="10-TCP的超时重传时间是如何计算的"><a href="#10-TCP的超时重传时间是如何计算的" class="headerlink" title="10.TCP的超时重传时间是如何计算的?"></a>10.TCP的超时重传时间是如何计算的?</h4><p>TCP具有超时重传机制，即间隔一段时间没有等到数据包的回复，就会重传这个数据包。这个重传间隔就是<strong>超时重传时间（RTO)。</strong></p><p><strong>经典方法：（平滑RTT来计算RTO）适用于RTT波动较小的情况</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503291516533.png" alt="image-20250329144101644" style="zoom:67%;"></p><p><em>注：SampleRTT是新采样的RTT的值。</em></p><h4 id="11-说一说TCP的流量控制"><a href="#11-说一说TCP的流量控制" class="headerlink" title="11.说一说TCP的流量控制"></a>11.说一说TCP的流量控制</h4><p><strong>TCP发送数据的过程：</strong>发送方将数据放到发送缓冲区，再由发送缓冲区发送给接收方的接收缓冲区。</p><p><strong>流量控制的目标：</strong>根据接收缓冲区的大小控制发送端的发送。如果接收缓冲区满了，发送方就不能再继续发送。</p><p><strong>流量控制的基本原理：</strong></p><ul><li><strong>窗口字段</strong>：每个TCP报文段头部都包含一个16位的窗口字段（在某些情况下，如使用窗口缩放选项时可以大于16位），该字段指示了其剩余未使用的接收缓冲区大小。</li></ul><p><em>注：随着接收方处理数据并释放缓冲区空间，它可以向发送方发送具有更新后的窗口大小的新报文段，告知发送方现在可接受更多数据。</em></p><h4 id="12-如何理解TCP的keep-alive原理？"><a href="#12-如何理解TCP的keep-alive原理？" class="headerlink" title="12.如何理解TCP的keep-alive原理？"></a>12.如何理解TCP的keep-alive原理？</h4><p>​    TCP  Keep-Alive机制用于<strong>检测长时间处于空闲状态的TCP连接是否仍然有效</strong>。在网络通信中，可能会出现由于网络故障或对端主机崩溃等原因导致的连接中断，而两端的应用程序并未意识到这种情况的发生。Keep-Alive机制通过在<strong>设定的时间间隔内没有数据传输时发送探测包来检查连接的状态</strong>，从而帮助应用程序及时发现并处理这些“死”连接。</p><h4 id="13-A、B两个主机之间建立了一个TCP连接，A主机发给B主机两个TCP报文，大小分别是500和300，第一个报文的序列号是200，那么B主机接收两个报文后，返回的确认号是多少"><a href="#13-A、B两个主机之间建立了一个TCP连接，A主机发给B主机两个TCP报文，大小分别是500和300，第一个报文的序列号是200，那么B主机接收两个报文后，返回的确认号是多少" class="headerlink" title="13.A、B两个主机之间建立了一个TCP连接，A主机发给B主机两个TCP报文，大小分别是500和300，第一个报文的序列号是200，那么B主机接收两个报文后，返回的确认号是多少?"></a>13.A、B两个主机之间建立了一个TCP连接，A主机发给B主机两个TCP报文，大小分别是500和300，第一个报文的序列号是200，那么B主机接收两个报文后，返回的确认号是多少?</h4><p><strong>TCP序列号与确认号规则：</strong></p><ul><li><strong>序列号（SEQ）</strong>：标识发送方数据字节流的起始位置。</li><li><strong>确认号（ACK）</strong>：表示接收方<strong>期望收到的下一个字节的序列号</strong>（即已成功接收所有之前的数据）。</li><li><strong>数据长度</strong>：TCP报文中实际携带的应用数据长度（不包含TCP头部）。</li></ul><p>所以确认号为500+300+200=1000</p><h4 id="14-收到IP数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议（UDP或TCP"><a href="#14-收到IP数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议（UDP或TCP" class="headerlink" title="14.收到IP数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议（UDP或TCP)?"></a>14.收到IP数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议（UDP或TCP)?</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504012024757.png" alt="image-20250329150436272" style="zoom:50%;"></p><p><strong>IP头中有协议字段来区分IP协议的上层协议</strong></p><h4 id="15-TCP和UDP的区别？"><a href="#15-TCP和UDP的区别？" class="headerlink" title="15.TCP和UDP的区别？"></a>15.TCP和UDP的区别？</h4><p><strong>连接类型：</strong></p><ul><li><strong>TCP</strong>：面向连接的协议。在数据传输前需要通过三次握手建立连接，确保双方准备好进行通信。</li><li><strong>UDP</strong>：无连接的协议。发送数据之前不需要建立连接，直接将数据报发送到目标地址。</li></ul><p><strong>可靠性：</strong></p><ul><li><strong>TCP</strong>：提供可靠的数据传输服务。它保证数据包按顺序到达且不会丢失或损坏。如果出现问题，TCP会自动重传丢失的数据包，并确保数据完整性。</li><li><strong>UDP</strong>：不保证数据包的到达顺序、重复性或可靠性。数据可能丢失、重复或者乱序到达，但它的开销更小，速度更快。</li></ul><p><strong>流量控制与拥塞控制</strong>：</p><ul><li><strong>TCP</strong>：内置了流量控制和拥塞控制机制，能够根据网络状况调整发送速率，避免网络过载。</li><li><strong>UDP</strong>：没有内置的流量控制或拥塞控制功能，依赖于应用层来管理这些问题。</li></ul><p><strong>应用场景：</strong></p><ul><li><strong>TCP</strong>：适用于对数据准确性和顺序有严格要求的应用，如文件传输（FTP）、电子邮件（SMTP）、网页浏览（HTTP/HTTPS）等。</li><li><strong>UDP</strong>：适合对实时性要求高但对少量丢包不太敏感的应用，如视频会议、在线游戏、语音通话（VoIP）、直播流媒体等。</li></ul><h4 id="16-设计一个系统，使得发送方能够向接收方发送-1GB-数据，但不知道接收方的-IP-地址。"><a href="#16-设计一个系统，使得发送方能够向接收方发送-1GB-数据，但不知道接收方的-IP-地址。" class="headerlink" title="16.设计一个系统，使得发送方能够向接收方发送 1GB 数据，但不知道接收方的 IP 地址。"></a>16.设计一个系统，使得发送方能够向接收方发送 1GB 数据，但不知道接收方的 IP 地址。</h4><ul><li><strong>发送方发送 UDP 广播寻找接收方</strong></li><li><strong>接收方回复 IP</strong></li><li><strong>建立 TCP 连接并传输</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 发送 UDP 广播寻找接收方</span><br><span class="line"><span class="built_in">broadcast</span>(<span class="string">&quot;DATA_SEND_REQUEST&quot;</span>, port=<span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> 接收方回复 IP</span><br><span class="line">receiver_ip = <span class="built_in">wait_for_response</span>()</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span> 建立 TCP 连接并传输</span><br><span class="line">with <span class="built_in">TCPConnection</span>(receiver_ip, port=<span class="number">54321</span>) as conn:</span><br><span class="line">    conn.<span class="built_in">send_file</span>(<span class="string">&quot;1GB_data.bin&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="17-什么是网络拥塞？说一说TCP协议的拥塞控制？"><a href="#17-什么是网络拥塞？说一说TCP协议的拥塞控制？" class="headerlink" title="17.什么是网络拥塞？说一说TCP协议的拥塞控制？"></a>17.什么是网络拥塞？说一说TCP协议的拥塞控制？</h4><p><strong>网络拥塞：</strong>当网络中的流量过大时，可能会导致路由器或<strong>链路过载</strong>，进而引发<strong>丢包</strong>、延迟增加等问题。</p><p><strong>TCP 的拥塞控制机制：</strong></p><ul><li><p><strong>慢启动：</strong></p><ul><li><strong>目的</strong>：逐步探测网络的可用带宽。</li><li><strong>工作原理</strong>：<ul><li>初始阶段，发送方将拥塞窗口（<code>cwnd</code>）设置为一个较小的值</li><li>每收到一个确认（ACK），<code>cwnd</code> 值加倍（即指数增长）</li><li>当 <code>cwnd</code> 达到慢启动阈值（<code>ssthresh</code>）时，进入拥塞避免阶段</li></ul></li><li><strong>缺点</strong>：可能导致初期传输效率较低</li></ul></li><li><p><strong>拥塞避免：</strong></p><ul><li><strong>目的</strong>：平稳地增加发送速率，避免网络过载。</li><li><strong>工作原理</strong>：<ul><li><code>cwnd</code> 不再指数增长，而是线性增长（每次增加 1 个 MSS）</li><li>如果由于网络拥塞发生丢包，<code>ssthresh</code> 被设置为当前 <code>cwnd</code> 的一半，并重新进入慢启动阶段。</li></ul></li></ul></li><li><p><strong>快速重传：</strong></p><ul><li><p><strong>目的</strong>：快速恢复因丢包导致的传输中断。</p></li><li><p><strong>工作原理</strong>：当发送方收到 3 个重复的 ACK 时，认为某个数据包丢失。发送方立即重传丢失的数据包，而不必等待超时。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202504101621506.png" alt="image-20250410161758659" style="zoom:50%;"></p></li></ul></li><li><p><strong>快速恢复：</strong></p><ul><li><strong>目的</strong>：在快速重传后快速恢复正常的传输速率。</li><li><strong>工作原理</strong>：<ul><li>当检测到丢包并触发快速重传后，<code>ssthresh</code> 被设置为当前 <code>cwnd</code> 的一半。</li><li><code>cwnd</code> 被设置为 <code>ssthresh</code>，然后继续线性增长（拥塞避免）。</li></ul></li></ul></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504101625741.png" alt="image-20250410161817347" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-什么是TCP网络分层？&quot;&gt;&lt;a href=&quot;#1-什么是TCP网络分层？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是TCP网络分层？&quot;&gt;&lt;/a&gt;1.什么是TCP网络分层？&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://typoraim</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="网络" scheme="https://wangak.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用</title>
    <link href="https://wangak.cc/posts/b21cb050.html"/>
    <id>https://wangak.cc/posts/b21cb050.html</id>
    <published>2025-03-27T16:00:00.000Z</published>
    <updated>2025-03-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p><strong>IO多路复用：</strong>由内核检测多个文件描述符的状态，来解决传统的阻塞式的IO，可以提高CPU的利用率。另外，相比于多线程模型，每个连接都要一个独立的线程，所需的系统开销过大，而IO多路复用只有在连接准备好进行读写操作时，才进行处理。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line">    <span class="type">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set *exceptfds, <span class="keyword">struct</span> timeval * timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>nfds：</strong>委托内核检测的这三个集合中<strong>最大的文件描述符 + 1</strong></li><li><strong>readfds：</strong>需要检测<strong>读</strong>缓冲区的文件描述符的集合</li><li><strong>writefds：</strong>需要检测<strong>写</strong>缓冲区的文件描述符的集合</li><li><strong>exceptfds：</strong> 需要检测<strong>异常</strong>缓冲区的文件描述符的集合</li><li><strong>timeout：</strong>超时时长</li></ul><p><strong>常用操作函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将文件描述符fd从set集合中删除 == 将fd对应的标志位设置为0        </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"><span class="comment">// 判断文件描述符fd是否在set集合中 == 读一下fd对应的标志位到底是0还是1</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"><span class="comment">// 将文件描述符fd添加到set集合中 == 将fd对应的标志位设置为1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"><span class="comment">// 将set集合中, 所有文件文件描述符对应的标志位设置为0, 集合中没有添加任何文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>select的局限性：</strong></p><ul><li><strong>频繁的数据复制：</strong>因为用户态和内核态之间存在严格的隔离，调用 <code>select</code> 函数会进行数据的拷贝（将文件描述符集合拷贝到内核空间，再将修改后的集合复制回用户空间），这种频繁的数据复制操作会带来额外的系统开销</li><li><strong>线性扫描：</strong>待检测文件描述符集合采取的是线性扫描的方式进行检查。</li><li><strong>默认最大文件描述符数限制</strong>：<code>select</code> 可以检测的最大文件描述符数量通常是有限制的，默认情况下这个值是 1024（由宏 <code>FD_SETSIZE</code> 定义）。</li></ul><h4 id="通信代码"><a href="#通信代码" class="headerlink" title="通信代码"></a>通信代码</h4><ul><li><p><strong>服务器端代码如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的fd</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    <span class="built_in">listen</span>(lfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的fd的状态检测委托给内核检测</span></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line">    <span class="comment">// 初始化检测的读集合</span></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    fd_set rdtemp;</span><br><span class="line">    <span class="comment">// 清零</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;rdset);</span><br><span class="line">    <span class="comment">// 将监听的lfd设置到检测的读集合中</span></span><br><span class="line">    <span class="built_in">FD_SET</span>(lfd, &amp;rdset);</span><br><span class="line">    <span class="comment">// 通过select委托内核检测读集合中的文件描述符状态, 检测read缓冲区有没有数据</span></span><br><span class="line">    <span class="comment">// 如果有数据, select解除阻塞返回</span></span><br><span class="line">    <span class="comment">// 应该让内核持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 默认阻塞</span></span><br><span class="line">        <span class="comment">// rdset 中是委托内核检测的所有的文件描述符</span></span><br><span class="line">        rdtemp = rdset;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">select</span>(maxfd+<span class="number">1</span>, &amp;rdtemp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// rdset中的数据被内核改写了, 只保留了发生变化的文件描述的标志位上的1, 没变化的改为0</span></span><br><span class="line">        <span class="comment">// 只要rdset中的fd对应的标志位为1 -&gt; 缓冲区有数据了</span></span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="comment">// 有没有新连接</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(lfd, &amp;rdtemp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 接受连接请求, 这个调用不阻塞</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliaddr;</span><br><span class="line">            <span class="type">int</span> cliLen = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">            <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;cliLen);</span><br><span class="line"><span class="comment">//accept会返回用于通信的文件描述符</span></span><br><span class="line">            <span class="comment">// 得到了有效的文件描述符</span></span><br><span class="line">            <span class="comment">// 通信的文件描述符添加到读集合</span></span><br><span class="line">            <span class="comment">// 在下一轮select检测的时候, 就能得到缓冲区的状态</span></span><br><span class="line">            <span class="built_in">FD_SET</span>(cfd, &amp;rdset);</span><br><span class="line">            <span class="comment">// 重置最大的文件描述符</span></span><br><span class="line">            maxfd = cfd &gt; maxfd ? cfd : maxfd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有新连接, 通信</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;maxfd+<span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">// 判断从监听的文件描述符之后到maxfd这个范围内的文件描述符是否读缓冲区有数据</span></span><br><span class="line">            <span class="keyword">if</span>(i != lfd &amp;&amp; <span class="built_in">FD_ISSET</span>(i, &amp;rdtemp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="comment">// 一次只能接收10个字节, 客户端一次发送100个字节</span></span><br><span class="line">                <span class="comment">// 一次是接收不完的, 文件描述符对应的读缓冲区中还有数据</span></span><br><span class="line">                <span class="comment">// 下一轮select检测的时候, 内核还会标记这个文件描述符缓冲区有数据 -&gt; 再读一次</span></span><br><span class="line">                <span class="comment">// 循环会一直持续, 知道缓冲区数据被读完位置</span></span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">read</span>(i, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端关闭了连接...\n&quot;</span>);</span><br><span class="line">                    <span class="comment">// 将检测的文件描述符从读集合中删除</span></span><br><span class="line">                    <span class="built_in">FD_CLR</span>(i, &amp;rdset);</span><br><span class="line">                    <span class="built_in">close</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 收到了数据</span></span><br><span class="line">                    <span class="comment">// 发送数据</span></span><br><span class="line">                    <span class="built_in">write</span>(i, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 异常</span></span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>客户端代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;     <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);   <span class="comment">// 服务器监听的端口, 字节序应该是网络字节序</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        <span class="comment">// sprintf(recvBuf, &quot;data: %d\n&quot;, i++);</span></span><br><span class="line">        <span class="built_in">fgets</span>(recvBuf, <span class="built_in">sizeof</span>(recvBuf), stdin);</span><br><span class="line">        <span class="built_in">write</span>(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">        <span class="built_in">read</span>(fd, recvBuf, <span class="built_in">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">close</span>(fd); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>对于待检测集合<code>select</code>和<code>poll</code>是基于线性方式处理的，epoll是基于红黑树来管理待检测集合的。</p><p>epoll实例就是一棵树，每个节点是<code>epoll_event</code>的结构体，结构体里有<strong><code>events</code></strong> 字段描述文件描述符的事件类型，还有<code>data</code>字段是一个联合体类型，通常存储对应的文件描述符</p><h4 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h4><p><strong>操作函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建epoll实例，通过一棵红黑树管理待检测集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">// 管理红黑树上的文件描述符(添加、修改、删除)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">// 检测epoll树中是否有就绪的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>struct epoll_event:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合体, 多个变量共用同一块内存        </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line"> <span class="type">void</span>        *ptr;</span><br><span class="line"><span class="type">int</span>          fd;<span class="comment">// 通常情况下使用这个成员, 和epoll_ctl的第三个参数相同即可</span></span><br><span class="line"><span class="type">uint32_t</span>     u32;</span><br><span class="line"><span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line"><span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="comment">//通常使用data.fd，将其设置为当前event的文件描述符</span></span><br><span class="line"><span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="通信代码（服务端）"><a href="#通信代码（服务端）" class="headerlink" title="通信代码（服务端）"></a>通信代码（服务端）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">// 本地多有的ＩＰ</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="comment">// 所有的文件描述符对应读写缓冲区状态都是委托内核进行检测的epoll</span></span><br><span class="line">    <span class="comment">// 创建一个epoll模型</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往epoll实例中添加需要检测的节点, 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.events = EPOLLIN;    <span class="comment">// 检测lfd读读缓冲区是否有数据</span></span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> evs[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">sizeof</span>(evs) / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="comment">// 持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用一次, 检测一次</span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">epoll_wait</span>(epfd, evs, size, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出当前的文件描述符</span></span><br><span class="line">            <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">            <span class="comment">// 判断这个文件描述符是不是用于监听的</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建立新的连接</span></span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">                ev.events = EPOLLIN;    <span class="comment">// 读缓冲区是否有数据</span></span><br><span class="line">                ev.data.fd = cfd;</span><br><span class="line">                ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl-accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理通信的文件描述符</span></span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">recv</span>(curfd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端已经断开了连接\n&quot;</span>);</span><br><span class="line">                    <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">close</span>(curfd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">                    <span class="built_in">send</span>(curfd, buf, len, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="epoll的工作模式"><a href="#epoll的工作模式" class="headerlink" title="epoll的工作模式"></a>epoll的工作模式</h4><p><strong>水平触发模式（LT）</strong></p><ul><li><strong>持续性通知</strong>：只要文件描述符处于就绪状态（例如，有数据可以读取），就会持续通知应用。这意味着即使你不处理完所有可用的数据，下一次调用<code>epoll_wait</code>时，如果该文件描述符仍然准备好进行操作，它将继续被包含在返回的事件列表中。</li><li><strong>易于使用</strong>：因为其持续通知特性，编程相对简单，不容易错过事件。</li><li><strong>效率</strong>：由于可能会多次通知同一个就绪状态，这在高并发场景下可能导致一定的性能损耗。</li></ul><p><strong>边沿触发模式（ET）</strong></p><ul><li><strong>一次性通知</strong>：<strong>仅当文件描述符的状态发生变化（例如，从不可读变为可读）时发出通知。</strong>这意味着如果你没有完全读取或写入所有数据，在下一次调用<code>epoll_wait</code>时可能不会再收到关于这个文件描述符的通知，除非它的状态再次改变。</li><li><strong>高效性</strong>：减少重复通知的数量，提高效率，特别适用于高负载的网络服务器等场景。</li><li><strong>复杂性增加</strong>：需要更细致地管理I/O操作，通常要求使用非阻塞I/O，并且需要确保每次触发时尽可能多地处理数据，以避免丢失事件。</li></ul><p><strong>ET模式的设置:</strong> 水平触发模式（LT）是默认的模式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">ev.events = EPOLLIN | EPOLLET;<span class="comment">// 设置边沿模式</span></span><br></pre></td></tr></table></figure><p><strong>边沿触发模式需要设置为阻塞</strong></p><p>边沿触发模式需要一次性操作缓冲区的全部数据，所以需要使用循环的结构操作数据，那么要将文件描述符设置为非阻塞，过程使用<code>fcntl()</code>进行处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置完成之后, 读写都变成了非阻塞模式</span></span><br><span class="line"><span class="type">int</span> flag = <span class="built_in">fcntl</span>(cfd, F_GETFL);</span><br><span class="line">flag |= O_NONBLOCK;                                                        </span><br><span class="line"><span class="built_in">fcntl</span>(cfd, F_SETFL, flag);</span><br></pre></td></tr></table></figure><p><em>注：当缓冲区数据被读完了，调用的read()/recv()函数还会继续从缓冲区中读数据，此时函数调用就失败了，返回-1，对应的全局变量 <code>errno</code> 值为<code>EAGAIN</code>或者 <code>EWOULDBLOCK</code></em></p><p><strong>边沿触发模式的通信代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">// 本地多有的ＩＰ</span></span><br><span class="line">    <span class="comment">// 127.0.0.1</span></span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr.s_addr);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">64</span>);<span class="comment">//将 Socket 设置为监听状态</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="comment">// 所有的文件描述符对应读写缓冲区状态都是委托内核进行检测的epoll</span></span><br><span class="line">    <span class="comment">// 创建一个epoll模型</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往epoll实例中添加需要检测的节点, 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.events = EPOLLIN;    <span class="comment">// 检测lfd读读缓冲区是否有数据</span></span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> evs[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">sizeof</span>(evs) / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="comment">// 持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用一次, 检测一次</span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">epoll_wait</span>(epfd, evs, size, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;==== num: %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出当前的文件描述符</span></span><br><span class="line">            <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">            <span class="comment">// 判断这个文件描述符是不是用于监听的</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建立新的连接</span></span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">// 将文件描述符设置为非阻塞</span></span><br><span class="line">                <span class="comment">// 得到文件描述符的属性</span></span><br><span class="line">                <span class="type">int</span> flag = <span class="built_in">fcntl</span>(cfd, F_GETFL);</span><br><span class="line">                flag |= O_NONBLOCK;</span><br><span class="line">                <span class="built_in">fcntl</span>(cfd, F_SETFL, flag);</span><br><span class="line">                <span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">                <span class="comment">// 通信的文件描述符检测读缓冲区数据的时候设置为边沿模式</span></span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;    <span class="comment">// 读缓冲区是否有数据</span></span><br><span class="line">                ev.data.fd = cfd;</span><br><span class="line">                ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl-accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理通信的文件描述符</span></span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                <span class="comment">// 循环读数据</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> len = <span class="built_in">recv</span>(curfd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 非阻塞模式下和阻塞模式是一样的 =&gt; 判断对方是否断开连接</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">                        <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">                        <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="built_in">close</span>(curfd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 通信</span></span><br><span class="line">                        <span class="comment">// 接收的数据打印到终端</span></span><br><span class="line">                        <span class="built_in">write</span>(STDOUT_FILENO, buf, len);</span><br><span class="line">                        <span class="comment">// 发送数据</span></span><br><span class="line">                        <span class="built_in">send</span>(curfd, buf, len, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// len == -1</span></span><br><span class="line">                        <span class="keyword">if</span>(errno == EAGAIN)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;数据读完了...\n&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h3><p>1.为什么epoll的边沿模式要使用<code>fcntl</code>将文件描述符设置为非阻塞？</p><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IO多路复用&quot;&gt;&lt;a href=&quot;#IO多路复用&quot; class=&quot;headerlink&quot; title=&quot;IO多路复用&quot;&gt;&lt;/a&gt;IO多路复用&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;IO多路复用：&lt;/strong&gt;由内核检测多个文件描述符的状态，来解决传统的阻塞式的IO，可</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="网络" scheme="https://wangak.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C++八股7</title>
    <link href="https://wangak.cc/posts/d4769a69.html"/>
    <id>https://wangak.cc/posts/d4769a69.html</id>
    <published>2025-03-26T16:00:00.000Z</published>
    <updated>2025-03-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么是STL？"><a href="#1-什么是STL？" class="headerlink" title="1. 什么是STL？"></a>1. 什么是STL？</h4><p>STL，即标准模板库</p><p><strong>STL</strong>从广义上讲主要包括三大部分：<strong>算法、容器和迭代器。</strong></p><h4 id="2-什么是RAII？"><a href="#2-什么是RAII？" class="headerlink" title="2. 什么是RAII？"></a>2. 什么是RAII？</h4><p>RAII 的全称是 <strong>Resource Acquisition Is Initialization</strong>（资源获取即初始化），这是一种 C++ 中的<strong>编程范式</strong>，用于管理资源（如内存、文件句柄、网络连接等）的生命周期。</p><p><strong>资源的分配与对象的构造绑定</strong>：在对象创建时（调用构造函数）申请或分配资源。</p><p><strong>资源的释放与对象的析构绑定</strong>：在对象销毁时（调用析构函数）自动释放资源。</p><p>智能指针（<code>std::shared_ptr</code>和<code>std::unique_ptr</code>）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记<code>delete</code>造成的内存泄漏。</p><h4 id="3-it-和-it-的区别以及哪个更好"><a href="#3-it-和-it-的区别以及哪个更好" class="headerlink" title="3.++it 和 it++ 的区别以及哪个更好?"></a>3.<code>++it</code> 和 <code>it++</code> 的区别以及哪个更好?</h4><p><strong>前置递增 (<code>++it</code>)</strong>：不需要额外创建临时对象，因此效率更高。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;  <span class="comment">// 将当前对象加 1</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后置递增 (<code>it++</code>)</strong>：后置递增首先会创建一个临时对象来保存当前值，然后调用前置递增操作修改当前对象的值，最后返回临时对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="type">int</span> temp = *<span class="keyword">this</span>; <span class="comment">// 创建一个临时对象保存当前值</span></span><br><span class="line">    ++*<span class="keyword">this</span>;          <span class="comment">// 调用前置递增操作，将当前对象加 1</span></span><br><span class="line">    <span class="keyword">return</span> temp;      <span class="comment">// 返回临时对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/d4769a69.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20250326142820411.png" alt="image-20250326142820411" style="zoom:50%;"></p><h4 id="4-简述哈希表的基本原理？什么是哈希冲突？有哪些解决方法？"><a href="#4-简述哈希表的基本原理？什么是哈希冲突？有哪些解决方法？" class="headerlink" title="4. 简述哈希表的基本原理？什么是哈希冲突？有哪些解决方法？"></a>4. 简述哈希表的基本原理？什么是哈希冲突？有哪些解决方法？</h4><p><strong>哈希表的基本原理：</strong>通过一个哈希函数将键（Key）映射到一个固定范围的索引位置（桶，Bucket）</p><ul><li><p><strong>哈希函数计算</strong>：将键（Key）通过哈希函数转换为一个整数值（哈希值）。</p></li><li><p><strong>映射到桶</strong>：根据哈希值确定数据在哈希表中的存储位置（桶）。</p></li><li><p><strong>插入或查找</strong>：将数据存入对应的桶中，或者从桶中查找数据。</p></li></ul><p><strong>哈希冲突：</strong> 不同的键通过哈希函数映射到同一个哈希值。</p><p><strong>解决哈希冲突的方法：</strong></p><ul><li><p><strong>链地址法： </strong>每个桶维护一个链表（或其他数据结构），当发生冲突时，将冲突的键值对存储在链表中。</p></li><li><p><strong>开放地址法：</strong></p><p><strong>常见的探测方法有：</strong></p><ul><li><strong>线性探测（Linear Probing）</strong>：依次检查当前桶的下一个桶。</li><li><strong>二次探测（Quadratic Probing）</strong>：以平方递增的方式检查桶。</li><li><strong>双重哈希（Double Hashing）</strong>：使用第二个哈希函数计算步长。</li></ul></li><li><p><strong>再哈希法</strong></p><ul><li><strong>使用多个哈希函数</strong>，当第一个哈希函数发生冲突时，尝试使用第二个哈希函数重新计算位置。</li><li>优点：减少冲突的概率。</li><li>缺点：增加了计算复杂度。</li></ul></li></ul><p><strong>STL中的hashtable使用的是链地址法解决hash冲突问题</strong></p><h4 id="5-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素-STL-中vector删除其中的元素，迭代器如何变化？"><a href="#5-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素-STL-中vector删除其中的元素，迭代器如何变化？" class="headerlink" title="5.vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素?STL 中vector删除其中的元素，迭代器如何变化？"></a>5.vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素?STL 中vector删除其中的元素，迭代器如何变化？</h4><p><strong><code>vector</code></strong>：</p><ul><li>基于动态数组实现，内存是连续的。</li><li>支持高效的随机访问（时间复杂度为 O(1)），因为可以通过索引直接定位到任意元素。</li><li>插入和删除操作效率较低（时间复杂度为 O(n)），因为在中间或头部插入/删除时需要移动大量数据。</li><li>动态扩容：当容量不足时，会重新分配更大的内存块，并将原有数据拷贝到新内存中。</li></ul><p><strong><code>list</code></strong>：</p><ul><li>基于双向链表实现，内存是非连续的。</li><li>不支持随机访问（时间复杂度为 O(n)），需要通过遍历链表才能访问指定位置的元素。</li><li>插入和删除操作效率高（时间复杂度为 O(1)），只需要修改相关节点的指针即可。</li><li>每个节点包含三个部分：元素值、指向前一个节点的指针（prev）和指向后一个节点的指针（next）。</li></ul><p><img src="/posts/d4769a69.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20250326150309901.png" alt="image-20250326150309901" style="zoom: 50%;"></p><p><strong>如何找到 <code>vector</code> 或 <code>list</code> 的倒数第二个元素：</strong></p><ul><li><p>由于 <code>vector</code> 支持随机访问，可以通过下标直接访问倒数第二个元素</p></li><li><p>由于 <code>list</code> 不支持随机访问，无法通过下标直接访问元素。但可以使用反向迭代器来访问倒数第二个元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (lst.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = lst.<span class="built_in">rbegin</span>(); <span class="comment">// 反向迭代器，指向最后一个元素</span></span><br><span class="line">        ++it;                   <span class="comment">// 移动到倒数第二个元素</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The second last element is: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;List has fewer than 2 elements.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>vector中的迭代器在使用后就失效了，而list的迭代器在使用之后还可以继续使用。</strong></p><p><strong><code>vector</code> 的迭代器失效</strong>：</p><ul><li><p><code>vector</code> 是基于连续内存的动态数组实现的。当发生插入或删除操作时，可能会导致内存重新分配（例如扩容），或者需要移动元素以保持连续性。这种情况下，原有的迭代器可能指向无效的内存地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>() + <span class="number">2</span>; <span class="comment">// 指向第三个元素（值为 3）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before insertion: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">10</span>); <span class="comment">// 在第二个位置插入元素 10</span></span><br><span class="line">    <span class="comment">// 尝试访问迭代器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After insertion: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl; <span class="comment">// 可能导致未定义行为</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>list</code> 的迭代器失效</strong>：</p><ul><li><p><code>list</code> 是基于双向链表实现的，每个节点独立存储，并通过指针连接。插入和删除操作只会影响相邻节点的指针，而不会影响其他节点的地址。因此，<code>list</code> 的迭代器在插入或删除后通常仍然有效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">next</span>(lst.<span class="built_in">begin</span>(), <span class="number">2</span>); <span class="comment">// 指向第三个元素（值为 3）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before insertion: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    lst.<span class="built_in">insert</span>(std::<span class="built_in">next</span>(lst.<span class="built_in">begin</span>(), <span class="number">1</span>), <span class="number">10</span>); <span class="comment">// 在第二个位置插入元素 10</span></span><br><span class="line">    <span class="comment">// 继续访问迭代器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After insertion: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl; <span class="comment">// 安全且正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：<code>std::next</code>: 基于给定的迭代器，向前或向后移动指定的步数，返回一个新的迭代器。</em></p></li></ul><h4 id="6-reserve-和-resize-的区别"><a href="#6-reserve-和-resize-的区别" class="headerlink" title="6. reserve 和 resize 的区别"></a>6. <code>reserve</code> 和 <code>resize</code> 的区别</h4><p><strong><code>reserve(n)</code></strong>： 只分配内存，不影响元素数量。</p><ul><li>只改变 <code>capacity()</code>，即预分配的总空间大小。</li><li>不会改变 <code>size()</code>，也不会初始化新分配的内存。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">10</span>); <span class="comment">// 预分配 10 个元素的空间</span></span><br><span class="line">std::cout &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>(); <span class="comment">// 输出：0 10</span></span><br></pre></td></tr></table></figure><p><code>resize</code>:  改变元素数量，并可能分配更多内存。</p><ul><li>改变 <code>size()</code>，即实际存储的元素数量</li><li>如果 <code>n &gt; size()</code>，会初始化新增的元素（对于基本类型，默认初始化为 0）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">10</span>); <span class="comment">// 调整大小为 10</span></span><br><span class="line">std::cout &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>(); <span class="comment">// 输出：10 10</span></span><br></pre></td></tr></table></figure><h4 id="7-容器内部删除一个元素"><a href="#7-容器内部删除一个元素" class="headerlink" title="7. 容器内部删除一个元素"></a>7. 容器内部删除一个元素</h4><p><strong>顺序容器(</strong><code>vector</code>、<code>deque</code><strong>):</strong></p><ul><li><p><code>erase(it)</code> 不仅会使被删除元素的迭代器失效，还会使被删除元素之后的所有迭代器失效。</p></li><li><p><strong>不能使用 <code>erase(it++)</code></strong></p></li><li><p><strong>正确的删除方式</strong>：<code>erase</code> 的返回值是下一个有效的迭代器，可以直接赋值给当前迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = c.<span class="built_in">begin</span>(); it != c.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (需要删除(*it)) &#123;</span><br><span class="line">        it = c.<span class="built_in">erase</span>(it); <span class="comment">// erase 返回下一个有效迭代器</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it; <span class="comment">// 如果不删除，则正常递增迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>关联容器（<code>map</code>、<code>set</code>、<code>multimap</code>、<code>multiset</code>）</strong></p><ul><li>可以安全地使用 <code>erase(it++)</code></li></ul><h4 id="8-map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？-为什么使用红黑树？"><a href="#8-map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？-为什么使用红黑树？" class="headerlink" title="8.map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？"></a>8.map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？</h4><p><strong><code>map</code> 和 <code>set</code> 的底层实现:</strong></p><ul><li><code>map</code> 和 <code>set</code> 是 C++ STL 中的关联容器，它们的底层实现通常基于<strong>红黑树</strong>。红黑树是一种自平衡二叉搜索树，它能够在插入、删除和查找操作中保持对数时间复杂度 <script type="math/tex">O(log⁡n)</script>。</li></ul><p><strong>红黑树的核心特性</strong>：</p><ul><li>每个节点要么是红色，要么是黑色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL 节点）是黑色。</li><li>如果一个节点是红色，那么它的两个子节点必须是黑色（即没有连续的红色节点）。</li><li>从任意节点到其每个叶子的所有路径都包含相同数量的黑色节点。</li></ul><p><strong><code>map</code> 和 <code>set</code> 的区别</strong>：</p><ul><li><p><strong><code>set</code></strong>：</p><ul><li>底层红黑树的节点数据类型为 <strong><code>key</code></strong>（即存储的值本身）。</li><li>插入和查找时，直接根据 <code>key</code> 进行操作。</li></ul></li><li><p><strong><code>map</code></strong>：</p><ul><li>底层红黑树的节点数据类型为 <strong><code>key + value</code></strong>（即键值对）。</li><li>插入和查找时，根据 <code>key</code> 进行操作，但节点中还存储了与 <code>key</code> 对应的 <code>value</code>。</li></ul></li></ul><p><strong>为什么使用红黑树？</strong></p><ul><li><p><strong>自动排序</strong>：红黑树作为一种二叉搜索树，能够自然地按照 <code>key</code> 的顺序组织数据。</p></li><li><p><strong>时间复杂度低</strong>：红黑树的操作（如插入、删除、查找）的时间复杂度为 <script type="math/tex">O(log⁡n)</script>，这比线性时间复杂度 <script type="math/tex">O(n)</script>​高效得多。</p><p><em>注：相比于 AVL 树，在插入和删除时的调整开销较小。</em></p></li></ul><h4 id="9-关于this指针你知道什么？"><a href="#9-关于this指针你知道什么？" class="headerlink" title="9.关于this指针你知道什么？"></a>9.关于this指针你知道什么？</h4><ul><li><p><code>this</code> 是一个常量指针（<code>const pointer</code>），指向当前对象的首地址。</p></li><li><p>它是一个隐含参数，编译器会自动将其<strong>作为非静态成员函数的第一个参数传递给函数。</strong></p><p><strong><code>this</code> 指针的作用：</strong></p></li><li><p><strong>访问类的成员</strong></p></li><li><strong>返回当前对象</strong>： 可以直接使用 <code>return *this;</code></li></ul><p><strong><code>this</code> 指针是什么时候创建的？</strong></p><ul><li><code>this</code> 指针在调用成员函数时由编译器生成，并在成员函数执行结束后销毁。</li></ul><h4 id="10-a-10-b-30-如何不使用新的变量交换两个数"><a href="#10-a-10-b-30-如何不使用新的变量交换两个数" class="headerlink" title="10.a=10,b=30,如何不使用新的变量交换两个数"></a>10.a=10,b=30,如何不使用新的变量交换两个数</h4><p><strong>使用异或：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 交换逻辑</span></span><br><span class="line">    a = a ^ b; <span class="comment">// a = 10 ^ 30</span></span><br><span class="line">    b = a ^ b; <span class="comment">// b = (10 ^ 30) ^ 30 = 10</span></span><br><span class="line">    a = a ^ b; <span class="comment">// a = (10 ^ 30) ^ 10 = 30</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-双端队列（deque-是否支持随机访问？"><a href="#11-双端队列（deque-是否支持随机访问？" class="headerlink" title="11.双端队列（deque)是否支持随机访问？"></a>11.双端队列（deque)是否支持随机访问？</h4><p><strong><code>std::deque</code>（双端队列）</strong>是 C++ STL 中的一个容器，支持在两端高效地插入和删除元素。它的底层实现基于<strong>分段连续存储结构</strong>，每个段是一个固定大小的连续内存块，这些<strong>段通过指针链接起来</strong>。这种设计使得 <code>std::deque</code> 能够在两端进行高效的插入操作。</p><p><strong><code>std::deque</code></strong>支持随机访问，可以通过下标直接访问任意位置的元素。</p><p><img src="/posts/d4769a69.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20250326193256814.png" alt="image-20250326193256814" style="zoom: 50%;"></p><p>12.举三个智能指针的应用场景</p><ul><li><p><strong><code>std::shared_ptr</code> 在多线程编程中保证线程安全的引用计数</strong></p><p>在多线程环境中，多个线程可能需要共享同一个对象（例如数据库连接池、配置文件对象等），并且需要确保对象在所有线程都使用完毕后才被释放。<code>std::shared_ptr</code> 的引用计数是线程安全的，因此可以用来实现这种共享。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseConnection</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">const</span> std::string&amp; sql)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Executing query: &quot;</span> &lt;&lt; sql &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadTask</span><span class="params">(std::shared_ptr&lt;DatabaseConnection&gt; conn, <span class="type">const</span> std::string&amp; queryStr)</span> </span>&#123;</span><br><span class="line">    conn-&gt;<span class="built_in">query</span>(queryStr); <span class="comment">// 使用共享的数据库连接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> dbConn = std::<span class="built_in">make_shared</span>&lt;DatabaseConnection&gt;(); <span class="comment">// 创建一个共享的数据库连接</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadTask, dbConn, <span class="string">&quot;SELECT * FROM users&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(threadTask, dbConn, <span class="string">&quot;SELECT * FROM products&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>(); <span class="comment">// 等待线程1完成</span></span><br><span class="line">    t2.<span class="built_in">join</span>(); <span class="comment">// 等待线程2完成</span></span><br><span class="line">    <span class="comment">// 当所有线程都完成后，dbConn 自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::unique_ptr</code> 在工厂模式中返回独占所有权的对象</strong></p><p><code>std::unique_ptr</code> 明确表示对象的所有权不可共享。</p></li><li><p><strong><code>std::weak_ptr</code>：检测对象是否已被销毁</strong></p><p>使用 <code>std::weak_ptr</code> 来检测对象是否仍然有效（即是否已经被销毁）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Event triggered!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;EventListener&gt; listener = std::<span class="built_in">make_shared</span>&lt;EventListener&gt;();</span><br><span class="line">    std::weak_ptr&lt;EventListener&gt; weakListener = listener; <span class="comment">// 创建弱引用</span></span><br><span class="line">    <span class="comment">// 模拟事件触发</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> strongListener = weakListener.<span class="built_in">lock</span>()) &#123; <span class="comment">// 尝试提升为 shared_ptr</span></span><br><span class="line">        strongListener-&gt;<span class="built_in">onEvent</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Listener has been destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 销毁 listener</span></span><br><span class="line">    listener.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="comment">// 再次尝试触发事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> strongListener = weakListener.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">        strongListener-&gt;<span class="built_in">onEvent</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Listener has been destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：<code>weakListener.lock()</code> 是 C++ 中 <code>std::weak_ptr</code> 提供的一个成员函数，用于尝试将弱引用（<code>std::weak_ptr</code>）提升为强引用（<code>std::shared_ptr</code>）。它的主要作用是检查底层对象是否仍然存在，并在对象有效时返回一个 <code>std::shared_ptr</code>。对象不存在返回空指针。</em></p></li></ul><h4 id="12-举例说明万能引用和完美转发的作用"><a href="#12-举例说明万能引用和完美转发的作用" class="headerlink" title="12.举例说明万能引用和完美转发的作用"></a>12.举例说明万能引用和完美转发的作用</h4><p><strong>万能引用</strong>： 指的是那些<strong>可以绑定到左值引用或右值引用的引用类型</strong></p><p>当一个模板函数的参数类型为 <code>T&amp;&amp;</code> 并且 <code>T</code> 是通过模板参数推导出来的，则该参数是一个万能引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayType</span><span class="params">(T&amp;&amp; val)</span> </span>&#123; <span class="comment">// 这里 T&amp;&amp; 是一个万能引用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">displayType</span>(x);        <span class="comment">// 左值传递给万能引用</span></span><br><span class="line">    <span class="built_in">displayType</span>(<span class="number">20</span>);       <span class="comment">// 右值传递给万能引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>完美转发:</strong></p><p><strong>完美转发:</strong> 允许函数模板将参数按其原始形式（包括值类别：左值或右值）转发给另一个函数。这意味着如果传入的是一个右值，那么它将以右值的形式被转发；如果是左值，则以左值的形式被转发。</p><ul><li><p><strong>完美转发</strong>借助于万能引用和 <code>std::forward</code>，能够让函数模板准确地将参数按照它们的原始类型和值类别转发给其他函数，保持了参数的特性和优化机会</p></li><li><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;utility&gt; // std::forward 所在头文件// 一个简单的函数，用于接收左值或右值void process(int&amp; x) &#123;    std::cout &lt;&lt; &quot;Lvalue reference: &quot; &lt;&lt; x &lt;&lt; std::endl;&#125;void process(int&amp;&amp; x) &#123;    std::cout &lt;&lt; &quot;Rvalue reference: &quot; &lt;&lt; x &lt;&lt; std::endl;&#125;// 模板函数，使用 std::forward 实现完美转发template&lt;typename T&gt;void wrapper(T&amp;&amp; arg) &#123;    process(std::forward&lt;T&gt;(arg)); // 使用 std::forward 转发参数&#125;int main() &#123;    int x = 42;    wrapper(x);       // 传入左值    wrapper(42);      // 传入右值    return 0;&#125;</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-什么是STL？&quot;&gt;&lt;a href=&quot;#1-什么是STL？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是STL？&quot;&gt;&lt;/a&gt;1. 什么是STL？&lt;/h4&gt;&lt;p&gt;STL，即标准模板库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STL&lt;/strong&gt;从广</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>套接字通信</title>
    <link href="https://wangak.cc/posts/d3b8d1d4.html"/>
    <id>https://wangak.cc/posts/d3b8d1d4.html</id>
    <published>2025-03-25T16:00:00.000Z</published>
    <updated>2025-03-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="套接字通信"><a href="#套接字通信" class="headerlink" title="套接字通信"></a>套接字通信</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><h4 id="1-1-局域网和广域网"><a href="#1-1-局域网和广域网" class="headerlink" title="1.1 局域网和广域网"></a>1.1 局域网和广域网</h4><p><strong>局域网：</strong>局域网将<strong>一定区域内</strong>的各种计算机、外部设备和数据库连接起来形成计算机通信的<strong>私有网络</strong>。、</p><ul><li>局域网的主要特点是传输速度快、延迟低、成本较低且安全性高。</li></ul><p><strong>广域网：</strong>又称广域网、外网、公网。是<strong>连接不同地区局域网</strong>或城域网计算机通信的远程<strong>公共网络</strong>。</p><ul><li>广域网相对于局域网来说，传输速度较慢，延迟较高。</li></ul><h4 id="1-2-IP和端口"><a href="#1-2-IP和端口" class="headerlink" title="1.2 IP和端口"></a>1.2 IP和端口</h4><p><strong>IP:</strong> 是分配给网络上每个<strong>设备的唯一标识符</strong>，用于在网络中进行通信。</p><ul><li><p><strong>IPv4</strong></p><ul><li>IPv4使用32位整数来表示一个IP地址，这相当于<strong>4个字节</strong>。通常，这个32位的地址被分为四部分，每部分8位（1字节），并<strong>以点分十进制格式表示。</strong></li><li>最小的IPv4地址是 <code>0.0.0.0</code>，而最大的是 <code>255.255.255.255</code></li><li>鉴于IPv4采用32位地址，理论上总共可以提供 <script type="math/tex">2^{32}</script>​个不同的地址</li></ul></li><li><p><strong>IPv6</strong></p><ul><li>IPv6使用128位整数来表示一个IP地址，等同于<strong>16个字节</strong>。</li><li>Pv6地址<strong>写作8组，每组4个十六进制数字</strong>，各组之间<strong>用冒号分隔</strong>，例如 <code>2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b</code>。</li><li>由于IPv6采用128位地址长度，所以它可以提供的地址总数为 <script type="math/tex">2^{128}</script></li></ul></li></ul><p><strong>端口: 用于定位主机上的特定进程。</strong></p><ul><li><p>端口号是一个16位的无符号整数（<code>unsigned short</code>），<strong>其取值范围是0到65535（<script type="math/tex">2^{16}−1</script>​）</strong></p></li><li><p><strong>只有那些涉及网络通信的进程才需要绑定端口。</strong>如果一个进程不需要与网络上的其他设备进行通信，那么它就不必绑定端口。</p></li><li><p><strong>一个端口可以被重复使用吗？</strong></p><p>在任何给定时间，<strong>一个具体的端口只能由一个进程独占使用</strong>。这意味着在同一时刻，多个进程不能同时监听同一个端口以接收数据。然而，一旦某个进程完成了对特定端口的使用并释放了它，该端口就可以被新的进程重新绑定和使用。此外，在一些情况下，如<strong>TCP连接结束后，可能会有一段等待时间（TIME_WAIT状态），在此期间端口暂时不可用，以确保网络上的数据包不会被错误地路由到新建立的连接上。</strong></p></li></ul><h4 id="1-3-网络分层模型"><a href="#1-3-网络分层模型" class="headerlink" title="1.3 网络分层模型"></a>1.3 网络分层模型</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202503282055052.png" alt="image-20250325150840912" style="zoom:67%;"></p><ul><li><p><strong>应用层</strong>：直接为用户提供服务，负责处理特定的应用程序细节。</p></li><li><p><strong>表示层</strong>：将数据转换为兼容格式进行传输，包括加密、压缩等操作。</p></li><li><strong>会话层</strong>：管理不同机器上进程之间的对话，控制对话连接的建立和终止。</li><li><strong>传输层</strong>：确保端到端的数据可靠传输，提供错误检测和恢复功能。主要协议有TCP和UDP。</li><li><strong>网络层</strong>：负责数据包的路由选择和转发，决定数据如何从源地址到达目的地址。IP协议工作在此层。</li><li><strong>数据链路层</strong>：在不可靠的物理连接上提供可靠的数据传输，处理错误检测和纠正。以太网协议工作于此层。</li><li><strong>物理层</strong>：定义了硬件设备的标准，如电压水平、线缆类型、针脚布局等，以及如何通过物理媒介传输比特流。</li></ul><h3 id="2-socket编程"><a href="#2-socket编程" class="headerlink" title="2.socket编程"></a>2.socket编程</h3><h4 id="2-1-字节序"><a href="#2-1-字节序" class="headerlink" title="2.1 字节序"></a>2.1 字节序</h4><p><strong>字节序:</strong> 大于一个字节类型的数据在内存中的存放顺序，也就是说对于单字符来说是没有字节序问题的，字符串是单字符的集合，因此字符串也没有字节序问题。</p><ul><li><p><strong>主机字节序 (小端):</strong> 数据的低位字节存储到内存的低地址位, 数据的高位字节存储到内存的高地址位</p></li><li><p><strong>网络字节序 (大端):</strong> 数据的低位字节存储到内存的高地址位, 数据的高位字节存储到内存的低地址位</p><p><em>注：<strong>套接字通信过程中操作的数据都是大端存储的</strong>，包括：接收/发送的数据、IP地址、端口。</em></p></li></ul><h4 id="2-2-大小端转换"><a href="#2-2-大小端转换" class="headerlink" title="2.2 大小端转换"></a>2.2 大小端转换</h4><p><strong>主机字节序的IP地址转换为网络字节序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>; </span><br></pre></td></tr></table></figure><p><code>af</code>: 地址族(IP地址的家族包括ipv4和ipv6)协议</p><ul><li><code>AF_INET</code>: ipv4格式的ip地址</li><li><code>AF_INET6</code>: ipv6格式的ip地址</li></ul><p><code>src</code>: 传入参数</p><p><code>dst</code>: 传出参数, 函数调用完成, 转换得到的大端整形IP被写入到这块内存中</p><p>返回值：成功返回1，失败返回0或者-1</p><p><strong>将大端的整形数, 转换为小端的点分十进制的IP地址 :</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p><code>af</code>: 地址族(IP地址的家族包括ipv4和ipv6)协议</p><ul><li><code>AF_INET</code>: ipv4格式的<code>ip</code>地址</li><li><code>AF_INET6</code>: ipv6格式的<code>ip</code>地址</li></ul><p><code>src</code>: 传入参数, 这个指针指向的内存中存储了大端的整形IP地址</p><p><code>dst</code>: 传出参数, 存储转换得到的小端的点分十进制的IP地址 </p><p><code>size</code>: 修饰<code>dst</code>参数的, 标记<code>dst</code>指向的内存中最多可以存储多少个字节</p><p>返回值:</p><ul><li>成功: 指针指向第三个参数对应的内存地址, 通过返回值也可以直接取出转换得到的IP字符串</li><li>失败: <code>NULL</code></li></ul><h4 id="2-3-sockaddr"><a href="#2-3-sockaddr" class="headerlink" title="2.3 sockaddr"></a>2.3 sockaddr</h4><p><code>sockaddr</code>: 一个通用的、协议无关的套接字地址结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;       <span class="comment">// 地址族协议, 比如 IPv4 (AF_INET)</span></span><br><span class="line">    <span class="type">char</span>        sa_data[<span class="number">14</span>];     <span class="comment">// 端口(2字节) + IP地址(4字节) + 填充(8字节)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sockaddr_in</code>: 是专门针对 IPv4 协议设计的套接字地址结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>   <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;      <span class="comment">// 端口类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;      <span class="comment">// IP 地址类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>; <span class="comment">// 地址族类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof(unsigned short int))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;          <span class="comment">// 地址族协议: AF_INET</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;              <span class="comment">// 端口, 2 字节 -&gt; 大端</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;         <span class="comment">// IP 地址, 4 字节 -&gt; 大端</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>];       <span class="comment">// 填充 8 字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;  <span class="comment">// IP 地址，4 字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-4-套接字函数"><a href="#2-4-套接字函数" class="headerlink" title="2.4 套接字函数"></a>2.4 套接字函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个套接字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p><code>domain</code>: 使用的地址族协议</p><ul><li>AF_INET: 使用IPv4格式的ip地址</li><li>AF_INET6: 使用IPv6格式的ip地址</li></ul><p><code>type</code>:</p><ul><li>SOCK_STREAM: 使用流式的传输协议</li><li>SOCK_DGRAM: 使用报式(报文)的传输协议</li></ul><p><code>protocol</code>: 一般写0即可, 使用默认的协议</p><ul><li>SOCK_STREAM: 流式传输默认使用的是tcp</li><li>SOCK_DGRAM: 报式传输默认使用的udp</li></ul><p><strong>函数的返回值是一个文件描述符，通过这个文件描述符可以操作内核中的某一块内存，网络通信是基于这个文件描述符来完成的。</strong></p><h4 id="2-5-bind"><a href="#2-5-bind" class="headerlink" title="2.5 bind"></a>2.5 bind</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将文件描述符和本地的IP与端口进行绑定   </span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure><p>参数:</p><ul><li><code>sockfd</code>: 监听的文件描述符, 通过<code>socket()</code>调用得到的返回值</li><li><code>addr</code>: 传入参数, 要绑定的IP和端口信息需要初始化到这个结构体中，IP和端口要转换为网络字节序</li><li><code>addrlen</code>: 参数<code>addr</code>指向的内存大小, <code>sizeof(struct sockaddr)</code></li></ul><h3 id="3-TCP通信流程"><a href="#3-TCP通信流程" class="headerlink" title="3.TCP通信流程"></a>3.TCP通信流程</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202503282055645.png" alt="image-20250325161611700" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503282055352.png" alt="image-20250325161638441" style="zoom:67%;"></p><p><strong>在tcp的服务器端, 有两类文件描述符：</strong></p><ul><li><p><strong>监听的文件描述符</strong></p><ul><li><strong>只需要有一个</strong></li><li>不负责和客户端通信, 负责检测客户端的连接请求, 检测到之后调用accept就可以建立新的连接</li></ul></li><li><p><strong>通信的文件描述符</strong></p><ul><li>负责和建立连接的客户端通信</li><li><strong>如果有N个客户端和服务器建立了新的连接, 通信的文件描述符就有N个</strong>，每个客户端和服务器都对应一个通信的文件描述符</li></ul></li></ul><p><strong>基于tcp的服务器端通信代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏一般用于本地的绑定操作</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line"><span class="comment">//    inet_pton(AF_INET, &quot;192.168.237.131&quot;, &amp;addr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliaddr;</span><br><span class="line">    <span class="type">int</span> clilen = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">    <span class="comment">//(struct sockaddr*)&amp;cliaddr：用于存储客户端的地址信息（IP 地址和端口号）。</span></span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印客户端的地址信息</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">24</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP地址: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">           <span class="built_in">inet_ntop</span>(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, <span class="built_in">sizeof</span>(ip)),</span><br><span class="line">           <span class="built_in">ntohs</span>(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 和客户端通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(cfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">            <span class="built_in">write</span>(cfd, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于tcp通信的客户端通信代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;192.168.237.131&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 和服务器端通信</span></span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;你好, 服务器...%d\n&quot;</span>, number++);</span><br><span class="line">        <span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器say: %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);   <span class="comment">// 每隔1s发送一条数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-补充"><a href="#4-补充" class="headerlink" title="4.补充"></a>4.补充</h3><h4 id="4-1-什么是-Socket？"><a href="#4-1-什么是-Socket？" class="headerlink" title="4.1 什么是 Socket？"></a>4.1 什么是 Socket？</h4><p>Socket 可以看作是一个<strong>应用程序与网络之间的接口</strong>，它定义了如何进行数据发送和接收的方式。</p><h4 id="4-2-Socket-的类型有哪些？"><a href="#4-2-Socket-的类型有哪些？" class="headerlink" title="4.2 Socket 的类型有哪些？"></a>4.2 Socket 的类型有哪些？</h4><ul><li><strong>流式套接字（SOCK_STREAM）</strong>：基于 TCP 协议，面向连接，可靠。</li><li><strong>数据报套接字（SOCK_DGRAM）</strong>：基于 UDP 协议，无连接，不可靠。</li></ul><h4 id="4-3-如何创建一个-Socket？"><a href="#4-3-如何创建一个-Socket？" class="headerlink" title="4.3 如何创建一个 Socket？"></a>4.3 如何创建一个 Socket？</h4><p><strong>创建一个 Socket需要指定所使用的地址族和协议类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sockfd = socket(AF_INET, SOCK_STREAM, 0);</span><br></pre></td></tr></table></figure><ul><li><code>AF_INET</code>：IPv4 地址族。</li><li><code>SOCK_STREAM</code>：流式套接字。</li><li>第三个参数通常为 0，表示使用默认协议。</li></ul><h4 id="4-4-bind-函数的作用是什么？"><a href="#4-4-bind-函数的作用是什么？" class="headerlink" title="4.4 bind 函数的作用是什么？"></a>4.4 bind 函数的作用是什么？</h4><p>将 Socket 绑定到指定的 IP 地址和端口号。</p><h4 id="4-5-listen-函数的作用是什么？"><a href="#4-5-listen-函数的作用是什么？" class="headerlink" title="4.5 listen 函数的作用是什么？"></a>4.5 listen 函数的作用是什么？</h4><p>将 Socket 设置为监听状态（它并不会阻塞程序，而是告诉操作系统：“我现在准备好了，可以开始接受客户端的连接请求了。”）</p><h4 id="4-6-accept-函数的作用是什么？"><a href="#4-6-accept-函数的作用是什么？" class="headerlink" title="4.6 accept 函数的作用是什么？"></a>4.6 accept 函数的作用是什么？</h4><p><strong>进入阻塞状态</strong>等待接受客户端的连接请求，并返回一个新的 Socket 文件描述符用于通信。</p><h4 id="4-7-connect-函数的作用是什么？"><a href="#4-7-connect-函数的作用是什么？" class="headerlink" title="4.7 connect 函数的作用是什么？"></a>4.7 connect 函数的作用是什么？</h4><p>客户端调用该函数向服务器发起连接请求。</p><h4 id="4-8-服务器中的两个文件描述符各自的作用？"><a href="#4-8-服务器中的两个文件描述符各自的作用？" class="headerlink" title="4.8 服务器中的两个文件描述符各自的作用？"></a>4.8 服务器中的两个文件描述符各自的作用？</h4><p>服务器上分别有用于监听的文件描述符和用于通信的文件描述符，其各自有两个缓冲区，读缓冲区和写缓冲区。</p><p>监听的文件描述符所对应的读缓冲区用于接收客户端的连接请求，当调用accept()时会检测监听的文件描述符的读缓冲区是否有请求数据，如果有请求数据accept()会解除阻塞和对应的客户端建立连接。</p><p>通信的文件描述符的读缓冲区用于存储客户端所发送的通信数据，调用read()（没有数据则阻塞）可以把数据从读缓冲区读出来，write()把数据再写入写缓冲区（缓冲区满则阻塞），然后内核会将写缓冲区的数据发送给对应的客户端的读缓冲区。</p><h4 id="4-9-read-recv-write-send区别？"><a href="#4-9-read-recv-write-send区别？" class="headerlink" title="4.9 read/recv write/send区别？"></a>4.9 read/recv write/send区别？</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;套接字通信&quot;&gt;&lt;a href=&quot;#套接字通信&quot; class=&quot;headerlink&quot; title=&quot;套接字通信&quot;&gt;&lt;/a&gt;套接字通信&lt;/h2&gt;&lt;h3 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="网络" scheme="https://wangak.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C++八股6</title>
    <link href="https://wangak.cc/posts/a371aaff.html"/>
    <id>https://wangak.cc/posts/a371aaff.html</id>
    <published>2025-03-23T16:00:00.000Z</published>
    <updated>2025-03-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-为什么虚函数能实现动态绑定？"><a href="#1-为什么虚函数能实现动态绑定？" class="headerlink" title="1.为什么虚函数能实现动态绑定？"></a>1.为什么虚函数能实现动态绑定？</h4><p>虚函数能实现动态绑定主要通过虚函数表和虚函数指针实现的</p><p><strong>动态绑定的具体过程：</strong></p><ul><li><p><strong>调用虚函数：</strong></p><p>当通过基类指针或引用调用虚函数时，编译器生成的代码不会直接调用函数，而是<strong>通过虚函数指针查找虚函数表中的函数地址。</strong></p></li><li><p><strong>查找虚函数表：</strong></p><ul><li>编译器会根据对象的虚函数指针找到该对象所属类的虚函数表。</li><li>在虚函数表中查找对应虚函数的地址。</li></ul></li><li><p><strong>调用实际函数：</strong></p><ul><li>根据虚函数表中的地址，调用实际的函数版本。</li><li>如果派生类重写了虚函数，则调用派生类的版本；否则调用基类的版本。</li></ul><p><strong>注：虚函数表 vs 虚函数指针</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503250956902.png" alt="image-20250323153658854" style="zoom:67%;"></p></li></ul><h4 id="2-如何禁止程序自动生成拷贝构造函数？"><a href="#2-如何禁止程序自动生成拷贝构造函数？" class="headerlink" title="2.如何禁止程序自动生成拷贝构造函数？"></a>2.如何禁止程序自动生成拷贝构造函数？</h4><ul><li><strong>方法一：将拷贝构造函数和拷贝赋值函数设置为 <code>private</code></strong></li><li><strong>方法二：直接使用 <code>= delete</code> 来显式删除函数</strong></li></ul><h4 id="3-你知道回调函数吗？它的作用？"><a href="#3-你知道回调函数吗？它的作用？" class="headerlink" title="3.你知道回调函数吗？它的作用？"></a>3.你知道回调函数吗？它的作用？</h4><p>回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。（Qt中的槽函数）</p><h4 id="4-介绍一下友元函数和友元类的用法和作用"><a href="#4-介绍一下友元函数和友元类的用法和作用" class="headerlink" title="4.介绍一下友元函数和友元类的用法和作用"></a>4.介绍一下友元函数和友元类的用法和作用</h4><p>友元（friend）机制允许某些函数或类访问另一个类的私有（private）和保护（protected）成员。</p><p><strong>友元关系打破了封装性，但提供了灵活性。</strong></p><p><strong>友元函数：</strong>友元函数是一个非成员函数（定义在类外的普通函数，不属于任何类），但它可以访问类的私有和保护成员。<strong>友元函数在类的外部定义，但在类内部声明为友元。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> data) : <span class="built_in">privateData</span>(data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPrivateData</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPrivateData</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Private data: &quot;</span> &lt;&lt; obj.privateData &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPrivateData</span>(obj);  <span class="comment">// 输出: Private data: 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>友元类</strong>: 友元类是一个类，它的所有成员函数都可以访问另一个类的私有和保护成员。友元类在类内部声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> data) : <span class="built_in">privateData</span>(data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printPrivateData</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Private data: &quot;</span> &lt;&lt; obj.privateData &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    FriendClass friendObj;</span><br><span class="line">    friendObj.<span class="built_in">printPrivateData</span>(obj);  <span class="comment">// 输出: Private data: 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li><strong>封装性</strong>：友元机制破坏了封装性，应谨慎使用，避免过度依赖。</li><li><strong>单向性</strong>：友元关系是单向的且没有传递性。如果类A是类B的友元，类B不会自动成为类A的友元。</li><li><strong>继承</strong>：友元关系不继承。如果类A是类B的友元，类A的派生类不会自动成为类B的友元。</li></ul><h4 id="5-delete和delete-区别？"><a href="#5-delete和delete-区别？" class="headerlink" title="5.delete和delete[]区别？"></a>5.delete和delete[]区别？</h4><ul><li>delete只会调用⼀次析构函数。</li><li>delete[]会调用数组中每个元素的析构函数。</li></ul><h4 id="6-类的对象存储空间？"><a href="#6-类的对象存储空间？" class="headerlink" title="6.类的对象存储空间？"></a>6.类的对象存储空间？</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202503250956132.png" alt="image-20250323161815483" style="zoom: 50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503250956935.png" alt="image-20250323162003652" style="zoom: 50%;"></p><h4 id="7-构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"><a href="#7-构造函数能否声明为虚函数或者纯虚函数，析构函数呢？" class="headerlink" title="7.构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"></a>7.构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</h4><p><strong>析构函数： </strong>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。</p><p><em>注1：只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</em></p><p><em>注2：析构函数也可以是纯虚函数。</em></p><p><strong>构造函数：</strong>构造函数不能定义为虚函数。</p><p><strong>虚函数要使用虚函数指针（vptr）调用，而对象没有进行初始化就没有虚函数指针（vptr）。</strong></p><h4 id="8-什么是线程？线程与进程的区别是什么？"><a href="#8-什么是线程？线程与进程的区别是什么？" class="headerlink" title="8.什么是线程？线程与进程的区别是什么？"></a>8.什么是线程？线程与进程的区别是什么？</h4><ul><li>线程是操作系统调度的最小单位，进程是资源分配的基本单位。</li><li>同一进程内的线程共享内存空间，而不同进程有独立的地址空间。</li></ul><h4 id="9-线程同步有哪些常见方式？请简要说明。"><a href="#9-线程同步有哪些常见方式？请简要说明。" class="headerlink" title="9.线程同步有哪些常见方式？请简要说明。"></a>9.线程同步有哪些常见方式？请简要说明。</h4><ul><li><strong>互斥锁 (Mutex)</strong>: 防止多个线程同时访问共享资源。</li><li><strong>条件变量 (Condition Variable)</strong>: 用于线程间的通信。</li><li><strong>信号量 (Semaphore)</strong>: 控制对共享资源的访问数量。</li><li><strong>原子操作 (Atomic)</strong>: 保证某些操作的不可分割性。</li></ul><h4 id="10-什么是死锁？如何避免死锁？"><a href="#10-什么是死锁？如何避免死锁？" class="headerlink" title="10.什么是死锁？如何避免死锁？"></a>10.什么是死锁？如何避免死锁？</h4><p><strong>定义</strong>: 多个线程因为循环等待资源而无法继续执行。</p><p><strong>避免方法</strong>:</p><ul><li>按顺序获取锁。</li><li>使用超时机制尝试加锁。</li></ul><h4 id="11-什么是线程安全？如何实现线程安全？"><a href="#11-什么是线程安全？如何实现线程安全？" class="headerlink" title="11.什么是线程安全？如何实现线程安全？"></a>11.什么是线程安全？如何实现线程安全？</h4><p><strong>线程安全的定义：</strong>如果多线程程序每一次的运行结果和单线程程序的运行结果始终一样，那么就是线程安全的</p><p><strong>实现方法</strong>:</p><ul><li>使用互斥锁保护共享资源。</li><li>使用原子变量（如 <code>std::atomic</code>）</li></ul><h4 id="12-什么是线程池？为什么使用线程池？"><a href="#12-什么是线程池？为什么使用线程池？" class="headerlink" title="12.什么是线程池？为什么使用线程池？"></a>12.什么是线程池？为什么使用线程池？</h4><p><strong>线程池（Thread  Pool）</strong>是一种用于管理线程的机制，预先创建一组线程，并将任务提交到一个任务队列中，线程从队列中取出任务并执行。</p><p><strong>优点</strong>:</p><ul><li>减少频繁创建和销毁线程的开销。</li><li>提高响应速度。</li><li>控制并发线程的数量，避免资源耗尽。</li></ul><h4 id="13-什么是原子操作？C-中如何使用原子操作？"><a href="#13-什么是原子操作？C-中如何使用原子操作？" class="headerlink" title="13.什么是原子操作？C++中如何使用原子操作？"></a>13.什么是原子操作？C++中如何使用原子操作？</h4><p><strong>原子操作(Atomic Operation)：</strong>是指在多线程环境下不会被线程调度机制打断的操作，这种操作一旦开始，就会一直运行到结束，中间不会有任何线程切换。原子操作是线程安全的基本保证。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// 原子整型变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        counter++; <span class="comment">// 原子自增操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-在多线程环境下，如何正确地停止一个线程？"><a href="#14-在多线程环境下，如何正确地停止一个线程？" class="headerlink" title="14.在多线程环境下，如何正确地停止一个线程？"></a>14.在多线程环境下，如何正确地停止一个线程？</h4><p><strong>使用标志变量控制线程的退出:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">stop</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Working...\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread stopped.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(worker)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-线程池是怎么构建的，遇到过什么问题是怎样解决的？"><a href="#15-线程池是怎么构建的，遇到过什么问题是怎样解决的？" class="headerlink" title="15.线程池是怎么构建的，遇到过什么问题是怎样解决的？"></a>15.线程池是怎么构建的，遇到过什么问题是怎样解决的？</h4><p><strong>构建线程池的一般步骤：</strong></p><ul><li><strong>确定线程池大小</strong>：线程池的大小通常基于可用的处理器核心数以及程序的具体需求进行设置。</li><li><strong>任务队列</strong>：用于存放待执行的任务。</li><li><strong>工作线程</strong>：这是线程池中的实际工作者。</li><li><strong>管理机制</strong>：包括添加任务、关闭线程池、处理异常等操作。</li></ul><p><strong>问题：</strong></p><ul><li>访问任务队列时，要加互斥锁和条件变量</li><li>析构函数要正确地退出所有线程，如果没有正确管理线程生命周期，可能会出现线程泄漏的情况，即线程完成任务后没有正常退出。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-为什么虚函数能实现动态绑定？&quot;&gt;&lt;a href=&quot;#1-为什么虚函数能实现动态绑定？&quot; class=&quot;headerlink&quot; title=&quot;1.为什么虚函数能实现动态绑定？&quot;&gt;&lt;/a&gt;1.为什么虚函数能实现动态绑定？&lt;/h4&gt;&lt;p&gt;虚函数能实现动态绑定主要通过</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程编程</title>
    <link href="https://wangak.cc/posts/2148a8a.html"/>
    <id>https://wangak.cc/posts/2148a8a.html</id>
    <published>2025-03-23T16:00:00.000Z</published>
    <updated>2025-03-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><p><strong>头文件：</strong><code>#include&lt;thread&gt;</code></p><p><strong>创建线程:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个线程并执行 threadFunction</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    <span class="comment">// 主线程继续执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main!\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 等待线程 t 完成(join是一个阻塞等待)</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分离线程:</strong> 不希望主线程等待子线程完成，可以调用<code>detach()</code>方法。分离后的线程将在后台运行，主线程不再与之关联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    <span class="comment">// 分离线程</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">// 主线程继续执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main!\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 注意：分离后的线程无法再 join</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>传递参数给线程函数:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, str = &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="comment">// 创建线程并传递参数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction, x, str)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>std::thread</code> :</strong> 提供了一个成员函数 <code>joinable()</code>，用于检查一个线程对象是否可以被 <strong>join</strong> 或 <strong>detach</strong>。</p><p><strong><code>std::ref</code>:</strong> 创建对象的引用包装器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x += <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(foo, std::ref(a))</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子线程调用类的成员函数"><a href="#子线程调用类的成员函数" class="headerlink" title="子线程调用类的成员函数"></a>子线程调用类的成员函数</h4><p><strong>直接传递成员函数指针和对象实例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunction</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Member function called with x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="comment">// 直接传递成员函数指针和对象实例</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(&amp;MyClass::memberFunction, &amp;obj, <span class="number">42</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 std::shared_ptr 来管理类对象的生命周期，确保在线程执行期间对象不会被销毁:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() </span><br><span class="line">        &lt;&lt; <span class="string">&quot; started&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; obj = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(&amp;MyClass::func, obj)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="互斥量解决多线程数据共享问题"><a href="#互斥量解决多线程数据共享问题" class="headerlink" title="互斥量解决多线程数据共享问题"></a>互斥量解决多线程数据共享问题</h4><p><strong>头文件：</strong><code>#include &lt;mutex&gt;</code></p><p><strong>线程安全的定义：</strong>如果多线程程序每一次的运行结果和单线程程序的运行结果始终一样，那么就是线程安全的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        mtx.<span class="built_in">lock</span>();<span class="comment">//加锁</span></span><br><span class="line">        shared_data++;        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; n </span><br><span class="line">        &lt;&lt; <span class="string">&quot; increment shared_data to &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>(); <span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final shared_data = &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="互斥量封装类"><a href="#互斥量封装类" class="headerlink" title="互斥量封装类"></a>互斥量封装类</h4><ul><li><p><strong><code>std::lock_guard</code></strong>：作用是在构造时自动锁定互斥锁，在析构时自动解锁互斥锁。</p><p>注：不支持手动控制锁的行为（如延迟锁定、提前解锁等）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动加锁</span></span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">// 自动解锁（当 lock 超出作用域时）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 2&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::unique_lock</code></strong>: 允许对锁进行更细粒度的控制，例如延迟锁定、手动解锁、尝试锁定等。</p><p><em>注：相对于 <code>std::lock_guard</code>，开销稍大（因为它需要维护更多的状态）。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::defer_lock)</span></span>; <span class="comment">// 延迟锁定</span></span><br><span class="line">    lock.<span class="built_in">lock</span>(); <span class="comment">// 手动加锁</span></span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    lock.<span class="built_in">unlock</span>(); <span class="comment">// 手动解锁</span></span><br><span class="line">    <span class="comment">// 锁会在 unique_lock 析构时自动解锁（如果尚未解锁）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 2&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::lock_guard</code> 和 <code>std::unique_lock</code> 的对比</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503261056266.png" alt="image-20250323210830055" style="zoom:50%;"></p></li></ul><h4 id="std-call-once"><a href="#std-call-once" class="headerlink" title="std::call_once"></a>std::call_once</h4><p><code>std::call_once</code> 用于确保某个函数或代码块在多线程环境中只被执行一次。</p><p><strong><code>std::call_once</code> 的主要作用是：</strong></p><ul><li><strong>线程安全的单次执行</strong>：确保某个函数或代码块在多个线程中只会被执行一次。</li><li><strong>避免竞态条件</strong>：在多线程环境下，多个线程可能同时尝试执行某段代码，<code>std::call_once</code> 可以保证只有一个线程能够成功执行，其他线程会等待该操作完成后再继续。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::once_flag flag;  <span class="comment">// 定义一个 once_flag 对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initialization function executed by thread &quot;</span></span><br><span class="line">              &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(flag, initialize);  <span class="comment">// 确保 initialize 函数只被调用一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread_func)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread_func)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(thread_func)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景：</strong></p><ul><li><strong>延迟初始化</strong>：在某些情况下，对象的初始化成本较高，或者只有在需要时才进行初始化。可以使用 <code>std::call_once</code> 来确保初始化逻辑只执行一次。</li><li><strong>单例模式</strong>：在实现线程安全的单例模式时，可以使用 <code>std::call_once</code> 来确保实例化过程只发生一次。</li></ul><p><em>注：<code>std::call_once</code>只能在线程函数中才能使用</em></p><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p><strong>条件变量（<code>std::condition_variable</code>）</strong>是一个用于线程间通信的同步原语。允许一个线程等待某个条件成立，而另一个线程可以在该条件满足时通知等待的线程继续执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cond_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(data++);</span><br><span class="line">        cond_var.<span class="built_in">notify_one</span>(); <span class="comment">// 通知正在等待的消费者线程</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// 模拟生产时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cond_var.<span class="built_in">wait</span>(lock, []()&#123;<span class="keyword">return</span> !q.<span class="built_in">empty</span>();&#125;); <span class="comment">// 等待直到队列非空</span></span><br><span class="line">        <span class="type">int</span> value = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong>生产者线程</strong>：不断地将数据添加到队列中，并通过 <code>cond_var.notify_one()</code> 通知可能正在等待的消费者线程，表示有新的数据可以处理了。</li><li><strong>消费者线程</strong>：首先尝试获取互斥锁，然后调用 <code>cond_var.wait(lock, condition)</code> 方法检查队列是否为空。如果队列为空，则当前线程会释放锁并进入等待状态，直到被生产者线程通知且条件满足（即队列非空）。一旦条件满足，消费者线程重新获取锁，并从队列中取出数据进行处理。</li></ul><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p><strong>线程池（Thread  Pool）</strong>是一种用于管理线程的机制，旨在减少频繁创建和销毁线程的开销。它<strong>预先创建一组线程</strong>，并将任务提交到一个<strong>任务队列</strong>中，<strong>线程从队列中取出任务并执行。</strong>这种方式特别适用于需要频繁执行短任务的场景，因为线程池可以避免每次任务执行时都创建新线程所带来的性能开销。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> numThreads) : <span class="built_in">stop</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">            threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//每个线程会不断地运行，直到满足特定的退出条件（如线程池关闭且任务队列为空）</span></span><br><span class="line">                    std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mutex);</span><br><span class="line">                    <span class="comment">//stop || !tasks.empty()是解锁的条件</span></span><br><span class="line">                    condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> stop || !tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                    <span class="keyword">if</span> (stop &amp;&amp; tasks.<span class="built_in">empty</span>()) &#123;<span class="comment">//线程退出的条件</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; <span class="built_in">task</span>(std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>()));</span><br><span class="line">                    tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    lock.<span class="built_in">unlock</span>();</span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        condition.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有等待的线程。</span></span><br><span class="line">        <span class="keyword">for</span> (std::thread&amp; thread : threads) &#123;<span class="comment">//等待所有线程完成其当前任务并退出</span></span><br><span class="line">            thread.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123; <span class="comment">//f是函数，args是参数</span></span><br><span class="line">        <span class="comment">//将用户提交的任务（函数 f 和其参数 args...）封装成一个无参数、无返回值的函数对象</span></span><br><span class="line">        <span class="comment">//std::bind 的作用是将函数及其参数绑定在一起，生成一个无参数的函数对象，从而满足任务队列的要求。</span></span><br><span class="line">        <span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...))</span></span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">            tasks.<span class="built_in">emplace</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">        &#125;</span><br><span class="line">        condition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;<span class="comment">//保存线程池中的所有线程。</span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;<span class="comment">//任务队列</span></span><br><span class="line">    std::mutex mutex;<span class="comment">//用于保护对共享资源（如任务队列）的访问，确保线程安全</span></span><br><span class="line">    std::condition_variable condition;<span class="comment">//条件变量，用于在线程间进行同步。线程会在任务队列为空时等待，直到有新任务被加入队列。</span></span><br><span class="line">    <span class="type">bool</span> stop;<span class="comment">//标志位，用于指示线程池是否停止运行。当线程池析构时，会设置该标志为 true，通知所有线程退出。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        pool.<span class="built_in">enqueue</span>([i] &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; is running in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; is done&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步并发机制"><a href="#异步并发机制" class="headerlink" title="异步并发机制"></a>异步并发机制</h4><p><strong><code>std::async</code> 和<code>std::future</code>：</strong></p><ul><li><code>std::async</code>: <strong>启动一个异步任务</strong>，返回一个<code>std::future</code>对象</li><li>两种启动策略：<ul><li><code>std::launch::async</code>：立即在新线程中执行</li><li><code>std::launch::deferred</code>：延迟执行，直到调用<code>future.get()</code></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 异步执行compute函数</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(std::launch::async, compute);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以做其他工作...</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing other work...\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取结果(会阻塞直到结果就绪)</span></span><br><span class="line">    <span class="type">int</span> value = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>std::future:</strong> <strong>表示异步操作的结果</strong><ul><li><code>get()</code>：获取结果，会阻塞直到结果就绪</li><li><code>wait()</code>：等待结果就绪</li><li><code>valid()</code>：检查future是否关联了共享状态</li><li><code>share()</code>：转换为<code>std::shared_future</code></li></ul></li></ul><p><strong>std::packaged_task:</strong> 是一个可调用的对象包装器，它将函数调用与future关联起来。</p><ul><li><p>比<code>std::async</code>更灵活，可以控制任务的执行方式</p></li><li><p>可以多次使用（通过重置）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个packaged_task，包装compute函数</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(compute)</span></span>;</span><br><span class="line">    <span class="comment">// 获取与任务关联的future</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// 在另一个线程中执行任务</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task), <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>(); <span class="comment">// 或使用t.join()</span></span><br><span class="line">    <span class="comment">// 获取结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>std::promise:</strong> 提供了更底层的设置异步结果的方式，允许显式设置值或异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compute</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp;&amp; prom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟计算</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 设置结果</span></span><br><span class="line">        prom.<span class="built_in">set_value</span>(<span class="number">42</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="comment">// 捕获异常并存储到promise中</span></span><br><span class="line">        prom.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = prom.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(compute, std::move(prom))</span></span>;</span><br><span class="line">    <span class="comment">// 获取结果</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多线程编程&quot;&gt;&lt;a href=&quot;#多线程编程&quot; class=&quot;headerlink&quot; title=&quot;多线程编程&quot;&gt;&lt;/a&gt;多线程编程&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;头文件：&lt;/strong&gt;&lt;code&gt;#include&amp;lt;thread&amp;gt;&lt;/code&gt;&lt;/</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++八股5</title>
    <link href="https://wangak.cc/posts/3a78fb45.html"/>
    <id>https://wangak.cc/posts/3a78fb45.html</id>
    <published>2025-03-22T16:00:00.000Z</published>
    <updated>2025-03-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-怎样判断两个浮点数是否相等？"><a href="#1-怎样判断两个浮点数是否相等？" class="headerlink" title="1.怎样判断两个浮点数是否相等？"></a>1.怎样判断两个浮点数是否相等？</h4><p>由于浮点数在计算机中的表示方式和存储限制，直接使用 <code>==</code> 操作符来判断两个浮点数是否相等可能会导致不准确的结果，即使这两个数看起来应该是相等的。这是因为浮点数的精度有限，在某些计算后可能产生非常小的<strong>舍入误差。</strong></p><p>正确的做法是比较两个浮点数之间的差值是否在一个很小的范围内，而不是直接检查它们是否完全相等。可以将这两个浮点数相减，然后取结果的绝对值，并与一个预设的小阈值（也称为“精度”）进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">abs</span><span class="params">(a - b)</span> &lt; epsilon:</span></span><br><span class="line"><span class="function">    print(<span class="string">&quot;a and b are considered equal&quot;</span>)</span></span><br><span class="line"><span class="function">else:</span></span><br><span class="line"><span class="function">    print(<span class="string">&quot;a and b are not equal&quot;</span>)</span></span><br></pre></td></tr></table></figure><h4 id="2-类如何实现只能静态分配和只能动态分配"><a href="#2-类如何实现只能静态分配和只能动态分配" class="headerlink" title="2.类如何实现只能静态分配和只能动态分配"></a>2.类如何实现只能静态分配和只能动态分配</h4><ul><li><p><strong>只能静态分配:</strong> 类的对象只能在栈上创建,将 <code>new</code> 和 <code>delete</code> 运算符重载并声明为 <code>private</code> 属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackOnly</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 重载new和delete运算符，并将它们设为private</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom new is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 不应该实际调用，因为我们不希望在堆上创建对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom delete is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 不应该实际调用</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StackOnly</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;StackOnly object created on stack.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">StackOnly</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;StackOnly object destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StackOnly obj; <span class="comment">// 正确：在栈上创建对象</span></span><br><span class="line">    <span class="comment">// 错误：尝试在堆上创建对象（这将导致编译错误）</span></span><br><span class="line">    <span class="comment">// StackOnly* obj2 = new StackOnly();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>只能动态分配:</strong> 类的对象只能在堆上创建,将构造函数和析构函数设为 <code>protected 属性</code>，并提供一个公有的静态成员函数用来创建对象实例。</p><ul><li><strong>限制直接实例化</strong>：通过将构造函数和析构函数设为 <code>protected</code>，可以防止外部代码直接使用构造函数来创建对象实例。</li><li><strong>允许继承</strong>：将构造函数和析构函数设为 <code>protected</code> 而不是 <code>private</code>，使得派生类仍然能够调用基类的构造函数进行初始化。</li><li><strong>集中控制对象创建逻辑</strong>：通过提供一个静态成员函数如 <code>createInstance</code> 来负责对象的创建，可以集中控制对象的创建过程。</li><li><strong>静态成员函数无需实例即可调用</strong>：静态成员函数不依赖于类的具体实例，可以直接通过类名调用。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个只能动态分配的基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OnlyDynamic</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 构造函数和析构函数都设置为protected</span></span><br><span class="line">    <span class="built_in">OnlyDynamic</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OnlyDynamic Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">OnlyDynamic</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OnlyDynamic Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 提供一个静态成员函数用于创建对象实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> OnlyDynamic* <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OnlyDynamic</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Display function of OnlyDynamic&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-继承机制中对象之间如何转换？指针和引用之间如何转换？"><a href="#3-继承机制中对象之间如何转换？指针和引用之间如何转换？" class="headerlink" title="3.继承机制中对象之间如何转换？指针和引用之间如何转换？"></a>3.继承机制中对象之间如何转换？指针和引用之间如何转换？</h4><ul><li><p><strong>向上类型转换:</strong> 派生类的指针或引用转换为基类的指针或引用。这种转换是安全的，并且在C++中会自动进行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line">Base* ptr = &amp;d;  <span class="comment">// 自动向上类型转换</span></span><br></pre></td></tr></table></figure></li><li><p><strong>向下类型转换:</strong> 将基类的指针或引用转换为派生类的指针或引用。向下类型转换不会自动进行，必须显式地执行,通常是通过<code>dynamic_cast</code> 来实现的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();  <span class="comment">// 假设我们知道这个基类指针实际指向一个派生类对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 dynamic_cast 进行向下类型转换，注意这里需要包含正确的头文件</span></span><br><span class="line">Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"><span class="keyword">if</span> (derivedPtr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 转换成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 转换失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-知道C-中的组合吗？它与继承相比有什么优缺点吗？"><a href="#4-知道C-中的组合吗？它与继承相比有什么优缺点吗？" class="headerlink" title="4.知道C++中的组合吗？它与继承相比有什么优缺点吗？"></a>4.知道C++中的组合吗？它与继承相比有什么优缺点吗？</h4><p><strong>继承：</strong></p><ul><li><p><strong>优点：</strong></p><ul><li>子类可以重写父类的方法来方便地扩展功能。</li></ul></li><li><p><strong>缺点：</strong></p><ul><li><strong>高耦合性</strong>：子类依赖于父类的实现细节，这增加了耦合度</li><li><strong>编译时绑定</strong>：子类从父类继承的方法在编译期就已经确定，无法在运行时改变行为。</li><li><strong>维护成本</strong>：如果修改了父类的方法（如添加参数），则所有相关的子类也需要相应调整，否则可能导致错误。</li></ul></li></ul><p><strong>组合：</strong>一个类中包含另一个类的对象作为成员变量，体现了“有一个”（Has-a）的关系。</p><ul><li><p><strong>优点：</strong></p><ul><li><strong>低耦合性</strong>：通过组合的方式，外部对象只能通过接口访问被包含对象的功能，因此内部实现细节对外部不可见。</li><li><strong>灵活性</strong>：由于当前对象和被包含的对象之间是低耦合的，所以对被包含对象的修改不需要修改当前对象的代码。</li><li><strong>动态绑定</strong>：可以在运行时动态地替换所包含的对象，提供了更大的灵活性。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个接口或抽象类，用于定义技能的行为</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Skill</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数，定义了技能的使用方法</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Skill</span>() &#123;&#125; <span class="comment">// 虚析构函数，确保派生类能正确释放</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现具体的技能A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkillA</span> : <span class="keyword">public</span> Skill &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using Skill A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现具体的技能B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkillB</span> : <span class="keyword">public</span> Skill &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using Skill B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏角色类，通过组合方式包含技能对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Skill&gt; skill; <span class="comment">// 使用智能指针管理技能对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 设置技能的方法，允许在运行时更换技能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSkill</span><span class="params">(std::unique_ptr&lt;Skill&gt; newSkill)</span> </span>&#123;</span><br><span class="line">        skill = std::<span class="built_in">move</span>(newSkill);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 角色使用当前装备的技能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">performSkill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (skill) &#123;</span><br><span class="line">            skill-&gt;<span class="built_in">use</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No skill available.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    GameCharacter character;</span><br><span class="line">    <span class="comment">// 初始设置为SkillA</span></span><br><span class="line">    character.<span class="built_in">setSkill</span>(std::<span class="built_in">make_unique</span>&lt;SkillA&gt;());</span><br><span class="line">    character.<span class="built_in">performSkill</span>(); <span class="comment">// 输出: Using Skill A</span></span><br><span class="line">    <span class="comment">// 动态替换为SkillB</span></span><br><span class="line">    character.<span class="built_in">setSkill</span>(std::<span class="built_in">make_unique</span>&lt;SkillB&gt;());</span><br><span class="line">    character.<span class="built_in">performSkill</span>(); <span class="comment">// 输出: Using Skill B</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>缺点</strong>：</p><ul><li><strong>对象管理复杂</strong>：过多使用组合可能会导致创建大量小对象，增加了系统的复杂性。</li><li><strong>接口设计要求高</strong>：为了有效地组合多个对象，必须仔细设计接口，确保它们能够良好协作。</li></ul></li></ul><h4 id="5-函数指针？"><a href="#5-函数指针？" class="headerlink" title="5.函数指针？"></a>5.函数指针？</h4><p><strong>函数指针的声明方法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*pf)(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;);</span><br></pre></td></tr></table></figure><p><em>注：<code>pf</code> 是一个指向函数的指针，该函数返回 <code>int</code> 类型并且接受两个 <code>const int&amp;</code> 类型的参数。注意这里的括号非常重要：`(</em>pf)<code>确保了</code><em><code>被应用到</code>pf<code>上，表明这是一个指针；如果没有这些括号，如</code>int </em>pf(const int&amp;, const int&amp;);<code>，这将被解析为一个返回</code>int<em>` 的函数声明。</em></p><p><strong>两种方法赋值：</strong></p><ul><li><p><strong>直接使用函数名：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pf = functionName;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用取地址运算符<code>&amp;</code>:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pf = &amp;functionName;</span><br></pre></td></tr></table></figure></li></ul><p><strong>函数指针的作用：动态选择函数执行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义几个基本的数学操作函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="number">0</span>) <span class="keyword">return</span> a / b;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error: Division by zero!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0作为错误处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数指针类型，简化声明</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*MathFunc)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeOperation</span><span class="params">(MathFunc operation, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; <span class="built_in">operation</span>(a, b) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">5</span>;</span><br><span class="line">    MathFunc operation;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Choose an operation (1: Add, 2: Subtract, 3: Multiply, 4: Divide): &quot;</span>;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    std::cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            operation = add; <span class="comment">// 函数名直接赋值给函数指针</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            operation = subtract;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            operation = multiply;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            operation = divide;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Invalid choice.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">executeOperation</span>(operation, x, y); <span class="comment">// 使用函数指针调用对应的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-结构体变量比较是否相等"><a href="#6-结构体变量比较是否相等" class="headerlink" title="6.结构体变量比较是否相等"></a>6.结构体变量比较是否相等</h4><p><strong>重载 <code>==</code> 操作符</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 == 操作符</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> foo&amp; rhs) <span class="type">const</span> &#123; <span class="comment">// 注意这里的 const 修饰符</span></span><br><span class="line">        <span class="built_in">return</span> (a == rhs.a) &amp;&amp; (b == rhs.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-函数调用过程栈的变化，返回值和参数变量哪个先入栈？"><a href="#7-函数调用过程栈的变化，返回值和参数变量哪个先入栈？" class="headerlink" title="7.函数调用过程栈的变化，返回值和参数变量哪个先入栈？"></a>7.函数调用过程栈的变化，返回值和参数变量哪个先入栈？</h4><ul><li><p><strong>参数入栈:</strong>调用者（caller）需要将被调函数（callee）所需的参数按照与形参顺序相反的顺序压入栈中。</p><p>对于函数调用 <code>func(a, b, c)</code>，则它们会以 <code>c</code>, <code>b</code>, <code>a</code> 的顺序依次压入栈中。</p></li><li><p><strong>调用和返回地址入栈:</strong> 使用 <code>call</code> 指令进行函数调用时，该指令除了跳转到被调函数的起始地址执行外，还会自动将 <code>call</code> 指令的下一条指令的地址（即返回地址）压入栈中。</p></li><li><strong>设置新的栈帧:</strong> 一旦控制权转移到被调函数，首先要做的就是设置一个新的栈帧。</li><li><strong>局部变量和临时变量入栈:</strong> 在新栈帧内，局部变量根据定义顺序分配空间，地址随栈的增长方向递减。</li></ul><h4 id="8-C-中类成员的访问权限和继承权限问题"><a href="#8-C-中类成员的访问权限和继承权限问题" class="headerlink" title="8.C++中类成员的访问权限和继承权限问题"></a>8.C++中类成员的访问权限和继承权限问题</h4><p><strong>三种访问权限:</strong></p><ul><li>一个类的public成员变量、成员函数，可以通过类的成员函数、类的实例变量进行访问</li><li>一个类的protected成员变量、成员函数，无法通过类的实例变量进行访问。但是可以通过<strong>类的友元函数、友元类</strong>进行访问。</li><li>一个类的private成员变量、成员函数，无法通过类的实例变量进行访问。但是<strong>可以通过类的友元函数、友元类进行访问。</strong></li></ul><p><strong>继承权限:</strong></p><ul><li><p><strong>public继承:</strong> 基类的各种权限不变 。</p></li><li><p><strong>protected继承:</strong> 派生类通过protected继承，基类的public成员在派生类中的权限变成了protected 。protected和private不变。</p></li><li><p><strong>private继承:</strong> private继承看成派生类将基类的public,protected成员囊括到派生类，全部作为派生类的private成员，但是不包括private成员。</p><p><em>注：基类的私有成员都不会直接被派生类继承</em></p></li></ul><h4 id="9-cout和printf有什么区别？"><a href="#9-cout和printf有什么区别？" class="headerlink" title="9.cout和printf有什么区别？"></a>9.cout和printf有什么区别？</h4><p><code>cout&lt;&lt;</code>是一个函数，<code>cout&lt;&lt;</code>后可以跟不同的类型是因为<code>cout&lt;&lt;</code>已存在针对各种类型数据的重载，所以会自动识别数据的类型。</p><p><strong>缓冲机制:</strong></p><ul><li><strong><code>cout</code>（有缓冲输出）</strong>: 输出到<code>cout</code>的内容首先会被放入缓冲区，然后根据特定条件（如遇到换行符<code>\n</code>、程序结束、手动刷新缓冲区等）才会从缓冲区输出到屏幕。为了确保立即输出内容，可以使用<code>endl</code>或者显式地调用<code>flush</code>方法（如<code>cout &lt;&lt; &quot;abc&quot; &lt;&lt; endl;</code> 或 <code>cout &lt;&lt; &quot;abc\n&quot; &lt;&lt; flush;</code>）。<code>endl</code>不仅插入了一个换行符，还会导致流被刷新；而<code>flush</code>仅刷新流而不添加任何字符。</li><li><strong><code>printf</code>（无缓冲输出）</strong>: 传统上认为<code>printf</code>是无缓冲输出，意味着当你调用<code>printf</code>时，输出几乎是立即显示的。</li></ul><h4 id="10-为什么可以为类的成员函数创建模板，但不能是虚函数和析构函数？"><a href="#10-为什么可以为类的成员函数创建模板，但不能是虚函数和析构函数？" class="headerlink" title="10.为什么可以为类的成员函数创建模板，但不能是虚函数和析构函数？"></a>10.为什么可以为类的成员函数创建模板，但不能是虚函数和析构函数？</h4><p>析构函数：没有参数，不需要使用模板</p><p>虚函数：由于模板成员函数的实例化是编译时的行为，而虚函数的动态绑定是运行时的行为，这两者无法同时满足。</p><h4 id="11-定义和声明的区别"><a href="#11-定义和声明的区别" class="headerlink" title="11.定义和声明的区别"></a>11.定义和声明的区别</h4><p><strong>变量的声明和定义：</strong></p><ul><li><strong>声明</strong>：当提到变量时，声明是指告诉编译器存在某个类型的变量，但并<strong>不会为这个变量分配内存空间</strong>。</li><li><strong>定义</strong>：而定义则是实际为变量<strong>分配内存空间</strong>的过程。这意味着系统会为该变量预留一定的存储空间，用于<strong>存放它的值</strong>。</li></ul><p><strong>函数的声明和定义：</strong></p><ul><li><strong>声明</strong>：对于函数来说，<strong>声明位于头文件（.h文件）中</strong>，其目的是通知编译器有关该函数的一些基本信息，比如函数名称、返回类型以及参数列表等。</li><li><strong>定义</strong>：函数的定义则包含了函数的实际实现代码，即函数体。它描述了函数执行的操作，并且<strong>位于源文件（.c或.cpp文件）中。</strong></li></ul><h4 id="12-静态成员与普通成员的区别是什么？"><a href="#12-静态成员与普通成员的区别是什么？" class="headerlink" title="12.静态成员与普通成员的区别是什么？"></a>12.静态成员与普通成员的区别是什么？</h4><p><strong>生命周期：</strong></p><ul><li><strong>静态成员变量</strong>：其生命周期从类被加载到内存开始，直到类被卸载为止。</li><li><strong>普通成员变量</strong>：它们的生命周期<strong>与对象实例</strong>紧密相关，只有当创建了一个类的对象时，普通成员变量才会存在</li></ul><p><strong>共享方式：</strong></p><ul><li><strong>静态成员变量</strong>：所有的对象都共享同一个静态成员变量</li><li><strong>普通成员变量</strong>：每个对象都有自己的一份副本</li></ul><p><strong>定义位置：</strong></p><ul><li><strong>普通成员变量</strong>：通常存储在栈或堆中，具体取决于它们是如何被声明和使用的。</li><li><strong>静态成员变量</strong>：存储在<strong>静态全局区</strong>，这意味着它们的存储空间是在程序启动时分配的，并且不会随对象的创建和销毁而变化。</li></ul><p><strong>初始化位置：</strong></p><ul><li><strong>普通成员变量</strong>：可以在类定义中直接初始化</li><li><strong>静态成员变量</strong>：必须<strong>在类外部进行初始化</strong>（除非是静态常量整型成员，可以直接在类定义中初始化）。</li></ul><h4 id="13-说一下你理解的-ifdef-endif代表着什么？"><a href="#13-说一下你理解的-ifdef-endif代表着什么？" class="headerlink" title="13.说一下你理解的 ifdef endif代表着什么？"></a>13.说一下你理解的 ifdef endif代表着什么？</h4><p><code>#ifdef</code>和<code>#endif</code>是C/C++语言中的预处理指令，用于<strong>实现条件编译</strong>。</p><p><strong>防止头文件重复包含</strong>（头文件卫士）：避免因多次包含同一头文件而导致的重定义问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEADER_FILE_NAME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEADER_FILE_NAME_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件的内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HEADER_FILE_NAME_H</span></span></span><br></pre></td></tr></table></figure><h4 id="14-隐式转换，如何消除隐式转换？"><a href="#14-隐式转换，如何消除隐式转换？" class="headerlink" title="14.隐式转换，如何消除隐式转换？"></a>14.隐式转换，如何消除隐式转换？</h4><p><strong>隐式转换:</strong></p><ul><li><strong>子类对象可以隐式地转换为父类对象(多态）</strong></li><li><strong>从小的数据类型（如<code>char</code>或<code>short</code>）向大的数据类型（如<code>int</code>或<code>long</code>）转换</strong></li></ul><p><strong>消除隐式转换的方法：</strong></p><ul><li><p><strong>使用<code>explicit</code>关键字</strong>：在构造函数声明时加上<code>explicit</code>关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="comment">/* 构造函数体 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="15-如果有一个空类，它会默认添加哪些函数？"><a href="#15-如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="15.如果有一个空类，它会默认添加哪些函数？"></a>15.如果有一个空类，它会默认添加哪些函数？</h4><ul><li><strong>默认构造函数</strong> (<code>Empty::Empty()</code>)</li><li><strong>拷贝构造函数</strong> (<code>Empty::Empty(const Empty&amp;)</code>)</li><li><strong>析构函数</strong> (<code>Empty::~Empty()</code>)</li><li><strong>赋值运算符重载函数</strong> (<code>Empty&amp; Empty::operator=(const Empty&amp;)</code>)</li></ul><h4 id="16-你知道const-char-与string之间的关系是什么吗？"><a href="#16-你知道const-char-与string之间的关系是什么吗？" class="headerlink" title="16.你知道const char* 与string之间的关系是什么吗？"></a>16.你知道const char* 与string之间的关系是什么吗？</h4><ul><li><strong><code>std::string</code></strong> 是C++标准库提供的一个类，用于封装字符串操作</li><li><strong><code>const char\*</code></strong> 是C风格的字符串表示形式，它实际上是一个指向以空字符（<code>\0</code>）结尾的字符数组的指针</li></ul><p>相互转换：</p><ul><li><p><strong>从 <code>std::string</code> 转换为 <code>const char\*</code></strong>： 使用 <code>std::string</code> 的成员函数 <code>c_str()</code> 可以获取一个 C 风格的字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = s.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure></li><li><p><strong>从 <code>const char\*</code> 转换为 <code>std::string</code></strong>： 可以直接通过构造函数将 <code>const char*</code> 转换为 <code>std::string</code>，这是隐式转换的一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(c_s)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="17-你什么情况用指针当参数，什么时候用引用，为什么？"><a href="#17-你什么情况用指针当参数，什么时候用引用，为什么？" class="headerlink" title="17.你什么情况用指针当参数，什么时候用引用，为什么？"></a>17.你什么情况用指针当参数，什么时候用引用，为什么？</h4><p>简单的数据类型：可以按值传递，因为复制成本低</p><p>数组只能使用指针</p><p>类对象使用引用传递</p><h4 id="18-如何设计一个类计算子类的个数？"><a href="#18-如何设计一个类计算子类的个数？" class="headerlink" title="18.如何设计一个类计算子类的个数？"></a>18.如何设计一个类计算子类的个数？</h4><p><strong>static静态变量coun计数：</strong></p><ul><li><p>为类设计一个static静态变量count作为计数器；</p></li><li><p>类定义结束后初始化count;</p></li><li><p>在构造函数中对count进行+1;</p></li><li><p>设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作；</p></li><li><p>设计复制构造函数，在进行复制函数中对count+1操作；</p></li><li><p>在析构函数中对count进行-1；</p></li></ul><h4 id="19-说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#19-说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="19.说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>19.说一说strcpy、sprintf与memcpy这三个函数的不同之处</h4><ul><li><p><strong><code>strcpy</code></strong>: 将<code>src</code>指向的字符串（包括终止符<code>\0</code>）复制到<code>dest</code>指向的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>sprintf</code></strong>: 根据提供的格式化字符串<code>format</code>和后续参数，生成一个格式化的字符串，并存储在<code>str</code>指向的缓冲区中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;The answer is %d&quot;</span>, number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>memcpy</code>:</strong> 从<code>src</code>指向的内存地址开始复制<code>n</code>个字节到<code>dest</code>指向的内存地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> src[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> dest[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="built_in">strlen</span>(src) + <span class="number">1</span>); <span class="comment">// 包括终止符&#x27;\0&#x27;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Copied string: %s\n&quot;</span>, dest);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="20-如何阻止一个类被实例化？有哪些方法？"><a href="#20-如何阻止一个类被实例化？有哪些方法？" class="headerlink" title="20.如何阻止一个类被实例化？有哪些方法？"></a>20.如何阻止一个类被实例化？有哪些方法？</h4><ul><li><p><strong>将类定义为抽象基类:</strong> <strong>抽象基类</strong>是一种不能实例化的类，它包含至少一个纯虚函数（即没有实现体的虚函数）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pureVirtualFunction</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractClass</span>() &#123;&#125; <span class="comment">// 虚析构函数确保派生类正确释放资源</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码会导致编译错误，因为不能实例化抽象类</span></span><br><span class="line"><span class="comment">// AbstractClass obj;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>将构造函数声明为<code>private</code></strong>: 提供静态成员函数来允许有限制地创建对象，或者根本不提供创建对象的方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonInstantiableClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">NonInstantiableClass</span>() &#123;&#125; <span class="comment">// 私有构造函数</span></span><br><span class="line">    ~<span class="built_in">NonInstantiableClass</span>() &#123;&#125; <span class="comment">// 私有析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以在这里执行一些操作，但不能创建对象实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码会导致编译错误，因为构造函数是私有的</span></span><br><span class="line"><span class="comment">// NonInstantiableClass obj;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>静态成员函数来允许有限制地创建对象:</strong></p><ul><li><p><strong>单例模式:</strong> 单例模式确保一个类只有一个实例，使用一个静态方法来返回唯一的实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonInstantiableClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="built_in">NonInstantiableClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有析构函数</span></span><br><span class="line">    ~<span class="built_in">NonInstantiableClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">NonInstantiableClass</span>(<span class="type">const</span> NonInstantiableClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    NonInstantiableClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonInstantiableClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态方法用于获取唯一实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> NonInstantiableClass&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> NonInstantiableClass instance; <span class="comment">// 局部静态变量保证线程安全</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Doing something...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过静态方法获取唯一实例并调用其方法</span></span><br><span class="line">    NonInstantiableClass&amp; obj = NonInstantiableClass::<span class="built_in">getInstance</span>();</span><br><span class="line">    obj.<span class="built_in">doSomething</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>工厂方法模式:</strong> 工厂方法模式允许类将对象的创建过程封装在一个或多个工厂方法中。这种方式可以控制对象的创建逻辑，并且可以隐藏具体的实现细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonInstantiableClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="built_in">NonInstantiableClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有析构函数</span></span><br><span class="line">    ~<span class="built_in">NonInstantiableClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">NonInstantiableClass</span>(<span class="type">const</span> NonInstantiableClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    NonInstantiableClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonInstantiableClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态工厂方法用于创建对象实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::unique_ptr&lt;NonInstantiableClass&gt; <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;NonInstantiableClass&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Doing something...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用工厂方法创建对象实例</span></span><br><span class="line">    std::unique_ptr&lt;NonInstantiableClass&gt; obj = NonInstantiableClass::<span class="built_in">createInstance</span>();</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        obj-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="21-虚基类"><a href="#21-虚基类" class="headerlink" title="21.虚基类"></a>21.虚基类</h4><p>虚基类主要用于解决多重继承中的菱形继承（多义性）问题</p><p>当一个类从多个类继承，而这些类又有一个共同的基类时，如果不使用虚基类，可能会导致基类部分被多次复制。通过将共同基类声明为虚基类，可以确保该基类在派生类中只存在一份实例。</p><p>在<code>FinalClass</code>类的构造函数中，需要显式调用 <code>Base</code> 类的构造函数，因为 <code>Base</code> 是虚基类，必须明确初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">// 定义基类 Base</span><br><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    int baseValue;</span><br><span class="line"></span><br><span class="line">    Base(int val) : baseValue(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Base constructor called, value = &quot; &lt;&lt; baseValue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void show() const &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Base value: &quot; &lt;&lt; baseValue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义 Derived1 类，从 Base 继承，并且 Base 是虚基类</span><br><span class="line">class Derived1 : virtual public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    Derived1(int val) : Base(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Derived1 constructor called&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义 Derived2 类，从 Base 继承，并且 Base 是虚基类</span><br><span class="line">class Derived2 : virtual public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    Derived2(int val) : Base(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Derived2 constructor called&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义 FinalClass 类，从 Derived1 和 Derived2 继承</span><br><span class="line">class FinalClass : public Derived1, public Derived2 &#123;</span><br><span class="line">public:</span><br><span class="line">    FinalClass(int val) : Base(val), Derived1(val), Derived2(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;FinalClass constructor called&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建 FinalClass 的对象</span><br><span class="line">    FinalClass obj(10);</span><br><span class="line"></span><br><span class="line">    // 调用 Base 类的方法</span><br><span class="line">    obj.show();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-怎样判断两个浮点数是否相等？&quot;&gt;&lt;a href=&quot;#1-怎样判断两个浮点数是否相等？&quot; class=&quot;headerlink&quot; title=&quot;1.怎样判断两个浮点数是否相等？&quot;&gt;&lt;/a&gt;1.怎样判断两个浮点数是否相等？&lt;/h4&gt;&lt;p&gt;由于浮点数在计算机中的表示方</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++泛编程</title>
    <link href="https://wangak.cc/posts/24f68203.html"/>
    <id>https://wangak.cc/posts/24f68203.html</id>
    <published>2025-03-22T16:00:00.000Z</published>
    <updated>2025-03-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-泛编程"><a href="#C-泛编程" class="headerlink" title="C++泛编程"></a>C++泛编程</h3><h4 id="1-auto"><a href="#1-auto" class="headerlink" title="1.auto"></a>1.auto</h4><p><strong>auto的主要用途：</strong>让编译器自动推断变量的类型</p><ul><li>代替冗长复杂的变量声明（函数指针）</li><li>在模板中，用于声明依赖模板参数的变量</li><li>函数模板依赖模板参数的返回值</li><li>用于Lambda表达式中</li></ul><h4 id="2-函数模板"><a href="#2-函数模板" class="headerlink" title="2.函数模板"></a>2.函数模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T &amp;a,T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注1：可以为类的成员函数创建模板，但不能是虚函数和析构函数。</em></p><p><em>注2：使用函数模板时，如果自动类型推导，不会发生隐式类型转换，而如果显式指定了函数模板的数据类型，则可以发生隐式类型转换。</em></p><p><strong>编译器使用各种函数的规则：</strong></p><ul><li><p>普通函数&gt;具体化&gt;常规模板</p></li><li><p>如果希望使用函数模板，可以用空模板参数强制使用函数模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;普通函数: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;函数模板: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认情况下，编译器可能优先选择普通函数</span></span><br><span class="line">    <span class="built_in">show</span>(value); <span class="comment">// 输出: 普通函数: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制使用函数模板</span></span><br><span class="line">    show&lt;&gt;(value); <span class="comment">// 输出: 函数模板: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果函数模板能产生更好的匹配，将优先于普通函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">long</span> a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;普通函数: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;函数模板: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽管有一个接受long类型的普通函数，</span></span><br><span class="line">    <span class="comment">// 但函数模板提供了对int类型更直接的匹配。</span></span><br><span class="line">    <span class="built_in">display</span>(value); <span class="comment">// 输出: 函数模板: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>函数模板分文件编写：</strong></p><ul><li><em>函数模板只是函数的描述，没有实体，创建函数模板的代码放在头文件中</em></li><li><em>函数模板具体化有实体，编译原理和普通函数一样，声明放在头文件中，定义放在源文件中。</em></li></ul><h4 id="3-类模板（泛化、全特化、偏特化）"><a href="#3-类模板（泛化、全特化、偏特化）" class="headerlink" title="3.类模板（泛化、全特化、偏特化）"></a>3.类模板（泛化、全特化、偏特化）</h4><p><strong>模板泛化</strong></p><p>模板泛化是不关心具体的类型，而是提供了通用的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 泛化的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic process: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>全特化</strong></p><p><strong>全特化：</strong>为某些类型提供更高效的实现</p><p>成员函数的全特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员函数的特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> MyClass&lt;<span class="type">int</span>&gt;::<span class="built_in">process</span>(<span class="type">int</span> data) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Specialized process for int: &quot;</span> &lt;&lt; data * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板全特化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板的特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized implementation for int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>偏特化</strong></p><p>模板偏特化是指在泛化的模板基础上，对其中的某一部分进行特化。</p><p><strong>模板参数数量的偏特化：</strong>特化部分参数，还存在一部分参数使用通用的模板定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板，有两个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T first;</span><br><span class="line">    U second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板参数数量的偏特化，对第一个模板参数进行特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;<span class="type">int</span>, U&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> first;</span><br><span class="line">    U second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>模板参数范围的偏特化：</strong>对模板的参数范围进行缩小</p><ul><li><strong>const 特化:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic process: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const 特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">const</span> T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> T data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized process for const type: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>指针特化：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic setValue: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span>&lt;T*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized setValue for pointers: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>左值引用特化:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyReference</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic printValue: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左值引用特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyReference</span>&lt;T&amp;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp; ref)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized printValue for lvalue references: &quot;</span> &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>右值引用特化:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRValueReference</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic printValue: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右值引用特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRValueReference</span>&lt;T&amp;&amp;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp;&amp; rvalue)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized printValue for rvalue references: &quot;</span> &lt;&lt; rvalue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>注：函数模板是不能偏特化的，只有类模板可以进行偏特化。函数模板可以不显式指定类型。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;C-泛编程&quot;&gt;&lt;a href=&quot;#C-泛编程&quot; class=&quot;headerlink&quot; title=&quot;C++泛编程&quot;&gt;&lt;/a&gt;C++泛编程&lt;/h3&gt;&lt;h4 id=&quot;1-auto&quot;&gt;&lt;a href=&quot;#1-auto&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++八股4</title>
    <link href="https://wangak.cc/posts/4d7fcbd3.html"/>
    <id>https://wangak.cc/posts/4d7fcbd3.html</id>
    <published>2025-03-19T16:00:00.000Z</published>
    <updated>2025-03-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-malloc、realloc、calloc的区别"><a href="#1-malloc、realloc、calloc的区别" class="headerlink" title="1.malloc、realloc、calloc的区别"></a>1.malloc、realloc、calloc的区别</h4><ul><li><p><strong><code>malloc</code>函数：</strong></p><ul><li><p>用于分配指定大小的内存块，并返回指向该内存块的指针。如果分配失败，则返回 <code>NULL</code>。</p></li><li><p>使用 <code>malloc</code> 分配的内存不会被初始化，其中的数据是随机的。</p></li></ul></li><li><p><strong><code>calloc</code> 函数</strong>：</p><ul><li>原型为 <code>void* calloc(size_t n, size_t size);</code></li><li>第一个参数 <code>n</code> 表示要分配多少个元素；第二个参数 <code>size</code> 表示每个元素的大小（以字节为单位）。</li><li><code>calloc</code> 会将分配的内存初始化为零。</li></ul></li><li><p><strong><code>realloc</code> 函数</strong>：</p><ul><li><p>原型为 <code>void* realloc(void *p, size_t new_size);</code></p></li><li><p><code>realloc</code> 函数用来改变已经分配的内存块的大小。它可以扩大或缩小已有的内存块。如果新的内存大小大于原来的大小，那么新增的部分内容未定义（即可能包含任何值）。如果缩小内存块，超出部分会被丢弃。</p><p><em>注：C++中可以通过使用STL容器来避免使用<code>realloc</code>的情况,可以减少由于手动管理内存而引发错误的可能。</em></p></li></ul></li></ul><h4 id="2-类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？"><a href="#2-类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？" class="headerlink" title="2.类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"></a>2.类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</h4><p><strong>类成员初始化方式：</strong></p><ul><li><strong>赋值初始化</strong>：这是通过在<strong>构造函数体内</strong>对成员变量进行赋值来实现的。</li><li><strong>成员初始化列表</strong>：使用冒号(<code>:</code>)后跟随初始化列表的方式，在构造函数体执行前对成员变量进行初始化。</li></ul><p><strong>构造函数的执行顺序：</strong>（在创建派生类对象时，<strong>基类的构造函数会在派生类的构造函数之前执行</strong>。）</p><ol><li><strong>首先执行虚拟基类的构造函数</strong>（如果有多个虚拟基类，则按照它们被继承的顺序）。</li><li><strong>然后是普通基类的构造函数</strong>（如果有多个普通基类，则按照它们在派生类继承列表中的顺序）。</li><li><strong>接着是派生类中对象成员（包含其他类类型的对象作为其成员变量）的构造函数</strong>（这些成员对象按照它们在类定义中的声明顺序进行初始化，而不是按照初始化列表中的顺序）。</li><li><strong>最后是派生类自己的构造函数</strong>。</li></ol><p><strong>使用成员初始化列表更快的原因：</strong></p><ul><li><strong>C++的赋值操作是会产生临时对象的</strong>：使用赋值初始化时，首先会调用默认构造函数为成员变量分配空间并创建一个临时对象，然后将这个临时对象赋值给成员变量，这会产生额外的开销。</li><li>使用成员初始化列表直接在<strong>成员变量创建时就对其进行初始化</strong>，避免了创建临时对象的过程。</li></ul><h4 id="3-有哪些情况必须用到成员列表初始化？作用是什么？"><a href="#3-有哪些情况必须用到成员列表初始化？作用是什么？" class="headerlink" title="3.有哪些情况必须用到成员列表初始化？作用是什么？"></a>3.有哪些情况必须用到成员列表初始化？作用是什么？</h4><p><strong>成员列表初始化的四种必须使用的情况：</strong></p><ul><li><p><strong>初始化引用成员</strong>：引用成员必须在创建时初始化，且不能重新赋值。因此，必须在成员初始化列表中进行初始化。</p></li><li><p><strong>初始化常量成员</strong>：常量成员（<code>const</code>）一旦初始化后不能修改，因此必须在成员初始化列表中初始化。</p></li><li><p><strong>调用基类的构造函数</strong>：如果<strong>基类没有默认构造函数</strong>，或者需要传递参数给基类构造函数，必须在成员初始化列表中调用基类的构造函数。</p></li><li><p><strong>调用成员类的构造函数</strong>：如果类的成员是另一个类的对象，并且该<strong>成员类没有默认构造函数</strong>，或者需要传递参数，必须在成员初始化列表中调用该成员类的构造函数。</p><p><em>注：在函数体内进行赋值初始化时，成员就已经存在了</em></p></li></ul><p><strong>成员初始化列表的作用：</strong></p><ul><li><strong>初始化顺序</strong>：编译器会按照成员初始化列表中的顺序，在构造函数体内插入初始化操作，且这些操作在任何用户代码之前执行。</li><li><strong>初始化顺序的决定</strong>：初始化列表的顺序并不决定实际的初始化顺序，实际的初始化顺序由类中成员的<strong>声明顺序决定。</strong></li></ul><h4 id="4-C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的？"><a href="#4-C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的？" class="headerlink" title="4.C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？"></a>4.C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？</h4><ul><li><strong>string是对char*进行了封装</strong>，封装的string包含了char*数组，容量，长度等等属性。</li><li><strong>string可以进行动态扩展</strong>，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</li></ul><h4 id="5-什么是内存泄露，如何检测与避免"><a href="#5-什么是内存泄露，如何检测与避免" class="headerlink" title="5.什么是内存泄露，如何检测与避免"></a>5.什么是内存泄露，如何检测与避免</h4><p><strong>内存泄露：</strong>指的是堆内存的泄露，分配的内存块在使用完成后没有正确地释放。</p><p><strong>避免内存的泄露的方式：</strong></p><ul><li><p><strong>计数法：</strong>使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</p></li><li><p><strong>将基类的析构函数声明为虚函数：</strong>这可以保证当通过基类指针删除派生类对象时，派生类的析构函数能够被正确调用，从而避免因未正确调用析构函数导致的内存泄漏。</p><p><em>注：如果基类的析构函数不是<code>virtual</code>，通过基类指针删除派生类对象只会调用基类的析构函数。</em></p></li><li><p><strong>正确释放对象数组</strong>：对于使用 <code>new[]</code> 分配的对象数组，应使用 <code>delete[]</code> 来释放，而不是 <code>delete</code>，以避免内存泄漏。</p></li><li><strong>成对出现原则</strong>：确保每一对 <code>new</code>/<code>delete</code> 和 <code>malloc</code>/<code>free</code> 成对出现，即每次分配内存后都必须有相应的释放操作</li></ul><p><strong>检测工具</strong></p><ul><li>Linux下可以使用<strong>Valgrind工具</strong></li><li>Windows下可以使用<strong>CRT库</strong></li></ul><h4 id="6-对象复用的了解，零拷贝的了解"><a href="#6-对象复用的了解，零拷贝的了解" class="headerlink" title="6.对象复用的了解，零拷贝的了解"></a>6.对象复用的了解，零拷贝的了解</h4><p><strong>对象复用</strong>：在设计模式中通常指的是<strong>Flyweight（享元）模式</strong>。该模式旨在通过共享尽可能多的数据来最小化内存使用，特别是当系统需要创建大量细粒度的对象时。通过<strong>将相似或相同的对象存储在一个“对象池”中，并在需要时重复利用这些对象</strong>，可以有效<strong>减少内存占用和对象创建的开销。</strong></p><ul><li><p><strong>亨元模式：</strong> 由亨元工厂创建新的亨元对象前，先检查“对象池”中是否有相同属性对象，若有可以重复使用这些对象，而不是创建新的对象。</p><p>eg:假设我们正在开发一个<strong>文本编辑器</strong>，其中每个字符都由一个独立的对象表示。如果我们直接为每个字符创建一个新的对象实例，那么对于长文档来说，这将导致大量的内存消耗。Flyweight模式可以帮助我们通过共享相同字符的属性（如字体、颜色等）来优化这一过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Flyweight接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Character</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体Flyweight类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCharacter</span> : <span class="keyword">public</span> Character &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> font_family_;</span><br><span class="line">    <span class="type">int</span> font_size_;</span><br><span class="line">    std::string color_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCharacter</span>(<span class="type">char</span> font_family, <span class="type">int</span> font_size, <span class="type">const</span> std::string&amp; color)</span><br><span class="line">        : <span class="built_in">font_family_</span>(font_family), <span class="built_in">font_size_</span>(font_size), <span class="built_in">color_</span>(color) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character: &quot;</span> &lt;&lt; ch </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, Font Family: &quot;</span> &lt;&lt; font_family_ </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, Font Size: &quot;</span> &lt;&lt; font_size_ </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, Color: &quot;</span> &lt;&lt; color_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flyweight工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CharacterFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, Character*&gt; characters_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">CharacterFactory</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : characters_) &#123;</span><br><span class="line">            <span class="keyword">delete</span> pair.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Character* <span class="title">getCharacter</span><span class="params">(<span class="type">char</span> font_family, <span class="type">int</span> font_size, <span class="type">const</span> std::string&amp; color)</span> </span>&#123;</span><br><span class="line">        std::string key = std::<span class="built_in">string</span>(<span class="number">1</span>, font_family) + std::<span class="built_in">to_string</span>(font_size) + color;</span><br><span class="line">        <span class="keyword">if</span> (characters_.<span class="built_in">find</span>(key) == characters_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            characters_[key] = <span class="keyword">new</span> <span class="built_in">ConcreteCharacter</span>(font_family, font_size, color);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> characters_[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CharacterFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一些字符对象，但共享相同的属性</span></span><br><span class="line">    Character* charA = factory.<span class="built_in">getCharacter</span>(<span class="string">&#x27;T&#x27;</span>, <span class="number">12</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">    Character* charB = factory.<span class="built_in">getCharacter</span>(<span class="string">&#x27;T&#x27;</span>, <span class="number">12</span>, <span class="string">&quot;red&quot;</span>); <span class="comment">// 应该复用charA的实例</span></span><br><span class="line"></span><br><span class="line">    charA-&gt;<span class="built_in">display</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    charB-&gt;<span class="built_in">display</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即使请求了两次相同的属性组合，实际上只会有一个ConcreteCharacter实例被创建</span></span><br><span class="line">    <span class="keyword">if</span> (charA == charB) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;charA and charB are the same instance.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;charA and charB are different instances.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码中分别请求了两个具有相同属性的字符对象，但实际上它们引用的是同一个<code>ConcreteCharacter</code>实例,实现了对象复用的目的。</strong></p></li></ul><p><strong>零拷贝</strong>：一种优化技术，目的是<strong>减少数据从一处存储到另一处传输过程中CPU的参与程度</strong>，从而提高效率并降低资源消耗。传统上，数据传输可能涉及多次复制操作，比如从磁盘读取数据到内核空间，再复制到用户空间等。零拷贝技术减少了这种不必要的数据复制次数，降低了CPU的工作量和总线活动。</p><p><strong>*注：<code>vector</code>的一个成员函数emplace_back()很好地体现了零拷贝技术。</strong><code>emplace_back()</code> 是在容器内部直接构造对象，而不是先创建一个临时对象再进行拷贝或移动。这意味着它可以在不调用拷贝构造函数或移动构造函数的情况下，在容器预留的位置原地构造对象，这通常更高效。*</p><h4 id="7-介绍面向对象的三大特性，并且举例说明"><a href="#7-介绍面向对象的三大特性，并且举例说明" class="headerlink" title="7.介绍面向对象的三大特性，并且举例说明"></a>7.介绍面向对象的三大特性，并且举例说明</h4><ul><li><strong>继承：</strong> 让某种类型对象获得另一个类型对象的属性和方法。<ul><li>实现继承：指使用基类的属性和方法而无需额外编码的能力</li><li>接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力</li></ul></li><li><strong>封装：</strong> <strong>把客观事物封装成抽象的类</strong>，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏</li><li><strong>多态：</strong> 同一事物表现出不同事物的能力<ul><li><strong>实现多态有二种方式：覆盖（override），重载（overload）</strong></li><li>重载实现编译时多态，虚函数实现运行时多态</li></ul></li></ul><h4 id="8-C-的四种强制转换"><a href="#8-C-的四种强制转换" class="headerlink" title="8.C++的四种强制转换"></a>8.C++的四种强制转换</h4><p>C++提供了四种类型的显式类型转换运算符：<code>reinterpret_cast</code>、<code>const_cast</code>、<code>static_cast</code> 和 <code>dynamic_cast</code></p><ul><li><p><strong><code>reinterpret_cast</code></strong>：在不相关的类型之间进行低级别的强制转换。它可以将任何指针类型转换为另一个指针类型，或指针到整数类型的转换等。<strong>转换后的数和原来的数有相同的比特位。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *c = reinterpret_cast&lt;char*&gt;(p); // 将int指针转换为char指针</span><br></pre></td></tr></table></figure><p><em>注：<code>reinterpret_cast</code>没有进行任何的类型检查,因此很容易发生由于指针类型不匹配而引发的内存错误</em></p></li><li><p><strong><code>const_cast</code></strong>：主要用于添加或移除变量的<code>const</code>或<code>volatile</code>属性。它只能改变这些限定符，不能改变对象的实际类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char *p = &quot;hello&quot;;</span><br><span class="line">char *q = const_cast&lt;char*&gt;(p);</span><br></pre></td></tr></table></figure><p><em>注：这里将 `const char</em><code>类型的指针</code>p<code>转换为</code>char<em><code>类型的指针</code>q`。</em></p></li><li><p><strong><code>static_cast</code></strong>：用于类层次结构中的上行转换（派生类到基类）和下行转换（基类到派生类），以及基本数据类型之间的转换。</p><ul><li><p><strong>特点</strong>：<strong>不进行运行时类型检查</strong>，因此在下行转换时可能不安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">65</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(n);<span class="comment">//这里将 int 类型的变量 n 转换为 char 类型的变量 c。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>dynamic_cast</code>:</strong> 主要用于类层次结构中的上行转换和下行转换，特别是用于多态类型的转换。</p><ul><li><p><strong>特点：</strong>在运行时<strong>进行类型检查</strong>，如果转换不安全（如下行转换时基类指针不指向派生类对象），则返回 <code>nullptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Base *b = <span class="keyword">new</span> Son;</span><br><span class="line">Son *s = <span class="built_in">dynamic_cast</span>&lt;Son*&gt;(b);<span class="comment">//这里将 Base* 类型的指针 b 转换为 Son* 类型的指针 s，并在转换失败时返回 nullptr。</span></span><br><span class="line"><span class="keyword">if</span> (s) &#123;</span><br><span class="line">    <span class="comment">// 转换成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 转换失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="9-C-函数调用的压栈过程"><a href="#9-C-函数调用的压栈过程" class="headerlink" title="9.C++函数调用的压栈过程"></a>9.C++函数调用的压栈过程</h4><p><strong>函数调用的压栈过程:</strong></p><ul><li><strong>分配栈空间</strong>：为被调用函数分配栈空间，用于存储函数的局部变量、参数和返回地址等信息。</li><li><strong>参数压栈</strong>：将实参的值复制到形参的栈空间中。C++中，参数是从右到左依次压栈的。</li><li><strong>保存返回地址</strong>：将当前函数的返回地址（即调用函数的下一条指令地址）压入栈中，以便函数执行完毕后能正确返回到调用点。</li><li><strong>保存调用函数的运行状态</strong>：将调用函数的寄存器状态、局部变量等信息压入栈中，以便函数调用结束后恢复。</li><li><strong>执行被调用函数</strong>：跳转到被调用函数的代码并执行。</li><li><strong>函数返回</strong>：函数执行完毕后，从栈中弹出返回地址、恢复调用函数的运行状态，并释放栈空间。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> param1, <span class="type">int</span> param2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var1 = param1;</span><br><span class="line">    <span class="type">int</span> var2 = param2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;var1=%d,var2=%d&quot;</span>, <span class="built_in">f</span>(var1), <span class="built_in">f</span>(var2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">var1=1,var2=2</span><br></pre></td></tr></table></figure><h4 id="10-说说移动构造函数"><a href="#10-说说移动构造函数" class="headerlink" title="==10.说说移动构造函数=="></a>==10.说说移动构造函数==</h4><p><strong>既要实现资源的有效转移，又要避免潜在的双重释放的风险</strong></p><p><strong>移动构造函数：</strong>用“转移”代替“复制”来提高性能</p><p><strong>拷贝构造 vs 移动构造</strong></p><ul><li><strong>拷贝构造函数</strong>：通常涉及到深拷贝，特别是对于包含动态分配资源的对象。例如，如果一个类含有指针成员变量，那么在拷贝构造时需要为新对象分配新的内存，并将原始对象的数据复制过去。这增加了额外的时间和空间开销。</li><li><strong>移动构造函数</strong>：则是采用<strong>浅层复制</strong>的方式，直接<strong>将资源的所有权从一个对象转移到另一个对象</strong>，而不进行实际的数据复制。这样做的前提是确保源对象不再持有这些资源，以防止重复释放同一块内存导致的错误。</li><li><strong>参数类型差异</strong><ul><li><strong>拷贝构造函数</strong>：接受一个<strong>左值引用</strong>作为参数，意味着它可以接受任何有效的已有对象。</li><li><strong>移动构造函数</strong>：接受一个<strong>右值引用</strong>（或称为将亡值引用）作为参数。这意味着它只能用于那些即将销毁或不再使用的对象，比如临时对象或者通过<code>std::move</code>显式转换成右值的对象。</li></ul></li></ul><p><strong>如何实现安全的资源转移？</strong></p><p>​    为了避免因浅层复制导致的双重释放问题，移动构造函数会在获取源对象资源的同时，将源对象中的相应指针置为<code>nullptr</code>（或其他适当值）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 确保other不会在析构时释放data指向的内存</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass</code> 的移动构造函数接收一个右值引用 <code>MyClass&amp;&amp;</code>，并将<code>other</code>对象的数据成员<code>data</code>直接赋值给当前对象的<code>data</code>成员，然后将<code>other.data</code>设置为<code>nullptr</code>。这样做既实现了资源的有效转移，又避免了潜在的双重释放风险。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass a;</span><br><span class="line">MyClass b = std::<span class="built_in">move</span>(a); <span class="comment">// 调用移动构造函数</span></span><br></pre></td></tr></table></figure><p>注：<code>std::move(a)</code>使得<code>a</code>被视为一个右值，从而触发<code>MyClass</code>的移动构造函数。</p><h4 id="11-说一下C-左值引用和右值引用"><a href="#11-说一下C-左值引用和右值引用" class="headerlink" title="11.说一下C++左值引用和右值引用"></a>11.说一下C++左值引用和右值引用</h4><p><strong>左值（lvalue）:</strong></p><ul><li><p>可以获取地址的表达式。</p></li><li><p>通常有名字，可以出现在赋值语句的左边。</p></li><li><p>例如：变量、对象、函数返回的引用等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// a 是左值</span></span><br><span class="line"><span class="type">int</span>&amp; b = a;  <span class="comment">// b 是左值引用</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>右值（rvalue）</strong>：</p><ul><li><p>不能获取地址的表达式。</p></li><li><p>通常是临时的、没有名字的值。</p></li><li><p>例如：常量、临时对象、函数返回值（非引用）、表达式结果等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c = <span class="number">5</span> + <span class="number">10</span>;  <span class="comment">// 5 + 10 是右值</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; d = <span class="number">10</span>;    <span class="comment">// 10 是右值</span></span><br></pre></td></tr></table></figure><ul><li><strong>纯右值（prvalue）</strong>：如字面量、临时对象、表达式结果等。</li><li><strong>将亡值（xvalue）</strong>：与右值引用相关的表达式，通常是通过 <code>std::move</code> 或返回右值引用的函数得到的值。</li></ul></li></ul><p><strong>左值引用</strong>：用 <code>&amp;</code> 声明。</p><p><strong>右值引用</strong>：用 <code>&amp;&amp;</code> 声明。主要用于实现 <strong>移动语义</strong> 和 <strong>完美转发</strong>。</p><p><strong>右值引用的特点:</strong></p><ul><li><p><strong>延长右值的生命周期</strong>：右值引用可以将临时对象（右值）的生命周期延长到与右值引用变量的生命周期一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; d = <span class="number">10</span>;  <span class="comment">// 临时对象 10 的生命周期被延长</span></span><br></pre></td></tr></table></figure></li><li><p><strong>右值引用可能是左值或右值</strong>：右值引用类型的变量本身可能是左值或右值，取决于其初始化方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; e = <span class="number">10</span>;  <span class="comment">// e 是右值引用，但 e 本身是左值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>自动类型推断中的右值引用</strong>：在模板函数中，<code>T&amp;&amp;</code> 可以是左值引用或右值引用，取决于传入的参数类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">fun</span>(a);  <span class="comment">// t 是左值引用</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="number">10</span>); <span class="comment">// t 是右值引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>移动语义</strong>：通过 <code>std::move</code> 将左值强制转换为右值引用，从而避免不必要的拷贝操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2 = std::<span class="built_in">move</span>(v1);  <span class="comment">// v1 的资源被移动到 v2</span></span><br></pre></td></tr></table></figure><p><strong>完美转发</strong>：通过右值引用和 <code>std::forward</code>，将参数按照其原始类型转发给其他函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 完美转发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-C-中将临时变量作为返回值时的处理过程"><a href="#12-C-中将临时变量作为返回值时的处理过程" class="headerlink" title="12.C++中将临时变量作为返回值时的处理过程"></a>12.C++中将临时变量作为返回值时的处理过程</h4><p>在C++中，当函数返回临时变量时，虽然该临时变量会在函数退出时被销毁，但由于<strong>返回值是通过寄存器而非栈或堆内存进行传递的</strong>，因此返回值的正确性和完整性得到了保证。</p><h4 id="13-静态类型和动态类型，静态绑定和动态绑定的介绍"><a href="#13-静态类型和动态类型，静态绑定和动态绑定的介绍" class="headerlink" title="13.静态类型和动态类型，静态绑定和动态绑定的介绍"></a>13.静态类型和动态类型，静态绑定和动态绑定的介绍</h4><p><strong>静态类型与动态类型</strong></p><ul><li><p><strong>静态类型：</strong>对象在声明时采⽤的类型，在编译期既已确定；例如，<code>A* pa</code>的静态类型是<code>A*</code>，无论<code>pa</code>指向的是哪个子类对象。</p></li><li><p><strong>动态类型：</strong>指针或引用实际指向的对象的类型，是在运行期决定的。例如，<code>A* pa = new B();</code>，<code>pa</code>的静态类型是<code>A*</code>，但动态类型是<code>B*</code>。</p></li></ul><p><strong>静态绑定与动态绑定</strong></p><ul><li><strong>静态绑定</strong>：绑定的是静态类型，函数或属性的调用依赖于对象的静态类型，发生在编译期。<strong>非虚函数通常使用静态绑定。</strong></li><li><strong>动态绑定</strong>：绑定的是动态类型，函数或属性的调用依赖于对象的动态类型，发生在运行期。<strong>虚函数使用动态绑定，从而实现多态性。</strong></li></ul><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*virtual*/</span> <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C* pc = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line">    B* pb = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    A* pa = pc;</span><br><span class="line">    pa = pb;</span><br><span class="line"></span><br><span class="line">    pa-&gt;<span class="built_in">func</span>(); <span class="comment">// 如果func不是虚函数，则总是调用A::func()</span></span><br><span class="line">    pc-&gt;<span class="built_in">func</span>(); <span class="comment">// 总是调用C::func()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pc;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注1：如果 <code>A</code> 中的 <code>func</code> 不是虚函数，那么 <code>pa-&gt;func()</code> 将总是调用 <code>A::func()</code>，因为这是基于 <code>pa</code> 的静态类型（即 `A</em>`）进行的静态绑定。*</p><p><em>注2：如果将 <code>func</code> 声明为虚函数（取消注释 <code>virtual</code>），那么 <code>pa-&gt;func()</code> 将根据 <code>pa</code> 所指向的实际对象类型（即动态类型）调用相应的 <code>func</code> 函数，实现动态绑定。</em></p><h4 id="14-引用是否能实现动态绑定，为什么可以实现？"><a href="#14-引用是否能实现动态绑定，为什么可以实现？" class="headerlink" title="14.引用是否能实现动态绑定，为什么可以实现？"></a>14.引用是否能实现动态绑定，为什么可以实现？</h4><p><strong>引用</strong>和<strong>指针</strong>都可以实现动态绑定，但这种动态绑定仅适用于<strong>虚函数</strong>。</p><p><strong>动态绑定的条件</strong></p><ul><li><strong>虚函数</strong>：只有当一个函数被声明为<code>virtual</code>时，才能通过基类的引用或指针调用派生类中的重写版本。这是因为<strong>虚函数支持运行期确定实际调用哪个函数</strong>，这被称为动态绑定或多态性。</li><li><strong>引用必须初始化</strong>：创建引用时必须同时初始化它，这意味着你必须指定引用所绑定的具体对象。一旦初始化完成，引用就不能再指向其他对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base :: fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;son :: fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;son :: not virtual function&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    Base&amp; b = s; <span class="comment">// 基类类型引用绑定到Son对象</span></span><br><span class="line">    s.<span class="built_in">fun</span>();     <span class="comment">// 输出: son::fun()</span></span><br><span class="line">    b.<span class="built_in">fun</span>();     <span class="comment">// 输出: son::fun()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-malloc、realloc、calloc的区别&quot;&gt;&lt;a href=&quot;#1-malloc、realloc、calloc的区别&quot; class=&quot;headerlink&quot; title=&quot;1.malloc、realloc、calloc的区别&quot;&gt;&lt;/a&gt;1.malloc</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++八股3</title>
    <link href="https://wangak.cc/posts/d31b5e70.html"/>
    <id>https://wangak.cc/posts/d31b5e70.html</id>
    <published>2025-03-17T16:00:00.000Z</published>
    <updated>2025-03-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么是大小端存储？"><a href="#1-什么是大小端存储？" class="headerlink" title="1.什么是大小端存储？"></a>1.什么是大小端存储？</h4><p><strong>大端存储：</strong>数据的最高有效字节存放在内存地址的最低位置</p><p><strong>小端存储：</strong>最低有效字节被存放在内存地址的最低位置</p><p><em>注：在网络协议中通常使用大端序</em></p><h4 id="2-volatile、mutable和explicit关键字的用法"><a href="#2-volatile、mutable和explicit关键字的用法" class="headerlink" title="2.volatile、mutable和explicit关键字的用法"></a>2.volatile、mutable和explicit关键字的用法</h4><ul><li><strong>volatile：</strong></li></ul><p><strong><code>volatile</code></strong>关键字用于告诉编译器，该变量的值可能会在程序控制之外被改变（如硬件中断、操作系统、其他线程等）。因此，<strong>编译器不应该对涉及该变量的操作进行优化。</strong></p><p><strong>每次访问<code>volatile</code>变量时，都会从内存重新读取数据，而不是使用寄存器中的缓存副本。（这样可以防止变量被其他线程修改后读到错误的变量值）</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503191910704.png" alt="image-20250318133449499" style="zoom: 50%;"></p><p><em>注：现代编译器为了提高性能，通常会将经常访问的变量值保存在CPU寄存器中，以便快速访问。</em></p><ul><li><strong>mutable：</strong> <code>mutable</code>关键字用于<strong>允许对象的某些成员变量即使在<code>const</code>成员函数内也可以被修改。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> accessCount; <span class="comment">// 可变成员变量，用于记录访问次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a) : <span class="built_in">age</span>(a), <span class="built_in">accessCount</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 成员函数，理论上不应该修改类的数据成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 在 const 函数中修改非 mutable 成员会导致编译错误</span></span><br><span class="line">        <span class="comment">// age = 30; // 错误：不能修改</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改 mutable 成员是允许的</span></span><br><span class="line">        ++accessCount;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This method has been called &quot;</span> &lt;&lt; accessCount &lt;&lt; <span class="string">&quot; times.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> Person <span class="title">person</span><span class="params">(<span class="number">25</span>)</span></span>; <span class="comment">// 创建一个常量对象</span></span><br><span class="line">    person.<span class="built_in">getAge</span>(); <span class="comment">// 第一次调用</span></span><br><span class="line">    person.<span class="built_in">getAge</span>(); <span class="comment">// 第二次调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>explicit: </strong> <code>explicit</code>关键字用于<strong>防止单参数构造函数的隐式类型转换</strong>。只能应用于类内部的<strong>构造函数声明</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Integer</span><span class="params">(<span class="type">int</span> x)</span> : value(x) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 假设我们需要提供获取值的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printInteger</span><span class="params">(<span class="type">const</span> Integer&amp; i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印 Integer 对象的内容</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The integer value is: &quot;</span> &lt;&lt; i.<span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面这一行会导致编译错误，因为不允许隐式转换</span></span><br><span class="line">    <span class="comment">// printInteger(10);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确的做法是显式地构造 Integer 对象</span></span><br><span class="line">    <span class="built_in">printInteger</span>(<span class="built_in">Integer</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-什么情况下会调用拷贝构造函数"><a href="#3-什么情况下会调用拷贝构造函数" class="headerlink" title="3.什么情况下会调用拷贝构造函数"></a>3.什么情况下会调用拷贝构造函数</h4><ul><li><p><strong>对象初始化：</strong> 用类的一个<strong>实例化对象去初始化另一个对象</strong>的时候</p></li><li><p><strong>按值传递参数</strong>： 当一个函数的参数是类的对象且通过值传递（非引用传递），在函数调用时<strong>会创建一个参数的副本</strong>，此时会调用拷贝构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useClassA</span><span class="params">(A a)</span> </span>&#123;&#125;  <span class="comment">// 函数定义</span></span><br><span class="line"><span class="built_in">useClassA</span>(a1);          <span class="comment">// 调用时会调用拷贝构造函数</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-C-中有几种类型的new"><a href="#4-C-中有几种类型的new" class="headerlink" title="4.C++中有几种类型的new"></a>4.C++中有几种类型的new</h4><ul><li><strong>Plain New</strong></li></ul><p>​    <code>Plain new</code>指的是标准的、普通的<code>new</code>操作符，用于动态分配内存。它不仅负责分配所需的内存空间，还会调用对象的构造函数（如果是对象的话）。</p><p>​    <strong>异常处理</strong>: 在C++中，当使用<code>plain new</code>进行内存分配且分配失败时（例如，系统无法提供请求的内存大小），它会抛出一个<code>std::bad_alloc</code>异常，而不是返回<code>NULL</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试分配一个极大的内存空间，可能会失败</span></span><br><span class="line">        <span class="type">char</span> *p = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10e11</span>];  <span class="comment">// 这里尝试分配大约100GB的空间，很可能导致std::bad_alloc异常被抛出</span></span><br><span class="line">        <span class="keyword">delete</span>[] p;  <span class="comment">// 如果分配成功，则释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc &amp;ex) &#123;  <span class="comment">// 捕捉std::bad_alloc异常</span></span><br><span class="line">        cout &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">// 输出异常信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>nothrow new</strong></p><p><code>nothrow new</code>在空间分配失败的情况下是不抛出异常，而是返回NULL</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="number">10e11</span>];</span><br><span class="line"> <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;alloc failed&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">delete</span> p;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//运⾏结果：alloc failed</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Placement New</strong></p></li></ul><p>​    <code>placement new</code>允许在⼀块已经分配成功的内存上新构造对象或对象数组。<code>placement new</code>不用担心内存分配失败，因为它根本不分配内存，它做的唯⼀⼀件事情就是调⽤对象的构造函数。</p><p>​    <strong>用途</strong>: 主要用于<strong>优化性能和控制内存管理</strong>，例如<strong>在一个循环中反复创建和销毁对象时，可以避免频繁的内存分配和释放操作</strong>，从而提高效率。</p><p>​    <em>注1：<strong>显式调用析构函数</strong>：由于 <code>placement new</code> 只负责调用对象的构造函数，并不负责释放内存，因此当你不再需要对象时，必须手动调用对象的析构函数来清理资源。</em></p><p>​    <em>注2：<strong>不要使用 <code>delete</code></strong>：不能对通过 <code>placement new</code> 创建的对象直接使用 <code>delete</code>，因为这可能导致内存泄漏或其他运行时错误。应该首先显式调用对象的析构函数，然后根据情况决定是否释放底层内存。（因为 <code>delete</code> 预期的是由 <code>new</code> 返回的一个指针，它只知道如何释放这块特定类型的内存。）</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ADT</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ADT</span>() : <span class="built_in">i</span>(<span class="number">10</span>), <span class="built_in">j</span>(<span class="number">100</span>) &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ADT construct i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j=&quot;</span> &lt;&lt; j &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ADT</span>() &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ADT destruct&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="built_in">sizeof</span>(ADT)]; <span class="comment">// 动态分配足够大的内存来容纳一个ADT对象</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123; <span class="comment">// 注意：这里应该是检查 p 是否为 nullptr 而不是 NULL</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;alloc failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ADT *q = <span class="built_in">new</span>(p) ADT; <span class="comment">// 使用 placement new 在 p 所指向的内存上构造 ADT 对象</span></span><br><span class="line">    <span class="comment">// 不可以直接 delete q;</span></span><br><span class="line">    q-&gt;~<span class="built_in">ADT</span>(); <span class="comment">// 显式调用 ADT 的析构函数</span></span><br><span class="line">    <span class="keyword">delete</span>[] p; <span class="comment">// 最后释放最初分配的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-C-的异常处理的方法"><a href="#5-C-的异常处理的方法" class="headerlink" title="5.C++的异常处理的方法"></a>5.C++的异常处理的方法</h4><ul><li><p><strong>try、throw和catch关键字</strong></p><ul><li><p><strong>try</strong>:  <code>try</code>块用于包裹可能抛出异常的代码段。当<code>try</code>块中的任何代码抛出了一个异常，程序会立即寻找与之匹配的<code>catch</code>块进行处理。</p></li><li><p><strong>throw</strong>: 当程序检测到一个无法处理的错误时，可以使用<code>throw</code>语句抛出一个异常。这个异常可以是任意类型的数据（例如整数、浮点数、字符串或者自定义类对象），它包含了关于错误的信息。</p></li><li><p><strong>catch</strong>: <code>catch</code>块用于捕获由<code>throw</code>语句抛出的异常。每个<code>catch</code>后面都跟着一个参数列表，指定了它可以处理的异常类型。一旦某个异常被抛出，程序会查找最近的匹配<code>catch</code>块，并将控制权转移到该块。如果找不到匹配的<code>catch</code>块，程序将终止运行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> m = <span class="number">1</span>, n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">-1</span>; <span class="comment">// 抛出int型异常</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">-1.0</span>; <span class="comment">// 抛出 double 型异常</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; m / n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">double</span> d) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;catch (double)&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通用的catch(...)块</span></span><br><span class="line"><span class="built_in">catch</span> (...) &#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;catch (...)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;finished&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>函数的异常声明列表:</strong> 在定义函数的时候知道函数可能发⽣的异常，可以在函数声明和定义时，指出所能抛出异常的列表.</p><p><code>int fun() throw(int,double,A,B,C)&#123;...&#125;;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义三个可能被抛出的异常类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionA</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionB</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionC</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数fun声明和定义时指定了它可能抛出的异常类型：int, double, ExceptionA, ExceptionB, ExceptionC</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>, ExceptionA, ExceptionB, ExceptionC)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> condition = <span class="number">3</span>; <span class="comment">// 假设根据某种条件决定抛出何种异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (condition == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">1</span>; <span class="comment">// 抛出int型异常</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">2.0</span>; <span class="comment">// 抛出double型异常</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ExceptionA</span>(); <span class="comment">// 抛出自定义异常ExceptionA</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ExceptionB</span>(); <span class="comment">// 抛出自定义异常ExceptionB</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ExceptionC</span>(); <span class="comment">// 抛出自定义异常ExceptionC</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">fun</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an int exception: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">double</span> e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught a double exception: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (ExceptionA&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an ExceptionA&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (ExceptionB&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an ExceptionB&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (ExceptionC&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an ExceptionC&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; <span class="comment">// 捕获所有其他未列出的异常</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an unspecified exception&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>C++标准异常类exception</strong></p><p>C++ 标准库中有⼀些类代表异常，这些类都是从 exception 类派⽣⽽来的</p><ul><li><p><code>std::bad_typeid:</code> 当使用<code>typeid</code>运算符对一个多态类的指针进行操作时，如果该指针的值为<code>NULL</code>（即指向空），则会抛出<code>std::bad_typeid</code>异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">typeid</span>(*ptr).<span class="built_in">name</span>() &lt;&lt; std::endl; <span class="comment">// 这里会抛出 std::bad_typeid 异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_typeid&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_typeid: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>std::bad_cast:</code> 当使用<code>dynamic_cast</code>进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的（例如，基类指针实际上并不指向正确的派生类对象），则会抛出<code>std::bad_cast</code>异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="keyword">public</span>: <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Derived&amp; derivedRef = <span class="built_in">dynamic_cast</span>&lt;Derived&amp;&gt;(*basePtr); <span class="comment">// 这里会抛出 std::bad_cast 异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_cast&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_cast: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>std::bad_alloc</code>: 当使用<code>new</code>运算符进行动态内存分配时，如果没有足够的内存，则会引发<code>std::bad_alloc</code>异常。</p></li><li><p><code>std::out_of_range</code>: 当你使用<code>vector</code>或<code>string</code>的<code>at()</code>成员函数根据下标访问元素时，如果提供的下标越界了，则会抛出<code>std::out_of_range</code>异常。</p></li></ul></li></ul><h4 id="6-形参与实参的区别？"><a href="#6-形参与实参的区别？" class="headerlink" title="6.形参与实参的区别？"></a>6.形参与实参的区别？</h4><ul><li><strong>形参变量的作用范围</strong>：形参是在定义函数时声明的变量，它们只有在函数被调用时才会分配内存单元，并且<strong>仅在函数内部有效。</strong></li><li><strong>实参的类型与值确定性</strong>：这就要求在调用函数之前，确保所有实参都有明确的值。</li><li><strong>实参与形参的一致性</strong>：实参和形参的数量、类型以及顺序需要严格匹配。</li><li><strong>非指针类型的形参与实参的独立性</strong>：如果形参和实参都不是指针类型，那么在函数执行期间，形参会创建实参的一个副本，即形参获得的是实参值的一份拷贝。这样，在函数内部对形参所做的任何改变都不会影响到外部的实参。当函数执行完毕后，形参占用的内存被释放，而实参保持不变。</li></ul><h4 id="7-值传递、指针传递、引用传递的区别和效率"><a href="#7-值传递、指针传递、引用传递的区别和效率" class="headerlink" title="7.值传递、指针传递、引用传递的区别和效率"></a>7.值传递、指针传递、引用传递的区别和效率</h4><ul><li><strong>值传递：</strong>将实际参数的值<strong>复制</strong>一份传递给函数的形式参数。函数内部对形参的修改不会影响到实参。如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。<strong>实参和形参在不同的内存位置，它们占用不同的存储空间。</strong>形参是实参的一个副本，当<strong>函数调用结束后，形参占用的内存空间会被释放。</strong></li><li><strong>指针传递：</strong>函数参数为指针类型。通过传递变量的地址，<strong>函数内部可以通过这个地址访问和修改原始变量的值。</strong>（<strong>传值</strong>，传递的是固定为<strong>4字节的地址值</strong>）</li><li><strong>引用传递：</strong>在函数调用时，将实际参数的引用（别名）传递给函数的形式参数。对形参的操作<strong>实际上就是对实参的操作</strong>。（<strong>传地址</strong>）</li></ul><p><strong>效率上，指针传递和引用传递比值传递效率高。</strong></p><p>注：<strong>需要返回多个值时可以使用指针作为参数</strong>：当一个函数需要返回多个值时，可以使用指针作为参数来允许函数修改传入的变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor, <span class="type">int</span>* quotient, <span class="type">int</span>* remainder)</span> </span>&#123;</span><br><span class="line">    *quotient = dividend / divisor;</span><br><span class="line">    *remainder = dividend % divisor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-局部变量什么时候初始化"><a href="#8-局部变量什么时候初始化" class="headerlink" title="8.局部变量什么时候初始化"></a>8.局部变量什么时候初始化</h4><ul><li><p><strong>普通局部变量：</strong></p><ul><li><strong>初始化时机</strong>：普通局部变量在每次进入其作用域时被创建，并且可以在声明时或者之后进行初始化。<strong>初始化不是自动的</strong>，需要显式地给它们赋值。</li></ul></li><li><p><strong>静态局部变量：</strong></p><ul><li><strong>初始化时机</strong>：在<strong>首次用到时初始化</strong>，可使用变量初始化，这是因为初始化要执行构造函数</li><li><strong>析构顺序</strong>：当程序结束时，静态局部变量会按照它们构造的逆序进行析构。此外，C++通过<code>atexit()</code>函数来管理这些对象的析构顺序，确保它们能以正确的顺序被销毁。</li></ul></li><li><p><strong>全局静态变量：</strong></p><ul><li><strong>初始化时机</strong>：全局静态变量和静态局部变量类似，在程序开始执行前就已初始化。然而，在不同编译单元中的全局静态对象的初始化顺序是不确定的，这可能导致依赖于特定初始化顺序的问题。</li><li><strong>解决方法</strong>：一种常用的解决方案是使用单例模式中的静态局部变量。由于静态局部变量具有“延迟初始化”的特点，即只有在首次使用时才会初始化，因此可以用来控制初始化顺序，避免跨编译单元初始化顺序导致的问题。</li></ul></li></ul><h4 id="9-深拷贝与浅拷贝"><a href="#9-深拷贝与浅拷贝" class="headerlink" title="9.深拷贝与浅拷贝"></a>9.<strong>深拷贝与浅拷贝</strong></h4><ul><li><strong>浅拷贝：</strong>浅拷贝是指简单地将原对象的<strong>基本数据类型</strong>的值<strong>复制</strong>给新对象，并且对于<strong>引用类型的数据</strong>（如指针），只是<strong>复制了指向实际数据的引用</strong>（即<strong>内存地址</strong>），并<strong>没有为引用类型的数据开辟新的内存空间。</strong></li><li><strong>深拷贝：</strong>深拷贝不仅复制了基本数据类型的值，而且对于引用类型的成员变量，还<strong>会在堆上为其指向的数据分配新的内存空间</strong>，并将这些数据复制到新的内存位置，从而使得<strong>新对象拥有自己的独立数据副本</strong>。</li></ul><h4 id="10-new、delete-p、delete-p、allocator都有什么作用？"><a href="#10-new、delete-p、delete-p、allocator都有什么作用？" class="headerlink" title="10.new、delete p、delete [] p、allocator都有什么作用？"></a>10.new、delete p、delete [] p、allocator都有什么作用？</h4><ul><li><p><strong><code>new[]</code>创建动态数组</strong>：当使用<code>new</code>分配一个数组时，方括号<code>[]</code>内的值必须是整数类型，它<strong>可以是变量</strong>（即运行时确定的值），而不必是常量表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 合法，size可以是变量</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>new</code>返回元素类型的指针:</strong> 当使用<code>new[]</code>来动态创建数组时，<strong>返回的是指向数组第一个元素的指针</strong>，而不是一个数组类型的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arrayPtr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// arrayPtr 是一个 int 类型的指针</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>delete[]</code>销毁顺序:</strong> 使用<code>delete[]</code>删除通过<code>new[]</code>分配的数组时，数组中的对象会按照它们被构造的逆序进行析构。因为C++保证了对象的析构顺序与它们的构造顺序相反，以确保资源正确释放。</p></li><li><p><strong><code>new/delete</code> vs <code>allocator</code></strong></p><ul><li><p><strong><code>new/delete</code>局限性</strong>：将构造函数/析构函数与内存管理绑定在一起不够灵活</p></li><li><p><strong><code>std::allocator</code>（分配器）的作用</strong>：<code>std::allocator</code>是C++标准库提供的一个工具，用于分离内存分配和对象构造的过程。它允许程序员先申请一块未初始化的内存，然后根据需要手动构造对象。这种方式提供了更大的灵活性，比如延迟对象的初始化时间或者复用已分配的内存块，从而可能提高性能或减少内存碎片。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::allocator&lt;<span class="type">int</span>&gt; alloc; <span class="comment">// 创建一个 allocator 对象</span></span><br><span class="line"><span class="type">int</span>* p = alloc.<span class="built_in">allocate</span>(<span class="number">10</span>); <span class="comment">// 分配内存但不初始化</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(p, <span class="number">100</span>); <span class="comment">// 初始化某个位置的对象</span></span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p, <span class="number">10</span>); <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="11-new和delete的实现原理，-delete是如何知道释放内存的大小的额？"><a href="#11-new和delete的实现原理，-delete是如何知道释放内存的大小的额？" class="headerlink" title="11.new和delete的实现原理， delete是如何知道释放内存的大小的额？"></a>11.new和delete的实现原理， delete是如何知道释放内存的大小的额？</h4><p>对于数组，<code>new[]</code>会额外存储数组的大小，<code>delete[]</code>会根据这个大小正确地调用析构函数并释放内存。</p><h4 id="12-malloc与free的实现原理？"><a href="#12-malloc与free的实现原理？" class="headerlink" title="12.malloc与free的实现原理？"></a>12.malloc与free的实现原理？</h4><p><code>alloc</code> 和 <code>free</code> 的底层实现依赖于操作系统提供的系统调用，主要包括：</p><ul><li><code>brk</code>：通过调整堆的边界来分配内存。</li><li><code>mmap</code>：在进程的虚拟地址空间中映射一块内存区域。</li><li><code>munmap</code>：释放由 <code>mmap</code> 分配的内存。</li></ul><p><strong>内存分配的两种方式:</strong></p><ul><li><p><strong><code>brk</code> 系统调用(小于 128KB)</strong>：调整堆的边界（即数据段的最高地址指针 <code>_edata</code>）来分配内存； <strong>分配的内存是连续的，释放时需要从高地址向低地址依次释放。</strong></p><ul><li><code>brk</code> 将 <code>_edata</code> 指针向高地址方向移动，扩展堆的大小。</li><li>分配的内存是虚拟内存，物理内存并未立即分配。</li><li>当程序首次访问这块内存时，操作系统会触发缺页中断，分配物理内存并建立虚拟内存与物理内存的映射关系。</li></ul></li><li><p><strong><code>mmap</code> 系统调用(大于 128KB)</strong>：<code>mmap</code> 在进程的虚拟地址空间中（<strong>堆和栈之间的文件映射区域</strong>）找一块空闲的虚拟内存。； <strong>分配的内存可以单独释放，灵活性更高。</strong></p><ul><li><code>mmap</code> 在文件映射区域中分配一块虚拟内存。</li><li>同样，物理内存并未立即分配，而是在首次访问时通过缺页中断分配。</li></ul></li><li><p><strong>内存紧缩（trim）</strong>：</p><ul><li>当 <code>free</code> 释放内存后，如果堆顶的空闲内存超过一定阈值（默认 128KB，可通过 <code>M_TRIM_THRESHOLD</code> 调节），操作系统会执行内存紧缩操作（trim）。</li><li>内存紧缩会将空闲的内存归还给操作系统，减少进程的内存占用。</li></ul></li></ul><p><strong><code>malloc</code> 的具体实现机制：</strong></p><ul><li><p><strong>空闲内存链表</strong>：</p><ul><li>操作系统中维护一个记录空闲内存地址的链表。</li><li>当程序<strong>调用 <code>malloc</code></strong> 时，操作系统会<strong>遍历这个链表</strong>，寻找第一个大小满足需求的空闲内存块。</li><li>如果找到合适的内存块，则将其从空闲链表中删除，并分配给程序。</li><li>如果<strong>没有找到合适的内存块，则会通过 <code>brk</code> 或 <code>mmap</code> 系统调用</strong>向操作系统申请更多的内存。</li></ul></li><li><p><strong>内存分配算法</strong>：</p><ul><li><code>malloc</code> 通常使用一些内存分配算法（如首次适应、最佳适应或伙伴系统）来管理空闲内存链表，以提高内存分配的效率。</li></ul></li></ul><p><strong><code>free</code> 的具体实现机制：</strong></p><ul><li><strong>释放内存</strong>：<ul><li>当程序调用 <code>free</code> 时，操作系统会将释放的内存块重新加入到空闲内存链表中。</li><li>如果释放的内存是通过 <strong><code>brk</code> 分配的</strong>，且位于堆的顶部，则<strong>可能会触发内存紧缩操作，将空闲内存归还给操作系统。</strong></li><li>如果释放的内存是通过 <code>mmap</code> 分配的，则直接调用 <strong><code>munmap</code> 系统调用</strong>将内存归还给操作系统。</li></ul></li></ul><h4 id="13-内联函数和普通函数的区别"><a href="#13-内联函数和普通函数的区别" class="headerlink" title="13.内联函数和普通函数的区别"></a>13.内联函数和普通函数的区别</h4><ul><li><p><strong>执行效率</strong>：内联函数效率高</p><ul><li><strong>内联函数</strong>：当一个函数被声明为内联函数时，编译器会在每次调用该函数的地方将其代码展开，而不是进行常规的函数调用（如保存当前环境、跳转到函数入口地址执行等）。这样做可以<strong>减少函数调用带来的开销</strong>，特别是对于简单的、短小的函数来说，能提高程序运行效率。</li><li><strong>普通函数</strong>：普通函数调用涉及到栈帧的创建与销毁、参数传递、返回值处理等一系列操作，这些都会带来一定的性能开销。</li></ul></li><li><p><strong>代码大小</strong>：内联函数会增大代码量</p><ul><li><strong>内联函数</strong>：由于内联函数是将函数体直接插入到调用点，如果一个内联函数在一个程序中被多次调用，那么这个函数的代码就会被复制多份，这可能导致生成的可执行文件变大。</li><li><strong>普通函数</strong>：普通函数只有一份副本，无论它被调用多少次，都不会增加代码量。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-什么是大小端存储？&quot;&gt;&lt;a href=&quot;#1-什么是大小端存储？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是大小端存储？&quot;&gt;&lt;/a&gt;1.什么是大小端存储？&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;大端存储：&lt;/strong&gt;数据的最高有效字节存放在</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++八股2</title>
    <link href="https://wangak.cc/posts/a41c6ee6.html"/>
    <id>https://wangak.cc/posts/a41c6ee6.html</id>
    <published>2025-03-15T16:00:00.000Z</published>
    <updated>2025-03-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-八股2"><a href="#C-八股2" class="headerlink" title="C++八股2"></a>C++八股2</h2><h4 id="1-C-中const和static的作用"><a href="#1-C-中const和static的作用" class="headerlink" title="1.C++中const和static的作用"></a>1.C++中const和static的作用</h4><p><strong>static：</strong></p><ul><li><p><strong>不考虑类的情况</strong></p><ul><li><p><strong>隐藏</strong>：当使用<code>static</code>修饰全局变量或函数时，它们将仅在定义它们的文件内可见（即具有内部链接性），而没有<code>static</code>修饰的全局变量和函数则可以在其他文件中通过声明来引用。</p><p><strong><em>注：当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</em></strong></p></li><li><p><strong>默认初始化为0</strong>：无论是未初始化的全局静态变量还是局部静态变量，默认情况下都会被初始化为0，并且这些变量都存储在全局未初始化区。</p></li><li><p><strong>持久存在与记忆性</strong>：如果在函数内部定义了静态变量，那么这个变量在整个程序运行期间一直存在，只会被初始化一次，并且即使函数退出后仍然存在，但它的作用域是局部的。</p></li></ul></li><li><p><strong>考虑类的情况</strong></p><ul><li><strong>static成员变量</strong>：必须在类外部进行初始化</li><li><strong>static成员函数</strong>：没有<code>this</code>指针，不能访问类的非静态成员变量或调用非静态成员函数。</li></ul></li></ul><p><strong>const:</strong></p><ul><li><strong>不考虑类的情况:</strong><ul><li><strong>不可变性</strong>：一旦定义了一个<code>const</code>常量，就必须同时对其进行初始化，之后其值不能再被修改。</li><li><strong>参数传递：</strong>用const修饰传入参数，则函数保证传入参数不发生改变</li></ul></li><li><strong>考虑类的情况</strong><ul><li><strong>const成员变量</strong>：必须通过构造函数的初始化列表进行初始化，不能在类定义之外进行初始化。</li><li><strong>const成员函数</strong>：这种函数承诺不会修改对象的数据成员（除非数据成员被声明为<code>mutable</code>），<code>const</code>成员函数不可以调用非<code>const</code>成员函数；<code>const</code>对象只能调用<code>const</code>成员函数，而非<code>const</code>对象既可以调用<code>const</code>也可以调用非<code>const</code>成员函数。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非const成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modifyValue</span><span class="params">(<span class="type">int</span> newVal)</span> </span>&#123;</span><br><span class="line">        value = newVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不能修改任何非mutable数据成员</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> MyClass <span class="title">constObj</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 创建一个const对象</span></span><br><span class="line">    <span class="function">MyClass <span class="title">nonConstObj</span><span class="params">(<span class="number">20</span>)</span></span>;    <span class="comment">// 创建一个非const对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行会导致编译错误，因为尝试在一个const对象上调用非const成员函数</span></span><br><span class="line">    <span class="comment">// constObj.modifyValue(30);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在一个const对象上调用const成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;constObj value: &quot;</span> &lt;&lt; constObj.<span class="built_in">getValue</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在非const对象上调用const成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;nonConstObj value: &quot;</span> &lt;&lt; nonConstObj.<span class="built_in">getValue</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以在非const对象上调用非const成员函数</span></span><br><span class="line">    nonConstObj.<span class="built_in">modifyValue</span>(<span class="number">40</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After modification, nonConstObj value: &quot;</span> &lt;&lt; nonConstObj.<span class="built_in">getValue</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-C-的顶层const和底层const"><a href="#2-C-的顶层const和底层const" class="headerlink" title="2.C++的顶层const和底层const"></a>2.C++的顶层const和底层const</h4><p><strong>顶层const（*在左边）</strong>：表示被修饰的对象本身是一个常量，不能通过这个对象改变它的值。（指针指向不可变）</p><p><strong>底层const（*在右边）</strong>：指针所指向的对象是不可变的。（指针指向的对象是常量）</p><p><em>注：标准的<code>const int</code>是顶层; const用于声明引用变量是底层</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> b1 = &amp;a;        <span class="comment">// 顶层const，b1本身是一个常量，即b1必须始终指向a</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* b2 = &amp;a;        <span class="comment">// 底层const，b2本身可变，但b2指向的对象（即*a）是常量，不可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b3 = <span class="number">20</span>;         <span class="comment">// 顶层const，b3是常量不可变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> b4 = &amp;a;  <span class="comment">// 前一个const为底层，后一个为顶层，b4不可变且*b4也不可变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; b5 = a;         <span class="comment">// 用于声明引用变量，都是底层const，a的值可通过非const引用改变，但b5无法修改a</span></span><br></pre></td></tr></table></figure><p>注：具有底层<code>const</code>的指针或引用不能直接赋值给没有<code>const</code>限定的指针或引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demonstrateConstRestrictions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向普通int类型的指针（无底层const）</span></span><br><span class="line">    <span class="type">int</span>* nonConstPtr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向const int类型的指针（有底层const）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* constPtr = &amp;b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行会导致编译错误：</span></span><br><span class="line">    <span class="comment">// error: invalid conversion from &#x27;const int*&#x27; to &#x27;int*&#x27;</span></span><br><span class="line">    <span class="comment">// nonConstPtr = constPtr;  // 错误：试图将底层const转换为非const</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确的做法是使用const_cast，但要小心使用，确保原始数据确实是可修改的</span></span><br><span class="line">    <span class="comment">// 在这个特定情况下，由于&#x27;b&#x27;是一个const int，这样做实际上是不安全的</span></span><br><span class="line">    <span class="comment">// nonConstPtr = const_cast&lt;int*&gt;(constPtr);  // 不建议这么做</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是，从非const到const的转换总是安全的</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* safePtr = &amp;a;  <span class="comment">// 安全：增加const限定不会有问题</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value via safePtr: &quot;</span> &lt;&lt; *safePtr &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">demonstrateConstRestrictions</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-数组名和指针（这里为指向数组首元素的指针）区别"><a href="#3-数组名和指针（这里为指向数组首元素的指针）区别" class="headerlink" title="3.数组名和指针（这里为指向数组首元素的指针）区别"></a>3.数组名和指针（这里为指向数组首元素的指针）区别</h4><ul><li><p>数组名不是真正意义上的指针，可以理解为常指针，所以<strong>数组名没有自增、自减等操作。</strong></p></li><li><p>当数组名当<strong>做形参</strong>传递给调用函数后，就失去了原有特性，<strong>退化成一般指针，多了自增、自减操作</strong>，但sizeof运算符不能再得到原数组的大小了。</p></li></ul><h4 id="4-final和override关键字"><a href="#4-final和override关键字" class="headerlink" title="4.final和override关键字"></a>4.final和override关键字</h4><p><strong>override:</strong> </p><p>​    指定了子类的这个虚函数是重写的父类的,如果函数名输错，编译器会报错</p><p><strong>final：</strong></p><p>​    当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;    </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">           <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// foo 被override并且是最后一个override，在其子类中不可以重写&#125;;</span></span><br></pre></td></tr></table></figure><h4 id="5-拷贝初始化和直接初始化"><a href="#5-拷贝初始化和直接初始化" class="headerlink" title="5.拷贝初始化和直接初始化"></a>5.拷贝初始化和直接初始化</h4><ul><li><p><strong>直接初始化</strong>：直接调用与实参匹配的构造函数来初始化对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;I am a string&quot;</span>)</span></span>; <span class="comment">// 语句1：直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(str1)</span></span>;            <span class="comment">// 语句2：直接初始化，使用另一个对象进行初始化</span></span><br></pre></td></tr></table></figure></li><li><p><strong>拷贝初始化</strong>：首先<strong>创建一个临时对象</strong>，然后使用拷贝构造函数将这个临时对象的内容拷贝到正在创建的对象中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str3 = <span class="string">&quot;I am a string&quot;</span>; <span class="comment">// 语句3：拷贝初始化</span></span><br><span class="line">string str4 = str1;            <span class="comment">// 语句4：拷贝初始化</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="6-野指针和悬空指针"><a href="#6-野指针和悬空指针" class="headerlink" title="6.野指针和悬空指针"></a>6.野指针和悬空指针</h4><p><strong>野指针：</strong></p><p>​    没有被初始化过的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;         </span><br><span class="line"><span class="type">int</span>* p;     <span class="comment">// 未初始化    </span></span><br><span class="line">std::cout&lt;&lt; *p &lt;&lt; std::endl; <span class="comment">// 未初始化就被使用,可能会报错        </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：确保指针在声明时就被初始化。如果暂时没有有效的内存地址可以赋值给指针，应该将其设置为<code>nullptr</code>。这样，如果尝试解引用一个<code>nullptr</code>，大多数现代编译器会在运行时抛出异常或给出错误提示，从而帮助开发者快速定位问题。</p><p><strong>悬空指针:</strong></p><p>​    最初指向的内存已经被释放了的一种指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;   </span><br><span class="line"><span class="type">int</span> * p = <span class="literal">nullptr</span>;  </span><br><span class="line"><span class="type">int</span>* p2 = <span class="keyword">new</span> <span class="type">int</span>;   </span><br><span class="line"> p = p2;  <span class="keyword">delete</span> p2;</span><br><span class="line">&#125; <span class="comment">// 此时p和p2都变成了悬空指针</span></span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：</p><ul><li>在释放指针所指向的内存之后，立即将指针设置为<code>nullptr</code>。</li><li>C++引入了智能指针（如<code>std::unique_ptr</code>和<code>std::shared_ptr</code>），它们能够自动管理内存的分配和释放，从而有效避免悬空指针的产生。</li></ul><h4 id="7-C-中的重载、重写（覆盖）和隐藏的区别"><a href="#7-C-中的重载、重写（覆盖）和隐藏的区别" class="headerlink" title="7.C++中的重载、重写（覆盖）和隐藏的区别"></a>7.C++中的重载、重写（覆盖）和隐藏的区别</h4><p><strong>重载： </strong>重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，<strong>不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。</strong></p><p><strong>重写（override）：</strong>在派生类中覆盖基类中的同名函数，<strong>重写就是重写函数体</strong>，<strong>要求基类函数必须是虚函数</strong>且：</p><ul><li>与基类的虚函数有相同的参数个数</li><li>与基类的虚函数有相同的参数类型</li><li>与基类的虚函数有相同的返回值类型</li></ul><p><strong>隐藏（hide）:</strong> 派生类中的函数屏蔽了基类中的同名函数</p><p><strong>隐藏和重写的区别：</strong>  重写可以体现多态性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base: &quot;</span> &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; endl; &#125; <span class="comment">// 重写了基类中的foo(int x)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl; &#125; <span class="comment">// 隐藏了基类中的foo(int x, int y)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *pb = <span class="keyword">new</span> Derived;</span><br><span class="line">    pb-&gt;<span class="built_in">foo</span>(<span class="number">1</span>);     <span class="comment">// 调用的是Derived::foo(int x)，因为Base::foo(int x)是虚函数且被重写</span></span><br><span class="line">    pb-&gt;<span class="built_in">foo</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 调用的是Base::foo(int x, int y)，因为Derived::foo(int x, int y)隐藏了基类的同名函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503162026007.png" alt="image-20250316202637727" style="zoom:67%;"></p><h4 id="8-C-有哪几种的构造函数"><a href="#8-C-有哪几种的构造函数" class="headerlink" title="8.C++有哪几种的构造函数"></a>8.C++有哪几种的构造函数</h4><ul><li><p><strong>默认构造函数:</strong> 不带任何参数的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="comment">// 默认构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj; <span class="comment">// 调用默认构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化构造函数:</strong> 接受一个或多个参数以初始化对象的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123; <span class="comment">// 初始化构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameterized Constructor with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 调用有参数的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>拷贝构造函数:</strong>  使用<strong>同一类型的另一个对象</strong>来初始化新创建的对象时调用的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass &amp;other) : <span class="built_in">value</span>(other.value) &#123; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy Constructor, value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    MyClass obj2 = obj1; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>移动构造函数（Move和右值引用）：</strong>用于实现资源转移而非复制，避免不必要的深拷贝操作。它通常与右值引用一起使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123; <span class="comment">// 移动构造函数</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">//确保原对象不再拥有对资源的所有权,防止悬空指针</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> size) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[size]) &#123;&#125; <span class="comment">// 简化的构造函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    MyClass obj2 = std::<span class="built_in">move</span>(obj1); <span class="comment">// 调用移动构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>委托构造函数： </strong>允许在一个构造函数内部调用同一个类的其他构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">MyClass</span>(<span class="number">0</span>) &#123; &#125; <span class="comment">// 委托构造函数，委托给下面的构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123; <span class="comment">// 初始化构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameterized Constructor with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj; <span class="comment">// 调用默认构造函数，但实际通过委托构造函数间接调用了有参数的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>转换构造函数:</strong> 允许编译器隐式地将一种类型的值转换为类的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Temperature</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> celsius;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换构造函数：从 double 到 Temperature 的转换</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Temperature</span><span class="params">(<span class="type">double</span> c)</span> : celsius(c) &#123;</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Conversion Constructor, Celsius: &quot;</span> &lt;&lt; celsius &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示当前温度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Temperature is &quot;</span> &lt;&lt; celsius &lt;&lt; <span class="string">&quot; degrees Celsius.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，接受一个 Temperature 对象并显示其值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayTemperature</span><span class="params">(<span class="type">const</span> Temperature&amp; temp)</span> </span>&#123;</span><br><span class="line">    temp.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用显式构造函数调用创建对象</span></span><br><span class="line">    <span class="function">Temperature <span class="title">t1</span><span class="params">(<span class="number">36.5</span>)</span></span>; <span class="comment">// 正确：显式调用转换构造函数</span></span><br><span class="line">    t1.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行会导致编译错误，因为构造函数被声明为 explicit</span></span><br><span class="line">    <span class="comment">// Temperature t2 = 40.0; // 错误：不允许隐式转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过辅助函数传递 double 值，但需要显式转换</span></span><br><span class="line">    <span class="built_in">displayTemperature</span>(<span class="built_in">Temperature</span>(<span class="number">25.0</span>)); <span class="comment">// 正确：显式创建临时对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果去掉 explicit 关键字，则下面的语句也会合法</span></span><br><span class="line">    <span class="comment">// Temperature t3 = 37.0; // 如果构造函数不是 explicit，则这是合法的隐式转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-浅拷贝和深拷贝的区别"><a href="#9-浅拷贝和深拷贝的区别" class="headerlink" title="9.浅拷贝和深拷贝的区别"></a>9.浅拷贝和深拷贝的区别</h4><p><strong>浅拷贝共享数据：</strong> 浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p><p><strong>深拷贝各自拥有独立的数据副本：</strong> 开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。</p><p><em>注：浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源</em></p><h4 id="10-内联函数和宏定义的区别"><a href="#10-内联函数和宏定义的区别" class="headerlink" title="10.内联函数和宏定义的区别"></a>10.内联函数和宏定义的区别</h4><ul><li><strong>处理时机</strong>：宏定义是在预处理阶段进行简单的文本替换； 内联函数则是在编译时进行处理，并且可以进行参数类型检查。这使得内联函数更加安全和可靠。</li><li><strong>类型检查与返回值</strong>：由于宏只是简单的字符串替换，它无法进行任何类型检查，也无法直接拥有返回值的概念。内联函数支持参数类型检查，确保传入参数的类型正确，并能够像普通函数一样有明确的返回值。</li></ul><p><strong>内联函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 定义一个内联函数来计算两个整数的和</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 使用内联函数计算两数之和</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">add</span>(num1, num2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>宏：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 定义一个宏来计算两个整数的和</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(a, b) ((a) + (b))</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 使用宏计算两数之和</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">ADD</span>(num1, num2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title=" "></a> </h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-八股2&quot;&gt;&lt;a href=&quot;#C-八股2&quot; class=&quot;headerlink&quot; title=&quot;C++八股2&quot;&gt;&lt;/a&gt;C++八股2&lt;/h2&gt;&lt;h4 id=&quot;1-C-中const和static的作用&quot;&gt;&lt;a href=&quot;#1-C-中const和static的作</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>Protobuf</title>
    <link href="https://wangak.cc/posts/608ca7e8.html"/>
    <id>https://wangak.cc/posts/608ca7e8.html</id>
    <published>2025-03-12T16:00:00.000Z</published>
    <updated>2025-03-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><h4 id="Protobuf序列化的步骤"><a href="#Protobuf序列化的步骤" class="headerlink" title="Protobuf序列化的步骤"></a>Protobuf序列化的步骤</h4><p><strong>protobuf中的数据类型 和 C++ 数据类型对照:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503131059638.png" alt="image-20250313100438695" style="zoom:67%;"></p><p><strong>使用protobuf进行序列化的步骤：</strong></p><ul><li><strong>定义.proto文件：</strong> <code>.proto</code>文件来描述要序列化的数据结构</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明所使用的protobuf版本号</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> id = <span class="number">2</span>;</span><br><span class="line">  <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：等号后面的编号要<strong>从1开始</strong>，每个成员都有一个<strong>唯一的编号</strong>，不能重复，一般连续编号即可。</em></p><ul><li><strong>编译.proto文件：</strong>使用<code>protoc</code>编译器将<code>user_info.proto</code>文件编译成C++代码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I path &lt;user_info.proto&gt; --cpp_out=输出路径(存储生成的c++文件)</span><br></pre></td></tr></table></figure><p><em>注1：<code>-I</code>: 参数后面可以跟随一个或多个路径，用于告诉编译器在哪些路径下查找导入的文件或依赖的文件,如<code>protoc -I path1 -I path2</code> 或 <code>protoc -I path1:path2</code></em></p><p><em>注2：这会在输出路径下生成<code>user_info.pb.h</code>和<code>user_info.pb.cc</code>两个文件。</em></p><ul><li><strong>在C++项目中集成：</strong></li></ul><p>在项目的源文件中包含生成的头文件：<code>#include &quot;user_info.pb.h&quot;</code></p><ul><li><p><strong>序列化和反序列化:</strong></p><ul><li><p><strong>序列化：</strong>创建一个<code>UserInfo</code>对象并设置其字段值，然后调用<code>SerializeToArray</code>或<code>SerializeToString</code>方法将其序列化为字节流。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UserInfo user;</span><br><span class="line">user.<span class="built_in">set_id</span>(<span class="number">1</span>);</span><br><span class="line">user.<span class="built_in">set_name</span>(<span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">user.<span class="built_in">set_email</span>(<span class="string">&quot;johndoe@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">std::string data;</span><br><span class="line"><span class="comment">//接受一个std::string类型的引用作为输出参数</span></span><br><span class="line">user.<span class="built_in">SerializeToString</span>(&amp;data);</span><br></pre></td></tr></table></figure></li><li><p><strong>反序列化</strong>：创建一个<code>UserInfo</code>对象，并通过调用<code>ParseFromArray</code>或<code>ParseFromString</code>方法从字节流中恢复数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UserInfo user;</span><br><span class="line"><span class="keyword">if</span> (user.<span class="built_in">ParseFromString</span>(data)) &#123;</span><br><span class="line">    <span class="comment">// 成功解析后，可以访问user的字段了</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; user.<span class="built_in">id</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; user.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Email: &quot;</span> &lt;&lt; user.<span class="built_in">email</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 解析失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="repeated-限定修饰符"><a href="#repeated-限定修饰符" class="headerlink" title="repeated 限定修饰符"></a>repeated 限定修饰符</h4><p><strong><code>repeated</code>：</strong> 用于定义可重复字段的关键字，与数组或列表概念相似。</p><p>eg:</p><ul><li><strong>定义 .proto 文件：</strong></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">string</span> title = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">string</span> authors = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int32</span> year_published = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用生成的类：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;book.pb.h&quot;</span> <span class="comment">// 假设生成的文件名为book.pb.h</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddBookInfo</span><span class="params">(Book &amp;book)</span> </span>&#123;</span><br><span class="line">    book.<span class="built_in">set_title</span>(<span class="string">&quot;Example Book Title&quot;</span>);</span><br><span class="line">    book.<span class="built_in">add_authors</span>(<span class="string">&quot;Author One&quot;</span>);</span><br><span class="line">    book.<span class="built_in">add_authors</span>(<span class="string">&quot;Author Two&quot;</span>);</span><br><span class="line">    book.<span class="built_in">set_year_published</span>(<span class="number">2025</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Book book;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加书籍信息</span></span><br><span class="line">    <span class="built_in">AddBookInfo</span>(book);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问并打印书籍信息</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Title: &quot;</span> &lt;&lt; book.<span class="built_in">title</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Year Published: &quot;</span> &lt;&lt; book.<span class="built_in">year_published</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Authors:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; book.<span class="built_in">authors_size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; book.<span class="built_in">authors</span>(i) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p><strong>c++中的枚举类型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    Red = <span class="number">5</span>,<span class="comment">// 可以不给初始值, 默认为0</span></span><br><span class="line">    Green,</span><br><span class="line">    Yellow,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <strong>.proto 文件中：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    Red = <span class="number">0</span>;</span><br><span class="line">    Green = <span class="number">3</span>;<span class="comment">// 第一个元素以外的元素值可以随意指定</span></span><br><span class="line">    Yellow = <span class="number">6</span>;</span><br><span class="line">    Blue = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：第一个元素的元素值必须为0，元素之间使用<code>;</code></em></p><h4 id="Protobuf中包的概念"><a href="#Protobuf中包的概念" class="headerlink" title="Protobuf中包的概念"></a>Protobuf中包的概念</h4><p>Protobuf使用包的概念避免消息类型之间的命名冲突</p><p>eg:</p><p><strong>定义 .proto 文件:</strong></p><ul><li><p><strong>user_info.proto:</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> user.profile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">2</span>;</span><br><span class="line">    <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>order_info.proto:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package order.details;</span><br><span class="line"></span><br><span class="line">message OrderInfo &#123;</span><br><span class="line">    string product_name = 1;</span><br><span class="line">    int32 order_id = 2;</span><br><span class="line">    string customer_email = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>在C++中使用:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user_info.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;order_info.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用user.profile.UserInfo(需要指定命名空间)</span></span><br><span class="line">    user::profile::UserInfo user;</span><br><span class="line">    user.<span class="built_in">set_name</span>(<span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">    user.<span class="built_in">set_id</span>(<span class="number">1234</span>);</span><br><span class="line">    user.<span class="built_in">set_email</span>(<span class="string">&quot;johndoe@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;User Info:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; user.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; user.<span class="built_in">id</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Email: &quot;</span> &lt;&lt; user.<span class="built_in">email</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用order.details.OrderInfo</span></span><br><span class="line">    order::details::OrderInfo order;</span><br><span class="line">    order.<span class="built_in">set_product_name</span>(<span class="string">&quot;Example Product&quot;</span>);</span><br><span class="line">    order.<span class="built_in">set_order_id</span>(<span class="number">5678</span>);</span><br><span class="line">    order.<span class="built_in">set_customer_email</span>(<span class="string">&quot;customer@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nOrder Info:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Product Name: &quot;</span> &lt;&lt; order.<span class="built_in">product_name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Order ID: &quot;</span> &lt;&lt; order.<span class="built_in">order_id</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Customer Email: &quot;</span> &lt;&lt; order.<span class="built_in">customer_email</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Protobuf&quot;&gt;&lt;a href=&quot;#Protobuf&quot; class=&quot;headerlink&quot; title=&quot;Protobuf&quot;&gt;&lt;/a&gt;Protobuf&lt;/h3&gt;&lt;h4 id=&quot;Protobuf序列化的步骤&quot;&gt;&lt;a href=&quot;#Protobuf序列化的步骤&quot;</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="Protobuf" scheme="https://wangak.cc/tags/Protobuf/"/>
    
  </entry>
  
  <entry>
    <title>CMake</title>
    <link href="https://wangak.cc/posts/42cbd3c8.html"/>
    <id>https://wangak.cc/posts/42cbd3c8.html</id>
    <published>2025-03-12T16:00:00.000Z</published>
    <updated>2025-03-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h3><h4 id="CMake编译过程"><a href="#CMake编译过程" class="headerlink" title="CMake编译过程"></a>CMake编译过程</h4><ul><li>创建CMakeLists.txt文件：<code>touch CMakeLists.txt</code></li><li>使⽤cmake，生成makefile文件</li><li>使⽤make命令编译，生成了可执行程序</li></ul><p><strong>PROJECT</strong></p><p><code>PROJECT:</code>来指定工程的名称</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span> (HELLO)</span><br></pre></td></tr></table></figure><p><strong>add_executable</strong>：定义工程会生成一个可执行程序</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(可执行程序名 源文件名称)</span><br></pre></td></tr></table></figure><h4 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h4><ul><li><p><strong>显示地指定变量</strong></p><p><code>SET(SRC_LIST main.cpp)</code> SRC_LIST变量就包含了main.cpp</p><p>多个cpp文件：<code>SET(SRC_LIST main.cpp t1.cpp t2.cpp)</code></p></li><li><p><strong>在 CMakeLists.txt 中通过 set 命令指定所使用的C++标准：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加-std=c++11</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment">#增加-std=c++14</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="comment">#增加-std=c++17</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>指定输出的路径：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(HOME /home/robin/Linux/Sort)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>/bin)</span><br></pre></td></tr></table></figure><p><em>注：<code>EXECUTABLE_OUTPUT_PATH</code>是可执行程序输出的路径对应的宏，如果这个路径中的子目录不存在，会自动生成，无需自己手动创建</em></p></li></ul><h4 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h4><ul><li><p><strong><code>aux_source_directory</code> 命令可以查找某个路径下的所有源文件</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 搜索 src 目录下的源文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src SRC_LIST)</span><br><span class="line"><span class="keyword">add_executable</span>(app  <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure></li></ul><p>​    <em>注1：<code>PROJECT_SOURCE_DIR</code>是执行<code>cmake</code>命令时指定的路径； <code>CMAKE_CURRENT_SOURCE_DIR</code>是当前的CMakeLists.txt所对应的路径</em></p><p>​    <em>注2：<code>PROJECT_SOURCE_DIR</code>和<code>CMAKE_CURRENT_SOURCE_DIR</code>存储的值是一样的</em></p><ul><li><p><strong><code>file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</code></strong></p><ul><li><p><code>GLOB</code>: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。</p></li><li><p><code>GLOB_RECURSE</code>：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>include_directories</code>: 用于指定头文件的路径</strong></p></li></ul><h4 id="制作动态库和静态库"><a href="#制作动态库和静态库" class="headerlink" title="制作动态库和静态库"></a>制作动态库和静态库</h4><ul><li><strong>制作静态库：<code>add_library(&lt;库名称&gt; STATIC &lt;源文件&gt;)</code></strong></li></ul><p>​    <em>注1：在Linux中，静态库名分为三部分：<code>lib+库名称+.a</code></em></p><ul><li><p><strong>制作动态库：<code>add_library(&lt;库名称&gt; SHARE &lt;源文件&gt;)</code></strong></p></li><li><p><strong>使用<code>LIBRARY_OUTPUT_PATH</code>指定生成的库文件的路径</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="comment"># 设置动态库/静态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment">#add_library(calc SHARED $&#123;SRC_LIST&#125;)</span></span><br><span class="line"><span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>链接静态库：</strong><code>link_libraries(&lt;库名称&gt;...)</code></p><p><em>注：如果静态库是自定义的，要使用<code>link_directories(&lt;lib path&gt;)</code>来指定库路径</em></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="comment"># 搜索指定目录下源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="comment"># 包含头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 包含静态库路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line"><span class="keyword">link_libraries</span>(calc)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>链接动态库：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">    &lt;需要链接动态库的文件&gt; </span><br><span class="line">    &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;库名称&gt;... </span><br><span class="line">    [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;库名称&gt;...]...)</span><br></pre></td></tr></table></figure><p>注：默认权限为<code>PUBLIC</code>,<code>PUBLIC</code>具有传递性； <code>INTERFACE</code>只会导出符号</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 添加并指定最终生成的可执行程序名</span></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 指定可执行程序要链接的动态库名字</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread)</span><br></pre></td></tr></table></figure></li></ul><h4 id="日志信息"><a href="#日志信息" class="headerlink" title="日志信息"></a>日志信息</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] <span class="string">&quot;message to display&quot;</span> ...)</span><br></pre></td></tr></table></figure><ul><li>(无) ：重要消息</li><li><code>STATUS</code>：非重要消息</li><li><code>WARNING</code>：CMake 警告, 会继续执行</li><li><code>AUTHOR_WARNING</code>：CMake 警告 (dev), 会继续执行</li><li><code>SEND_ERROR</code>：CMake 错误, 继续执行，但是会跳过生成的步骤</li><li><code>FATAL_ERROR</code>：CMake 错误, 终止所有处理过程</li></ul><h4 id="变量的操作"><a href="#变量的操作" class="headerlink" title="变量的操作"></a>变量的操作</h4><ul><li><p><strong>字符串拼接：</strong></p><ul><li><p><code>set(变量名1 $&#123;变量名1&#125; $&#123;变量名2&#125; ...)</code></p></li><li><p><code>list(APPEND &lt;list&gt; [&lt;element&gt; ...])</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">set</span>(TEMP <span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src1/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_2 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src2/*.cpp)</span><br><span class="line"><span class="comment"># 追加(拼接)</span></span><br><span class="line"><span class="keyword">list</span>(APPEND SRC_1 <span class="variable">$&#123;SRC_1&#125;</span> <span class="variable">$&#123;SRC_2&#125;</span> <span class="variable">$&#123;TEMP&#125;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>字符串移除:</strong></p><p><code>list(REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...])</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 移除 main.cpp</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/main.cpp)</span><br></pre></td></tr></table></figure></li></ul><h4 id="定义宏"><a href="#定义宏" class="headerlink" title="定义宏"></a>定义宏</h4><p><code>add_definitions(-D宏名称)</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="comment"># 自定义 DEBUG 宏</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-DDEBUG)</span><br><span class="line"><span class="keyword">add_executable</span>(app ./<span class="keyword">test</span>.c)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#define NUMBER  3</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">#ifdef DEBUG</span></span><br><span class="line">    printf(<span class="string">&quot;我是一个程序猿, 我不会爬树...\n&quot;</span>);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    for(int i=<span class="number">0</span>; i&lt;NUMBER; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;hello, GCC!!!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌套的CMake"><a href="#嵌套的CMake" class="headerlink" title="嵌套的CMake"></a>嵌套的CMake</h4><p><strong>建立父子节点之间的关系：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(source_dir)</span><br></pre></td></tr></table></figure><p><code>source_dir:</code> 子节点所在的目录</p><p><em>注：子节点可以使用根节点定义的变量，而根节点不可以使用子节点的变量</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CMake&quot;&gt;&lt;a href=&quot;#CMake&quot; class=&quot;headerlink&quot; title=&quot;CMake&quot;&gt;&lt;/a&gt;CMake&lt;/h3&gt;&lt;h4 id=&quot;CMake编译过程&quot;&gt;&lt;a href=&quot;#CMake编译过程&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="CMake" scheme="https://wangak.cc/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>Shell基础</title>
    <link href="https://wangak.cc/posts/4544560.html"/>
    <id>https://wangak.cc/posts/4544560.html</id>
    <published>2025-03-11T07:52:05.000Z</published>
    <updated>2025-03-11T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shell基础"><a href="#Shell基础" class="headerlink" title="Shell基础"></a>Shell基础</h2><p>shell是一个命令行解释器，用于接收用户（应用程序）命令来调用系统内核。</p><ul><li><p><strong>脚本格式：</strong>以<strong><code>#!/bin/bash</code></strong>开头（指定解析器）</p></li><li><p><strong>执行方式：</strong></p><ul><li><p><strong><code>1.bash/sh + 绝对路径（相对路径）</code></strong></p></li><li><p><strong><code>2.绝对路径（相对路径）</code></strong></p><p>需要可执行(x)权限</p></li><li><p><strong><code>3.source + 绝对路径（相对路径）</code>:</strong> 在当前的shell下执行</p></li></ul></li></ul><p><strong>子shell：</strong>在子shell中设置的当前的环境变量，对于父shell不可见</p><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h3><h4 id="1-1-常用系统变量"><a href="#1-1-常用系统变量" class="headerlink" title="1.1 常用系统变量"></a>1.1 常用系统变量</h4><p><strong>常用系统变量：</strong>$HOME、$PWD、$USR、$SHELL、$PATH</p><p><code>env</code>: 列出当前 shell 的所有环境变量</p><p><code>set</code>: 显示所有 shell 变量（包括环境变量和局部变量）</p><p><code>printenv+环境变量名</code>: 输出某个环境变量的值</p><p><code>$PATH</code>: 保存了搜索系统命令的路径(<code>/usr/bin</code>)</p><h4 id="1-2-自定义变量"><a href="#1-2-自定义变量" class="headerlink" title="1.2 自定义变量"></a>1.2 自定义变量</h4><p><strong>自定义变量（局部变量）：</strong><code>变量名=变量值</code><strong>(等号前后不能有空格)</strong></p><p><strong>局部变量导出为全局变量：</strong><code>export + 变量名</code></p><p><em>注：在子shell中修改全局变量对父shell不可见</em></p><p><strong>只读变量：</strong><code>readonly 变量名=变量值</code></p><p><strong>撤销变量：</strong><code>unset + 变量名</code></p><p><em>注1：在bash中，变量默认的类型都是字符串类型，无法直接进行数值计算。</em></p><p><em>注2：只读变量不能unset。</em></p><h4 id="1-3-特殊变量"><a href="#1-3-特殊变量" class="headerlink" title="1.3 特殊变量"></a>1.3 特殊变量</h4><ul><li><code>$n</code>: n为数字，<code>$0</code>代表脚本名称，<code>$1</code>-<code>$9</code>代表第一到第九个参数，十个以上使用<code>&#123;&#125;</code>，如<code>$&#123;10&#125;</code>。</li><li><code>$#</code>: 获取所有输入参数的个数，常用于循环，判断参数的个数是否正确。</li><li><code>$*</code>: 获取命令行中的所有参数，并将其看成一个整体</li><li><p><code>$@</code>: 获取命令行中的所有参数，将其看作一个集合</p></li><li><p><code>$?</code>: 获取上一个命令的返回状态，返回0表示正常结束</p></li></ul><h3 id="2-运算"><a href="#2-运算" class="headerlink" title="2.运算"></a>2.运算</h3><h4 id="2-1-运算符"><a href="#2-1-运算符" class="headerlink" title="2.1 运算符"></a>2.1 运算符</h4><p><strong>语法格式：<code>$((运算式))</code>或<code>$[运算式]</code></strong></p><p><em>注：(( ))中可用使用数学表达式进行运算</em></p><p><strong>使用expr:</strong> <code>a=$(expr 5 \* 2)</code></p><h4 id="2-2-条件判断"><a href="#2-2-条件判断" class="headerlink" title="2.2 条件判断"></a>2.2 条件判断</h4><ul><li><p><strong><code>test +判断条件</code> :</strong> <code>test $a = 2</code></p></li><li><p><strong><code>[ 判断条件 ]</code></strong>: “[ ]”前后要有空格</p></li></ul><p><strong>判断条件：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503112004717.png" alt="image-20250311151642241" style="zoom:67%;"></p><p>​                                                      <img src="https://typoraimg.wangak.cc/2023/img/202503112004656.png" alt="image-20250311151752312" style="zoom:67%;"></p><p>​                                                  <img src="https://typoraimg.wangak.cc/2023/img/202503112004116.png" alt="image-20250311152111395" style="zoom:67%;"></p><p>​                                              <img src="https://typoraimg.wangak.cc/2023/img/202503112004470.png" alt="image-20250311152834726" style="zoom:67%;"></p><p><strong>eg:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断<span class="built_in">test</span>文件是否有读的权限</span></span><br><span class="line">[ -r test ]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断8是否小于2</span></span><br><span class="line">[ 8 -lt 2 ]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断目录是否存在</span></span><br><span class="line">[ -d /home/ubuntu/scripts ] </span><br></pre></td></tr></table></figure><p><strong>“[ ]”中的逻辑条件连接使用：<code>-a</code>(and)和<code>-o</code>(or)</strong></p><h4 id="2-3-流程控制"><a href="#2-3-流程控制" class="headerlink" title="2.3 流程控制"></a>2.3 流程控制</h4><p><strong>if判断</strong></p><ul><li><p><strong>单分支：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断 ];then</span><br><span class="line">程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p><strong>双分支:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断 ];then</span><br><span class="line">程序1</span><br><span class="line">else</span><br><span class="line">程序2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p><strong>多分支：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断1 ]</span><br><span class="line">then</span><br><span class="line">程序1</span><br><span class="line">elif [ 条件判断2 ]</span><br><span class="line">then</span><br><span class="line">程序2</span><br><span class="line">else</span><br><span class="line">程序3</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li></ul><p><strong>for循环</strong></p><p><strong>用法一：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sum=0</span><br><span class="line">for (( i=1 ;i &lt;= $1; i++))</span><br><span class="line">do</span><br><span class="line">        sum=$[ $sum + $i ]</span><br><span class="line">done</span><br><span class="line">echo sum=$sum</span><br></pre></td></tr></table></figure><p><strong>用法二：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3...</span><br><span class="line">do </span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sum=0</span><br><span class="line">for i in &#123;1..100&#125;</span><br><span class="line">do</span><br><span class="line">        sum=$[$sum + $i]</span><br><span class="line">done</span><br><span class="line">echo sum=$sum</span><br></pre></td></tr></table></figure><p><strong>while循环</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [条件判断式]</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="2-4-Read读取控制台的输入"><a href="#2-4-Read读取控制台的输入" class="headerlink" title="2.4 Read读取控制台的输入"></a>2.4 Read读取控制台的输入</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202503112004690.png" alt="image-20250311163511274" style="zoom:67%;"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置超时时间为 5 秒</span></span><br><span class="line">read -t 5 -p &quot;请在 5 秒内输入您的名字: &quot; name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查用户是否输入</span></span><br><span class="line">if [ -z &quot;$name&quot; ]; then</span><br><span class="line">    echo &quot;您未在规定时间内输入名字。&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;您好, $name! 欢迎使用本脚本。&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="2-5-函数"><a href="#2-5-函数" class="headerlink" title="2.5 函数"></a>2.5 函数</h4><p><strong>系统函数</strong></p><p><code>data +%s</code>: 输出时间戳</p><p><code>basename 路径 [后缀]</code>: 用于从文件路径中提取文件名或目录名，去除路径前缀和后缀</p><p><code>dirname 路径</code>: 用于从文件路径中提取目录部分，即去掉文件名，返回路径的父目录。</p><p><strong>自定义函数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名() &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">function add() &#123;</span><br><span class="line">    s=$[$1 + $2]</span><br><span class="line">    echo $s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;输入第一个数&quot; a</span><br><span class="line">read -p &quot;输入第二个数&quot; b</span><br><span class="line">sum=$(add $a $b)</span><br><span class="line">echo &quot;和:&quot;$sum</span><br></pre></td></tr></table></figure><p><em>注：不使用<code>$?</code>接受返回值，<code>$?</code>接收的范围为[0~255]</em></p><h4 id="2-6-正则表达式"><a href="#2-6-正则表达式" class="headerlink" title="2.6 正则表达式"></a>2.6 正则表达式</h4><ul><li><p><strong>常规匹配:</strong> 匹配常规字符”xxxx”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | grep xxxx</span><br></pre></td></tr></table></figure></li><li><p><strong>模糊匹配：</strong></p><ul><li><p><code>^</code>: 匹配一行的开头</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匹配所有以a开头的行</span></span><br><span class="line">cat /etc/passwd |grep ^a</span><br></pre></td></tr></table></figure></li><li><p><code>$</code>: 匹配一行的结束</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匹配所有以a结束的行</span></span><br><span class="line">cat /etc/passwd |grep a$</span><br></pre></td></tr></table></figure></li><li><p><code>.</code>: 匹配任意的字符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匹配所有r..t的行</span></span><br><span class="line">cat /etc/passwd |grep r..t</span><br></pre></td></tr></table></figure></li><li><p><code>*</code>: 不单独使用，与上一个字符连用，表示匹配上个字符的<strong>0次</strong>或多次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匹配rt,rot,root,rooot等所有行</span></span><br><span class="line">cat /etc/passwd |grep ro*t</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匹配以a开头，bash结尾,中间为任意字符的所有行</span></span><br><span class="line">cat /etc/passwd |grep ^a.*bash$</span><br></pre></td></tr></table></figure><ul><li><code>[ ]</code>: 匹配某个范围内的字符</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202503112004742.png" alt="image-20250311195601295" style="zoom:67%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Shell基础&quot;&gt;&lt;a href=&quot;#Shell基础&quot; class=&quot;headerlink&quot; title=&quot;Shell基础&quot;&gt;&lt;/a&gt;Shell基础&lt;/h2&gt;&lt;p&gt;shell是一个命令行解释器，用于接收用户（应用程序）命令来调用系统内核。&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="shell" scheme="https://wangak.cc/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>C++八股1</title>
    <link href="https://wangak.cc/posts/c2c0fb72.html"/>
    <id>https://wangak.cc/posts/c2c0fb72.html</id>
    <published>2025-03-10T16:00:00.000Z</published>
    <updated>2025-03-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-八股"><a href="#C-八股" class="headerlink" title="C++八股"></a>C++八股</h2><h4 id="1-在main执行之前和之后执行的代码可能是什么"><a href="#1-在main执行之前和之后执行的代码可能是什么" class="headerlink" title="1.在main执行之前和之后执行的代码可能是什么"></a><strong>1.在main执行之前和之后执行的代码可能是什么</strong></h4><ul><li><p>main函数执行之前，主要就是<strong>初始化系统相关资源</strong>：</p><ul><li>设置栈指针</li><li>初始化静态static变量和global全局变量</li><li>调用构造函数</li></ul></li><li><p>main函数执行之后：</p><ul><li>全局对象的析构函数</li></ul></li></ul><h4 id="2-指针和引用的区别"><a href="#2-指针和引用的区别" class="headerlink" title="2.指针和引用的区别"></a><strong>2.指针和引用的区别</strong></h4><ul><li><p><strong>指针是一个变量</strong>，存储的是一个地址，<strong>引用是原变量的别名</strong></p></li><li><p>指针可以为空，引用不能为NULL且在定义时必须初始化</p></li></ul><h4 id="3-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"><a href="#3-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？" class="headerlink" title="3.在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"></a><strong>3.在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</strong></h4><ul><li><strong>需要返回函数内局部变量的内存的时候用指针。</strong>指针作为函数参数，需要在堆上动态分配内存，在函数外部仍然可以访问这块内存。完要记得释放指针，不然会内存泄漏。</li><li>对栈空间大小比较敏感（比如递归）的时候使用引用。<strong>使用引用传递不需要创建临时变量，开销要更小</strong></li><li><strong>类对象作为参数传递的时候使用引用</strong>，这是C++类对象传递的标准方式</li></ul><h4 id="4-堆和栈的区别"><a href="#4-堆和栈的区别" class="headerlink" title="4.堆和栈的区别"></a><strong>4.堆和栈的区别</strong></h4><ul><li><p>申请<strong>方式</strong>不同。</p><ul><li>栈由系统自动分配。</li><li>堆是自己申请和释放的。</li></ul></li><li><p>申请<strong>大小限制</strong>不同。</p><ul><li><p>栈顶和栈底是之前预设好的，栈是向栈底扩展（从高地址向低地址扩展），大小固定</p><p>注：栈空间耗尽（例如递归调用过深），会导致 <strong>栈溢出</strong></p></li><li><p>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</p></li></ul></li><li><p>申请<strong>效率</strong>不同。</p><ul><li>栈由系统分配，<strong>速度快</strong>，不会有碎片。</li><li>堆由程序员分配，速度慢，且会有碎片。</li></ul></li></ul><h4 id="5-new-delete-与-malloc-free的异同"><a href="#5-new-delete-与-malloc-free的异同" class="headerlink" title="5.new / delete 与 malloc / free的异同"></a>5.new / delete 与 malloc / free的异同</h4><p><strong>相同点：</strong></p><ul><li>都可用于内存的动态申请和释放</li></ul><p><strong>不同点：</strong></p><ul><li>前者是C++运算符，后者是C/C++语言标准库函数。</li><li><code>new</code><strong>自动</strong>计算要分配的空间大小，<code>malloc</code>需要<strong>手工</strong>计算。</li><li><code>new</code> 在分配内存后会调用对象的构造函数初始化对象，在使用 <code>delete</code> 时则会先调用对象的析构函数再释放内存。后者均没有相关调用。</li><li><p><strong>new是类型安全的，malloc不是。</strong></p></li><li><p><code>new</code>是封装了<code>malloc</code>，直接<code>free</code>不会报错，但是这只是释放内存，而不会析构对象</p></li><li><p><strong>malloc和free返回的是void类型指针(void*)（必须进行类型转换）</strong>，new和delete返回的是具体类型指针。</p><p><em>注：虽然 <code>new</code> 和 <code>malloc</code> 都能用于内存的动态分配，但由于C++中面向对象特性的引入，<code>new</code> 提供了更高级、更安全的内存管理机制，包括自动计算内存大小、类型安全性和自动调用构造函数与析构函数等特性。</em></p></li></ul><p><code>new/delete</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个整型对象</span></span><br><span class="line"><span class="type">int</span>* pInt = <span class="keyword">new</span> <span class="type">int</span>; </span><br><span class="line">*pInt = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放该对象</span></span><br><span class="line"><span class="keyword">delete</span> pInt;</span><br></pre></td></tr></table></figure><p><code>malloc/free</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配空间用于存储一个整型值，并将其初始化为10</span></span><br><span class="line"><span class="type">int</span>* pInt = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*pInt = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放该对象</span></span><br><span class="line"><span class="built_in">free</span>(pInt);</span><br></pre></td></tr></table></figure><h4 id="6-new和delete是如何实现的？"><a href="#6-new和delete是如何实现的？" class="headerlink" title="6.new和delete是如何实现的？"></a>6.new和delete是如何实现的？</h4><p><strong>new：</strong></p><ul><li><strong>分配内存：</strong>调用名为<strong>operator new</strong>的标准库函数</li><li><strong>初始化构造对象：</strong>调用构造函数</li><li><strong>返回指针：</strong>返回指向新分配并构造后的的对象的指针</li></ul><p><strong>delete：</strong></p><ul><li><strong>调用析构函数</strong></li><li><strong>释放所用内存：</strong>调用名为<strong>operator delete</strong>的标准库函数释放所用内存</li></ul><h4 id="7-被free回收的内存是立即返还给操作系统吗？"><a href="#7-被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="7.被free回收的内存是立即返还给操作系统吗？"></a>7.被free回收的内存是立即返还给操作系统吗？</h4><p>​    不是的，被free回收的内存会首先被ptmalloc使用<strong>双链表保存</strong>起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就<strong>避免了频繁的系统调用</strong>，占用过多的系统资源。同时ptmalloc也会尝试对小块<strong>内存进行合并</strong>，<strong>避免过多的内存碎片。</strong></p><h4 id="8-宏定义和函数有何区别？"><a href="#8-宏定义和函数有何区别？" class="headerlink" title="8.宏定义和函数有何区别？"></a>8.宏定义和函数有何区别？</h4><ul><li><strong>宏在编译时完成替换</strong>，<strong>执行起来更快</strong>；函数调用在运行时需要跳转到具体调用函数。</li><li>宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。 </li><li>宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。</li></ul><h4 id="9-宏定义和typedef区别？"><a href="#9-宏定义和typedef区别？" class="headerlink" title="9.宏定义和typedef区别？"></a>9.宏定义和typedef区别？</h4><ul><li><p><strong>typedef主要用于定义类型别名。</strong></p></li><li><p>宏替换发生在编译阶段之前（预处理阶段），属于文本插入替换；<strong>typedef是编译的一部分。</strong></p></li><li>宏不检查类型；typedef会检查数据类型。</li></ul><h4 id="10-strlen和sizeof区别？"><a href="#10-strlen和sizeof区别？" class="headerlink" title="10.strlen和sizeof区别？"></a>10.strlen和sizeof区别？</h4><ul><li><p><strong><code>sizeof</code>是运算符</strong>，并不是函数，结果<strong>在编译时得到而非运行中获得</strong>；<code>strlen</code>是字符处理的库函数。</p></li><li><p><strong><code>sizeof</code>参数可以是任何数据类型或数据；<code>strlen</code>的参数只能是字符指针且结尾是’\0’的字符串</strong>：</p></li><li>因为<code>sizeof</code>值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。 </li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sizeof</span>(str); <span class="comment">// 取的是指针str的长度，是8</span></span><br><span class="line">    <span class="built_in">strlen</span>(str); <span class="comment">// 取的是这个字符串的长度，不包含结尾的 \0。大小是4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-常量指针和指针常量区别"><a href="#11-常量指针和指针常量区别" class="headerlink" title="11.常量指针和指针常量区别"></a>11.常量指针和指针常量区别</h4><ul><li>指针常量，如<code>int const *p</code>或<code>const int *p</code>，是一个指针指向一个只读变量。</li><li>常量指针是一个不能给改变指向的指针,<code>int *const p</code></li></ul><h4 id="12-数组名-a和取地址操作符-amp-a有什么区别"><a href="#12-数组名-a和取地址操作符-amp-a有什么区别" class="headerlink" title="12.数组名 a和取地址操作符 &amp;a有什么区别?"></a>12.数组名 <code>a</code>和取地址操作符 <code>&amp;a</code>有什么区别?</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C++</span><br><span class="line">假设数组</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">10</span>] = &amp;a;</span><br></pre></td></tr></table></figure><p><strong>数组名 <code>a</code>:</strong></p><ul><li><strong>作为首元素的指针</strong>：指向数组第一个元素</li><li><strong>加法运算</strong>：<code>a + 1</code>，它会<strong>根据数组元素的数据类型</strong>（在这个例子中是 <code>int</code>）来增加地址,<code>a + 1</code> 将会指向下一个 <code>int</code> 的位置</li></ul><p><strong>取地址操作符 <code>&amp;a</code>:</strong></p><ul><li><strong>指向整个数组的指针</strong>：<code>&amp;a + 1</code>，它会跳过整个数组的长度（即10个 <code>int</code> 的大小），指向数组最后一个元素之后的位置。</li></ul><h4 id="13-C-中struct和class的区别"><a href="#13-C-中struct和class的区别" class="headerlink" title="13.C++中struct和class的区别"></a>13.C++中struct和class的区别</h4><p><strong>相同点:</strong></p><ul><li>两者都拥有成员函数、公有和私有部分</li><li>任何可以使用class完成的工作，同样可以使用struct完成</li></ul><p><strong>不同点：</strong></p><ul><li>两者中如果不对成员不指定公私有，<strong>struct默认是公有的</strong>，<strong>class则默认是私有的</strong></li><li>class默认是private继承，而struct模式是public继承</li><li>struct一般用于描述一个数据结构的集合，而class是对一个对象数据的封装</li></ul><h4 id="14-C-代码生成可执行文件的过程有几个阶段？"><a href="#14-C-代码生成可执行文件的过程有几个阶段？" class="headerlink" title="14.C++代码生成可执行文件的过程有几个阶段？"></a>14.C++代码生成可执行文件的过程有几个阶段？</h4><ul><li><strong>预处理：</strong> 预处理器会处理源代码中的预处理指令，如<code>#include</code>、<code>#define</code>等。</li><li><strong>编译：</strong> 经过预处理后的代码翻译成特定于目标机器的汇编语言代码，这个过程进行了语法检查，每个源文件都会被单独编译成一个对象文件（.obj或.o文件）。。</li><li><strong>汇编：</strong> 汇编器将编译阶段生成的汇编代码转换为目标机器的二进制指令集</li><li><strong>链接：</strong> 链接器负责将编译阶段产生的多个对象文件合并成一个最终的可执行文件。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-八股&quot;&gt;&lt;a href=&quot;#C-八股&quot; class=&quot;headerlink&quot; title=&quot;C++八股&quot;&gt;&lt;/a&gt;C++八股&lt;/h2&gt;&lt;h4 id=&quot;1-在main执行之前和之后执行的代码可能是什么&quot;&gt;&lt;a href=&quot;#1-在main执行之前和之后执行的代码</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>docker基础</title>
    <link href="https://wangak.cc/posts/5ae6092.html"/>
    <id>https://wangak.cc/posts/5ae6092.html</id>
    <published>2025-03-10T07:52:05.000Z</published>
    <updated>2025-03-10T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-docker与VM"><a href="#1-docker与VM" class="headerlink" title="1.docker与VM"></a>1.docker与VM</h4><p><strong>docker的作用：</strong>实现跨平台的快速运行应用</p><p><strong>docker为什么比VM快？</strong></p><p><strong>docker有着比虚拟机更少的抽象层：</strong>docker 容器共享宿主机的操作系统内核，不需要为每个容器启动一个完整的操作系统实例。而虚拟机需要为每个虚拟机启动一个完整的操作系统实例，这会占用更多的内存和 CPU 资源。</p><p><strong>区别：</strong></p><ul><li><strong>虚拟机：</strong>虚拟机是通过Hypervisor(虚拟机管理系统，常见的有VMWare、workstation、VirtualBox)，虚拟出网卡、cpu、内存等虚拟硬件，再在其上建立虚拟机，每个虚拟机是个独立的操作系统，拥有自己的<strong>系统内核(GuestOS)</strong>。</li><li><strong>容器：</strong>容器是利用<strong>namespace</strong>将文件系统、进程、网络、设备等资源进行隔离，利用<strong>cgroup</strong>对权限、cpu资源进行限制，最终让容器之间互不影响，容器无法影响宿主机。</li></ul><h4 id="2-docker基本组成"><a href="#2-docker基本组成" class="headerlink" title="2.docker基本组成"></a>2.docker基本组成</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202503101222301.png" alt="image-20250310122147161" style="zoom: 50%;"></p><h4 id="3-docker常用指令"><a href="#3-docker常用指令" class="headerlink" title="3.docker常用指令"></a>3.docker常用指令</h4><p><code>docker images</code>:查看容器列表</p><p><strong>启动容器：</strong></p><p><code>docker run [-d]  [--name] [-p] [-v] [--network] 容器名（指定） 容器 [-e]</code></p><p><code>docker run -d --name mynginx -p 88:80 -v /app/nghtml:/usr/share/nginx/html nginx</code></p><ul><li><p><code>-d:</code> 后台启动容器</p></li><li><p><code>--name:</code> 指定容器的名字</p></li><li><p><code>-p</code>: 端口映射，如<code>-p 88:80</code>(将内部端口80映射到外部端口88)</p></li><li><p><code>-v</code>: 目录挂载(挂载后的目录要修改权限) </p></li><li><p><strong>卷映射：</strong><code>-v ngconf:/etc/nginx</code></p><p><em>注：卷的存储位置：/var/lib/docker/volumes/&lt;卷名&gt;</em></p></li><li><p><code>--network</code>: 指定自定义网络</p></li><li><p><code>-e</code> :设置环境变量</p></li></ul><p><strong><em>注：目录挂载和卷映射的目的都是数据持久化，其允许容器和主机之间共享数据。</em></strong></p><p><strong>删除容器：</strong></p><p><code>rm [-f] 容器id</code> : 不加<code>-f</code>不能删除正在运行的容器</p><p><strong>进入容器：</strong></p><p><code>docker exec [-it] &lt;容器名&gt; /bin/bash</code></p><p><code>docker exec -it mynginx /bin/bash</code></p><p><strong>删除镜像：</strong></p><p><code>docker rmi  &lt;镜像名&gt;</code></p><p><strong>保存镜像：</strong></p><ul><li><p><strong>提交：</strong><code>docker commit</code></p><p><code>docker commit -m &quot;update index.html&quot; mynginx mynginx:v1.0</code></p></li><li><p><strong>保存：</strong><code>docker save</code></p></li></ul><p>​    <code>docker save -o mynginx.tar mynginx:v1.0</code></p><ul><li><p><strong>加载：</strong><code>docker load -i &lt;镜像包&gt;</code></p><p><code>docker load -i mynginx.tar</code></p></li></ul><p><strong>docker自定义网络：</strong>实现容器之间的相互访问</p><ul><li><p><strong>创建网络：</strong><code>docker network create mynet</code></p></li><li><p><strong>查看容器ip:</strong><code>docker inspect app1</code></p></li><li><p><strong>容器1\<app1>访问容器2\<app2>:</app2></app1></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it app1 bash</span><br><span class="line">curl http://app2:80</span><br></pre></td></tr></table></figure><p><em>注1：这里的80是内部端口号</em></p><p><em>注2：docker为每个容器分配唯一ip，使用容器ip+容器端口可以互相访问。但由于ip可能会变化，可以创建自定义网络，<strong>容器名可以当作稳定的域名进行访问。</strong></em></p></li></ul><h4 id="4-docker-compose"><a href="#4-docker-compose" class="headerlink" title="4.docker compose"></a>4.docker compose</h4><p>利用docker compose可以快速启动或停止所有服务</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 定义数据库服务</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db_data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/myconf:/etc/mysql/conf.d</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blog</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 定义WordPress服务</span></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_NAME:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">wordpress:/var/www/html</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db_data:</span> </span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">blog:</span></span><br></pre></td></tr></table></figure><p><strong>启动docker compose:</strong> <code>docker compose -f compose.yaml up -d</code></p><p><strong>下线docker compose:</strong> <code>docker compose -f compose.yaml down -d</code></p><h4 id="5-Dockerfile"><a href="#5-Dockerfile" class="headerlink" title="5.Dockerfile"></a>5.Dockerfile</h4><p><strong>Dockerfile的常见指令：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503101933618.png" alt="image-20250310190804854" style="zoom: 50%;"></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">17</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> author=aaa</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.jar /app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>构建镜像：</strong><code>docker build -f Dockerfile -t myjavaapp:v1.0 .</code></p><p>注：<code>-t</code>: 给镜像打上标签，<code>myjavaapp</code>是镜像名，<code>v1.0</code>是版本号</p><p><strong>镜像分层机制：</strong></p><ul><li><p><strong>基础层:</strong> 每个Docker镜像都始于一个基础层，这个基础层通常是操作系统的基础镜像，比如Ubuntu、Alpine等。</p></li><li><p><strong>中间层:</strong> 在基础层之上，你可以添加多个中间层。每执行一条指令（如安装软件包、复制文件等），都会创建一个新的层。这些层按照指令执行的顺序堆叠在一起。</p></li><li><strong>可写层: </strong>Docker会在镜像的最上层添加一个可写的容器层。在这个层中，可以进行修改（如写入数据、更改配置等）。但这些<strong>修改仅限于该容器，不会影响到原始镜像</strong>或其他使用同一镜像启动的容器。</li></ul><p><strong><em>注：镜像分层机制允许不同的镜像共享相同的层，减少了重复数据的存储需求。</em></strong></p><p><code>ARG DEBIAN_FRONTEND=noninteractive</code>: 禁用软件包安装时的交互式提示，确保自动化构建过程不会中断。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-docker与VM&quot;&gt;&lt;a href=&quot;#1-docker与VM&quot; class=&quot;headerlink&quot; title=&quot;1.docker与VM&quot;&gt;&lt;/a&gt;1.docker与VM&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;docker的作用：&lt;/strong&gt;实现跨平台的快</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="docker" scheme="https://wangak.cc/tags/docker/"/>
    
  </entry>
  
</feed>
