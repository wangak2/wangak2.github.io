<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>丹青两幻</title>
  
  <subtitle>欢迎~</subtitle>
  <link href="https://wangak.cc/atom.xml" rel="self"/>
  
  <link href="https://wangak.cc/"/>
  <updated>2025-04-25T16:00:00.000Z</updated>
  <id>https://wangak.cc/</id>
  
  <author>
    <name>丹青两幻</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面经1</title>
    <link href="https://wangak.cc/posts/cf2d191f.html"/>
    <id>https://wangak.cc/posts/cf2d191f.html</id>
    <published>2025-04-25T16:00:00.000Z</published>
    <updated>2025-04-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-单例模式的应用场景？"><a href="#1-单例模式的应用场景？" class="headerlink" title="1.单例模式的应用场景？"></a>1.单例模式的应用场景？</h4><ul><li><strong>日志记录器</strong>：整个应用程序只需要一个日志记录，可以防止被重复创建。</li><li><strong>文件配置初始化类</strong></li></ul><h4 id="2-HTTP协议常见状态码"><a href="#2-HTTP协议常见状态码" class="headerlink" title="2.HTTP协议常见状态码"></a>2.HTTP协议常见状态码</h4><ul><li><p><strong>1xx (信息)：</strong>临时响应 - 已收到请求，正在继续处理。</p></li><li><p><strong>2xx (成功)：</strong>服务器已成功接收并接受请求。</p></li><li><p><strong>3xx (重定向)：</strong>需要采取进一步操作才能完成请求。</p></li><li><p><strong>4xx (客户端错误)：</strong>请求包含错误，无法实现。</p></li><li><p><strong>5xx (服务器错误)：</strong>服务器无法完成请求。</p></li></ul><ul><li><strong>200（成功）</strong> - 服务器成功返回网页</li><li>201（已创建） - 请求成功并且服务器创建了新的资源。</li><li>304（未修改） - 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</li><li><strong>400（错误请求）</strong> - 服务器不理解请求的语法。</li><li><strong>404（未找到）</strong> - 请求的网页不存在</li><li><strong>500（服务器内部错误）</strong> - 服务器遇到错误，无法完成请求。</li><li><strong>503（服务不可用）</strong>- 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</li></ul><h4 id="3-前向声明的作用？"><a href="#3-前向声明的作用？" class="headerlink" title="3.前向声明的作用？"></a>3.前向声明的作用？</h4><p><strong>前向声明主要用于.h文件中，仅告诉编译器某个类的存在，而没有提供类的具体实现</strong>。</p><p><strong>作用：</strong></p><ul><li><p><strong>减少编译依赖，加快编译速度：</strong>当一个头文件中包含另一个类的完整定义时，任何对该头文件的修改都会导致所有依赖该头文件的源文件重新编译。</p></li><li><p><strong>解决循环依赖问题：</strong>不使用前向声明，两个类的头文件中可能出现相互引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;B.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    B* b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    A* a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-TCP-IP五层模型各自常用的物理设备？"><a href="#4-TCP-IP五层模型各自常用的物理设备？" class="headerlink" title="4.TCP/IP五层模型各自常用的物理设备？"></a>4.TCP/IP五层模型各自常用的物理设备？</h4><ul><li><strong>应用层：</strong> 应用层直接面向用户的应用程序，为用户提供各种网络服务。不涉及特定的物理设备。</li><li><strong>传输层：</strong> 提供端到端的通信服务。不涉及特定的物理设备。</li><li><p><strong>网络层：</strong> 网络层负责路由选择及数据包的转发，确保数据可以从源端到达目的端。</p><ul><li><strong>路由器：</strong>根据IP地址进行数据包的转发，从而实现在不同网络之间的通信。</li></ul></li><li><p><strong>数据链路层：</strong> 处理节点间的可靠数据传输，包括错误检测与纠正。</p><ul><li><strong>交换机：</strong>通过MAC地址来转发数据帧</li><li><strong>网桥：</strong> 用于连接两个或更多的局域网段。</li></ul></li><li><p><strong>物理层：</strong> 负责在物理介质上传输原始比特流。</p><ul><li><strong>网线、光纤、中继器、集线器</strong></li></ul></li></ul><h4 id="5-进程间通讯方式，各自的优缺点？"><a href="#5-进程间通讯方式，各自的优缺点？" class="headerlink" title="5.进程间通讯方式，各自的优缺点？"></a>5.进程间通讯方式，各自的优缺点？</h4><ul><li><p><strong>管道</strong></p><ul><li>简单易用，但对于非亲缘关系的进程不适用，且性能受限于I/O操作。</li></ul></li><li><p><strong>消息队列： </strong>为进程提供了<strong>异步通信</strong>的方式，消息可以被发送到队列中，并由<strong>另一个进程按顺序</strong>读取。</p><ul><li>适用于那些需要保证消息传递顺序及可靠性的应用场景。</li></ul></li><li><p><strong>共享内存：</strong> 允许多个进程访问同一块物理内存空间，从而实现高效的数据交换。</p><ul><li><strong>优点：</strong>速度快，适合需要频繁或大量数据传输的情况</li><li><strong>缺点：</strong>需要处理同步问题，避免竞态条件。</li></ul></li><li><p><strong>套接字：</strong>支持本地和网络上的进程间通信。</p></li><li><p><strong>信号：</strong> 用于通知进程发生了特定事件，比如异常终止等，本身不是用来传输复杂数据的。</p></li></ul><h4 id="6-介绍一下匿名管道和命名管道"><a href="#6-介绍一下匿名管道和命名管道" class="headerlink" title="6.介绍一下匿名管道和命名管道"></a>6.介绍一下匿名管道和命名管道</h4><p><strong>匿名管道：</strong></p><ul><li>用于具有亲缘关系的进程之间通信，如<strong>父子进程</strong>。</li><li><strong>仅存在于内存</strong>中，并没有实体文件与之对应。</li><li>匿名管道是<strong>单向的</strong>，意味着数据只能在一个方向上流动。</li></ul><p><strong>命名管道（FIFO)：</strong></p><ul><li><p><strong>使用一个特殊路径来标识，任何知道该路径的进程</strong>都可以打开并使用这个管道进行通信，不论这些进程是否具有亲缘关系。</p></li><li><p>保证了数据按照<strong>先进先出</strong>的原则被读取。</p></li><li><p>命名管道是一个<strong>实际存在的对象</strong>，可以在文件系统中看到它。</p></li><li>相较于匿名管道，<strong>配置和管理更加复杂。</strong></li></ul><h4 id="7-哪些函数不能定义为虚函数"><a href="#7-哪些函数不能定义为虚函数" class="headerlink" title="7.哪些函数不能定义为虚函数"></a>7.哪些函数不能定义为虚函数</h4><ul><li><strong>构造函数</strong></li><li><strong>静态成员函数</strong></li><li><strong>友元函数</strong></li><li><strong>inline内联函数：</strong>inline内联函数是在<strong>编译时被展开</strong>，<strong>虚函数</strong>实在运行时才能<strong>动态绑定</strong>函数。</li></ul><h4 id="8-为什么模板类通常放在头文件中？"><a href="#8-为什么模板类通常放在头文件中？" class="headerlink" title="8.为什么模板类通常放在头文件中？"></a>8.为什么模板类通常放在头文件中？</h4><p><strong>模板实例化</strong>是指编译器基于模板定义和提供的具体类型参数生成具体的类或函数版本的过程。</p><p><strong>普通类的代码在编译阶段生成，模板类的代码在实例化（编译阶段）的阶段生成。</strong></p><p><strong>模板实例化时，编译器需要看到模板的定义，以便生成相应的代码。所以模板类一般在头文件中要有具体的定义。</strong></p><p><strong>分离编译的条件：</strong></p><ul><li><p><strong>模板实现</strong>放在<strong>.cpp</strong>文件中，同时在该文件中给出<strong>所有可能的模板实例化</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyTemplate.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyTemplate.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyTemplate&lt;T&gt;::<span class="built_in">MyTemplate</span>() : <span class="built_in">value</span>(<span class="built_in">T</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> MyTemplate&lt;T&gt;::<span class="built_in">print</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyTemplate</span>&lt;<span class="type">int</span>&gt;;     <span class="comment">// 实例化 MyTemplate&lt;int&gt;</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyTemplate</span>&lt;<span class="type">double</span>&gt;;  <span class="comment">// 实例化 MyTemplate&lt;double&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="9-静态库和动态库的区别"><a href="#9-静态库和动态库的区别" class="headerlink" title="9.静态库和动态库的区别"></a>9.静态库和动态库的区别</h4><p><strong>静态库：</strong></p><ul><li><p><strong>扩展名</strong>：</p><ul><li>在Unix/Linux系统上，以<code>.a</code>为扩展名</li><li>在Windows系统上，以<code>.lib</code>为扩展名。</li></ul></li><li><p><strong>链接时机</strong>：在<strong>编译阶段</strong>，静态库中的代码会被完整地复制到最终生成的可执行文件中</p></li><li><p><strong>优点</strong>：</p><ul><li>编译后的可执行文件<strong>包含了所有需要的库代码</strong>，因此<strong>无需担心依赖</strong>问题。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>由于每个使用该静态库的<strong>应用程序都会包含一份库代码</strong>，这会导致生成的可执行文件体积增大。</li><li>如果静态库更新了，所有依赖它的应用程序都需要重新编译链接。</li></ul></li></ul><p><strong>动态库：</strong></p><ul><li><p><strong>扩展名</strong>：</p><ul><li>在Unix/Linux系统上，以<code>.so</code>作为扩展名。</li><li>在Windows系统上，以<code>.dll</code>作为扩展名。</li></ul></li><li><p><strong>链接时机</strong>：动态库只在程序启动时或者<strong>运行过程</strong>中按需加载。</p></li><li><p><strong>优点</strong>：</p><ul><li><strong>多个程序可以共享同一个动态库实例</strong>，节省内存和磁盘空间。</li><li><strong>方便更新：</strong>库文件更新后，只要接口不变，已有的应用程序无需重新编译即可使用新版本的库。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>程序<strong>运行时需要确保相应的动态库存在，并且版本兼容</strong>，否则可能导致程序无法启动或出现错误。</li><li>相对于静态库，可能会有稍微<strong>复杂</strong>的依赖管理和部署要求。</li></ul></li></ul><h4 id="10-线程池有什么缺点"><a href="#10-线程池有什么缺点" class="headerlink" title="10.线程池有什么缺点"></a>10.线程池有什么缺点</h4><p><strong>线程池中的线程数量配置：</strong></p><ul><li>如果任务量<strong>超过了线程池的最大容量</strong>，额外的任务可能需要等待空闲线程，这可能会导致响应时间增加。</li><li>设置的<strong>线程数过多</strong>，可能会导致系统资源（如内存、CPU）过度消耗，<strong>影响整个系统的性能</strong></li></ul><h4 id="11-RAII"><a href="#11-RAII" class="headerlink" title="11.RAII"></a>11.RAII</h4><p><strong>使用局部对象来管理对象资源。</strong>局部对象是存储在栈上的对象，生命周期由操作系统来管理，不需要人工介入。对象获取即初始化，当不再需要使用即自动释放资源</p><h4 id="12-线程安全"><a href="#12-线程安全" class="headerlink" title="12.线程安全"></a>12.线程安全</h4><ul><li><p><strong>数据竞争</strong>： 互斥锁</p></li><li><p><strong>原子操作：</strong> 原子操作是不可分割的操作，不会被其他线程中断。</p></li><li><p><strong>死锁：</strong> </p><ul><li><p><strong>按顺序加锁</strong>：确保所有线程以相同的顺序获取锁。</p></li><li><p><strong>使用超时机制</strong>：尝试加锁时设置超时时间。</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-单例模式的应用场景？&quot;&gt;&lt;a href=&quot;#1-单例模式的应用场景？&quot; class=&quot;headerlink&quot; title=&quot;1.单例模式的应用场景？&quot;&gt;&lt;/a&gt;1.单例模式的应用场景？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;日志记录器&lt;/strong&gt;：整</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>网络八股</title>
    <link href="https://wangak.cc/posts/aa7d05b8.html"/>
    <id>https://wangak.cc/posts/aa7d05b8.html</id>
    <published>2025-04-20T16:00:00.000Z</published>
    <updated>2025-04-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么是负载均衡？如何实现负载均衡？"><a href="#1-什么是负载均衡？如何实现负载均衡？" class="headerlink" title="1.什么是负载均衡？如何实现负载均衡？"></a>1.什么是负载均衡？如何实现负载均衡？</h4><p><strong>负载均衡：</strong>将<strong>工作负载</strong>（如<strong>用户请求</strong>、数据流量等）合理地分配到<strong>多个服务器</strong>，以优化资源利用率、<strong>提高系统性能</strong>、增强系统的可靠性和可用性，<strong>避免单个服务器过载</strong>。</p><ul><li><strong>（硬件/软件）负载均衡器：</strong>根据负载情况/预定的规则，来将请求转发到后端服务器。</li><li><strong>DNS负载均衡：</strong>同<strong>一个域名可以解析为多个 IP 地址</strong>，<strong>DNS 服务器</strong>会根据一定的<strong>策略</strong>（如轮询）<strong>返回不同的 IP</strong><ul><li><strong>分配策略：</strong><ul><li><strong>轮询：</strong> 按顺序依次分配请求到服务器。01</li><li><strong>加权轮询：</strong> 根据服务器的性能设置权重，性能高的服务器分配更多请求。</li><li><strong>最少连接（适合长连接场景）：</strong> 将请求分配给当前连接数最少的服务器。</li><li><strong>哈希算法（适合需要会话保持的场景）：</strong> 根据请求的某些特征（如 IP 地址、会话 ID）进行哈希计算，确保相同特征的请求总是分配到同一台服务器。</li></ul></li></ul></li></ul><h4 id="2-介绍一下ping命令的原理"><a href="#2-介绍一下ping命令的原理" class="headerlink" title="2.介绍一下ping命令的原理"></a>2.介绍一下ping命令的原理</h4><p>ping是用于测试<strong>网络中主机间是否可达</strong>的工具。其基于<strong>ICMP协议</strong>（<strong>网络层</strong>，与I<strong>P协议配合使用</strong>，为IP协议提供了<strong>错误报告和控制机制</strong>）</p><p><strong>ICMP协议：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202504220926465.png" alt="image-20250420142751949" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202504220927151.png" alt="image-20250420142832876" style="zoom:67%;"></p><p><strong>ping命令的过程：</strong></p><ul><li><p><strong>命令发起：</strong> 输入 <code>ping</code> 命令</p></li><li><p><strong>域名解析(DNS)</strong></p></li><li><p><strong>构造 ICMP 请求报文:</strong> <code>ping</code> 命令会构造一个 <strong>ICMP Echo Request</strong> 报文</p><ul><li><p><strong>类型字段：值为 <code>8</code></strong>，表示这是一个 “Echo Request” 报文。</p></li><li><p>标识符和序列号：用于区分不同的请求和响应。</p></li></ul></li><li><p><strong>发送 ICMP 请求: </strong>构造好的 <strong>ICMP 请求报文被封装到 IP 数据包</strong>中，并通过网络发送到目标主机。</p></li><li><p><strong>目标主机接收并响应: </strong>当目标主机接收到 ICMP Echo Request 报文后，会检查报文的有效性。生成一个 <strong>ICMP Echo Reply</strong> 报文作为响应。</p><ul><li><strong>类型字段：值为 <code>0</code></strong>，表示这是一个 “Echo Reply” 报文。</li><li>原始请求中的标识符和序列号会被复制到响应中。</li></ul></li><li><p><strong>计算往返时间</strong></p></li><li><strong>重复发送多个请求，统计结果</strong></li></ul><p><strong>Request Timed Out的原因：</strong></p><ul><li><strong>防火墙限制</strong>：某些服务器可能会配置防火墙规则，禁止 ICMP 流量，导致 <code>ping</code> 无法成功。</li><li><strong>目标不可达</strong>：如果<strong>目标主机不在线</strong>、防火墙阻止了 ICMP 流量，或者网络路径中断，<code>ping</code> 将无法收到回应，显示超时</li></ul><h4 id="3-网络层协议和传输层协议的区别"><a href="#3-网络层协议和传输层协议的区别" class="headerlink" title="3.网络层协议和传输层协议的区别"></a>3.网络层协议和传输层协议的区别</h4><p><strong>传输层协议：</strong>提供端口号，实现的是不同主机上<strong>进程间的通信</strong>。端口号主要用于区分同一台主机上的不同进程。</p><p><strong>网络层协议：</strong>提供IP地址，实现的是不同<strong>主机间的通信</strong>。</p><h4 id="4-HTTPS的原理？"><a href="#4-HTTPS的原理？" class="headerlink" title="4.HTTPS的原理？"></a>4.HTTPS的原理？</h4><ul><li><p><strong>客户端请求：</strong>尝试访问一个 HTTPS 网址时，客户端（浏览器）会发起一个到服务器 <strong>443</strong> 端口（HTTPS 的默认端口）的<strong>连接请求</strong>。</p></li><li><p><strong>服务器响应：</strong> 服务器会向客户端发送其数字证书，证书包含了<strong>公钥</strong>、<strong>服务器信息</strong>（如域名）、<strong>有效期</strong>以及证书颁发者的信息等。</p></li><li><p><strong>客户端解析证书并对其进行验证：</strong></p><ul><li>如果证书<strong>不是可信机构</strong>颁布，或者证书中的域名与实际域名不一致，或者证书<strong>已经过期</strong>，就会向访问者显示一个<strong>警告</strong>，由其选择<strong>是否还要继续通信</strong>。</li><li>如果证书<strong>没有问题</strong>，客户端就会从服务器证书中<strong>取出服务器的公钥</strong>。然后客户端还会生成一个<strong>随机码 KEY</strong>，并使用<strong>公钥将其加密</strong>。</li></ul></li><li><p><strong>客户端发送对称密钥：</strong>客户端把<strong>加密后的随机码 KEY</strong> 发送给服务器，作为后面对称加密的密钥。</p></li><li><p><strong>服务器解密：</strong>服务器在收到随机码 KEY 之后会使用私钥B将其解密。</p></li><li><p><strong>使用对称密钥进行通信：</strong>服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。</p></li></ul><h4 id="5-二层转发的工作原理"><a href="#5-二层转发的工作原理" class="headerlink" title="5.二层转发的工作原理"></a>5.二层转发的工作原理</h4><p><strong>二层转发：</strong>数据链路层进行的数据包转发过程。</p><ul><li><p><strong>学习（维护一个MAC地址表）</strong>：当交换机接收到一个数据帧时，它会检查源MAC地址，并记录下这个地址与接收此帧的端口之间的对应关系。</p></li><li><p><strong>转发/过滤</strong>：一旦建立了MAC地址表，每当交换机收到一个目标为特定MAC地址的数据帧时，它就会查找其MAC地址表，找到对应的出端口并将帧直接转发到那个端口。如果目标MAC地址不在表中，或者帧的目标是一个广播地址，则交换机会将该帧<strong>泛洪</strong>（flooding）至除接收端口外的<strong>所有其他端口</strong>，以确保能够到达目标设备。</p></li><li><strong>老化</strong>：为了适应网络拓扑的变化，交换机会定期更新MAC地址表中的条目。如果一段时间内没有收到来自某个MAC地址的数据帧，交换机会删除相应的条目，以便释放空间给新的条目。</li></ul><h4 id="6-IPv4地址划分"><a href="#6-IPv4地址划分" class="headerlink" title="6.IPv4地址划分"></a>6.IPv4地址划分</h4><p><strong>分类地址：</strong></p><ul><li><strong>A类</strong>：第一个字节表示网络部分，后面三个字节表示主机部分。范围：0.0.0.0 - 127.255.255.255。默认子网掩码：/8或255.0.0.0。</li><li><strong>B类</strong>：前两个字节表示网络部分，后两个字节表示主机部分。范围：128.0.0.0 - 191.255.255.255。默认子网掩码：/16或255.255.0.0。</li><li><strong>C类</strong>：前三字节表示网络部分，最后一个字节表示主机部分。范围：192.0.0.0 - 223.255.255.255。默认子网掩码：/24或255.255.255.0。</li><li><strong>D类</strong>：用于多播（即一对多的通信）。范围：224.0.0.0 - 239.255.255.255。</li><li><strong>E类</strong>：保留用于实验和研究。范围：240.0.0.0 - 255.255.255.255。</li></ul><p><strong>子网掩码的作用</strong>：子网掩码中值为1的部分对应的IP地址位属于网络号，值为0的部分对应的IP地址位属于主机号。</p><h4 id="7-网络层多跳是什么？"><a href="#7-网络层多跳是什么？" class="headerlink" title="7.网络层多跳是什么？"></a>7.网络层多跳是什么？</h4><p><strong>网络层的“多跳”：</strong>是指数据包从源节点到达目的节点的过程中，需要<strong>经过多个中间节点（路由器）进行转发</strong>的过程。每经过一个中间节点即视为一跳，因此当数据包从源地址到目标地址需通过若干个这样的中间节点时，就称为多跳传输。</p><p><strong>IP 地址的分层结构</strong>：路由器根据<strong>目标 IP 地址的网络部分逐步靠近目标</strong>，而不是直接送达。</p><h4 id="8-HTTP2的头部压缩HPACK的工作原理"><a href="#8-HTTP2的头部压缩HPACK的工作原理" class="headerlink" title="8.HTTP2的头部压缩HPACK的工作原理"></a>8.HTTP2的头部压缩HPACK的工作原理</h4><p><strong>静态表：</strong>HPACK 预定义了一个静态表，其中包含了一些<strong>常见的 HTTP 头部字段</strong>及其值（如 <code>:method: GET</code>、<code>:status: 200</code> 等）。如果请求或响应中使用了这些字段，可以直接用静态表中的索引代替，从而减少传输的数据量。</p><p><strong>动态表</strong>：动态表是由客户端和服务器在通信过程中<strong>动态维护的一个共享表</strong>。当一个新的头部字段首次出现时，它会被添加到动态表中，并分配一个唯一的索引值。后续的请求或响应可以使用这个索引来引用该字段，避免重复传输完整字段。</p><p><strong>差量编码</strong>：如果某个头部字段的值发生了变化（例如 Cookie 的内容略有不同），HPACK 只传输发生变化的部分，而不是重新发送整个字段。这种方式进一步减少了数据量。</p><p><strong>霍夫曼编码</strong>：对于未被静态表或动态表覆盖的头部字段，HPACK 使用霍夫曼编码对字段名和字段值进行压缩。霍夫曼编码是一种基于频率的无损压缩算法，能够显著减少字符串的长度。</p><p><strong>在 HTTP/2 中，HPACK 压缩算法会显著减少重复的 <code>Cookie</code> 数据传输：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一次请求：</span><br><span class="line">GET /page1 HTTP/2</span><br><span class="line">:method: GET</span><br><span class="line">:path: /page1</span><br><span class="line">:authority: example.com</span><br><span class="line">cookie: sessionId=abc123; userId=456; theme=dark</span><br><span class="line">第二次请求：</span><br><span class="line">GET /page2 HTTP/2</span><br><span class="line">:method: GET</span><br><span class="line">:path: /page2</span><br><span class="line">:authority: example.com</span><br><span class="line">cookie: 62; theme=light</span><br></pre></td></tr></table></figure><h4 id="9-常见TCP的连接状态有哪些？"><a href="#9-常见TCP的连接状态有哪些？" class="headerlink" title="9.常见TCP的连接状态有哪些？"></a>9.常见TCP的连接状态有哪些？</h4><p><strong>LISTEN：</strong> 服务器端处于等待客户端发起连接请求的状态。</p><p><strong>SYN_SENT：</strong> 客户端socket执行CONNECT连接，发送SYN包，进入此状态。</p><p><strong>SYN_RECV：</strong>服务端收到SYN包并发送服务端SYN包，进入此状态。</p><p><strong>ESTABLISH：</strong>表示连接建立。客户端发送了最后⼀个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</p><p><strong>FIN_WAIT_1：</strong> 主动关闭方（通常是客户端或服务器中的一方）已经发送了FIN（结束）报文段，等待对方的ACK确认或者同时带有ACK的FIN报文。</p><p><strong>FIN_WAIT_2：</strong> 主动关闭方收到了对方的ACK确认，但还在等待对方发送FIN报文来完成关闭过程。</p><p><strong>CLOSE_WAIT</strong>：被动关闭方已经接收到对方的FIN报文，并发送了ACK确认，正在等待应用程序调用close()函数来发出自己的FIN。</p><p><strong>TIME_WAIT：</strong> 主动关闭方在收到对方的FIN报文并发送了ACK确认后进入此状态，主要是为了确保对方有足够的时间收到ACK报文。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-什么是负载均衡？如何实现负载均衡？&quot;&gt;&lt;a href=&quot;#1-什么是负载均衡？如何实现负载均衡？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是负载均衡？如何实现负载均衡？&quot;&gt;&lt;/a&gt;1.什么是负载均衡？如何实现负载均衡？&lt;/h4&gt;&lt;p&gt;&lt;s</summary>
      
    
    
    
    <category term="网络" scheme="https://wangak.cc/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://wangak.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>设计模式面试</title>
    <link href="https://wangak.cc/posts/3d262387.html"/>
    <id>https://wangak.cc/posts/3d262387.html</id>
    <published>2025-04-14T16:00:00.000Z</published>
    <updated>2025-04-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设计模式面试"><a href="#设计模式面试" class="headerlink" title="设计模式面试"></a>设计模式面试</h3><h4 id="1-什么是设计模式？为什么要使用设计模式？"><a href="#1-什么是设计模式？为什么要使用设计模式？" class="headerlink" title="1.什么是设计模式？为什么要使用设计模式？"></a>1.什么是设计模式？为什么要使用设计模式？</h4><p>设计模式是一种解决问题的方案。</p><p><strong>为什么要使用设计模式？</strong></p><ul><li><strong>提高代码复用性</strong>：经过验证的解决方案可以直接应用于类似问题</li><li><strong>提高可维护性</strong>：使代码更易于理解和修改</li><li><strong>提高扩展性</strong>：使系统更容易应对变化和增长</li></ul><h4 id="2-设计模式有哪些原则？"><a href="#2-设计模式有哪些原则？" class="headerlink" title="2.设计模式有哪些原则？"></a>2.设计模式有哪些原则？</h4><p><strong>单一职责原则(SRP)</strong>：一个类只应该有一个引起它变化的原因。<strong>一个类只负责一项职责。</strong></p><p><strong>开闭原则（OCP）</strong>：软件中的对象（类、模块、函数等）应该<strong>对扩展开放，对修改关闭。</strong>通过扩展来实现变化，而不是修改现有代码。</p><p><strong>依赖倒置原则（DIP）</strong>：为了保证低耦合</p><ul><li>高层模块不应该依赖低层模块，二者都应该依赖抽象</li><li><strong>抽象不应该依赖细节，细节应该依赖抽象</strong></li></ul><h4 id="3-工厂模式和策略模式的区别？"><a href="#3-工厂模式和策略模式的区别？" class="headerlink" title="3.工厂模式和策略模式的区别？"></a>3.工厂模式和策略模式的区别？</h4><ul><li><p><strong>目的不同：</strong></p><ul><li><strong>工厂模式</strong>的目的是<strong>创建对象</strong>，将对象的创建过程封装起来，使客户端的代码<strong>不需要依赖于</strong>具体类的<strong>实例化逻辑和使用逻辑。</strong></li><li><strong>策略模式</strong>的目的是对于<strong>行为的封装和替换</strong>，使得客户端可以在运行时<strong>动态选择不同的算法。</strong></li></ul></li><li><p><strong>结构不同：</strong></p><ul><li><strong>工厂模式：</strong>抽象产品类+具体产品类</li><li><strong>策略模式</strong>：抽象策略类+具体策略类+上下文类（持有一个 <strong>抽象策略 的引用</strong>，并允许在<strong>运行时动态设置不同的策略</strong>）</li></ul></li></ul><h4 id="4-什么是单例模式的懒汉模式？为什么线程不安全？怎么解决？"><a href="#4-什么是单例模式的懒汉模式？为什么线程不安全？怎么解决？" class="headerlink" title="4.什么是单例模式的懒汉模式？为什么线程不安全？怎么解决？"></a>4.什么是单例模式的懒汉模式？为什么线程不安全？怎么解决？</h4><p><strong>单例模式的懒汉模式：延迟初始化</strong>，即直到第一次使用该实例时才进行实例化。</p><p><strong>为什么线程不安全？</strong></p><p>​    如果两个线程同时调用 <code>getInstance()</code> 方法，获取实例，可能会创建多个实例，从而违反单例模式的原则。</p><p><strong>如何使其线程安全？</strong></p><ul><li><p><strong>使用互斥锁（Mutex）</strong>：可以在 <code>getInstance</code> 方法内部使用互斥锁来保证同一时刻只有一个线程能够执行实例化代码块。但是，这种方法每次获取实例都需要加锁和解锁，影响性能。</p></li><li><p><strong>双重检查锁定（Double-Checked Locking）</strong>：为了减少不必要的同步开销，可以采用双重检查锁定的方法。首先检查是否已经实例化，如果没有，则进行加锁后再检查一次并实例化。</p></li><li><p><strong>使用局部静态变量（C++11及以上标准）</strong>：C++11引入了对局部静态变量的支持，保证了其线程安全性，因此可以通过定义一个局部静态变量来实现懒汉模式下的线程安全单例。<strong>（局部静态变量只有第一次进入作用域时才初始化，且初始化具有原子性）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;  <span class="comment">// 构造函数私有化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance; <span class="comment">// 局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;            <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止赋值操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;设计模式面试&quot;&gt;&lt;a href=&quot;#设计模式面试&quot; class=&quot;headerlink&quot; title=&quot;设计模式面试&quot;&gt;&lt;/a&gt;设计模式面试&lt;/h3&gt;&lt;h4 id=&quot;1-什么是设计模式？为什么要使用设计模式？&quot;&gt;&lt;a href=&quot;#1-什么是设计模式？为什么要使用</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="设计模式" scheme="https://wangak.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++八股8</title>
    <link href="https://wangak.cc/posts/44c987f8.html"/>
    <id>https://wangak.cc/posts/44c987f8.html</id>
    <published>2025-04-12T16:00:00.000Z</published>
    <updated>2025-04-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-类对象的大小由哪些因素决定？"><a href="#1-类对象的大小由哪些因素决定？" class="headerlink" title="1.类对象的大小由哪些因素决定？"></a>1.类对象的大小由哪些因素决定？</h4><ul><li><p><strong>空类或无数据成员类的默认大小</strong>：如果一个类不包含任何数据成员（包括继承来的数据成员），根据C++标准，即使是空类也会被分配<strong>至少1个字节</strong>的空间。这是为了确保每个<strong>对象都有唯一的地址。</strong></p></li><li><p><strong>虚函数的影响（虚函数指针）</strong>：当一个类包含虚函数时，编译器会为该类添加一个指向虚函数表（vtable）的指针，称为vptr。这个指针是每个对象的一部分，因此它增加了对象的大小。指针的大小取决于系统架构（例如，在32位系统上是4字节，在64位系统上是8字节）。</p></li><li><p><strong>虚继承的影响</strong>：当使用虚继承来解决多重继承下的菱形继承问题时，每个对象需要额外的指针来维护到虚基类子对象的引用，这被称为<strong>虚基表指针</strong>（vbptr）。这样的设计避免了基类部分的重复，但同时也增加了每个对象的大小。</p></li><li><p><strong>内存对齐</strong>：类对象的大小计算遵循结构体内存对齐的原则。这意味着编译器会在数据成员之间或者末尾插入填充字节，以满足特定硬件平台上的对齐要求。这种对齐可以提高访问速度，但同时可能增加对象的实际大小。</p></li></ul><p><em>注：<strong>静态数据成员和成员函数不影响</strong>：无论是静态还是非静态成员函数，它们都不会影响类对象的大小。这是因为<strong>成员函数实际上是存储在代码段</strong>中的，所有对象<strong>共享同一份函数代码副本</strong>。同样，静态数据成员属于整个类，而非单个对象，因此它们也不会增加对象的大小。</em></p><h4 id="2-虚基表指针是什么？有什么作用？"><a href="#2-虚基表指针是什么？有什么作用？" class="headerlink" title="2.虚基表指针是什么？有什么作用？"></a>2.虚基表指针是什么？有什么作用？</h4><p><strong>虚基表指针：</strong>编译器会为每个<strong>包含虚基类的类</strong>插入一个虚基表指针<strong>（vbptr）</strong>，该指针<strong>指向一个虚基表（vbtable）</strong>。这个表包含了访问虚基类子对象所需的信息。</p><p><strong>虚基表结构</strong>：</p><ul><li>虚基类子对象相对于当前对象的偏移量</li><li>当前对象相对于虚基表指针的偏移量</li></ul><p><strong>虚基表指针的作用：</strong></p><p>虚基表指针的主要作用是<strong>在虚继承情况下，正确找到共享的虚基类子对象（虚基类子对象相对于当前对象的偏移量）</strong>。</p><h4 id="3-什么是内存对齐？内存对齐有什么作用？"><a href="#3-什么是内存对齐？内存对齐有什么作用？" class="headerlink" title="3.什么是内存对齐？内存对齐有什么作用？"></a>3.什么是内存对齐？内存对齐有什么作用？</h4><p><strong>内存对齐：</strong>要求数据的存储地址必须是某个特定值的整数倍。</p><p><em>eg:</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Example1</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;      <span class="comment">// 1字节（地址0）</span></span><br><span class="line">    <span class="type">int</span> b;       <span class="comment">// 4字节（必须对齐到4，地址4）</span></span><br><span class="line">    <span class="type">double</span> c;    <span class="comment">// 8字节（必须对齐到8，地址8）</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 大小：1 + 3（填充） + 4 + 8 = 16字节</span></span><br></pre></td></tr></table></figure><p><strong>为什么要内存对齐？</strong></p><p>加快<strong>硬件访问效率</strong>，现代CPU通常以<strong>固定大小的块（如4字节、8字节）读取内存</strong>。如果数据未对齐，CPU可能需要多次访问内存才能读取完整数据。</p><h4 id="4-std-move的作用和使用场景？"><a href="#4-std-move的作用和使用场景？" class="headerlink" title="4.std::move的作用和使用场景？"></a>4.std::move的作用和使用场景？</h4><p><code>std::move</code>: 将一个对象转换为<strong>右值引用</strong>，从而启用移动语义。</p><p><strong>使用场景：</strong>如果类实现了<strong>移动构造函数</strong>或<strong>移动赋值运算符</strong>，可以结合 <code>std::move</code> 使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="built_in">int</span>(value)) &#123;&#125;</span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span> data;         <span class="comment">// 释放当前资源</span></span><br><span class="line">            data = other.data;   <span class="comment">// 窃取资源</span></span><br><span class="line">            other.data = <span class="literal">nullptr</span>;<span class="comment">// 将原对象置空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data; <span class="comment">// 释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    MyClass obj2 = std::<span class="built_in">move</span>(obj1); <span class="comment">// 使用 std::move 调用移动构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (obj1.data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;obj1&#x27;s resource has been moved!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj2&#x27;s data: &quot;</span> &lt;&lt; *(obj2.data) &lt;&lt; std::endl; <span class="comment">// 输出 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-std-forward的作用和使用场景？"><a href="#5-std-forward的作用和使用场景？" class="headerlink" title="5.std::forward的作用和使用场景？"></a>5.std::forward的作用和使用场景？</h4><p><strong><code>std::forward</code>:</strong> 主要作用是实现<strong>完美转发</strong>，即将函数模板的参数原封不动地转发给另一个函数，同时保留其值类别（lvalue 或 rvalue）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Lvalue reference&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Rvalue reference&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg)); <span class="comment">// 根据 arg 的值类别转发</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(x);       <span class="comment">// 左值，调用 process(int&amp;)</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">42</span>);      <span class="comment">// 右值，调用 process(int&amp;&amp;)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：<code>T&amp;&amp;</code>是万能引用，既能接收左值又能接收右值。</em></p><h4 id="6-构造函数和析构函数能抛出异常吗？"><a href="#6-构造函数和析构函数能抛出异常吗？" class="headerlink" title="6.构造函数和析构函数能抛出异常吗？"></a>6.构造函数和析构函数能抛出异常吗？</h4><p><strong>构造函数可以抛出异常，但可能会造成内存泄露。</strong></p><ul><li>如果构造函数抛出异常，对象被视为未完全构造，析构函数不会被调用，可能导致资源泄漏。使用智能指针（如 <code>std::unique_ptr</code>）可以有效避免资源泄漏问题。</li></ul><p><strong>析构函数不能、也不应该抛出异常。</strong></p><ul><li>如果析构函数抛出异常，则异常点之后的程序不会被执行，如果析构函数在<strong>异常点之后执行了某些必要的动作比如释放某些资源</strong>，则这些动作不会被执行，会造成诸如<strong>资源泄露</strong>的问题。</li><li>通常<strong>异常发生时</strong>，C++机制会<strong>调用已经构造对象的析构函数</strong>来释放资源，此时如<strong>析构函数本身也抛出异常</strong>，则前一个异常尚未处理，又有新的异常，会造成<strong>程序崩溃</strong>的问题。</li></ul><h4 id="7-左值和右值的区别？"><a href="#7-左值和右值的区别？" class="headerlink" title="7.左值和右值的区别？"></a>7.左值和右值的区别？</h4><p>左值有明确的内存地址、能够被引用和修改。</p><p>右值是指临时的、没有明确的内存地址的对象。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202504171506915.png" alt="image-20250417150545277" style="zoom:67%;"></p><h4 id="8-类中默认构造函数有几个？"><a href="#8-类中默认构造函数有几个？" class="headerlink" title="8.类中默认构造函数有几个？"></a>8.类中默认构造函数有几个？</h4><p><strong>八个：</strong></p><ul><li><strong>默认构造函数</strong></li><li><strong>默认拷贝构造函数</strong></li><li><strong>默认析构函数</strong></li><li><strong>默认拷贝赋值运算符</strong></li><li><strong>默认移动构造函数</strong></li><li><strong>默认移动赋值运算符</strong></li><li><strong>默认取址运算符</strong></li><li><strong>默认取址运算符 <code>const</code> 版本</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-类对象的大小由哪些因素决定？&quot;&gt;&lt;a href=&quot;#1-类对象的大小由哪些因素决定？&quot; class=&quot;headerlink&quot; title=&quot;1.类对象的大小由哪些因素决定？&quot;&gt;&lt;/a&gt;1.类对象的大小由哪些因素决定？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;stro</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>面试模板</title>
    <link href="https://wangak.cc/posts/1977b211.html"/>
    <id>https://wangak.cc/posts/1977b211.html</id>
    <published>2025-04-12T16:00:00.000Z</published>
    <updated>2025-04-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1.自我介绍"></a>1.自我介绍</h4><p>尊敬的面试官，您好。我是东北大学在读硕士研究生XXX。我的技术栈是C++,熟悉windows和linux的C++开发，熟悉网络编程开发和常见的网络协议。</p><p>在实践过程中，我实现过一个高性能RPC框架，让我对分布式系统通信和RPC远程过程调用有了进一步的认识，另外，我也做Linux性能监控项目，基于grpc实现了对服务器上的性能数据采集，并进行监控的过程。</p><p>在校期间，我曾多次获得过校奖学金，参加过蓝桥杯和程序设计天梯赛，并均获得了国家三等奖，这些经历使我具有扎实的算法基础和工程实践能力，所以我认为贵公司的开发岗位要求和我的技术能力是非常契合的。</p><p>最后，非常感谢您给我这次面试机会，谢谢。</p><h4 id="2-1-介绍一下你的项目（分布式Linux性能监控）"><a href="#2-1-介绍一下你的项目（分布式Linux性能监控）" class="headerlink" title="2.1 介绍一下你的项目（分布式Linux性能监控）"></a>2.1 介绍一下你的项目（分布式Linux性能监控）</h4><p>在校期间我做过<strong>分布式Linux性能监控</strong>的项目，首先，我利用了Docker容器化的技术，通过Dockerfile来构建环境，例如安装CMake、gRpc、Protobuf等依赖，以此来<strong>简化多服务器的部署</strong>。</p><p>通过基于gRpc的框架来构建服务端和客户端，服务端位于目标监控的服务器上，客户端调用<strong>monitor模块</strong>和<strong>display模块</strong>实现对服务端的监控，通过这样的设计保证了模块之间的<strong>低耦合</strong>。</p><p>对于<strong>monitor模块</strong>主要作用是用来获取服务器端的CPU、内存、网络、软中断等性能指标。Display模块就利用了monitor模块所获取到的性能指标来使用Qt构建ui界面。</p><p>最后，使用<code>stress</code>工具模拟高负载情况，验证了系统的稳定性。</p><p>遇到的困难：</p><ul><li>protobuf如何使用cmake进行编译</li></ul><h4 id="2-2-介绍一下你的项目（RPC）"><a href="#2-2-介绍一下你的项目（RPC）" class="headerlink" title="2.2 介绍一下你的项目（RPC）"></a>2.2 介绍一下你的项目（RPC）</h4><p>这个项目是基于C++实现的RPC网络通信框架，实现了同一台机器不同进程间或者不同机器间的服务调用。</p><p>首先，本项目是使用protobuf进行序列化和反序列化，并使用了Zookeeper作为服务注册中心，动态地存储服务的ip和端口。</p><p>其次，对于网络层采用Muduo库的Reactor模型，来将网络IO和业务逻辑相解耦，提升系统的并发处理能力。</p><p>最后，通过CMake构建编译环境。</p><h3 id="1-Docker相关"><a href="#1-Docker相关" class="headerlink" title="1.Docker相关"></a>1.Docker相关</h3><h4 id="1-1-docker和VM的区别"><a href="#1-1-docker和VM的区别" class="headerlink" title="1.1 docker和VM的区别"></a>1.1 docker和VM的区别</h4><p>Docker 和虚拟机是两种不同的<strong>虚拟化技术</strong>，它们的核心目标都是为了<strong>实现资源隔离</strong>和环境一致性。</p><ul><li><p><strong>性能开销：</strong></p><ul><li>每个<strong>虚拟机</strong>都需要运行一个<strong>完整的操作系统</strong>，所以<strong>资源消耗较大</strong>，启动时间较长，占用更多的磁盘空间和内存。</li><li>容器<strong>共享宿主机的内核</strong>，因此几乎没有额外的虚拟化开销，启动<strong>速度更快</strong>（通常在毫秒级别），并且占用的磁盘空间和内存也更少。</li></ul></li><li><p><strong>隔离性：</strong></p><ul><li><strong>虚拟机</strong>提供了<strong>更强的隔离性</strong>，因为每个虚拟机都运行在一个完全独立的操作系统中，彼此之间互不影响。这种隔离性使得虚拟机更适合需要<strong>高度安全性</strong>和稳定性的场景。</li><li><strong>容器</strong>之间的<strong>隔离性相对较弱</strong>，因为它们共享宿主机的内核。如果某个容器被攻破，可能会对宿主机或其他容器造成影响。不过，通过命名空间和控制组等技术，Docker 已经能够提供一定程度的安全隔离。<strong>Docker容器适合需要进行快速部署的场景。</strong></li></ul></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504131447602.png" alt="image-20250410141629895" style="zoom:50%;"></p><h4 id="1-2-使用docker创建镜像的流程是什么？相关的命令有哪些？"><a href="#1-2-使用docker创建镜像的流程是什么？相关的命令有哪些？" class="headerlink" title="1.2 使用docker创建镜像的流程是什么？相关的命令有哪些？"></a>1.2 使用docker创建镜像的流程是什么？相关的命令有哪些？</h4><ul><li><p><strong>编写 Dockerfile（.dockerfile文件）</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>  ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get clean &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get autoclean</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> apt/sources.list /etc/apt/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update  &amp;&amp; apt-get upgrade -y  &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y \</span></span><br><span class="line"><span class="language-bash">    htop \</span></span><br><span class="line"><span class="language-bash">    apt-utils \</span></span><br><span class="line"><span class="language-bash">    curl \</span></span><br><span class="line"><span class="language-bash">    git \</span></span><br><span class="line"><span class="language-bash">    openssh-server \</span></span><br><span class="line"><span class="language-bash">    build-essential \</span></span><br><span class="line"><span class="language-bash">    qtbase5-dev \</span></span><br><span class="line"><span class="language-bash">    qtchooser \</span></span><br><span class="line"><span class="language-bash">    qt5-qmake \</span></span><br><span class="line"><span class="language-bash">    qtbase5-dev-tools \</span></span><br><span class="line"><span class="language-bash">    libboost-all-dev \</span></span><br><span class="line"><span class="language-bash">    net-tools \</span></span><br><span class="line"><span class="language-bash">    vim \</span></span><br><span class="line"><span class="language-bash">    stress </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y libc-ares-dev  libssl-dev gcc g++ make </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y  \</span></span><br><span class="line"><span class="language-bash">    libx11-xcb1 \</span></span><br><span class="line"><span class="language-bash">    libfreetype6 \</span></span><br><span class="line"><span class="language-bash">    libdbus-1-3 \</span></span><br><span class="line"><span class="language-bash">    libfontconfig1 \</span></span><br><span class="line"><span class="language-bash">    libxkbcommon0   \</span></span><br><span class="line"><span class="language-bash">    libxkbcommon-x11-0</span></span><br><span class="line"> <span class="comment"># 复制当前目录下的文件到容器中</span></span><br><span class="line"> <span class="keyword">COPY</span><span class="language-bash"> install/cmake /tmp/install/cmake</span></span><br><span class="line"> <span class="comment"># 安装 cmake 依赖</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="language-bash"> /tmp/install/cmake/install_cmake.sh</span></span><br><span class="line"> <span class="keyword">COPY</span><span class="language-bash"> install/protobuf /tmp/install/protobuf</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="language-bash"> /tmp/install/protobuf/install_protobuf.sh</span></span><br><span class="line"> <span class="keyword">COPY</span><span class="language-bash"> install/abseil /tmp/install/abseil</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="language-bash"> /tmp/install/abseil/install_abseil.sh</span></span><br><span class="line"> <span class="keyword">COPY</span><span class="language-bash"> install/grpc /tmp/install/grpc</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="language-bash"> /tmp/install/grpc/install_grpc.sh</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="language-bash"> apt-get install -y python3-pip</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="language-bash"> pip3 install cuteci -i https://mirrors.aliyun.com/pypi/simple</span></span><br><span class="line"> <span class="keyword">COPY</span><span class="language-bash"> install/qt /tmp/install/qt</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="language-bash"> /tmp/install/qt/install_qt.sh</span></span><br></pre></td></tr></table></figure></li><li><p><strong>构建镜像：</strong>使用 <code>docker build</code> 命令根据 <code>Dockerfile</code> 构建镜像。</p></li><li><p><strong>测试镜像：</strong><code>docker images</code>查看本地已经存在的镜像列表</p></li><li><p><strong>运行容器:</strong><code>docker run</code>运行镜像并启动容器。</p></li><li><p><strong>查看运行中的容器:</strong> <code>docker ps</code></p></li><li><p><strong>进入容器的交互式终端</strong>：<code>docker exec -it &lt;容器ID或名称&gt; /bin/bash</code></p></li></ul><h4 id="1-3-docker的namespace是什么？有什么作用？"><a href="#1-3-docker的namespace是什么？有什么作用？" class="headerlink" title="1.3 docker的namespace是什么？有什么作用？"></a>1.3 docker的namespace是什么？有什么作用？</h4><p>namespace是<strong>实现隔离的机制</strong>，每个容器运行在一个独立的命名空间之中</p><p><strong>每个进程都有自己所属的 namespace，可以在 <code>/proc/&lt;pid&gt;/ns/</code> 目录下查看。</strong></p><p><strong>Docker 使用的主要几种 namespace：</strong></p><ul><li><strong>PID Namespace</strong>：用于隔离<strong>进程ID编号空间</strong>。这意味着在不同的 PID namespace 中可以存在相同的 PID，而且一个 namespace 中的进程对于另一个 namespace 来说是不可见的。</li><li><strong>Network Namespace</strong>：提供<strong>独立的网络协议栈</strong>（例如网络设备、IP地址、路由表等）。每个 Network namespace 都有自己的网络配置和状态。</li><li><strong>Mount Namespace</strong>：允许修改<strong>文件系统的挂载点列表</strong>，使不同容器可以看到完全不同的文件系统结构。</li><li><strong>UTS Namespace</strong>：允许<strong>单个系统上存在不同的主机名和域名</strong>，这有助于创建更真实的测试环境。</li><li><strong>IPC Namespace</strong>：用于隔离System V IPC 和 POSIX消息队列，这样即使在同一系统上，不同容器也可以安全地使用这些通信机制而不会相互干扰。</li><li><strong>User Namespace</strong>：提供了用户ID和组ID的隔离，使得同一用户的ID在不同的namespace中可以对应不同的权限。</li></ul><p>​    通过使用这些 namespace，Docker  能够<strong>为每个容器创建一个独立的执行环境</strong>，这个环境看起来就像是一个单独的操作系统实例。这种隔离性是容器技术的核心特点之一，使得<strong>多个容器可以在同一台机器上共存而互不干扰</strong>。同时，由于它们共享同一个内核，所以比传统的虚拟机更加高效且<strong>占用资源更少</strong>。</p><h4 id="1-4-docker的cgroups是什么？有什么作用？"><a href="#1-4-docker的cgroups是什么？有什么作用？" class="headerlink" title="1.4 docker的cgroups是什么？有什么作用？"></a>1.4 docker的cgroups是什么？有什么作用？</h4><p>​    cgroups是一种用于限制和隔离一个或一组进程对系统资源使用的机制，将<strong>一组进程组织在一个控制组中</strong>，为这个控制组分配特定的<strong>资源限制</strong>与优先级，包括 CPU资源、内存、网络等。确保容器在共享主机上合理利用系统资源，避免资源竞争和过度使用。 </p><p>​    <strong>容器利用 Linux 的namespace技术来实现这种隔离，并结合 cgroups 来管理资源的使用，保证容器之间不会互相干扰。</strong></p><h4 id="1-5-什么是镜像？为什么要使用镜像？"><a href="#1-5-什么是镜像？为什么要使用镜像？" class="headerlink" title="1.5 什么是镜像？为什么要使用镜像？"></a>1.5 什么是镜像？为什么要使用镜像？</h4><p><strong>镜像：包含程序运行环境的软件包</strong></p><p><strong>使用 Docker镜像 的主要原因：</strong></p><ul><li><strong>环境一致性：</strong> 确保在任何地方运行结果一致。</li><li><strong>快速部署：</strong> 镜像可以 <strong>一键运行</strong>，秒级启动容器</li><li><strong>资源隔离：</strong> 每个容器基于镜像独立运行，资源相互隔离。</li></ul><h4 id="1-6-docker分层原理与内部结构"><a href="#1-6-docker分层原理与内部结构" class="headerlink" title="1.6 docker分层原理与内部结构"></a>1.6 docker分层原理与内部结构</h4><p><strong>Docker采用分层存储结构：</strong></p><ul><li><strong>基础镜像层</strong>：通常是一个最小化的操作系统环境，例如 <code>alpine</code> 或 <code>ubuntu</code>。它是其他所有层的基础。</li><li><p><strong>中间层</strong>：基于基础镜像层之上，每执行一条指令（比如 <code>RUN</code> 命令），都会创建一个新的层。这<strong>包括安装软件包、复制文件等操作。</strong></p></li><li><p><strong>可写层（容器层）</strong>：当使用 <strong><code>docker run</code></strong> 命令启动一个容器时，在镜像的最顶层会添加一个可写的容器层。所有对容器的更改（如文件的增删改）都只会发生在这一层，而不会影响到下面的只读层。<strong>容器删除后，可写层也随之消失(除非数据被持久化)。</strong></p></li></ul><p><strong>分层的工作方式：</strong></p><ul><li><p><strong>镜像构建时的分层：只读层(镜像层)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:<span class="number">20.04</span>          # 基础层(第<span class="number">1</span>层)</span><br><span class="line">RUN apt-get update         # 第<span class="number">2</span>层</span><br><span class="line">RUN apt-get install -y nginx  # 第<span class="number">3</span>层</span><br><span class="line">COPY index.html /var/www/html/  # 第<span class="number">4</span>层</span><br><span class="line">CMD [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]  # 第<span class="number">5</span>层</span><br></pre></td></tr></table></figure></li><li><p><strong>容器运行时的分层: 可写层(容器层)</strong> 通过<code>docker run</code>创建</p></li></ul><p><strong>分层的好处：</strong></p><ul><li><strong>高效的存储</strong>：由于各层之间共享(<strong>只读层共享，可写层独立</strong>），如果两个镜像共用了某些层，那么这些层只需要存储一次，从而<strong>节省了磁盘空间。</strong></li><li><strong>快速部署</strong>：在构建新镜像时，只有变动的部分需要重新生成新的层，其余未变的部分可以直接复用，大大加快了镜像的构建速度。</li></ul><h3 id="2-Protobuf"><a href="#2-Protobuf" class="headerlink" title="2.Protobuf"></a>2.Protobuf</h3><p><strong>Protobuf: 轻量级的数据序列化协议</strong></p><h4 id="2-1-为什么数据的传输和通信需要序列化？"><a href="#2-1-为什么数据的传输和通信需要序列化？" class="headerlink" title="2.1 为什么数据的传输和通信需要序列化？"></a>2.1 为什么数据的传输和通信需要序列化？</h4><ul><li><p><strong>跨平台兼容性</strong>：<strong>不同的系统、编程语言或者运行环境可能对数据结构有不同的表示方法。</strong>通过序列化，可以将这些差异抽象掉，使得数据可以在不同平台间进行有效传输。</p></li><li><p><strong>优化传输大小</strong>：有效的序列化格式能够减少数据传输的体积，从而提高传输效率并节省带宽。</p><p><em>注：<strong>Protobuf 使用字段编号（如 <code>1</code>、<code>2</code>）来代替字段名</strong>，这样可以大大减少字段标识的占用空间。</em></p></li></ul><h4 id="2-2-为什么使用protobuf？"><a href="#2-2-为什么使用protobuf？" class="headerlink" title="2.2 为什么使用protobuf？"></a>2.2 为什么使用protobuf？</h4><ul><li><p><strong>性能</strong>：Protobuf 使用二进制格式进行数据编码，这使得它更加紧凑，占用更少的空间，同时也加快了序列化和反序列化的速度。</p><p><em>注：字段编号（如 <code>1</code>、<code>2</code>）来代替字段名，另外，二进制格式相比于文本格式去掉了空白字符。</em></p></li><li><p><strong>支持跨平台</strong>：Protobuf 支持<strong>多种编程语言</strong>，如 C++, Java, Python 等，并且支持跨平台使用。</p></li></ul><h3 id="3-CMake"><a href="#3-CMake" class="headerlink" title="3.CMake"></a>3.CMake</h3><h4 id="3-1-使用cmake进行编译的步骤？"><a href="#3-1-使用cmake进行编译的步骤？" class="headerlink" title="3.1 使用cmake进行编译的步骤？"></a>3.1 使用cmake进行编译的步骤？</h4><ul><li><p><strong>编写<code>CMakeLists.txt</code> 文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.10</span><span class="number">.2</span>)</span><br><span class="line"><span class="built_in">project</span>(test_monitor LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_subdirectory</span>(rpc_manager)</span><br><span class="line"><span class="built_in">add_subdirectory</span>(test_monitor)</span><br><span class="line"><span class="built_in">add_subdirectory</span>(proto)</span><br><span class="line"><span class="built_in">add_subdirectory</span>(display_monitor)</span><br></pre></td></tr></table></figure></li><li><p><strong>创建构建目录：</strong>创建一个单独的构建目录build,避免污染源代码目录。</p></li><li><p><strong>进入构建目录，执行<code>cmake ..</code>,生成 <code>Makefile</code></strong></p></li><li><p><strong>执行构建:</strong> 使用<code>make</code>命令执行构建</p></li></ul><h4 id="3-2-cmake的常用API"><a href="#3-2-cmake的常用API" class="headerlink" title="3.2 cmake的常用API?"></a>3.2 cmake的常用API?</h4><ul><li><strong>项目配置: </strong> <code>cmake_minimum_required(VERSION &lt;version&gt;)</code></li><li><strong>设置变量:</strong> <code>set(&lt;variable&gt; &lt;value&gt;)</code></li><li><strong>定义一个可执行目标:</strong> <code>add_executable(&lt;target_name&gt; &lt;source_files&gt;)</code></li><li><strong>定义一个库目标:</strong> <code>add_library(&lt;target_name&gt; [STATIC | SHARED | MODULE] &lt;source_files&gt;)</code></li><li><strong>链接库:</strong> <code>target_link_libraries(&lt;target&gt; &lt;libraries&gt;)</code></li><li><strong>指定头文件路径:</strong> <code>target_include_directories(&lt;target&gt; [PRIVATE | PUBLIC | INTERFACE] &lt;directories&gt;)</code></li><li><strong>将子目录添加到构建系统:</strong> <code>add_subdirectory</code></li></ul><p>3.3 动态库和静态库的区别？</p><ul><li><p><strong>静态库：</strong></p><ul><li><strong>编译时集成</strong>：静态库在编译阶段与应用程序代码一起被编译并链接到可执行文件中。这意味着每个使用该静态库的应用程序都会包含一份库代码的副本。</li><li><strong>大小和性能</strong>：由于静态库的代码被直接嵌入到最终的可执行文件中，这可能导致生成的可执行文件较大。</li></ul></li><li><p><strong>动态库：</strong></p><ul><li>动态库在程序运行时才被加载到内存，并与程序进行链接。<strong>多个程序可以共享同一个动态库实例</strong>，从而节省内存和磁盘空间。</li></ul></li><li><p>静态库适合于<strong>确保程序独立运行</strong>，减少对外部依赖的情况；动态库则有助于资源共享、减小程序体积，并简化库的升级流程。</p></li></ul><h3 id="4-gRPC"><a href="#4-gRPC" class="headerlink" title="4.gRPC"></a>4.gRPC</h3><h4 id="4-1-介绍一下gRPC"><a href="#4-1-介绍一下gRPC" class="headerlink" title="4.1 介绍一下gRPC"></a>4.1 介绍一下gRPC</h4><p>​    gRPC是一种高性能的远程过程调用框架，主要用于分布式场景中的服务与服务间的数据交互，其采用HTTP2（支持io多路复用）作为传输协议，使用protobuf作为序列化协议，并且支持多种开发语言。</p><h4 id="4-2-对比一下HTTP1-0、HTTP1-1、HTTP2-0、HTTP3-0"><a href="#4-2-对比一下HTTP1-0、HTTP1-1、HTTP2-0、HTTP3-0" class="headerlink" title="4.2 对比一下HTTP1.0、HTTP1.1、HTTP2.0、HTTP3.0"></a>4.2 对比一下HTTP1.0、HTTP1.1、HTTP2.0、HTTP3.0</h4><p><strong>HTTP/1.0:</strong></p><ul><li><strong>连接方式（短连接）</strong>：每个<strong>请求都需要建立一个新的TCP连接</strong>，完成之后立即关闭，这导致了较大的延迟。</li><li><strong>基于文本的协议：</strong>传输文本格式的数据 </li><li><strong>单工：</strong>无法实现服务端的推送</li></ul><p><strong>HTTP1.1：</strong></p><ul><li><strong>有限的长连接：</strong> 由keep-alived决定保持的时间，允许在一个TCP连接上发送多个请求和响应。</li><li><strong>基于文本的协议：</strong>传输文本格式的数据 </li><li><strong>无法实现双工通信</strong></li><li><strong>存在队头阻塞的问题（不支持多路复用）：</strong>下一个请求必须在前一个请求响应到达之后才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。（一个连接上不能同时发出多个请求）</li></ul><p><strong>HTTP2.0：</strong></p><ul><li><strong>长连接</strong></li><li><strong>多路复用</strong>：解决了HTTP/1.x中的队头阻塞问题，通过一条TCP连接可以同时进行多个请求和响应的传输。</li><li><strong>二进制协议</strong>：传输二进制数据效率高</li><li><strong>可以实现双工通信</strong></li><li><strong>仍存在可能因丢包重传阻塞所有流（TCP 层队头阻塞）</strong></li></ul><p><strong>HTTP/3.0：</strong></p><ul><li><strong>底层协议变更</strong>：最大的变化是从基于TCP变为基于UDP的QUIC协议，旨在减少连接建立时间并提高安全性。</li><li><strong>快速握手</strong>：利用TLS 1.3实现了更快的安全握手过程，使得连接建立速度显著加快。</li></ul><h3 id="5-性能相关"><a href="#5-性能相关" class="headerlink" title="5.性能相关"></a>5.性能相关</h3><h4 id="5-1-性能数据是怎么得到的？"><a href="#5-1-性能数据是怎么得到的？" class="headerlink" title="5.1 性能数据是怎么得到的？"></a>5.1 性能数据是怎么得到的？</h4><p>通过读取<code>/proc</code>文件系统下的相关文件得到。</p><h4 id="5-2-什么是中断？什么是软中断？"><a href="#5-2-什么是中断？什么是软中断？" class="headerlink" title="5.2 什么是中断？什么是软中断？"></a>5.2 什么是中断？什么是软中断？</h4><p><code>/proc/softirqs</code></p><p><strong>中断：</strong>是一种<strong>异步</strong>的事件处理机制，可以提高系统的并发处理能力。</p><p><strong>软中断（异常）：</strong></p><p>为了解决中断处理程序<strong>执行过长</strong>和<strong>中断丢失</strong>的问题，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部（软中断）。</p><ul><li>上半部用来快速处理中断，它在<strong>中断禁止模式</strong>下运行，主要处理跟<strong>硬件</strong>紧密相关的或时间敏感的工作。</li><li>下半部用来延迟处理上半部未完成的工作，通常以<strong>内核线程</strong>的方式运行。</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504131447451.png" alt="image-20250412094031429" style="zoom:50%;"></p><h4 id="5-3-统计了内存相关的哪些信息？"><a href="#5-3-统计了内存相关的哪些信息？" class="headerlink" title="5.3 统计了内存相关的哪些信息？"></a>5.3 统计了内存相关的哪些信息？</h4><p>/proc/meminfo 当前内存使用的统计信息，常由free命令使用</p><p><strong>基础内存统计：</strong></p><ul><li><strong><code>total</code>：</strong> 系统的总物理内存大小</li><li><strong><code>free</code>： </strong>当前未被使用的物理内存大小。</li><li><strong><code>avail</code>： </strong> 可用于启动新应用程序而无需交换的内存大小。它包括了空闲内存 (<code>free</code>) 和可回收的缓存（如文件缓存和部分 slab 缓存）。</li></ul><p><strong>缓存与缓冲区：</strong></p><ul><li><p><strong><code>buffers</code>： </strong>块设备 I/O 操作的缓冲区内存大小。</p></li><li><p><strong><code>cached</code>： </strong>表示文件系统缓存占用的内存大小。</p><p>……</p></li></ul><p><strong>活跃与非活跃内存</strong></p><ul><li><p><strong><code>active</code>: </strong>最近被频繁访问的内存页面大小。这些页面不太可能被回收。</p></li><li><p><strong><code>in_active</code>: </strong>最近较少被访问的内存页面大小。这些页面可能被回收以释放内存。</p><p>……</p></li></ul><p><strong>脏页与写回</strong></p><ul><li><strong><code>dirty</code>: </strong>尚未写入磁盘的脏页（修改过的页面）的内存大小。这些页面需要尽快写回磁盘以确保数据一致性。</li><li><strong><code>writeback</code>: </strong>表示正在写回磁盘的页面的内存大小。这些页面已经被标记为“正在写入”，但尚未完成。</li></ul><p><strong>匿名内存</strong></p><ul><li><p><strong><code>anon_pages</code>: </strong>表示匿名内存的总大小。匿名内存是指没有文件支持的内存区域，如堆、栈和通过 <code>mmap</code> 创建的匿名映射。</p><p>……</p></li></ul><p><strong>可回收内存</strong></p><ul><li><p><strong><code>kReclaimable</code>: </strong>表示内核中可回收的内存大小。这部分内存由内核管理，但可以被回收以供其他用途。</p><p>……</p></li></ul><h3 id="6-Muduo库"><a href="#6-Muduo库" class="headerlink" title="6.Muduo库"></a>6.Muduo库</h3><h4 id="6-1-介绍一下Muduo库的Reactor模型"><a href="#6-1-介绍一下Muduo库的Reactor模型" class="headerlink" title="6.1 介绍一下Muduo库的Reactor模型"></a>6.1 介绍一下Muduo库的Reactor模型</h4><p>​    Reactor模型其核心思想是<strong>“事件驱动”</strong>，即通过一个事件循环（<strong>EventLoop</strong>）监听多种事件，然后通过一个<strong>事件分发器</strong>分发给对应的<strong>事件处理器（回调函数）</strong>进行处理。</p><p>然而，在高并发的场景下，单线程的EventLoop可能无法满足性能需求。这是通常采用主Reactor线程和子Reactor线程的分离设计。</p><ul><li><strong>主Reactor线程：</strong>运行一个 EventLoop，负责监听服务器端口并接受新连接，并把连接分配给子Reactor线程。</li><li><strong>子Reactor线程：</strong>每个线程都运行一个独立的 EventLoop，负责处理具体的 TCP 连接，后续的所有 IO 操作（如读写）都在对应的子线程中完成。</li></ul><h4 id="6-2-同步和异步的区别"><a href="#6-2-同步和异步的区别" class="headerlink" title="6.2 同步和异步的区别"></a>6.2 同步和异步的区别</h4><p><strong>同步</strong>：指<strong>任务依次执行</strong>，一个任务完成之后下一个任务才开始</p><p><strong>异步</strong>：指<strong>任务可以不按顺序执行</strong>，发起一个任务后无需等待其完成即可继续执行其他任务，通过回调、通知或轮询等方式获取任务结果。</p><h4 id="6-3-什么是事件驱动？Reactor模型是怎么实现事件驱动的？"><a href="#6-3-什么是事件驱动？Reactor模型是怎么实现事件驱动的？" class="headerlink" title="6.3 什么是事件驱动？Reactor模型是怎么实现事件驱动的？"></a>6.3 什么是事件驱动？Reactor模型是怎么实现事件驱动的？</h4><p><strong>事件驱动的核心思想是：</strong></p><ul><li><p><strong>异步非阻塞</strong>：程序<strong>不会主动轮询</strong>或等待某个事件的发生，而是通过<strong>注册回调函数</strong>的方式，由底层框架在事件发生时<strong>通知应用程序</strong>。</p></li><li><p><strong>事件循环（Event Loop）</strong>：一个持续运行的循环，用于<strong>监听事件并调用相应的回调函数。</strong></p></li></ul><p><strong>Reactor 模型的事件驱动流程</strong></p><ul><li><p><strong>注册事件：</strong>将感兴趣的事件（如可读、可写、连接关闭等）注册到 Reactor 中。</p><ul><li><code>setConnectionCallback</code> 注册了连接事件的回调函数 <code>OnConnection</code></li><li><code>setMessageCallback</code> 注册了消息事件的回调函数 <code>OnMessage</code></li></ul></li><li><p><strong>监听事件</strong>：<code>loop.loop()</code> 启动事件循环，通过 <code>epoll</code> 监听服务器端口上的连接请求和已连接套接字上的读写事件。</p></li><li><p><strong>分发事件：</strong></p><ul><li>当有新连接到达时，Muduo 调用 <code>OnConnection</code> 处理连接事件。</li><li>当有数据到达时，Muduo 调用 <code>OnMessage</code> 处理消息事件。</li></ul></li><li><p><strong>执行回调：</strong> <code>OnConnection</code> 和 <code>OnMessage</code> 执行具体的业务逻辑，例如打印日志、回显消息等。</p></li></ul><h3 id="7-Zookeeper"><a href="#7-Zookeeper" class="headerlink" title="7.Zookeeper"></a>7.Zookeeper</h3><h4 id="7-1-什么是Zookeeper？为什么使用Zookeeper？"><a href="#7-1-什么是Zookeeper？为什么使用Zookeeper？" class="headerlink" title="7.1 什么是Zookeeper？为什么使用Zookeeper？"></a>7.1 什么是Zookeeper？为什么使用Zookeeper？</h4><p>Zookeeper是一个<strong>分布式协调工具</strong>，而在本项目中主要用到了它的服务注册与发现的功能。</p><p><strong>具体的设计：</strong></p><ul><li>对于服务的提供者，以自己提供的服务名和方法作为Znode的路径，而将ip和端口作为Znode节点的数据，注册到zookeeper上。</li><li>对于服务的调用者，根据所请求的服务名和方法名就可以查找到对应服务器的ip和端口。</li></ul><p><strong>好处：</strong></p><ul><li>服务的调用者<strong>无需手动配置</strong>服务器的地址，只需提供服务名和方法名即可。</li><li>Zookeeper提供了<strong>Watcher机制</strong>可以<strong>实时感知</strong>服务的上线和下线。</li></ul><h4 id="7-2-ZooKeeper-的-Watcher-机制是如何实现的？"><a href="#7-2-ZooKeeper-的-Watcher-机制是如何实现的？" class="headerlink" title="7.2 ZooKeeper 的 Watcher 机制是如何实现的？"></a>7.2 ZooKeeper 的 Watcher 机制是如何实现的？</h4><p>​    Zookeeper 的观察者（Watcher）机制是一种事件通知机制，允许<strong>客户端在 ZNode 上设置观察者</strong>，以便在 ZNode 的数据或状态发生变化时接收通知。但在本项目中只使用了一个全局的<strong><code>global_watcher</code></strong>来监听<strong>客户端与服务器之间的连接状态变化</strong></p><h4 id="7-3-ZooKeeper客户端和服务器是长连接吗？"><a href="#7-3-ZooKeeper客户端和服务器是长连接吗？" class="headerlink" title="7.3 ZooKeeper客户端和服务器是长连接吗？"></a>7.3 ZooKeeper客户端和服务器是长连接吗？</h4><p>​    <strong>可以保持长连接</strong>，线程会定期向 ZooKeeper 服务器发送心跳包（Ping 消息），以确保连接的有效性。通过设置一个超时时间，如果客户端未收到服务器的响应（包括心跳响应），ZooKeeper 客户端会认为会话已过期，连接会被关闭。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-自我介绍&quot;&gt;&lt;a href=&quot;#1-自我介绍&quot; class=&quot;headerlink&quot; title=&quot;1.自我介绍&quot;&gt;&lt;/a&gt;1.自我介绍&lt;/h4&gt;&lt;p&gt;尊敬的面试官，您好。我是东北大学在读硕士研究生XXX。我的技术栈是C++,熟悉windows和linux的C</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>STL面试</title>
    <link href="https://wangak.cc/posts/ea5b5bc.html"/>
    <id>https://wangak.cc/posts/ea5b5bc.html</id>
    <published>2025-04-07T16:00:00.000Z</published>
    <updated>2025-04-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="STL面试"><a href="#STL面试" class="headerlink" title="STL面试"></a>STL面试</h2><h4 id="1-vector迭代器失效的问题？"><a href="#1-vector迭代器失效的问题？" class="headerlink" title="1.vector迭代器失效的问题？"></a>1.vector迭代器失效的问题？</h4><p>vector中的插入/删除会改变元素的位置或数量，从而导致迭代器失效。对vector进行连续插入或者删除操作（insert/erase)，一定要更新迭代器。</p><h4 id="2-array和vector的区别？"><a href="#2-array和vector的区别？" class="headerlink" title="2.array和vector的区别？"></a>2.array和vector的区别？</h4><ul><li><p><strong>大小是否可变：</strong></p><ul><li><strong><code>std::array</code></strong>在<strong>编译时确定大小</strong>，运行时无法更改。</li><li><strong><code>std::vector</code></strong>可在运行时动态调整大小</li></ul></li><li><p><strong>底层实现：</strong></p><ul><li><strong><code>std::array</code>：</strong> 基于普通数组（连续存储）实现，直接存储在栈上（除非它是某个堆对象的一部分）。</li><li><strong><code>std::vector</code>：</strong> 基于动态数组实现，数据存储在堆上。（在使用vector这个结构的时候，如果vector在函数内部直接定义，则对象存储在栈上，数据存储在堆上；而通过new动态创建时，指针在栈上，对象和数据都在堆上。</li></ul></li><li><p><strong>性能：</strong> <strong><code>vector</code></strong>插入或删除元素时可能需要重新分配内存和复制数据，导致性能下降。</p><p>注：如果提前预留足够的容量（通过 <code>reserve()</code> 方法），可以减少动态分配的次数。</p></li><li><p><strong>容器大小：</strong></p><ul><li><strong><code>std::array</code>：</strong> 返回的是编译时固定的大小</li><li><strong><code>std::vector</code></strong>：返回当前存储的元素数量</li></ul></li><li><p><strong>迭代器失效</strong>：<code>array</code>迭代器永远不会失效，除非整个容器被销毁。</p></li></ul><h4 id="3-描述一下vetcor动态内存的基本原理"><a href="#3-描述一下vetcor动态内存的基本原理" class="headerlink" title="3.描述一下vetcor动态内存的基本原理"></a>3.描述一下vetcor动态内存的基本原理</h4><p><strong>内存分配策略：</strong></p><ul><li><strong>分配更大的内存块</strong>：通过<strong>增长因子</strong>将容量翻倍（例如，从 4 → 8 → 16 → 32…）</li><li><strong>复制原有数据</strong>： 将原有数据从旧内存块复制到新内存块</li><li><strong>释放旧内存</strong>： 在完成数据迁移后，旧的内存块会被释放</li><li><strong>更新内部状态</strong>： 更新 <code>capacity</code> 和指向新内存块的指针。</li></ul><h4 id="4-介绍一下deque的底层结构"><a href="#4-介绍一下deque的底层结构" class="headerlink" title="4.介绍一下deque的底层结构"></a>4.介绍一下deque的底层结构</h4><p><code>std::deque</code>结合了数组和链表的特性</p><p><strong>底层实现：分块存储</strong></p><ul><li><strong>主数组（Map 或索引数组）:</strong> 指针数组，存储指向各个小块（chunk）的指针。</li><li><strong>小块（Chunk）:</strong> 固定大小的连续内存区域，用于存储 <code>std::deque</code> 的实际数据。</li><li><strong>头部和尾部标记:</strong> <code>std::deque</code> 内部维护两个标记，分别指向当前数据的起始位置和结束位置。</li></ul><p><strong><em>注：deque支持随机访问</em></strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202504102134400.png" alt="image-20250407170801444" style="zoom:50%;"></p><h4 id="5-list的底层结构是什么？"><a href="#5-list的底层结构是什么？" class="headerlink" title="5.list的底层结构是什么？"></a>5.list的底层结构是什么？</h4><p>双向循环链表</p><h4 id="6-容器适配器有哪些？底层结构是什么？"><a href="#6-容器适配器有哪些？底层结构是什么？" class="headerlink" title="6.容器适配器有哪些？底层结构是什么？"></a>6.容器适配器有哪些？底层结构是什么？</h4><ul><li><strong><code>stack</code>： </strong>底层默认使用 <code>std::deque</code></li><li><strong><code>queue</code>:</strong>  底层默认使用 <code>std::deque</code></li><li><strong><code>priority_queue:</code></strong> 底层默认使用<code>std::vector</code>。队列中的元素根据优先级排序，默认是大根堆。入队时进行排序，出队时排出优先级最高的元素，并对剩下的元素重新排序</li></ul><p><em>容器适配器没有自己的数据结构，它的方法全部由底层依赖的容器进行实现</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;STL面试&quot;&gt;&lt;a href=&quot;#STL面试&quot; class=&quot;headerlink&quot; title=&quot;STL面试&quot;&gt;&lt;/a&gt;STL面试&lt;/h2&gt;&lt;h4 id=&quot;1-vector迭代器失效的问题？&quot;&gt;&lt;a href=&quot;#1-vector迭代器失效的问题？&quot; class</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>智能指针面试题</title>
    <link href="https://wangak.cc/posts/1be7b917.html"/>
    <id>https://wangak.cc/posts/1be7b917.html</id>
    <published>2025-04-07T16:00:00.000Z</published>
    <updated>2025-04-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="智能指针面试题"><a href="#智能指针面试题" class="headerlink" title="智能指针面试题"></a>智能指针面试题</h3><h4 id="1-介绍一下shared-ptr的底层实现"><a href="#1-介绍一下shared-ptr的底层实现" class="headerlink" title="1.介绍一下shared_ptr的底层实现"></a>1.介绍一下shared_ptr的底层实现</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504081029173.png" alt="image-20250408093323071" style="zoom:67%;"></p><p><code>std::shared_ptr</code>的底层结构分为两部分：</p><ul><li><p><strong>控制块（Control Block）</strong>：一个动态分配的小型数据结构，用于存储引用计数和其他元信息。</p><ul><li><strong>强引用计数（Strong Reference Count）</strong>：记录有多少个 <code>shared_ptr</code> 引用了该对象。</li><li><strong>弱引用计数（Weak Reference Count）</strong>：记录有多少个 <code>std::weak_ptr</code> 引用了该对象（用于支持 <code>std::weak_ptr</code>）。</li><li><strong>删除器（Deleter）</strong>：可选的自定义函数，用于释放对象时执行特定操作。</li><li><strong>分配器（Allocator）</strong>：可选的自定义分配器，用于管理内存分配和释放。</li></ul></li><li><p><strong>原始指针（Raw Pointer）</strong>：保存一个指向实际对象的原始指针</p></li></ul><h4 id="2-介绍一下shared-ptr的引用计数的操作"><a href="#2-介绍一下shared-ptr的引用计数的操作" class="headerlink" title="2.介绍一下shared_ptr的引用计数的操作"></a>2.介绍一下shared_ptr的引用计数的操作</h4><p><strong>增加引用计数</strong>：当一个 <code>shared_ptr</code> 被拷贝（通过拷贝构造函数或赋值操作符）时，控制块中的强引用计数加 1。</p><p><strong>减少引用计数</strong>：当一个 <code>shared_ptr</code> 被销毁或重置时，控制块中的强引用计数减 1。</p><ul><li><strong>强引用计数变为 0：</strong><ul><li>调用删除器（如果有）来释放原始指针指向的对象。</li><li>如果<strong>弱引用计数也为 0</strong>，则释放控制块本身。</li></ul></li></ul><h4 id="3-weak-ptr能直接访问对象吗"><a href="#3-weak-ptr能直接访问对象吗" class="headerlink" title="3.weak_ptr能直接访问对象吗"></a>3.weak_ptr能直接访问对象吗</h4><p><code>std::weak_ptr</code> 本身<strong>不能直接访问对象</strong>，<code>std::weak_ptr</code> 可以通过检查控制块的状态来<strong>判断对象是否仍然有效</strong>。</p><p><strong>间接访问：</strong></p><ul><li><p><strong>检查对象是否仍然有效：</strong> 调用 <code>std::weak_ptr::lock()</code> 方法，尝试将 <code>std::weak_ptr</code> 提升为一个 <code>std::shared_ptr</code></p><ul><li>强引用计数为 0（即对象已经被销毁），<code>lock()</code> 返回一个空的 <code>std::shared_ptr</code></li><li>强引用计数大于 0（即对象仍然有效），<code>lock()</code> 返回一个新的 <code>std::shared_ptr</code>，并增加强引用计数。</li></ul></li><li><p><strong>提升为 <code>std::shared_ptr</code>：</strong> 如果 <code>std::weak_ptr::lock()</code> 成功返回一个有效的 <code>std::shared_ptr</code>，则可以通过这个 <code>std::shared_ptr</code> 访问对象。</p></li></ul><h4 id="4-shared-ptr和unique-ptr的区别"><a href="#4-shared-ptr和unique-ptr的区别" class="headerlink" title="4.shared_ptr和unique_ptr的区别"></a>4.shared_ptr和unique_ptr的区别</h4><ul><li><p><strong>所有权：</strong></p><ul><li><strong><code>std::unique_ptr</code></strong>：实现了独占所有权语义。</li><li><strong><code>std::shared_ptr</code></strong>：实现了共享所有权语义。</li></ul></li><li><p><strong>性能与内存开销：</strong></p><ul><li><strong><code>std::unique_ptr</code></strong>：性能较高，因为它不需要额外的内存开销来存储引用计数或其他元数据。</li><li><strong><code>std::shared_ptr</code></strong>：性能较低，因为每次增加或减少引用计数都需要原子操作。还需要额外的控制块来存储引用计数和其他信息。</li></ul></li><li><p><strong>移动语义 vs 复制语义：</strong></p><ul><li><strong><code>std::unique_ptr</code></strong>：支持移动语义，但不支持复制语义。</li><li><strong><code>std::shared_ptr</code></strong>：支持复制和赋值操作。</li></ul></li></ul><h4 id="5-shared-ptr的循环引用问题是什么？如何解决？"><a href="#5-shared-ptr的循环引用问题是什么？如何解决？" class="headerlink" title="5.shared_ptr的循环引用问题是什么？如何解决？"></a>5.shared_ptr的循环引用问题是什么？如何解决？</h4><p><strong>循环引用:</strong> <code>std::shared_ptr</code> 的循环引用问题是指两个或多个对象通过 <code>std::shared_ptr</code> <strong>相互持有对方</strong>，导致它们的强引用计数永远不会降为 0，从而无法释放内存。</p><p><strong>解决方案：用 <code>std::weak_ptr</code> 替代部分 <code>std::shared_ptr</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr; <span class="comment">// A 持有 B 的 shared_ptr</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A is destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;A&gt; a_ptr; <span class="comment">// 使用 weak_ptr 持有 A，此处如果是shared_ptr就变成了循环引用</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B is destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    <span class="keyword">auto</span> b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">    a-&gt;b_ptr = b; <span class="comment">// A 持有 B</span></span><br><span class="line">    b-&gt;a_ptr = a; <span class="comment">// B 使用 weak_ptr 持有 A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时 a 的强引用计数为 1，b 的强引用计数为 2</span></span><br><span class="line">&#125; <span class="comment">// 离开作用域后，a 和 b 的局部变量被销毁，引用计数降为 0，对象被正确释放</span></span><br></pre></td></tr></table></figure><h4 id="6-shared-ptr是否线程安全？"><a href="#6-shared-ptr是否线程安全？" class="headerlink" title="6.shared_ptr是否线程安全？"></a>6.shared_ptr是否线程安全？</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504081029981.png" alt="image-20250408100616337" style="zoom:50%;"></p><h4 id="7-shared-ptr的构造方法有哪几种，为什么尽量使用make-shared"><a href="#7-shared-ptr的构造方法有哪几种，为什么尽量使用make-shared" class="headerlink" title="7.shared_ptr的构造方法有哪几种，为什么尽量使用make_shared?"></a>7.shared_ptr的构造方法有哪几种，为什么尽量使用make_shared?</h4><p><strong>构造方法：</strong></p><ul><li><p><strong>默认构造函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr; <span class="comment">// 空 shared_ptr</span></span><br></pre></td></tr></table></figure></li><li><p><strong>从原始指针构造</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* rawPtr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(rawPtr)</span></span>; <span class="comment">// 用裸指针初始化 shared_ptr</span></span><br></pre></td></tr></table></figure><p><em>注：这种方式需要手动分配内存（如 <code>new</code>），容易导致资源泄漏或双重释放。</em></p></li><li><p><strong>使用 <code>std::make_shared</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用删除器：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>), [](<span class="type">int</span>* p) &#123; <span class="keyword">delete</span> p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>为什么尽量使用make_shared:</strong></p><ul><li><p><strong>减少内存分配次数</strong>：裸指针需要两次内存分配,而 <code>std::make_shared</code> 将对象和控制块合并到一次内存分配中，减少了内存分配的开销。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用裸指针构造 shared_ptr</span></span><br><span class="line"><span class="type">int</span>* rawPtr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>); <span class="comment">// 分配对象</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(rawPtr)</span></span>; <span class="comment">// 分配控制块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 make_shared</span></span><br><span class="line"><span class="keyword">auto</span> ptr2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 合并对象和控制块的一次分配</span></span><br></pre></td></tr></table></figure></li><li><p><strong>异常安全性:</strong> 在分配对象后、构造 <code>std::shared_ptr</code> 前抛出异常，则会导致内存泄漏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用裸指针可能引发异常安全性问题</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span>* rawPtr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>); <span class="comment">// 分配对象</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error&quot;</span>); <span class="comment">// 抛出异常，rawPtr 未被管理</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(rawPtr)</span></span>; <span class="comment">// 这行代码不会被执行</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 内存泄漏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 make_shared 是安全的</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 单步完成分配和管理</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error&quot;</span>); <span class="comment">// 异常安全，ptr 会正确释放资源</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 资源被正确释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504081029670.png" alt="image-20250408101900500" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;智能指针面试题&quot;&gt;&lt;a href=&quot;#智能指针面试题&quot; class=&quot;headerlink&quot; title=&quot;智能指针面试题&quot;&gt;&lt;/a&gt;智能指针面试题&lt;/h3&gt;&lt;h4 id=&quot;1-介绍一下shared-ptr的底层实现&quot;&gt;&lt;a href=&quot;#1-介绍一下shared</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Muduo库</title>
    <link href="https://wangak.cc/posts/70fda4f8.html"/>
    <id>https://wangak.cc/posts/70fda4f8.html</id>
    <published>2025-04-06T16:00:00.000Z</published>
    <updated>2025-04-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="非阻塞IO-IO复用"><a href="#非阻塞IO-IO复用" class="headerlink" title="非阻塞IO+IO复用"></a>非阻塞IO+IO复用</h4><p><strong>Event Loop：</strong> <strong>一个不断监听事件的发生，并调用相应回调函数的机制。</strong>处理<strong>异步</strong>I/O操作的编程模式，通过一个无限循环监听和分发事件。</p><p>注：在Event Loop中，应用首先注册感兴趣的事件处理器（如网络连接、文件I/O等），然后进入一个循环，等待这些事件的发生，并在事件发生时调用相应的处理器来响应事件。</p><p><strong>Non-Blocking 几乎总是和 I/O 多路复用一起使用：</strong></p><ul><li>单用Non-Blocking需要<strong>轮询</strong>检测I/O状态，会浪费CPU资源。</li><li><strong>I/O多路复用不能与阻塞I/O共存：</strong>I/O 多路复用判断某个 socket 可能处于某种状态（如“可读”或“可写”），但这并不保证后续的阻塞 I/O 操作一定能够成功完成。<ul><li>对于“可读”状态，可能只是表示内核缓冲区中有一些数据，但实际的数据量可能不足以满足 <code>read()</code> 请求（比如请求读取 100 字节，但缓冲区只有 50 字节）。</li><li>对于“可写”状态，可能只是表示内核缓冲区有空间，但如果你尝试写入大量数据，可能会超出缓冲区容量，导致 <code>write()</code> 阻塞。</li></ul></li></ul><p><strong><em>注：阻塞 I/O 会导致线程被挂起，从而无法处理其他 socket 上的事件。</em></strong></p><h4 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h4><p><strong>Reactor模型：</strong>是一个<strong>异步</strong>I/O模型，它不会阻塞程序的执行等待某个I/O操作完成，而是通过<strong>事件驱动</strong>的方式来处理I/O操作。Reactor设计模式是用于处理服务请求的事件处理模式，由一个或多个输入同时传递给服务处理程序，服务处理程序然后对传入的请求进行<strong>解复用</strong>，并将它们<strong>同步分派</strong>给关联的请求处理程序。</p><p><strong>Reactor模式的核心概念：事件分发和处理分离</strong></p><ul><li><strong>事件驱动</strong>：在Reactor模型中，所有输入（如客户端连接请求、数据到达等）都被视为事件。这些事件由Reactor负责监听和分发。</li><li><strong>解复用</strong>：当多个输入同时到达服务端时，Reactor会将这些输入进行解复用（demultiplexing），即<strong>根据事件类型将它们分类</strong>。例如，连接请求和数据接收是两种不同的事件类型，会被分配给不同的处理器处理。</li><li><strong>同步分派</strong>：一旦事件被解复用后，Reactor会同步地将这些事件分派给对应的事件处理器（EventHandler）。这里的“同步”意味着<strong>Reactor以同步方式分派事件。</strong></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504071032961.png" alt="image-20250407100736409" style="zoom: 50%;"></p><p><strong>一个Reactor模型的网络服务器交互流程：</strong></p><ul><li><strong>注册感兴趣的事件和回调函数：</strong> 将感兴趣的事件及预置的回调函数Handler注册到Reactor反应堆上</li><li><p><strong>启动Reactor反应堆：</strong> 一旦所有的事件都注册完毕，Reactor 就开始监听这些事件的发生。</p></li><li><p><strong>启动事件分发器：</strong>持续等待直到有事件发生，一旦事件分发器检测到某个事件已经准备好，就会通知 Reactor。</p></li><li><strong>处理事件并响应:</strong>  Reactor会通过map表找到Event事件对应的事件处理器来读取用户请求</li></ul><p><strong>Main Reactor 和 Sub Reactors：</strong>为了提高系统的可扩展性（连接和读写请求相分离）和性能（负载均衡）</p><ul><li><p>当有新的客户端连接请求到达时，Main Reactor 调用 <code>accept()</code> 接受连接，<strong>并获取客户端的 socket 文件描述符</strong>，将其分配给某个 Sub Reactor。</p><p><em>注：这里一般是Main Reactor 直接调用<code>accept()</code> ，而不用事件处理器。因为接受新连接的逻辑简单且高效</em></p></li><li><p>Sub Reactors 的任务是<strong>监听已经建立的连接</strong>（即客户端的 socket），并处理（调用对应的事件处理器）这些连接上的 I/O 事件，比如数据到达、可写等。</p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504071033850.png" alt="image-20250407101911108" style="zoom:67%;"></p><h4 id="ET模式与LT模式"><a href="#ET模式与LT模式" class="headerlink" title="ET模式与LT模式"></a>ET模式与LT模式</h4><p><strong>LT模式：</strong> 当 <code>epoll_wait</code> 检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用 <code>epoll_wait</code>时，还会再次向应用程序通告此事件，直到该事件被处理。</p><p><strong>ET模式：</strong>当<code>epoll_wait</code>检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的<code>epoll_wait</code>调用将不再向应用程序通知这一事件。所以 ET 模式在很大程度上<strong>降低了同一个<code>epoll</code>事件被重复触发的次数</strong>，因此一半了来说效率比 LT 模式高。</p><p><strong>实际上muduo库采用的为LT模式，主要好处如下：</strong></p><ul><li><strong>不会丢失数据或者消息：</strong> 应用没有读取完数据，内核是会不断上报的。</li><li><strong>低延迟处理：</strong> 每次读数据只需要一次系统调用；照顾了多个连接的<strong>公平性</strong>，不会因为某个连接上的数据量过大而影响其他连接处理消息。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;非阻塞IO-IO复用&quot;&gt;&lt;a href=&quot;#非阻塞IO-IO复用&quot; class=&quot;headerlink&quot; title=&quot;非阻塞IO+IO复用&quot;&gt;&lt;/a&gt;非阻塞IO+IO复用&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Event Loop：&lt;/strong&gt; &lt;strong&gt;一</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="网络" scheme="https://wangak.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux项目相关</title>
    <link href="https://wangak.cc/posts/a61c879f.html"/>
    <id>https://wangak.cc/posts/a61c879f.html</id>
    <published>2025-04-01T16:00:00.000Z</published>
    <updated>2025-04-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-平均负载？"><a href="#1-平均负载？" class="headerlink" title="1.平均负载？"></a><strong>1.平均负载？</strong></h4><p><strong>平均负载：</strong> 单位时间内活跃的进程数</p><p><strong>eg:</strong></p><p><strong>平均负载为 2 时，意味着什么呢？</strong></p><ul><li>系统有2个CPU：所有的CPU都刚好被完全占用。</li><li>系统有4个CPU： CPU有50%的空闲。</li><li>系统有1个CPU：一半的进程竞争不到CPU，会有进程切换</li></ul><h4 id="2-记录了1分钟、5分钟、15分钟的平均负载，到底怎么参考？"><a href="#2-记录了1分钟、5分钟、15分钟的平均负载，到底怎么参考？" class="headerlink" title="2.记录了1分钟、5分钟、15分钟的平均负载，到底怎么参考？"></a>2.记录了1分钟、5分钟、15分钟的平均负载，到底怎么参考？</h4><p><strong>负载平衡：</strong>1 分钟、5 分钟、15 分钟的三个值基本相同</p><p><strong>1 分钟的值远小于 15 分钟的值：</strong> 在14分钟的时间里系统的负载情况是有一点问题的</p><p><strong>1 分钟的值远大于 15 分钟的值：</strong> 这种增加有可能只是临时性的，需要持续观察</p><p><strong>1 分钟的平均负载接近或超过了 CPU 的个数：</strong> 系统正在发生过载的问题，就需要分析具体的问题，并进行优化了</p><p>当平均负载高于 CPU 数量 70% 的时候，你就应该分析排查负载高的问题了。</p><h4 id="3-平均负载与-CPU-使用率的区别"><a href="#3-平均负载与-CPU-使用率的区别" class="headerlink" title="3.平均负载与 CPU 使用率的区别"></a>3.平均负载与 CPU 使用率的区别</h4><p><strong>平均负载：</strong> 代表的是活跃进程数，指单位时间内，处于可运行状态和不可中断状态的进程数。</p><p><strong>CPU 使用率：</strong> 单位时间内 CPU 繁忙情况的统计。</p><p><strong>平均负载和CPU使用率未必是一致的：</strong></p><ul><li><strong>CPU 密集型进程</strong>，使用大量 CPU 会导致平均负载升高，此时这两者是一致的</li><li><strong>I/O 密集型进程</strong>，等待 I/O 也会导致平均负载升高，但 CPU 使用 率不一定很高</li></ul><h4 id="4-什么是中断？"><a href="#4-什么是中断？" class="headerlink" title="4.什么是中断？"></a>4.什么是中断？</h4><p><strong>中断其实是一种异步的事件处理机制，可以提高系统的并发处理能力</strong>，中断处理程序会打断其他进程的运行。</p><p><strong><em>注：中断处理程序在响应中断时，还会临时关闭别的中断（中断屏蔽）。这就会导致上一次中断处理完成之前，其他中断都不能响应，也就是说中断有可能会丢失。（中断队列的容量限制）</em></strong></p><h4 id="5-什么是软中断？"><a href="#5-什么是软中断？" class="headerlink" title="5.什么是软中断？"></a>5.什么是软中断？</h4><p>为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部：</p><ul><li>上半部用来快速处理中断，它<strong>在中断禁止模式下运行</strong>，主要处理跟硬件紧密相关的或时间敏感的工作。</li><li>下半部用来延迟处理上半部未完成的工作，通常以<strong>内核线程</strong>的方式运行</li></ul><p>从上半部到下半部的切换是通过<strong>软中断信号</strong>实现的</p><ul><li><p>上半部直接处理<strong>硬件请求</strong>，也就是我们常说的<strong>硬中断</strong>，特点是快速执行；</p></li><li><p>下半部则是由<strong>内核触发</strong>，也就是我们常说的软中断，特点是延迟执行。</p></li></ul><p><em>注1：软中断不只包括了硬件设备中断处理程序的下半部，一些内核自定义的事件也属于软中断</em></p><p><em>注2：同一种中断在不同 CPU 上的累积次数应该差不多。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-平均负载？&quot;&gt;&lt;a href=&quot;#1-平均负载？&quot; class=&quot;headerlink&quot; title=&quot;1.平均负载？&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.平均负载？&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;平均负载：&lt;/strong&gt; 单位时间内活跃的进程</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议</title>
    <link href="https://wangak.cc/posts/51aeee82.html"/>
    <id>https://wangak.cc/posts/51aeee82.html</id>
    <published>2025-03-31T16:00:00.000Z</published>
    <updated>2025-03-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么是TCP网络分层？"><a href="#1-什么是TCP网络分层？" class="headerlink" title="1.什么是TCP网络分层？"></a>1.什么是TCP网络分层？</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504012024749.png" alt="image-20250328205930579" style="zoom:67%;"></p><p>客户端：发送HTTP数据包</p><ul><li>应用层：根据HTTP协议组装数据包</li><li>传输层：增加TCP头部（包含端口号、序列号等）</li><li>网络层：增加IP头部（包含源IP地址等）</li><li>网络接口层：增加以太网头部（包含MAC地址等）</li></ul><p>服务端：接收HTTP数据包</p><ul><li>应用层：HTTP报文解析</li><li>传输层：TCP报文解析</li><li>网络层：IP报文解析，传送数据包、确定路由</li><li>网络接口层：根据MAC地址判断包是不是发给自己的</li></ul><h4 id="2-TCP协议的三次握手为什么不能是两次？为什么不能是四次？"><a href="#2-TCP协议的三次握手为什么不能是两次？为什么不能是四次？" class="headerlink" title="2.TCP协议的三次握手为什么不能是两次？为什么不能是四次？"></a>2.TCP协议的三次握手为什么不能是两次？为什么不能是四次？</h4><p><strong>三次握手：</strong></p><ul><li>客户端向服务端发送连接请求：客户端发送请求报文将 SYN = 1 同步序列号和初始化序列号 seq = x 发送给服务端，发送完之后客户端处于 <code>SYN_Send</code> 状态 (确认客户端的发送能力、服务端的接收能力)</li><li>服务端向客户端确认：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，此时服务器处于<code>SYN_RCVD</code> 的状态(确认服务端的发送能力、客户端的接收能力)</li><li>客户端收到 SYN 报文之后，会发送⼀个 ACK 报文，当然，也是⼀样把服务器的 ISN + 1 作为ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <code>ESTABLISHED</code> 状态。服务器收到 ACK 报文之后，也处于 <code>ESTABLISHED</code>状态，此时，双方已建立起了连接 (客户端向服务端建立连接)</li></ul><h4 id="3-TCP为什么是四次挥手？"><a href="#3-TCP为什么是四次挥手？" class="headerlink" title="3.TCP为什么是四次挥手？"></a>3.TCP为什么是四次挥手？</h4><p><strong>四次挥手：</strong></p><ul><li>第一次挥手：客户端请求断开(客户端发送FIN)</li><li>第二次挥手：服务端许可客户端断开连接（服务端回ACK，缓冲区写入<code>EOF</code>文件结束符，read读到<code>EOF</code>会返回0，进入<code>close_wait</code>状态）</li><li>第三次挥手：服务器请求断开(服务端发送FIN)</li><li>第四次挥手：客户端许可服务端断开连接(发送ACK)</li></ul><p><em>注：使用close（读写端都关闭）没有四次挥手，只有使用shutdown（关闭写端）时才有四次挥手</em></p><p><strong>为什么不能是三次？</strong></p><p>​    因为TCP的连接是全双工的，每个方向上的关闭都需要单独进行确认，否则一方关闭，另一方还在继续发送数据，会导致数据的丢失。</p><p><strong>为什么第二次挥手和第三次挥手不能合成一次？</strong></p><p>​    因为服务器上可能还有尚未处理完的数据，只有等数据都处理完毕之后，才能发出断开连接的请求</p><p><strong>如果发生数据包丢失，会发生什么？</strong></p><p>​    FIN包会重传，如果超出了所设置的最大重传次数，会直接断开。而ACK不会重传，ACK丢失会导致发送FIN包的一端不断重传，直至断开。</p><h4 id="4-四次挥手为什么要有time-wait的状态？"><a href="#4-四次挥手为什么要有time-wait的状态？" class="headerlink" title="4.四次挥手为什么要有time_wait的状态？"></a>4.四次挥手为什么要有time_wait的状态？</h4><ul><li><p><strong>防止旧数据包干扰新连接：</strong>如果一个 TCP 连接关闭后立即重新使用相同的源 IP、源端口、目标 IP 和目标端口（即相同的四元组）建立新的连接，那么之前滞留在网络中的旧数据包可能会被错误地认为是新连接的数据包。</p><ul><li><code>TIME_WAIT</code> 状态的作用是等待足够长的时间（通常是 2 倍的 MSL，Maximum Segment Lifetime），以确保所有可能的旧数据包都从网络中消失。</li><li>MSL 是指一个数据包在网络中能够存活的最长时间，通常设置为 30 秒到 2 分钟。因此，<code>TIME_WAIT</code> 的持续时间一般为 2MSL（大约 1~4 分钟）。</li></ul></li><li><p><strong>确保对方收到最后的 ACK</strong></p><ul><li>在 TCP 四次挥手中，主动关闭连接的一方（通常是客户端）会发送最后一个 ACK 来确认对方的 FIN 包。然而，这个 ACK 可能会在网络中丢失。如果对方没有收到这个 ACK，它会重传 FIN 包。</li></ul></li></ul><h4 id="5-为什么TIME-WAIT是-2MSL？"><a href="#5-为什么TIME-WAIT是-2MSL？" class="headerlink" title="5.为什么TIME_WAIT是 2MSL？"></a>5.<strong>为什么TIME_WAIT是 2MSL？</strong></h4><ul><li><strong>第一个 MSL</strong>：用于确保最后一个 ACK 能够到达对方。如果对方没有收到 ACK，它会重传 FIN 包。</li><li><strong>第二个 MSL</strong>：用于确保对方重传的 FIN 包能够到达本方，并得到处理。</li></ul><h4 id="6-为什么SYN-FIN不包含数据却需要消耗一个序列号？"><a href="#6-为什么SYN-FIN不包含数据却需要消耗一个序列号？" class="headerlink" title="6.为什么SYN/FIN不包含数据却需要消耗一个序列号？"></a>6.为什么SYN/FIN不包含数据却需要消耗一个序列号？</h4><p><strong>在TCP协议中，SYN（同步）和FIN（结束）标志位的报文虽然不包含应用层数据，但它们仍然需要消耗一个序列号。</strong></p><p>这是因为:</p><p><strong>凡是需要对端的确认，一定消耗TCP报文的序列号：</strong>TCP通过序列号和确认号来检测丢包并触发重传。如果无法区分重复的SYN或FIN报文。例如，如果网络中存在延迟的SYN报文，接收方可能会错误地认为这是一个新的连接请求。</p><h4 id="7-什么是半连接队列？什么是SYN-Flood攻击？"><a href="#7-什么是半连接队列？什么是SYN-Flood攻击？" class="headerlink" title="7.什么是半连接队列？什么是SYN Flood攻击？"></a>7.什么是半连接队列？什么是SYN Flood攻击？</h4><p><strong>半连接队列：</strong>客户端<strong>伪造IP发送SYN包</strong>，而服务端回复的ACK+SYN去到了一个未知的IP地址，这会造成大量的连接无法正常建立，这样的连接会处于半连接状态，而服务器会在半连接队列中记录这样的尚未完成的连接请求。</p><p><strong>SYN Flood（洪泛攻击）：</strong> 服务器的半连接队列大小是有限的，如果半连接队列满，会无法处理正常的请求。</p><h4 id="8-说说TCP快速打开-TCP-Fast-Open-TFO-原理"><a href="#8-说说TCP快速打开-TCP-Fast-Open-TFO-原理" class="headerlink" title="8.说说TCP快速打开(TCP Fast Open, TFO)原理"></a>8.说说TCP快速打开(TCP Fast Open, TFO)原理</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504012024295.png" alt="image-20250329141017329" style="zoom:50%;"></p><p><strong>TCP快速打开（TCP Fast Open, TFO）</strong>是一种旨在减少TCP连接建立时间，从而加速网络数据传输的机制。</p><p><strong>传统的TCP的缺陷：</strong>三次握手在每次建立连接时都需要完整地进行，这会引入一定的延迟，特别是在处理小数据量的请求时这种延迟尤为明显。</p><p><strong>TFO的工作流程：</strong></p><p><strong>阶段一：首次连接（无TFO，获取Cookie）</strong></p><ul><li><strong>客户端发送SYN并请求Cookie</strong>：普通SYN包，无数据，首选项表明支持TFO。</li><li><strong>服务端生成Cookie并发送至客户端</strong>：服务端生成一个加密的Cookie（基于客户端IP、密钥等），通过<code>SYN-ACK</code>的TFO选项返回。</li><li><strong>客户端存储Cookie</strong>：客户端保存该Cookie，用于后续连接。</li></ul><p><strong>阶段二：后续连接（启用TFO，加速握手）</strong></p><ul><li><p><strong>客户端发送SYN + 数据 + Cookie</strong>：</p></li><li><p>在SYN包中直接携带应用数据（如HTTP请求）和之前存储的Cookie。</p></li><li><p><strong>服务端验证Cookie</strong>：</p><ul><li>若Cookie有效，服务端立即处理数据并返回<code>SYN-ACK</code>（同时携带响应数据）。</li><li>若无效，则回退到普通三次握手，丢弃SYN中的数据。</li></ul></li><li><p><strong>客户端确认</strong>：发送<code>ACK</code>（若服务端已返回响应数据，此ACK可能已无实际数据，仅为确认连接的可靠性，否则退化为三次握手）</p></li></ul><p><strong>TFO性能收益:</strong></p><ul><li><strong>延迟降低</strong>：短连接场景可减少1 RTT，平均延迟下降20%~30%。</li></ul><h4 id="9-TCP时间戳的作用？"><a href="#9-TCP时间戳的作用？" class="headerlink" title="9.TCP时间戳的作用？"></a>9.TCP时间戳的作用？</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504012024595.png" alt="image-20250329143009627" style="zoom: 50%;"></p><p><strong>核心作用: </strong></p><ul><li><strong>计算往返时间</strong></li><li><strong>防止序列号回绕: </strong>时间戳作为序列号的扩展，即使序列号回绕，接收方通过比较时间戳（严格递增）可区分新旧数据包，<strong>丢弃过期的重复包</strong>。</li></ul><h4 id="10-TCP的超时重传时间是如何计算的"><a href="#10-TCP的超时重传时间是如何计算的" class="headerlink" title="10.TCP的超时重传时间是如何计算的?"></a>10.TCP的超时重传时间是如何计算的?</h4><p>TCP具有超时重传机制，即间隔一段时间没有等到数据包的回复，就会重传这个数据包。这个重传间隔就是<strong>超时重传时间（RTO)。</strong></p><p><strong>经典方法：（平滑RTT来计算RTO）适用于RTT波动较小的情况</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503291516533.png" alt="image-20250329144101644" style="zoom:67%;"></p><p><em>注：SampleRTT是新采样的RTT的值。</em></p><h4 id="11-说一说TCP的流量控制"><a href="#11-说一说TCP的流量控制" class="headerlink" title="11.说一说TCP的流量控制"></a>11.说一说TCP的流量控制</h4><p><strong>TCP发送数据的过程：</strong>发送方将数据放到发送缓冲区，再由发送缓冲区发送给接收方的接收缓冲区。</p><p><strong>流量控制的目标：</strong>根据接收缓冲区的大小控制发送端的发送。如果接收缓冲区满了，发送方就不能再继续发送。</p><p><strong>流量控制的基本原理：</strong></p><ul><li><strong>窗口字段</strong>：每个TCP报文段头部都包含一个16位的窗口字段（在某些情况下，如使用窗口缩放选项时可以大于16位），该字段指示了其剩余未使用的接收缓冲区大小。</li></ul><p><em>注：随着接收方处理数据并释放缓冲区空间，它可以向发送方发送具有更新后的窗口大小的新报文段，告知发送方现在可接受更多数据。</em></p><h4 id="12-如何理解TCP的keep-alive原理？"><a href="#12-如何理解TCP的keep-alive原理？" class="headerlink" title="12.如何理解TCP的keep-alive原理？"></a>12.如何理解TCP的keep-alive原理？</h4><p>​    TCP  Keep-Alive机制用于<strong>检测长时间处于空闲状态的TCP连接是否仍然有效</strong>。在网络通信中，可能会出现由于网络故障或对端主机崩溃等原因导致的连接中断，而两端的应用程序并未意识到这种情况的发生。Keep-Alive机制通过在<strong>设定的时间间隔内没有数据传输时发送探测包来检查连接的状态</strong>，从而帮助应用程序及时发现并处理这些“死”连接。</p><h4 id="13-A、B两个主机之间建立了一个TCP连接，A主机发给B主机两个TCP报文，大小分别是500和300，第一个报文的序列号是200，那么B主机接收两个报文后，返回的确认号是多少"><a href="#13-A、B两个主机之间建立了一个TCP连接，A主机发给B主机两个TCP报文，大小分别是500和300，第一个报文的序列号是200，那么B主机接收两个报文后，返回的确认号是多少" class="headerlink" title="13.A、B两个主机之间建立了一个TCP连接，A主机发给B主机两个TCP报文，大小分别是500和300，第一个报文的序列号是200，那么B主机接收两个报文后，返回的确认号是多少?"></a>13.A、B两个主机之间建立了一个TCP连接，A主机发给B主机两个TCP报文，大小分别是500和300，第一个报文的序列号是200，那么B主机接收两个报文后，返回的确认号是多少?</h4><p><strong>TCP序列号与确认号规则：</strong></p><ul><li><strong>序列号（SEQ）</strong>：标识发送方数据字节流的起始位置。</li><li><strong>确认号（ACK）</strong>：表示接收方<strong>期望收到的下一个字节的序列号</strong>（即已成功接收所有之前的数据）。</li><li><strong>数据长度</strong>：TCP报文中实际携带的应用数据长度（不包含TCP头部）。</li></ul><p>所以确认号为500+300+200=1000</p><h4 id="14-收到IP数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议（UDP或TCP"><a href="#14-收到IP数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议（UDP或TCP" class="headerlink" title="14.收到IP数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议（UDP或TCP)?"></a>14.收到IP数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议（UDP或TCP)?</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504012024757.png" alt="image-20250329150436272" style="zoom:50%;"></p><p><strong>IP头中有协议字段来区分IP协议的上层协议</strong></p><h4 id="15-TCP和UDP的区别？"><a href="#15-TCP和UDP的区别？" class="headerlink" title="15.TCP和UDP的区别？"></a>15.TCP和UDP的区别？</h4><p><strong>连接类型：</strong></p><ul><li><strong>TCP</strong>：面向连接的协议。在数据传输前需要通过三次握手建立连接，确保双方准备好进行通信。</li><li><strong>UDP</strong>：无连接的协议。发送数据之前不需要建立连接，直接将数据报发送到目标地址。</li></ul><p><strong>可靠性：</strong></p><ul><li><strong>TCP</strong>：提供可靠的数据传输服务。它保证数据包按顺序到达且不会丢失或损坏。如果出现问题，TCP会自动重传丢失的数据包，并确保数据完整性。</li><li><strong>UDP</strong>：不保证数据包的到达顺序、重复性或可靠性。数据可能丢失、重复或者乱序到达，但它的开销更小，速度更快。</li></ul><p><strong>流量控制与拥塞控制</strong>：</p><ul><li><strong>TCP</strong>：内置了流量控制和拥塞控制机制，能够根据网络状况调整发送速率，避免网络过载。</li><li><strong>UDP</strong>：没有内置的流量控制或拥塞控制功能，依赖于应用层来管理这些问题。</li></ul><p><strong>应用场景：</strong></p><ul><li><strong>TCP</strong>：适用于对数据准确性和顺序有严格要求的应用，如文件传输（FTP）、电子邮件（SMTP）、网页浏览（HTTP/HTTPS）等。</li><li><strong>UDP</strong>：适合对实时性要求高但对少量丢包不太敏感的应用，如视频会议、在线游戏、语音通话（VoIP）、直播流媒体等。</li></ul><h4 id="16-设计一个系统，使得发送方能够向接收方发送-1GB-数据，但不知道接收方的-IP-地址。"><a href="#16-设计一个系统，使得发送方能够向接收方发送-1GB-数据，但不知道接收方的-IP-地址。" class="headerlink" title="16.设计一个系统，使得发送方能够向接收方发送 1GB 数据，但不知道接收方的 IP 地址。"></a>16.设计一个系统，使得发送方能够向接收方发送 1GB 数据，但不知道接收方的 IP 地址。</h4><ul><li><strong>发送方发送 UDP 广播寻找接收方</strong></li><li><strong>接收方回复 IP</strong></li><li><strong>建立 TCP 连接并传输</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 发送 UDP 广播寻找接收方</span><br><span class="line"><span class="built_in">broadcast</span>(<span class="string">&quot;DATA_SEND_REQUEST&quot;</span>, port=<span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> 接收方回复 IP</span><br><span class="line">receiver_ip = <span class="built_in">wait_for_response</span>()</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span> 建立 TCP 连接并传输</span><br><span class="line">with <span class="built_in">TCPConnection</span>(receiver_ip, port=<span class="number">54321</span>) as conn:</span><br><span class="line">    conn.<span class="built_in">send_file</span>(<span class="string">&quot;1GB_data.bin&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="17-什么是网络拥塞？说一说TCP协议的拥塞控制？"><a href="#17-什么是网络拥塞？说一说TCP协议的拥塞控制？" class="headerlink" title="17.什么是网络拥塞？说一说TCP协议的拥塞控制？"></a>17.什么是网络拥塞？说一说TCP协议的拥塞控制？</h4><p><strong>网络拥塞：</strong>当网络中的流量过大时，可能会导致路由器或<strong>链路过载</strong>，进而引发<strong>丢包</strong>、延迟增加等问题。</p><p><strong>TCP 的拥塞控制机制：</strong></p><ul><li><p><strong>慢启动：</strong></p><ul><li><strong>目的</strong>：逐步探测网络的可用带宽。</li><li><strong>工作原理</strong>：<ul><li>初始阶段，发送方将拥塞窗口（<code>cwnd</code>）设置为一个较小的值</li><li>每收到一个确认（ACK），<code>cwnd</code> 值加倍（即指数增长）</li><li>当 <code>cwnd</code> 达到慢启动阈值（<code>ssthresh</code>）时，进入拥塞避免阶段</li></ul></li><li><strong>缺点</strong>：可能导致初期传输效率较低</li></ul></li><li><p><strong>拥塞避免：</strong></p><ul><li><strong>目的</strong>：平稳地增加发送速率，避免网络过载。</li><li><strong>工作原理</strong>：<ul><li><code>cwnd</code> 不再指数增长，而是线性增长（每次增加 1 个 MSS）</li><li>如果由于网络拥塞发生丢包，<code>ssthresh</code> 被设置为当前 <code>cwnd</code> 的一半，并重新进入慢启动阶段。</li></ul></li></ul></li><li><p><strong>快速重传：</strong></p><ul><li><p><strong>目的</strong>：快速恢复因丢包导致的传输中断。</p></li><li><p><strong>工作原理</strong>：当发送方收到 3 个重复的 ACK 时，认为某个数据包丢失。发送方立即重传丢失的数据包，而不必等待超时。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202504101621506.png" alt="image-20250410161758659" style="zoom:50%;"></p></li></ul></li><li><p><strong>快速恢复：</strong></p><ul><li><strong>目的</strong>：在快速重传后快速恢复正常的传输速率。</li><li><strong>工作原理</strong>：<ul><li>当检测到丢包并触发快速重传后，<code>ssthresh</code> 被设置为当前 <code>cwnd</code> 的一半。</li><li><code>cwnd</code> 被设置为 <code>ssthresh</code>，然后继续线性增长（拥塞避免）。</li></ul></li></ul></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504101625741.png" alt="image-20250410161817347" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-什么是TCP网络分层？&quot;&gt;&lt;a href=&quot;#1-什么是TCP网络分层？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是TCP网络分层？&quot;&gt;&lt;/a&gt;1.什么是TCP网络分层？&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://typoraim</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="网络" scheme="https://wangak.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用</title>
    <link href="https://wangak.cc/posts/b21cb050.html"/>
    <id>https://wangak.cc/posts/b21cb050.html</id>
    <published>2025-03-27T16:00:00.000Z</published>
    <updated>2025-03-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p><strong>IO多路复用：</strong>由内核检测多个文件描述符的状态，来解决传统的阻塞式的IO，可以提高CPU的利用率。另外，相比于多线程模型，每个连接都要一个独立的线程，所需的系统开销过大，而IO多路复用只有在连接准备好进行读写操作时，才进行处理。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line">    <span class="type">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set *exceptfds, <span class="keyword">struct</span> timeval * timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>nfds：</strong>委托内核检测的这三个集合中<strong>最大的文件描述符 + 1</strong></li><li><strong>readfds：</strong>需要检测<strong>读</strong>缓冲区的文件描述符的集合</li><li><strong>writefds：</strong>需要检测<strong>写</strong>缓冲区的文件描述符的集合</li><li><strong>exceptfds：</strong> 需要检测<strong>异常</strong>缓冲区的文件描述符的集合</li><li><strong>timeout：</strong>超时时长</li></ul><p><strong>常用操作函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将文件描述符fd从set集合中删除 == 将fd对应的标志位设置为0        </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"><span class="comment">// 判断文件描述符fd是否在set集合中 == 读一下fd对应的标志位到底是0还是1</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"><span class="comment">// 将文件描述符fd添加到set集合中 == 将fd对应的标志位设置为1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"><span class="comment">// 将set集合中, 所有文件文件描述符对应的标志位设置为0, 集合中没有添加任何文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>select的局限性：</strong></p><ul><li><strong>频繁的数据复制：</strong>因为用户态和内核态之间存在严格的隔离，调用 <code>select</code> 函数会进行数据的拷贝（将文件描述符集合拷贝到内核空间，再将修改后的集合复制回用户空间），这种频繁的数据复制操作会带来额外的系统开销</li><li><strong>线性扫描：</strong>待检测文件描述符集合采取的是线性扫描的方式进行检查。</li><li><strong>默认最大文件描述符数限制</strong>：<code>select</code> 可以检测的最大文件描述符数量通常是有限制的，默认情况下这个值是 1024（由宏 <code>FD_SETSIZE</code> 定义）。</li></ul><h4 id="通信代码"><a href="#通信代码" class="headerlink" title="通信代码"></a>通信代码</h4><ul><li><p><strong>服务器端代码如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的fd</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    <span class="built_in">listen</span>(lfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的fd的状态检测委托给内核检测</span></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line">    <span class="comment">// 初始化检测的读集合</span></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    fd_set rdtemp;</span><br><span class="line">    <span class="comment">// 清零</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;rdset);</span><br><span class="line">    <span class="comment">// 将监听的lfd设置到检测的读集合中</span></span><br><span class="line">    <span class="built_in">FD_SET</span>(lfd, &amp;rdset);</span><br><span class="line">    <span class="comment">// 通过select委托内核检测读集合中的文件描述符状态, 检测read缓冲区有没有数据</span></span><br><span class="line">    <span class="comment">// 如果有数据, select解除阻塞返回</span></span><br><span class="line">    <span class="comment">// 应该让内核持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 默认阻塞</span></span><br><span class="line">        <span class="comment">// rdset 中是委托内核检测的所有的文件描述符</span></span><br><span class="line">        rdtemp = rdset;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">select</span>(maxfd+<span class="number">1</span>, &amp;rdtemp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// rdset中的数据被内核改写了, 只保留了发生变化的文件描述的标志位上的1, 没变化的改为0</span></span><br><span class="line">        <span class="comment">// 只要rdset中的fd对应的标志位为1 -&gt; 缓冲区有数据了</span></span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="comment">// 有没有新连接</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(lfd, &amp;rdtemp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 接受连接请求, 这个调用不阻塞</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliaddr;</span><br><span class="line">            <span class="type">int</span> cliLen = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">            <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;cliLen);</span><br><span class="line"><span class="comment">//accept会返回用于通信的文件描述符</span></span><br><span class="line">            <span class="comment">// 得到了有效的文件描述符</span></span><br><span class="line">            <span class="comment">// 通信的文件描述符添加到读集合</span></span><br><span class="line">            <span class="comment">// 在下一轮select检测的时候, 就能得到缓冲区的状态</span></span><br><span class="line">            <span class="built_in">FD_SET</span>(cfd, &amp;rdset);</span><br><span class="line">            <span class="comment">// 重置最大的文件描述符</span></span><br><span class="line">            maxfd = cfd &gt; maxfd ? cfd : maxfd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有新连接, 通信</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;maxfd+<span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">// 判断从监听的文件描述符之后到maxfd这个范围内的文件描述符是否读缓冲区有数据</span></span><br><span class="line">            <span class="keyword">if</span>(i != lfd &amp;&amp; <span class="built_in">FD_ISSET</span>(i, &amp;rdtemp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="comment">// 一次只能接收10个字节, 客户端一次发送100个字节</span></span><br><span class="line">                <span class="comment">// 一次是接收不完的, 文件描述符对应的读缓冲区中还有数据</span></span><br><span class="line">                <span class="comment">// 下一轮select检测的时候, 内核还会标记这个文件描述符缓冲区有数据 -&gt; 再读一次</span></span><br><span class="line">                <span class="comment">// 循环会一直持续, 知道缓冲区数据被读完位置</span></span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">read</span>(i, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端关闭了连接...\n&quot;</span>);</span><br><span class="line">                    <span class="comment">// 将检测的文件描述符从读集合中删除</span></span><br><span class="line">                    <span class="built_in">FD_CLR</span>(i, &amp;rdset);</span><br><span class="line">                    <span class="built_in">close</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 收到了数据</span></span><br><span class="line">                    <span class="comment">// 发送数据</span></span><br><span class="line">                    <span class="built_in">write</span>(i, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 异常</span></span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>客户端代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;     <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);   <span class="comment">// 服务器监听的端口, 字节序应该是网络字节序</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        <span class="comment">// sprintf(recvBuf, &quot;data: %d\n&quot;, i++);</span></span><br><span class="line">        <span class="built_in">fgets</span>(recvBuf, <span class="built_in">sizeof</span>(recvBuf), stdin);</span><br><span class="line">        <span class="built_in">write</span>(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">        <span class="built_in">read</span>(fd, recvBuf, <span class="built_in">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">close</span>(fd); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>对于待检测集合<code>select</code>和<code>poll</code>是基于线性方式处理的，epoll是基于红黑树来管理待检测集合的。</p><p>epoll实例就是一棵树，每个节点是<code>epoll_event</code>的结构体，结构体里有<strong><code>events</code></strong> 字段描述文件描述符的事件类型，还有<code>data</code>字段是一个联合体类型，通常存储对应的文件描述符</p><h4 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h4><p><strong>操作函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建epoll实例，通过一棵红黑树管理待检测集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">// 管理红黑树上的文件描述符(添加、修改、删除)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">// 检测epoll树中是否有就绪的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>struct epoll_event:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合体, 多个变量共用同一块内存        </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line"> <span class="type">void</span>        *ptr;</span><br><span class="line"><span class="type">int</span>          fd;<span class="comment">// 通常情况下使用这个成员, 和epoll_ctl的第三个参数相同即可</span></span><br><span class="line"><span class="type">uint32_t</span>     u32;</span><br><span class="line"><span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line"><span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="comment">//通常使用data.fd，将其设置为当前event的文件描述符</span></span><br><span class="line"><span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="通信代码（服务端）"><a href="#通信代码（服务端）" class="headerlink" title="通信代码（服务端）"></a>通信代码（服务端）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">// 本地多有的ＩＰ</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="comment">// 所有的文件描述符对应读写缓冲区状态都是委托内核进行检测的epoll</span></span><br><span class="line">    <span class="comment">// 创建一个epoll模型</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往epoll实例中添加需要检测的节点, 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.events = EPOLLIN;    <span class="comment">// 检测lfd读读缓冲区是否有数据</span></span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> evs[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">sizeof</span>(evs) / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="comment">// 持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用一次, 检测一次</span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">epoll_wait</span>(epfd, evs, size, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出当前的文件描述符</span></span><br><span class="line">            <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">            <span class="comment">// 判断这个文件描述符是不是用于监听的</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建立新的连接</span></span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">                ev.events = EPOLLIN;    <span class="comment">// 读缓冲区是否有数据</span></span><br><span class="line">                ev.data.fd = cfd;</span><br><span class="line">                ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl-accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理通信的文件描述符</span></span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">recv</span>(curfd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端已经断开了连接\n&quot;</span>);</span><br><span class="line">                    <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">close</span>(curfd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">                    <span class="built_in">send</span>(curfd, buf, len, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="epoll的工作模式"><a href="#epoll的工作模式" class="headerlink" title="epoll的工作模式"></a>epoll的工作模式</h4><p><strong>水平触发模式（LT）</strong></p><ul><li><strong>持续性通知</strong>：只要文件描述符处于就绪状态（例如，有数据可以读取），就会持续通知应用。这意味着即使你不处理完所有可用的数据，下一次调用<code>epoll_wait</code>时，如果该文件描述符仍然准备好进行操作，它将继续被包含在返回的事件列表中。</li><li><strong>易于使用</strong>：因为其持续通知特性，编程相对简单，不容易错过事件。</li><li><strong>效率</strong>：由于可能会多次通知同一个就绪状态，这在高并发场景下可能导致一定的性能损耗。</li></ul><p><strong>边沿触发模式（ET）</strong></p><ul><li><strong>一次性通知</strong>：<strong>仅当文件描述符的状态发生变化（例如，从不可读变为可读）时发出通知。</strong>这意味着如果你没有完全读取或写入所有数据，在下一次调用<code>epoll_wait</code>时可能不会再收到关于这个文件描述符的通知，除非它的状态再次改变。</li><li><strong>高效性</strong>：减少重复通知的数量，提高效率，特别适用于高负载的网络服务器等场景。</li><li><strong>复杂性增加</strong>：需要更细致地管理I/O操作，通常要求使用非阻塞I/O，并且需要确保每次触发时尽可能多地处理数据，以避免丢失事件。</li></ul><p><strong>ET模式的设置:</strong> 水平触发模式（LT）是默认的模式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">ev.events = EPOLLIN | EPOLLET;<span class="comment">// 设置边沿模式</span></span><br></pre></td></tr></table></figure><p><strong>边沿触发模式需要设置为阻塞</strong></p><p>边沿触发模式需要一次性操作缓冲区的全部数据，所以需要使用循环的结构操作数据，那么要将文件描述符设置为非阻塞，过程使用<code>fcntl()</code>进行处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置完成之后, 读写都变成了非阻塞模式</span></span><br><span class="line"><span class="type">int</span> flag = <span class="built_in">fcntl</span>(cfd, F_GETFL);</span><br><span class="line">flag |= O_NONBLOCK;                                                        </span><br><span class="line"><span class="built_in">fcntl</span>(cfd, F_SETFL, flag);</span><br></pre></td></tr></table></figure><p><em>注：当缓冲区数据被读完了，调用的read()/recv()函数还会继续从缓冲区中读数据，此时函数调用就失败了，返回-1，对应的全局变量 <code>errno</code> 值为<code>EAGAIN</code>或者 <code>EWOULDBLOCK</code></em></p><p><strong>边沿触发模式的通信代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">// 本地多有的ＩＰ</span></span><br><span class="line">    <span class="comment">// 127.0.0.1</span></span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr.s_addr);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">64</span>);<span class="comment">//将 Socket 设置为监听状态</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="comment">// 所有的文件描述符对应读写缓冲区状态都是委托内核进行检测的epoll</span></span><br><span class="line">    <span class="comment">// 创建一个epoll模型</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往epoll实例中添加需要检测的节点, 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.events = EPOLLIN;    <span class="comment">// 检测lfd读读缓冲区是否有数据</span></span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> evs[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">sizeof</span>(evs) / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="comment">// 持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用一次, 检测一次</span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">epoll_wait</span>(epfd, evs, size, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;==== num: %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出当前的文件描述符</span></span><br><span class="line">            <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">            <span class="comment">// 判断这个文件描述符是不是用于监听的</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建立新的连接</span></span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">// 将文件描述符设置为非阻塞</span></span><br><span class="line">                <span class="comment">// 得到文件描述符的属性</span></span><br><span class="line">                <span class="type">int</span> flag = <span class="built_in">fcntl</span>(cfd, F_GETFL);</span><br><span class="line">                flag |= O_NONBLOCK;</span><br><span class="line">                <span class="built_in">fcntl</span>(cfd, F_SETFL, flag);</span><br><span class="line">                <span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">                <span class="comment">// 通信的文件描述符检测读缓冲区数据的时候设置为边沿模式</span></span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;    <span class="comment">// 读缓冲区是否有数据</span></span><br><span class="line">                ev.data.fd = cfd;</span><br><span class="line">                ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl-accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理通信的文件描述符</span></span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                <span class="comment">// 循环读数据</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> len = <span class="built_in">recv</span>(curfd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 非阻塞模式下和阻塞模式是一样的 =&gt; 判断对方是否断开连接</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">                        <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">                        <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="built_in">close</span>(curfd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 通信</span></span><br><span class="line">                        <span class="comment">// 接收的数据打印到终端</span></span><br><span class="line">                        <span class="built_in">write</span>(STDOUT_FILENO, buf, len);</span><br><span class="line">                        <span class="comment">// 发送数据</span></span><br><span class="line">                        <span class="built_in">send</span>(curfd, buf, len, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// len == -1</span></span><br><span class="line">                        <span class="keyword">if</span>(errno == EAGAIN)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;数据读完了...\n&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h3><p>1.为什么epoll的边沿模式要使用<code>fcntl</code>将文件描述符设置为非阻塞？</p><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IO多路复用&quot;&gt;&lt;a href=&quot;#IO多路复用&quot; class=&quot;headerlink&quot; title=&quot;IO多路复用&quot;&gt;&lt;/a&gt;IO多路复用&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;IO多路复用：&lt;/strong&gt;由内核检测多个文件描述符的状态，来解决传统的阻塞式的IO，可</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="网络" scheme="https://wangak.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C++八股7</title>
    <link href="https://wangak.cc/posts/d4769a69.html"/>
    <id>https://wangak.cc/posts/d4769a69.html</id>
    <published>2025-03-26T16:00:00.000Z</published>
    <updated>2025-03-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么是STL？"><a href="#1-什么是STL？" class="headerlink" title="1. 什么是STL？"></a>1. 什么是STL？</h4><p>STL，即标准模板库</p><p><strong>STL</strong>从广义上讲主要包括三大部分：<strong>算法、容器和迭代器。</strong></p><h4 id="2-什么是RAII？"><a href="#2-什么是RAII？" class="headerlink" title="2. 什么是RAII？"></a>2. 什么是RAII？</h4><p>RAII 的全称是 <strong>Resource Acquisition Is Initialization</strong>（资源获取即初始化），这是一种 C++ 中的<strong>编程范式</strong>，用于管理资源（如内存、文件句柄、网络连接等）的生命周期。</p><p><strong>资源的分配与对象的构造绑定</strong>：在对象创建时（调用构造函数）申请或分配资源。</p><p><strong>资源的释放与对象的析构绑定</strong>：在对象销毁时（调用析构函数）自动释放资源。</p><p>智能指针（<code>std::shared_ptr</code>和<code>std::unique_ptr</code>）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记<code>delete</code>造成的内存泄漏。</p><h4 id="3-it-和-it-的区别以及哪个更好"><a href="#3-it-和-it-的区别以及哪个更好" class="headerlink" title="3.++it 和 it++ 的区别以及哪个更好?"></a>3.<code>++it</code> 和 <code>it++</code> 的区别以及哪个更好?</h4><p><strong>前置递增 (<code>++it</code>)</strong>：不需要额外创建临时对象，因此效率更高。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;  <span class="comment">// 将当前对象加 1</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后置递增 (<code>it++</code>)</strong>：后置递增首先会创建一个临时对象来保存当前值，然后调用前置递增操作修改当前对象的值，最后返回临时对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="type">int</span> temp = *<span class="keyword">this</span>; <span class="comment">// 创建一个临时对象保存当前值</span></span><br><span class="line">    ++*<span class="keyword">this</span>;          <span class="comment">// 调用前置递增操作，将当前对象加 1</span></span><br><span class="line">    <span class="keyword">return</span> temp;      <span class="comment">// 返回临时对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202504131432347.png" alt="image-20250326142820411" style="zoom:50%;"></p><h4 id="4-简述哈希表的基本原理？什么是哈希冲突？有哪些解决方法？"><a href="#4-简述哈希表的基本原理？什么是哈希冲突？有哪些解决方法？" class="headerlink" title="4. 简述哈希表的基本原理？什么是哈希冲突？有哪些解决方法？"></a>4. 简述哈希表的基本原理？什么是哈希冲突？有哪些解决方法？</h4><p><strong>哈希表的基本原理：</strong>通过一个哈希函数将键（Key）映射到一个固定范围的索引位置（桶，Bucket）</p><ul><li><p><strong>哈希函数计算</strong>：将键（Key）通过哈希函数转换为一个整数值（哈希值）。</p></li><li><p><strong>映射到桶</strong>：根据哈希值确定数据在哈希表中的存储位置（桶）。</p></li><li><p><strong>插入或查找</strong>：将数据存入对应的桶中，或者从桶中查找数据。</p></li></ul><p><strong>哈希冲突：</strong> 不同的键通过哈希函数映射到同一个哈希值。</p><p><strong>解决哈希冲突的方法：</strong></p><ul><li><p><strong>链地址法： </strong>每个桶维护一个链表（或其他数据结构），当发生冲突时，将冲突的键值对存储在链表中。</p></li><li><p><strong>开放地址法：</strong></p><p><strong>常见的探测方法有：</strong></p><ul><li><strong>线性探测（Linear Probing）</strong>：依次检查当前桶的下一个桶。</li><li><strong>二次探测（Quadratic Probing）</strong>：以平方递增的方式检查桶。</li><li><strong>双重哈希（Double Hashing）</strong>：使用第二个哈希函数计算步长。</li></ul></li><li><p><strong>再哈希法</strong></p><ul><li><strong>使用多个哈希函数</strong>，当第一个哈希函数发生冲突时，尝试使用第二个哈希函数重新计算位置。</li><li>优点：减少冲突的概率。</li><li>缺点：增加了计算复杂度。</li></ul></li></ul><p><strong>STL中的hashtable使用的是链地址法解决hash冲突问题</strong></p><h4 id="5-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素-STL-中vector删除其中的元素，迭代器如何变化？"><a href="#5-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素-STL-中vector删除其中的元素，迭代器如何变化？" class="headerlink" title="5.vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素?STL 中vector删除其中的元素，迭代器如何变化？"></a>5.vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素?STL 中vector删除其中的元素，迭代器如何变化？</h4><p><strong><code>vector</code></strong>：</p><ul><li>基于动态数组实现，内存是连续的。</li><li>支持高效的随机访问（时间复杂度为 O(1)），因为可以通过索引直接定位到任意元素。</li><li>插入和删除操作效率较低（时间复杂度为 O(n)），因为在中间或头部插入/删除时需要移动大量数据。</li><li>动态扩容：当容量不足时，会重新分配更大的内存块，并将原有数据拷贝到新内存中。</li></ul><p><strong><code>list</code></strong>：</p><ul><li>基于双向链表实现，内存是非连续的。</li><li>不支持随机访问（时间复杂度为 O(n)），需要通过遍历链表才能访问指定位置的元素。</li><li>插入和删除操作效率高（时间复杂度为 O(1)），只需要修改相关节点的指针即可。</li><li>每个节点包含三个部分：元素值、指向前一个节点的指针（prev）和指向后一个节点的指针（next）。</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504131432772.png" alt="image-20250326150309901" style="zoom: 50%;"></p><p><strong>如何找到 <code>vector</code> 或 <code>list</code> 的倒数第二个元素：</strong></p><ul><li><p>由于 <code>vector</code> 支持随机访问，可以通过下标直接访问倒数第二个元素</p></li><li><p>由于 <code>list</code> 不支持随机访问，无法通过下标直接访问元素。但可以使用反向迭代器来访问倒数第二个元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (lst.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = lst.<span class="built_in">rbegin</span>(); <span class="comment">// 反向迭代器，指向最后一个元素</span></span><br><span class="line">        ++it;                   <span class="comment">// 移动到倒数第二个元素</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The second last element is: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;List has fewer than 2 elements.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>vector中的迭代器在使用后就失效了，而list的迭代器在使用之后还可以继续使用。</strong></p><p><strong><code>vector</code> 的迭代器失效</strong>：</p><ul><li><p><code>vector</code> 是基于连续内存的动态数组实现的。当发生插入或删除操作时，可能会导致内存重新分配（例如扩容），或者需要移动元素以保持连续性。这种情况下，原有的迭代器可能指向无效的内存地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>() + <span class="number">2</span>; <span class="comment">// 指向第三个元素（值为 3）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before insertion: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">10</span>); <span class="comment">// 在第二个位置插入元素 10</span></span><br><span class="line">    <span class="comment">// 尝试访问迭代器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After insertion: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl; <span class="comment">// 可能导致未定义行为</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>list</code> 的迭代器失效</strong>：</p><ul><li><p><code>list</code> 是基于双向链表实现的，每个节点独立存储，并通过指针连接。插入和删除操作只会影响相邻节点的指针，而不会影响其他节点的地址。因此，<code>list</code> 的迭代器在插入或删除后通常仍然有效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">next</span>(lst.<span class="built_in">begin</span>(), <span class="number">2</span>); <span class="comment">// 指向第三个元素（值为 3）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before insertion: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    lst.<span class="built_in">insert</span>(std::<span class="built_in">next</span>(lst.<span class="built_in">begin</span>(), <span class="number">1</span>), <span class="number">10</span>); <span class="comment">// 在第二个位置插入元素 10</span></span><br><span class="line">    <span class="comment">// 继续访问迭代器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After insertion: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl; <span class="comment">// 安全且正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：<code>std::next</code>: 基于给定的迭代器，向前或向后移动指定的步数，返回一个新的迭代器。</em></p></li></ul><h4 id="6-reserve-和-resize-的区别"><a href="#6-reserve-和-resize-的区别" class="headerlink" title="6. reserve 和 resize 的区别"></a>6. <code>reserve</code> 和 <code>resize</code> 的区别</h4><p><strong><code>reserve(n)</code></strong>： 只分配内存，不影响元素数量。</p><ul><li>只改变 <code>capacity()</code>，即预分配的总空间大小。</li><li>不会改变 <code>size()</code>，也不会初始化新分配的内存。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">10</span>); <span class="comment">// 预分配 10 个元素的空间</span></span><br><span class="line">std::cout &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>(); <span class="comment">// 输出：0 10</span></span><br></pre></td></tr></table></figure><p><code>resize</code>:  改变元素数量，并可能分配更多内存。</p><ul><li>改变 <code>size()</code>，即实际存储的元素数量</li><li>如果 <code>n &gt; size()</code>，会初始化新增的元素（对于基本类型，默认初始化为 0）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">10</span>); <span class="comment">// 调整大小为 10</span></span><br><span class="line">std::cout &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>(); <span class="comment">// 输出：10 10</span></span><br></pre></td></tr></table></figure><h4 id="7-容器内部删除一个元素"><a href="#7-容器内部删除一个元素" class="headerlink" title="7. 容器内部删除一个元素"></a>7. 容器内部删除一个元素</h4><p><strong>顺序容器(</strong><code>vector</code>、<code>deque</code><strong>):</strong></p><ul><li><p><code>erase(it)</code> 不仅会使被删除元素的迭代器失效，还会使被删除元素之后的所有迭代器失效。</p></li><li><p><strong>不能使用 <code>erase(it++)</code></strong></p></li><li><p><strong>正确的删除方式</strong>：<code>erase</code> 的返回值是下一个有效的迭代器，可以直接赋值给当前迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = c.<span class="built_in">begin</span>(); it != c.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (需要删除(*it)) &#123;</span><br><span class="line">        it = c.<span class="built_in">erase</span>(it); <span class="comment">// erase 返回下一个有效迭代器</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it; <span class="comment">// 如果不删除，则正常递增迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>关联容器（<code>map</code>、<code>set</code>、<code>multimap</code>、<code>multiset</code>）</strong></p><ul><li>可以安全地使用 <code>erase(it++)</code></li></ul><h4 id="8-map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？-为什么使用红黑树？"><a href="#8-map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？-为什么使用红黑树？" class="headerlink" title="8.map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？"></a>8.map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？</h4><p><strong><code>map</code> 和 <code>set</code> 的底层实现:</strong></p><ul><li><code>map</code> 和 <code>set</code> 是 C++ STL 中的关联容器，它们的底层实现通常基于<strong>红黑树</strong>。红黑树是一种自平衡二叉搜索树，它能够在插入、删除和查找操作中保持对数时间复杂度 <script type="math/tex">O(log⁡n)</script>。</li></ul><p><strong>红黑树的核心特性</strong>：</p><ul><li>每个节点要么是红色，要么是黑色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL 节点）是黑色。</li><li>如果一个节点是红色，那么它的两个子节点必须是黑色（即没有连续的红色节点）。</li><li>从任意节点到其每个叶子的所有路径都包含相同数量的黑色节点。</li></ul><p><strong><code>map</code> 和 <code>set</code> 的区别</strong>：</p><ul><li><p><strong><code>set</code></strong>：</p><ul><li>底层红黑树的节点数据类型为 <strong><code>key</code></strong>（即存储的值本身）。</li><li>插入和查找时，直接根据 <code>key</code> 进行操作。</li></ul></li><li><p><strong><code>map</code></strong>：</p><ul><li>底层红黑树的节点数据类型为 <strong><code>key + value</code></strong>（即键值对）。</li><li>插入和查找时，根据 <code>key</code> 进行操作，但节点中还存储了与 <code>key</code> 对应的 <code>value</code>。</li></ul></li></ul><p><strong>为什么使用红黑树？</strong></p><ul><li><p><strong>自动排序</strong>：红黑树作为一种二叉搜索树，能够自然地按照 <code>key</code> 的顺序组织数据。</p></li><li><p><strong>时间复杂度低</strong>：红黑树的操作（如插入、删除、查找）的时间复杂度为 <script type="math/tex">O(log⁡n)</script>，这比线性时间复杂度 <script type="math/tex">O(n)</script>​高效得多。</p><p><em>注：相比于 AVL 树，在插入和删除时的调整开销较小。</em></p></li></ul><h4 id="9-关于this指针你知道什么？"><a href="#9-关于this指针你知道什么？" class="headerlink" title="9.关于this指针你知道什么？"></a>9.关于this指针你知道什么？</h4><ul><li><p><code>this</code> 是一个常量指针（<code>const pointer</code>），指向当前对象的首地址。</p></li><li><p>它是一个隐含参数，编译器会自动将其<strong>作为非静态成员函数的第一个参数传递给函数。</strong></p><p><strong><code>this</code> 指针的作用：</strong></p></li><li><p><strong>访问类的成员</strong></p></li><li><strong>返回当前对象</strong>： 可以直接使用 <code>return *this;</code></li></ul><p><strong><code>this</code> 指针是什么时候创建的？</strong></p><ul><li><code>this</code> 指针在调用成员函数时由编译器生成，并在成员函数执行结束后销毁。</li></ul><h4 id="10-a-10-b-30-如何不使用新的变量交换两个数"><a href="#10-a-10-b-30-如何不使用新的变量交换两个数" class="headerlink" title="10.a=10,b=30,如何不使用新的变量交换两个数"></a>10.a=10,b=30,如何不使用新的变量交换两个数</h4><p><strong>使用异或：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 交换逻辑</span></span><br><span class="line">    a = a ^ b; <span class="comment">// a = 10 ^ 30</span></span><br><span class="line">    b = a ^ b; <span class="comment">// b = (10 ^ 30) ^ 30 = 10</span></span><br><span class="line">    a = a ^ b; <span class="comment">// a = (10 ^ 30) ^ 10 = 30</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-双端队列（deque-是否支持随机访问？"><a href="#11-双端队列（deque-是否支持随机访问？" class="headerlink" title="11.双端队列（deque)是否支持随机访问？"></a>11.双端队列（deque)是否支持随机访问？</h4><p><strong><code>std::deque</code>（双端队列）</strong>是 C++ STL 中的一个容器，支持在两端高效地插入和删除元素。它的底层实现基于<strong>分段连续存储结构</strong>，每个段是一个固定大小的连续内存块，这些<strong>段通过指针链接起来</strong>。这种设计使得 <code>std::deque</code> 能够在两端进行高效的插入操作。</p><p><strong><code>std::deque</code></strong>支持随机访问，可以通过下标直接访问任意位置的元素。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202504131432727.png" alt="image-20250326193256814" style="zoom: 50%;"></p><p>12.举三个智能指针的应用场景</p><ul><li><p><strong><code>std::shared_ptr</code> 在多线程编程中保证线程安全的引用计数</strong></p><p>在多线程环境中，多个线程可能需要共享同一个对象（例如数据库连接池、配置文件对象等），并且需要确保对象在所有线程都使用完毕后才被释放。<code>std::shared_ptr</code> 的引用计数是线程安全的，因此可以用来实现这种共享。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseConnection</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">const</span> std::string&amp; sql)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Executing query: &quot;</span> &lt;&lt; sql &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadTask</span><span class="params">(std::shared_ptr&lt;DatabaseConnection&gt; conn, <span class="type">const</span> std::string&amp; queryStr)</span> </span>&#123;</span><br><span class="line">    conn-&gt;<span class="built_in">query</span>(queryStr); <span class="comment">// 使用共享的数据库连接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> dbConn = std::<span class="built_in">make_shared</span>&lt;DatabaseConnection&gt;(); <span class="comment">// 创建一个共享的数据库连接</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadTask, dbConn, <span class="string">&quot;SELECT * FROM users&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(threadTask, dbConn, <span class="string">&quot;SELECT * FROM products&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>(); <span class="comment">// 等待线程1完成</span></span><br><span class="line">    t2.<span class="built_in">join</span>(); <span class="comment">// 等待线程2完成</span></span><br><span class="line">    <span class="comment">// 当所有线程都完成后，dbConn 自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::unique_ptr</code> 在工厂模式中返回独占所有权的对象</strong></p><p><code>std::unique_ptr</code> 明确表示对象的所有权不可共享。</p></li><li><p><strong><code>std::weak_ptr</code>：检测对象是否已被销毁</strong></p><p>使用 <code>std::weak_ptr</code> 来检测对象是否仍然有效（即是否已经被销毁）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Event triggered!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;EventListener&gt; listener = std::<span class="built_in">make_shared</span>&lt;EventListener&gt;();</span><br><span class="line">    std::weak_ptr&lt;EventListener&gt; weakListener = listener; <span class="comment">// 创建弱引用</span></span><br><span class="line">    <span class="comment">// 模拟事件触发</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> strongListener = weakListener.<span class="built_in">lock</span>()) &#123; <span class="comment">// 尝试提升为 shared_ptr</span></span><br><span class="line">        strongListener-&gt;<span class="built_in">onEvent</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Listener has been destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 销毁 listener</span></span><br><span class="line">    listener.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="comment">// 再次尝试触发事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> strongListener = weakListener.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">        strongListener-&gt;<span class="built_in">onEvent</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Listener has been destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：<code>weakListener.lock()</code> 是 C++ 中 <code>std::weak_ptr</code> 提供的一个成员函数，用于尝试将弱引用（<code>std::weak_ptr</code>）提升为强引用（<code>std::shared_ptr</code>）。它的主要作用是检查底层对象是否仍然存在，并在对象有效时返回一个 <code>std::shared_ptr</code>。对象不存在返回空指针。</em></p></li></ul><h4 id="12-举例说明万能引用和完美转发的作用"><a href="#12-举例说明万能引用和完美转发的作用" class="headerlink" title="12.举例说明万能引用和完美转发的作用"></a>12.举例说明万能引用和完美转发的作用</h4><p><strong>万能引用</strong>： 指的是那些<strong>可以绑定到左值引用或右值引用的引用类型</strong></p><p>当一个模板函数的参数类型为 <code>T&amp;&amp;</code> 并且 <code>T</code> 是通过模板参数推导出来的，则该参数是一个万能引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayType</span><span class="params">(T&amp;&amp; val)</span> </span>&#123; <span class="comment">// 这里 T&amp;&amp; 是一个万能引用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">displayType</span>(x);        <span class="comment">// 左值传递给万能引用</span></span><br><span class="line">    <span class="built_in">displayType</span>(<span class="number">20</span>);       <span class="comment">// 右值传递给万能引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>完美转发:</strong></p><p><strong>完美转发:</strong> 允许函数模板将参数按其原始形式（包括值类别：左值或右值）转发给另一个函数。这意味着如果传入的是一个右值，那么它将以右值的形式被转发；如果是左值，则以左值的形式被转发。</p><ul><li><p><strong>完美转发</strong>借助于万能引用和 <code>std::forward</code>，能够让函数模板准确地将参数按照它们的原始类型和值类别转发给其他函数，保持了参数的特性和优化机会</p></li><li><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;utility&gt; // std::forward 所在头文件// 一个简单的函数，用于接收左值或右值void process(int&amp; x) &#123;    std::cout &lt;&lt; &quot;Lvalue reference: &quot; &lt;&lt; x &lt;&lt; std::endl;&#125;void process(int&amp;&amp; x) &#123;    std::cout &lt;&lt; &quot;Rvalue reference: &quot; &lt;&lt; x &lt;&lt; std::endl;&#125;// 模板函数，使用 std::forward 实现完美转发template&lt;typename T&gt;void wrapper(T&amp;&amp; arg) &#123;    process(std::forward&lt;T&gt;(arg)); // 使用 std::forward 转发参数&#125;int main() &#123;    int x = 42;    wrapper(x);       // 传入左值    wrapper(42);      // 传入右值    return 0;&#125;</code></pre></li></ul><h4 id="13-extern-“C”的作用"><a href="#13-extern-“C”的作用" class="headerlink" title="13.extern “C”的作用"></a>13.extern “C”的作用</h4><p><strong>extern “C”：</strong> 用于告诉编译器按照C语言的方式编译和链接函数或变量，来解决兼容性的问题。</p><p><strong>为什么需要extern “C”？</strong></p><p><strong>C++:</strong> 支持函数重载，在编译时会修改函数名，加入参数类型信息。</p><p><strong>C:</strong> 不支持重载，编译后函数名不会改变。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-什么是STL？&quot;&gt;&lt;a href=&quot;#1-什么是STL？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是STL？&quot;&gt;&lt;/a&gt;1. 什么是STL？&lt;/h4&gt;&lt;p&gt;STL，即标准模板库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STL&lt;/strong&gt;从广</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>套接字通信</title>
    <link href="https://wangak.cc/posts/d3b8d1d4.html"/>
    <id>https://wangak.cc/posts/d3b8d1d4.html</id>
    <published>2025-03-25T16:00:00.000Z</published>
    <updated>2025-03-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="套接字通信"><a href="#套接字通信" class="headerlink" title="套接字通信"></a>套接字通信</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><h4 id="1-1-局域网和广域网"><a href="#1-1-局域网和广域网" class="headerlink" title="1.1 局域网和广域网"></a>1.1 局域网和广域网</h4><p><strong>局域网：</strong>局域网将<strong>一定区域内</strong>的各种计算机、外部设备和数据库连接起来形成计算机通信的<strong>私有网络</strong>。、</p><ul><li>局域网的主要特点是传输速度快、延迟低、成本较低且安全性高。</li></ul><p><strong>广域网：</strong>又称广域网、外网、公网。是<strong>连接不同地区局域网</strong>或城域网计算机通信的远程<strong>公共网络</strong>。</p><ul><li>广域网相对于局域网来说，传输速度较慢，延迟较高。</li></ul><h4 id="1-2-IP和端口"><a href="#1-2-IP和端口" class="headerlink" title="1.2 IP和端口"></a>1.2 IP和端口</h4><p><strong>IP:</strong> 是分配给网络上每个<strong>设备的唯一标识符</strong>，用于在网络中进行通信。</p><ul><li><p><strong>IPv4</strong></p><ul><li>IPv4使用32位整数来表示一个IP地址，这相当于<strong>4个字节</strong>。通常，这个32位的地址被分为四部分，每部分8位（1字节），并<strong>以点分十进制格式表示。</strong></li><li>最小的IPv4地址是 <code>0.0.0.0</code>，而最大的是 <code>255.255.255.255</code></li><li>鉴于IPv4采用32位地址，理论上总共可以提供 <script type="math/tex">2^{32}</script>​个不同的地址</li></ul></li><li><p><strong>IPv6</strong></p><ul><li>IPv6使用128位整数来表示一个IP地址，等同于<strong>16个字节</strong>。</li><li>Pv6地址<strong>写作8组，每组4个十六进制数字</strong>，各组之间<strong>用冒号分隔</strong>，例如 <code>2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b</code>。</li><li>由于IPv6采用128位地址长度，所以它可以提供的地址总数为 <script type="math/tex">2^{128}</script></li></ul></li></ul><p><strong>端口: 用于定位主机上的特定进程。</strong></p><ul><li><p>端口号是一个16位的无符号整数（<code>unsigned short</code>），<strong>其取值范围是0到65535（<script type="math/tex">2^{16}−1</script>​）</strong></p></li><li><p><strong>只有那些涉及网络通信的进程才需要绑定端口。</strong>如果一个进程不需要与网络上的其他设备进行通信，那么它就不必绑定端口。</p></li><li><p><strong>一个端口可以被重复使用吗？</strong></p><p>在任何给定时间，<strong>一个具体的端口只能由一个进程独占使用</strong>。这意味着在同一时刻，多个进程不能同时监听同一个端口以接收数据。然而，一旦某个进程完成了对特定端口的使用并释放了它，该端口就可以被新的进程重新绑定和使用。此外，在一些情况下，如<strong>TCP连接结束后，可能会有一段等待时间（TIME_WAIT状态），在此期间端口暂时不可用，以确保网络上的数据包不会被错误地路由到新建立的连接上。</strong></p></li></ul><h4 id="1-3-网络分层模型"><a href="#1-3-网络分层模型" class="headerlink" title="1.3 网络分层模型"></a>1.3 网络分层模型</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202503282055052.png" alt="image-20250325150840912" style="zoom:67%;"></p><ul><li><p><strong>应用层</strong>：直接为用户提供服务，负责处理特定的应用程序细节。</p></li><li><p><strong>表示层</strong>：将数据转换为兼容格式进行传输，包括加密、压缩等操作。</p></li><li><strong>会话层</strong>：管理不同机器上进程之间的对话，控制对话连接的建立和终止。</li><li><strong>传输层</strong>：确保端到端的数据可靠传输，提供错误检测和恢复功能。主要协议有TCP和UDP。</li><li><strong>网络层</strong>：负责数据包的路由选择和转发，决定数据如何从源地址到达目的地址。IP协议工作在此层。</li><li><strong>数据链路层</strong>：在不可靠的物理连接上提供可靠的数据传输，处理错误检测和纠正。以太网协议工作于此层。</li><li><strong>物理层</strong>：定义了硬件设备的标准，如电压水平、线缆类型、针脚布局等，以及如何通过物理媒介传输比特流。</li></ul><h3 id="2-socket编程"><a href="#2-socket编程" class="headerlink" title="2.socket编程"></a>2.socket编程</h3><h4 id="2-1-字节序"><a href="#2-1-字节序" class="headerlink" title="2.1 字节序"></a>2.1 字节序</h4><p><strong>字节序:</strong> 大于一个字节类型的数据在内存中的存放顺序，也就是说对于单字符来说是没有字节序问题的，字符串是单字符的集合，因此字符串也没有字节序问题。</p><ul><li><p><strong>主机字节序 (小端):</strong> 数据的低位字节存储到内存的低地址位, 数据的高位字节存储到内存的高地址位</p></li><li><p><strong>网络字节序 (大端):</strong> 数据的低位字节存储到内存的高地址位, 数据的高位字节存储到内存的低地址位</p><p><em>注：<strong>套接字通信过程中操作的数据都是大端存储的</strong>，包括：接收/发送的数据、IP地址、端口。</em></p></li></ul><h4 id="2-2-大小端转换"><a href="#2-2-大小端转换" class="headerlink" title="2.2 大小端转换"></a>2.2 大小端转换</h4><p><strong>主机字节序的IP地址转换为网络字节序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>; </span><br></pre></td></tr></table></figure><p><code>af</code>: 地址族(IP地址的家族包括ipv4和ipv6)协议</p><ul><li><code>AF_INET</code>: ipv4格式的ip地址</li><li><code>AF_INET6</code>: ipv6格式的ip地址</li></ul><p><code>src</code>: 传入参数</p><p><code>dst</code>: 传出参数, 函数调用完成, 转换得到的大端整形IP被写入到这块内存中</p><p>返回值：成功返回1，失败返回0或者-1</p><p><strong>将大端的整形数, 转换为小端的点分十进制的IP地址 :</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p><code>af</code>: 地址族(IP地址的家族包括ipv4和ipv6)协议</p><ul><li><code>AF_INET</code>: ipv4格式的<code>ip</code>地址</li><li><code>AF_INET6</code>: ipv6格式的<code>ip</code>地址</li></ul><p><code>src</code>: 传入参数, 这个指针指向的内存中存储了大端的整形IP地址</p><p><code>dst</code>: 传出参数, 存储转换得到的小端的点分十进制的IP地址 </p><p><code>size</code>: 修饰<code>dst</code>参数的, 标记<code>dst</code>指向的内存中最多可以存储多少个字节</p><p>返回值:</p><ul><li>成功: 指针指向第三个参数对应的内存地址, 通过返回值也可以直接取出转换得到的IP字符串</li><li>失败: <code>NULL</code></li></ul><h4 id="2-3-sockaddr"><a href="#2-3-sockaddr" class="headerlink" title="2.3 sockaddr"></a>2.3 sockaddr</h4><p><code>sockaddr</code>: 一个通用的、协议无关的套接字地址结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;       <span class="comment">// 地址族协议, 比如 IPv4 (AF_INET)</span></span><br><span class="line">    <span class="type">char</span>        sa_data[<span class="number">14</span>];     <span class="comment">// 端口(2字节) + IP地址(4字节) + 填充(8字节)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sockaddr_in</code>: 是专门针对 IPv4 协议设计的套接字地址结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>   <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;      <span class="comment">// 端口类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;      <span class="comment">// IP 地址类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>; <span class="comment">// 地址族类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof(unsigned short int))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;          <span class="comment">// 地址族协议: AF_INET</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;              <span class="comment">// 端口, 2 字节 -&gt; 大端</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;         <span class="comment">// IP 地址, 4 字节 -&gt; 大端</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>];       <span class="comment">// 填充 8 字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;  <span class="comment">// IP 地址，4 字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-4-套接字函数"><a href="#2-4-套接字函数" class="headerlink" title="2.4 套接字函数"></a>2.4 套接字函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个套接字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p><code>domain</code>: 使用的地址族协议</p><ul><li>AF_INET: 使用IPv4格式的ip地址</li><li>AF_INET6: 使用IPv6格式的ip地址</li></ul><p><code>type</code>:</p><ul><li>SOCK_STREAM: 使用流式的传输协议</li><li>SOCK_DGRAM: 使用报式(报文)的传输协议</li></ul><p><code>protocol</code>: 一般写0即可, 使用默认的协议</p><ul><li>SOCK_STREAM: 流式传输默认使用的是tcp</li><li>SOCK_DGRAM: 报式传输默认使用的udp</li></ul><p><strong>函数的返回值是一个文件描述符，通过这个文件描述符可以操作内核中的某一块内存，网络通信是基于这个文件描述符来完成的。</strong></p><h4 id="2-5-bind"><a href="#2-5-bind" class="headerlink" title="2.5 bind"></a>2.5 bind</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将文件描述符和本地的IP与端口进行绑定   </span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure><p>参数:</p><ul><li><code>sockfd</code>: 监听的文件描述符, 通过<code>socket()</code>调用得到的返回值</li><li><code>addr</code>: 传入参数, 要绑定的IP和端口信息需要初始化到这个结构体中，IP和端口要转换为网络字节序</li><li><code>addrlen</code>: 参数<code>addr</code>指向的内存大小, <code>sizeof(struct sockaddr)</code></li></ul><h3 id="3-TCP通信流程"><a href="#3-TCP通信流程" class="headerlink" title="3.TCP通信流程"></a>3.TCP通信流程</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202503282055645.png" alt="image-20250325161611700" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503282055352.png" alt="image-20250325161638441" style="zoom:67%;"></p><p><strong>在tcp的服务器端, 有两类文件描述符：</strong></p><ul><li><p><strong>监听的文件描述符</strong></p><ul><li><strong>只需要有一个</strong></li><li>不负责和客户端通信, 负责检测客户端的连接请求, 检测到之后调用accept就可以建立新的连接</li></ul></li><li><p><strong>通信的文件描述符</strong></p><ul><li>负责和建立连接的客户端通信</li><li><strong>如果有N个客户端和服务器建立了新的连接, 通信的文件描述符就有N个</strong>，每个客户端和服务器都对应一个通信的文件描述符</li></ul></li></ul><p><strong>基于tcp的服务器端通信代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏一般用于本地的绑定操作</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line"><span class="comment">//    inet_pton(AF_INET, &quot;192.168.237.131&quot;, &amp;addr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliaddr;</span><br><span class="line">    <span class="type">int</span> clilen = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">    <span class="comment">//(struct sockaddr*)&amp;cliaddr：用于存储客户端的地址信息（IP 地址和端口号）。</span></span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印客户端的地址信息</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">24</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP地址: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">           <span class="built_in">inet_ntop</span>(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, <span class="built_in">sizeof</span>(ip)),</span><br><span class="line">           <span class="built_in">ntohs</span>(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 和客户端通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(cfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">            <span class="built_in">write</span>(cfd, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于tcp通信的客户端通信代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;192.168.237.131&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 和服务器端通信</span></span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;你好, 服务器...%d\n&quot;</span>, number++);</span><br><span class="line">        <span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器say: %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);   <span class="comment">// 每隔1s发送一条数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-补充"><a href="#4-补充" class="headerlink" title="4.补充"></a>4.补充</h3><h4 id="4-1-什么是-Socket？"><a href="#4-1-什么是-Socket？" class="headerlink" title="4.1 什么是 Socket？"></a>4.1 什么是 Socket？</h4><p>Socket 可以看作是一个<strong>应用程序与网络之间的接口</strong>，它定义了如何进行数据发送和接收的方式。</p><h4 id="4-2-Socket-的类型有哪些？"><a href="#4-2-Socket-的类型有哪些？" class="headerlink" title="4.2 Socket 的类型有哪些？"></a>4.2 Socket 的类型有哪些？</h4><ul><li><strong>流式套接字（SOCK_STREAM）</strong>：基于 TCP 协议，面向连接，可靠。</li><li><strong>数据报套接字（SOCK_DGRAM）</strong>：基于 UDP 协议，无连接，不可靠。</li></ul><h4 id="4-3-如何创建一个-Socket？"><a href="#4-3-如何创建一个-Socket？" class="headerlink" title="4.3 如何创建一个 Socket？"></a>4.3 如何创建一个 Socket？</h4><p><strong>创建一个 Socket需要指定所使用的地址族和协议类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sockfd = socket(AF_INET, SOCK_STREAM, 0);</span><br></pre></td></tr></table></figure><ul><li><code>AF_INET</code>：IPv4 地址族。</li><li><code>SOCK_STREAM</code>：流式套接字。</li><li>第三个参数通常为 0，表示使用默认协议。</li></ul><h4 id="4-4-bind-函数的作用是什么？"><a href="#4-4-bind-函数的作用是什么？" class="headerlink" title="4.4 bind 函数的作用是什么？"></a>4.4 bind 函数的作用是什么？</h4><p>将 Socket 绑定到指定的 IP 地址和端口号。</p><h4 id="4-5-listen-函数的作用是什么？"><a href="#4-5-listen-函数的作用是什么？" class="headerlink" title="4.5 listen 函数的作用是什么？"></a>4.5 listen 函数的作用是什么？</h4><p>将 Socket 设置为监听状态（它并不会阻塞程序，而是告诉操作系统：“我现在准备好了，可以开始接受客户端的连接请求了。”）</p><h4 id="4-6-accept-函数的作用是什么？"><a href="#4-6-accept-函数的作用是什么？" class="headerlink" title="4.6 accept 函数的作用是什么？"></a>4.6 accept 函数的作用是什么？</h4><p><strong>进入阻塞状态</strong>等待接受客户端的连接请求，并返回一个新的 Socket 文件描述符用于通信。</p><h4 id="4-7-connect-函数的作用是什么？"><a href="#4-7-connect-函数的作用是什么？" class="headerlink" title="4.7 connect 函数的作用是什么？"></a>4.7 connect 函数的作用是什么？</h4><p>客户端调用该函数向服务器发起连接请求。</p><h4 id="4-8-服务器中的两个文件描述符各自的作用？"><a href="#4-8-服务器中的两个文件描述符各自的作用？" class="headerlink" title="4.8 服务器中的两个文件描述符各自的作用？"></a>4.8 服务器中的两个文件描述符各自的作用？</h4><p>服务器上分别有用于监听的文件描述符和用于通信的文件描述符，其各自有两个缓冲区，读缓冲区和写缓冲区。</p><p>监听的文件描述符所对应的读缓冲区用于接收客户端的连接请求，当调用accept()时会检测监听的文件描述符的读缓冲区是否有请求数据，如果有请求数据accept()会解除阻塞和对应的客户端建立连接。</p><p>通信的文件描述符的读缓冲区用于存储客户端所发送的通信数据，调用read()（没有数据则阻塞）可以把数据从读缓冲区读出来，write()把数据再写入写缓冲区（缓冲区满则阻塞），然后内核会将写缓冲区的数据发送给对应的客户端的读缓冲区。</p><h4 id="4-9-read-recv-write-send区别？"><a href="#4-9-read-recv-write-send区别？" class="headerlink" title="4.9 read/recv write/send区别？"></a>4.9 read/recv write/send区别？</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;套接字通信&quot;&gt;&lt;a href=&quot;#套接字通信&quot; class=&quot;headerlink&quot; title=&quot;套接字通信&quot;&gt;&lt;/a&gt;套接字通信&lt;/h2&gt;&lt;h3 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="网络" scheme="https://wangak.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C++八股6</title>
    <link href="https://wangak.cc/posts/a371aaff.html"/>
    <id>https://wangak.cc/posts/a371aaff.html</id>
    <published>2025-03-23T16:00:00.000Z</published>
    <updated>2025-03-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-为什么虚函数能实现动态绑定？"><a href="#1-为什么虚函数能实现动态绑定？" class="headerlink" title="1.为什么虚函数能实现动态绑定？"></a>1.为什么虚函数能实现动态绑定？</h4><p>虚函数能实现动态绑定主要通过虚函数表和虚函数指针实现的</p><p><strong>动态绑定的具体过程：</strong></p><ul><li><p><strong>调用虚函数：</strong></p><p>当通过基类指针或引用调用虚函数时，编译器生成的代码不会直接调用函数，而是<strong>通过虚函数指针查找虚函数表中的函数地址。</strong></p></li><li><p><strong>查找虚函数表：</strong></p><ul><li>编译器会根据对象的虚函数指针找到该对象所属类的虚函数表。</li><li>在虚函数表中查找对应虚函数的地址。</li></ul></li><li><p><strong>调用实际函数：</strong></p><ul><li>根据虚函数表中的地址，调用实际的函数版本。</li><li>如果派生类重写了虚函数，则调用派生类的版本；否则调用基类的版本。</li></ul><p><strong>注：虚函数表 vs 虚函数指针</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503250956902.png" alt="image-20250323153658854" style="zoom:67%;"></p></li></ul><h4 id="2-如何禁止程序自动生成拷贝构造函数？"><a href="#2-如何禁止程序自动生成拷贝构造函数？" class="headerlink" title="2.如何禁止程序自动生成拷贝构造函数？"></a>2.如何禁止程序自动生成拷贝构造函数？</h4><ul><li><strong>方法一：将拷贝构造函数和拷贝赋值函数设置为 <code>private</code></strong></li><li><strong>方法二：直接使用 <code>= delete</code> 来显式删除函数</strong></li></ul><h4 id="3-你知道回调函数吗？它的作用？"><a href="#3-你知道回调函数吗？它的作用？" class="headerlink" title="3.你知道回调函数吗？它的作用？"></a>3.你知道回调函数吗？它的作用？</h4><p>回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。（Qt中的槽函数）</p><h4 id="4-介绍一下友元函数和友元类的用法和作用"><a href="#4-介绍一下友元函数和友元类的用法和作用" class="headerlink" title="4.介绍一下友元函数和友元类的用法和作用"></a>4.介绍一下友元函数和友元类的用法和作用</h4><p>友元（friend）机制允许某些函数或类访问另一个类的私有（private）和保护（protected）成员。</p><p><strong>友元关系打破了封装性，但提供了灵活性。</strong></p><p><strong>友元函数：</strong>友元函数是一个非成员函数（定义在类外的普通函数，不属于任何类），但它可以访问类的私有和保护成员。<strong>友元函数在类的外部定义，但在类内部声明为友元。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> data) : <span class="built_in">privateData</span>(data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPrivateData</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPrivateData</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Private data: &quot;</span> &lt;&lt; obj.privateData &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPrivateData</span>(obj);  <span class="comment">// 输出: Private data: 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>友元类</strong>: 友元类是一个类，它的所有成员函数都可以访问另一个类的私有和保护成员。友元类在类内部声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> data) : <span class="built_in">privateData</span>(data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printPrivateData</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Private data: &quot;</span> &lt;&lt; obj.privateData &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    FriendClass friendObj;</span><br><span class="line">    friendObj.<span class="built_in">printPrivateData</span>(obj);  <span class="comment">// 输出: Private data: 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li><strong>封装性</strong>：友元机制破坏了封装性，应谨慎使用，避免过度依赖。</li><li><strong>单向性</strong>：友元关系是单向的且没有传递性。如果类A是类B的友元，类B不会自动成为类A的友元。</li><li><strong>继承</strong>：友元关系不继承。如果类A是类B的友元，类A的派生类不会自动成为类B的友元。</li></ul><h4 id="5-delete和delete-区别？"><a href="#5-delete和delete-区别？" class="headerlink" title="5.delete和delete[]区别？"></a>5.delete和delete[]区别？</h4><ul><li>delete只会调用⼀次析构函数。</li><li>delete[]会调用数组中每个元素的析构函数。</li></ul><h4 id="6-类的对象存储空间？"><a href="#6-类的对象存储空间？" class="headerlink" title="6.类的对象存储空间？"></a>6.类的对象存储空间？</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202503250956132.png" alt="image-20250323161815483" style="zoom: 50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503250956935.png" alt="image-20250323162003652" style="zoom: 50%;"></p><h4 id="7-构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"><a href="#7-构造函数能否声明为虚函数或者纯虚函数，析构函数呢？" class="headerlink" title="7.构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"></a>7.构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</h4><p><strong>析构函数： </strong>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。</p><p><em>注1：只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</em></p><p><em>注2：析构函数也可以是纯虚函数。</em></p><p><strong>构造函数：</strong>构造函数不能定义为虚函数。</p><p><strong>虚函数要使用虚函数指针（vptr）调用，而对象没有进行初始化就没有虚函数指针（vptr）。</strong></p><h4 id="8-什么是线程？线程与进程的区别是什么？"><a href="#8-什么是线程？线程与进程的区别是什么？" class="headerlink" title="8.什么是线程？线程与进程的区别是什么？"></a>8.什么是线程？线程与进程的区别是什么？</h4><ul><li>线程是操作系统调度的最小单位，进程是资源分配的基本单位。</li><li>同一进程内的线程共享内存空间，而不同进程有独立的地址空间。</li></ul><h4 id="9-线程同步有哪些常见方式？请简要说明。"><a href="#9-线程同步有哪些常见方式？请简要说明。" class="headerlink" title="9.线程同步有哪些常见方式？请简要说明。"></a>9.线程同步有哪些常见方式？请简要说明。</h4><ul><li><strong>互斥锁 (Mutex)</strong>: 防止多个线程同时访问共享资源。</li><li><strong>条件变量 (Condition Variable)</strong>: 用于线程间的通信。</li><li><strong>信号量 (Semaphore)</strong>: 控制对共享资源的访问数量。</li><li><strong>原子操作 (Atomic)</strong>: 保证某些操作的不可分割性。</li></ul><h4 id="10-什么是死锁？如何避免死锁？"><a href="#10-什么是死锁？如何避免死锁？" class="headerlink" title="10.什么是死锁？如何避免死锁？"></a>10.什么是死锁？如何避免死锁？</h4><p><strong>定义</strong>: 多个线程因为循环等待资源而无法继续执行。</p><p><strong>避免方法</strong>:</p><ul><li>按顺序获取锁。</li><li>使用超时机制尝试加锁。</li></ul><h4 id="11-什么是线程安全？如何实现线程安全？"><a href="#11-什么是线程安全？如何实现线程安全？" class="headerlink" title="11.什么是线程安全？如何实现线程安全？"></a>11.什么是线程安全？如何实现线程安全？</h4><p><strong>线程安全的定义：</strong>如果多线程程序每一次的运行结果和单线程程序的运行结果始终一样，那么就是线程安全的</p><p><strong>实现方法</strong>:</p><ul><li>使用互斥锁保护共享资源。</li><li>使用原子变量（如 <code>std::atomic</code>）</li></ul><h4 id="12-什么是线程池？为什么使用线程池？"><a href="#12-什么是线程池？为什么使用线程池？" class="headerlink" title="12.什么是线程池？为什么使用线程池？"></a>12.什么是线程池？为什么使用线程池？</h4><p><strong>线程池（Thread  Pool）</strong>是一种用于管理线程的机制，预先创建一组线程，并将任务提交到一个任务队列中，线程从队列中取出任务并执行。</p><p><strong>优点</strong>:</p><ul><li>减少频繁创建和销毁线程的开销。</li><li>提高响应速度。</li><li>控制并发线程的数量，避免资源耗尽。</li></ul><h4 id="13-什么是原子操作？C-中如何使用原子操作？"><a href="#13-什么是原子操作？C-中如何使用原子操作？" class="headerlink" title="13.什么是原子操作？C++中如何使用原子操作？"></a>13.什么是原子操作？C++中如何使用原子操作？</h4><p><strong>原子操作(Atomic Operation)：</strong>是指在多线程环境下不会被线程调度机制打断的操作，这种操作一旦开始，就会一直运行到结束，中间不会有任何线程切换。原子操作是线程安全的基本保证。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// 原子整型变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        counter++; <span class="comment">// 原子自增操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-在多线程环境下，如何正确地停止一个线程？"><a href="#14-在多线程环境下，如何正确地停止一个线程？" class="headerlink" title="14.在多线程环境下，如何正确地停止一个线程？"></a>14.在多线程环境下，如何正确地停止一个线程？</h4><p><strong>使用标志变量控制线程的退出:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">stop</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Working...\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread stopped.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(worker)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-线程池是怎么构建的，遇到过什么问题是怎样解决的？"><a href="#15-线程池是怎么构建的，遇到过什么问题是怎样解决的？" class="headerlink" title="15.线程池是怎么构建的，遇到过什么问题是怎样解决的？"></a>15.线程池是怎么构建的，遇到过什么问题是怎样解决的？</h4><p><strong>构建线程池的一般步骤：</strong></p><ul><li><strong>确定线程池大小</strong>：线程池的大小通常基于可用的处理器核心数以及程序的具体需求进行设置。</li><li><strong>任务队列</strong>：用于存放待执行的任务。</li><li><strong>工作线程</strong>：这是线程池中的实际工作者。</li><li><strong>管理机制</strong>：包括添加任务、关闭线程池、处理异常等操作。</li></ul><p><strong>问题：</strong></p><ul><li>访问任务队列时，要加互斥锁和条件变量</li><li>析构函数要正确地退出所有线程，如果没有正确管理线程生命周期，可能会出现线程泄漏的情况，即线程完成任务后没有正常退出。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-为什么虚函数能实现动态绑定？&quot;&gt;&lt;a href=&quot;#1-为什么虚函数能实现动态绑定？&quot; class=&quot;headerlink&quot; title=&quot;1.为什么虚函数能实现动态绑定？&quot;&gt;&lt;/a&gt;1.为什么虚函数能实现动态绑定？&lt;/h4&gt;&lt;p&gt;虚函数能实现动态绑定主要通过</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程编程</title>
    <link href="https://wangak.cc/posts/2148a8a.html"/>
    <id>https://wangak.cc/posts/2148a8a.html</id>
    <published>2025-03-23T16:00:00.000Z</published>
    <updated>2025-03-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><p><strong>头文件：</strong><code>#include&lt;thread&gt;</code></p><p><strong>创建线程:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个线程并执行 threadFunction</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    <span class="comment">// 主线程继续执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main!\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 等待线程 t 完成(join是一个阻塞等待)</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分离线程:</strong> 不希望主线程等待子线程完成，可以调用<code>detach()</code>方法。分离后的线程将在后台运行，主线程不再与之关联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    <span class="comment">// 分离线程</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">// 主线程继续执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main!\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 注意：分离后的线程无法再 join</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>传递参数给线程函数:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, str = &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="comment">// 创建线程并传递参数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction, x, str)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>std::thread</code> :</strong> 提供了一个成员函数 <code>joinable()</code>，用于检查一个线程对象是否可以被 <strong>join</strong> 或 <strong>detach</strong>。</p><p><strong><code>std::ref</code>:</strong> 创建对象的引用包装器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x += <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(foo, std::ref(a))</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子线程调用类的成员函数"><a href="#子线程调用类的成员函数" class="headerlink" title="子线程调用类的成员函数"></a>子线程调用类的成员函数</h4><p><strong>直接传递成员函数指针和对象实例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunction</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Member function called with x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="comment">// 直接传递成员函数指针和对象实例</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(&amp;MyClass::memberFunction, &amp;obj, <span class="number">42</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 std::shared_ptr 来管理类对象的生命周期，确保在线程执行期间对象不会被销毁:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() </span><br><span class="line">        &lt;&lt; <span class="string">&quot; started&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; obj = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(&amp;MyClass::func, obj)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="互斥量解决多线程数据共享问题"><a href="#互斥量解决多线程数据共享问题" class="headerlink" title="互斥量解决多线程数据共享问题"></a>互斥量解决多线程数据共享问题</h4><p><strong>头文件：</strong><code>#include &lt;mutex&gt;</code></p><p><strong>线程安全的定义：</strong>如果多线程程序每一次的运行结果和单线程程序的运行结果始终一样，那么就是线程安全的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        mtx.<span class="built_in">lock</span>();<span class="comment">//加锁</span></span><br><span class="line">        shared_data++;        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; n </span><br><span class="line">        &lt;&lt; <span class="string">&quot; increment shared_data to &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>(); <span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final shared_data = &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="互斥量封装类"><a href="#互斥量封装类" class="headerlink" title="互斥量封装类"></a>互斥量封装类</h4><ul><li><p><strong><code>std::lock_guard</code></strong>：作用是在构造时自动锁定互斥锁，在析构时自动解锁互斥锁。</p><p>注：不支持手动控制锁的行为（如延迟锁定、提前解锁等）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动加锁</span></span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">// 自动解锁（当 lock 超出作用域时）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 2&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::unique_lock</code></strong>: 允许对锁进行更细粒度的控制，例如延迟锁定、手动解锁、尝试锁定等。</p><p><em>注：相对于 <code>std::lock_guard</code>，开销稍大（因为它需要维护更多的状态）。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::defer_lock)</span></span>; <span class="comment">// 延迟锁定</span></span><br><span class="line">    lock.<span class="built_in">lock</span>(); <span class="comment">// 手动加锁</span></span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    lock.<span class="built_in">unlock</span>(); <span class="comment">// 手动解锁</span></span><br><span class="line">    <span class="comment">// 锁会在 unique_lock 析构时自动解锁（如果尚未解锁）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 2&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::lock_guard</code> 和 <code>std::unique_lock</code> 的对比</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503261056266.png" alt="image-20250323210830055" style="zoom:50%;"></p></li></ul><h4 id="std-call-once"><a href="#std-call-once" class="headerlink" title="std::call_once"></a>std::call_once</h4><p><code>std::call_once</code> 用于确保某个函数或代码块在多线程环境中只被执行一次。</p><p><strong><code>std::call_once</code> 的主要作用是：</strong></p><ul><li><strong>线程安全的单次执行</strong>：确保某个函数或代码块在多个线程中只会被执行一次。</li><li><strong>避免竞态条件</strong>：在多线程环境下，多个线程可能同时尝试执行某段代码，<code>std::call_once</code> 可以保证只有一个线程能够成功执行，其他线程会等待该操作完成后再继续。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::once_flag flag;  <span class="comment">// 定义一个 once_flag 对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initialization function executed by thread &quot;</span></span><br><span class="line">              &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(flag, initialize);  <span class="comment">// 确保 initialize 函数只被调用一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread_func)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread_func)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(thread_func)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景：</strong></p><ul><li><strong>延迟初始化</strong>：在某些情况下，对象的初始化成本较高，或者只有在需要时才进行初始化。可以使用 <code>std::call_once</code> 来确保初始化逻辑只执行一次。</li><li><strong>单例模式</strong>：在实现线程安全的单例模式时，可以使用 <code>std::call_once</code> 来确保实例化过程只发生一次。</li></ul><p><em>注：<code>std::call_once</code>只能在线程函数中才能使用</em></p><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p><strong>条件变量（<code>std::condition_variable</code>）</strong>是一个用于线程间通信的同步原语。允许一个线程等待某个条件成立，而另一个线程可以在该条件满足时通知等待的线程继续执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cond_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(data++);</span><br><span class="line">        cond_var.<span class="built_in">notify_one</span>(); <span class="comment">// 通知正在等待的消费者线程</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// 模拟生产时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cond_var.<span class="built_in">wait</span>(lock, []()&#123;<span class="keyword">return</span> !q.<span class="built_in">empty</span>();&#125;); <span class="comment">// 等待直到队列非空</span></span><br><span class="line">        <span class="type">int</span> value = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong>生产者线程</strong>：不断地将数据添加到队列中，并通过 <code>cond_var.notify_one()</code> 通知可能正在等待的消费者线程，表示有新的数据可以处理了。</li><li><strong>消费者线程</strong>：首先尝试获取互斥锁，然后调用 <code>cond_var.wait(lock, condition)</code> 方法检查队列是否为空。如果队列为空，则当前线程会释放锁并进入等待状态，直到被生产者线程通知且条件满足（即队列非空）。一旦条件满足，消费者线程重新获取锁，并从队列中取出数据进行处理。</li></ul><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p><strong>线程池（Thread  Pool）</strong>是一种用于管理线程的机制，旨在减少频繁创建和销毁线程的开销。它<strong>预先创建一组线程</strong>，并将任务提交到一个<strong>任务队列</strong>中，<strong>线程从队列中取出任务并执行。</strong>这种方式特别适用于需要频繁执行短任务的场景，因为线程池可以避免每次任务执行时都创建新线程所带来的性能开销。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> numThreads) : <span class="built_in">stop</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">            threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//每个线程会不断地运行，直到满足特定的退出条件（如线程池关闭且任务队列为空）</span></span><br><span class="line">                    std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mutex);</span><br><span class="line">                    <span class="comment">//stop || !tasks.empty()是解锁的条件</span></span><br><span class="line">                    condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> stop || !tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                    <span class="keyword">if</span> (stop &amp;&amp; tasks.<span class="built_in">empty</span>()) &#123;<span class="comment">//线程退出的条件</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; <span class="built_in">task</span>(std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>()));</span><br><span class="line">                    tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    lock.<span class="built_in">unlock</span>();</span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        condition.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有等待的线程。</span></span><br><span class="line">        <span class="keyword">for</span> (std::thread&amp; thread : threads) &#123;<span class="comment">//等待所有线程完成其当前任务并退出</span></span><br><span class="line">            thread.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123; <span class="comment">//f是函数，args是参数</span></span><br><span class="line">        <span class="comment">//将用户提交的任务（函数 f 和其参数 args...）封装成一个无参数、无返回值的函数对象</span></span><br><span class="line">        <span class="comment">//std::bind 的作用是将函数及其参数绑定在一起，生成一个无参数的函数对象，从而满足任务队列的要求。</span></span><br><span class="line">        <span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...))</span></span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">            tasks.<span class="built_in">emplace</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">        &#125;</span><br><span class="line">        condition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;<span class="comment">//保存线程池中的所有线程。</span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;<span class="comment">//任务队列</span></span><br><span class="line">    std::mutex mutex;<span class="comment">//用于保护对共享资源（如任务队列）的访问，确保线程安全</span></span><br><span class="line">    std::condition_variable condition;<span class="comment">//条件变量，用于在线程间进行同步。线程会在任务队列为空时等待，直到有新任务被加入队列。</span></span><br><span class="line">    <span class="type">bool</span> stop;<span class="comment">//标志位，用于指示线程池是否停止运行。当线程池析构时，会设置该标志为 true，通知所有线程退出。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        pool.<span class="built_in">enqueue</span>([i] &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; is running in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; is done&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步并发机制"><a href="#异步并发机制" class="headerlink" title="异步并发机制"></a>异步并发机制</h4><p><strong><code>std::async</code> 和<code>std::future</code>：</strong></p><ul><li><code>std::async</code>: <strong>启动一个异步任务</strong>，返回一个<code>std::future</code>对象</li><li>两种启动策略：<ul><li><code>std::launch::async</code>：立即在新线程中执行</li><li><code>std::launch::deferred</code>：延迟执行，直到调用<code>future.get()</code></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 异步执行compute函数</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(std::launch::async, compute);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以做其他工作...</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing other work...\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取结果(会阻塞直到结果就绪)</span></span><br><span class="line">    <span class="type">int</span> value = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>std::future:</strong> <strong>表示异步操作的结果</strong><ul><li><code>get()</code>：获取结果，会阻塞直到结果就绪</li><li><code>wait()</code>：等待结果就绪</li><li><code>valid()</code>：检查future是否关联了共享状态</li><li><code>share()</code>：转换为<code>std::shared_future</code></li></ul></li></ul><p><strong>std::packaged_task:</strong> 是一个可调用的对象包装器，它将函数调用与future关联起来。</p><ul><li><p>比<code>std::async</code>更灵活，可以控制任务的执行方式</p></li><li><p>可以多次使用（通过重置）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个packaged_task，包装compute函数</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(compute)</span></span>;</span><br><span class="line">    <span class="comment">// 获取与任务关联的future</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// 在另一个线程中执行任务</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task), <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>(); <span class="comment">// 或使用t.join()</span></span><br><span class="line">    <span class="comment">// 获取结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>std::promise:</strong> 提供了更底层的设置异步结果的方式，允许显式设置值或异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compute</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp;&amp; prom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟计算</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 设置结果</span></span><br><span class="line">        prom.<span class="built_in">set_value</span>(<span class="number">42</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="comment">// 捕获异常并存储到promise中</span></span><br><span class="line">        prom.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = prom.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(compute, std::move(prom))</span></span>;</span><br><span class="line">    <span class="comment">// 获取结果</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多线程编程&quot;&gt;&lt;a href=&quot;#多线程编程&quot; class=&quot;headerlink&quot; title=&quot;多线程编程&quot;&gt;&lt;/a&gt;多线程编程&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;头文件：&lt;/strong&gt;&lt;code&gt;#include&amp;lt;thread&amp;gt;&lt;/code&gt;&lt;/</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++八股5</title>
    <link href="https://wangak.cc/posts/3a78fb45.html"/>
    <id>https://wangak.cc/posts/3a78fb45.html</id>
    <published>2025-03-22T16:00:00.000Z</published>
    <updated>2025-03-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-怎样判断两个浮点数是否相等？"><a href="#1-怎样判断两个浮点数是否相等？" class="headerlink" title="1.怎样判断两个浮点数是否相等？"></a>1.怎样判断两个浮点数是否相等？</h4><p>由于浮点数在计算机中的表示方式和存储限制，直接使用 <code>==</code> 操作符来判断两个浮点数是否相等可能会导致不准确的结果，即使这两个数看起来应该是相等的。这是因为浮点数的精度有限，在某些计算后可能产生非常小的<strong>舍入误差。</strong></p><p>正确的做法是比较两个浮点数之间的差值是否在一个很小的范围内，而不是直接检查它们是否完全相等。可以将这两个浮点数相减，然后取结果的绝对值，并与一个预设的小阈值（也称为“精度”）进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">abs</span><span class="params">(a - b)</span> &lt; epsilon:</span></span><br><span class="line"><span class="function">    print(<span class="string">&quot;a and b are considered equal&quot;</span>)</span></span><br><span class="line"><span class="function">else:</span></span><br><span class="line"><span class="function">    print(<span class="string">&quot;a and b are not equal&quot;</span>)</span></span><br></pre></td></tr></table></figure><h4 id="2-类如何实现只能静态分配和只能动态分配"><a href="#2-类如何实现只能静态分配和只能动态分配" class="headerlink" title="2.类如何实现只能静态分配和只能动态分配"></a>2.类如何实现只能静态分配和只能动态分配</h4><ul><li><p><strong>只能静态分配:</strong> 类的对象只能在栈上创建,将 <code>new</code> 和 <code>delete</code> 运算符重载并声明为 <code>private</code> 属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackOnly</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 重载new和delete运算符，并将它们设为private</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom new is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 不应该实际调用，因为我们不希望在堆上创建对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom delete is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 不应该实际调用</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StackOnly</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;StackOnly object created on stack.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">StackOnly</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;StackOnly object destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StackOnly obj; <span class="comment">// 正确：在栈上创建对象</span></span><br><span class="line">    <span class="comment">// 错误：尝试在堆上创建对象（这将导致编译错误）</span></span><br><span class="line">    <span class="comment">// StackOnly* obj2 = new StackOnly();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>只能动态分配:</strong> 类的对象只能在堆上创建,将构造函数和析构函数设为 <code>protected 属性</code>，并提供一个公有的静态成员函数用来创建对象实例。</p><ul><li><strong>限制直接实例化</strong>：通过将构造函数和析构函数设为 <code>protected</code>，可以防止外部代码直接使用构造函数来创建对象实例。</li><li><strong>允许继承</strong>：将构造函数和析构函数设为 <code>protected</code> 而不是 <code>private</code>，使得派生类仍然能够调用基类的构造函数进行初始化。</li><li><strong>集中控制对象创建逻辑</strong>：通过提供一个静态成员函数如 <code>createInstance</code> 来负责对象的创建，可以集中控制对象的创建过程。</li><li><strong>静态成员函数无需实例即可调用</strong>：静态成员函数不依赖于类的具体实例，可以直接通过类名调用。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个只能动态分配的基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OnlyDynamic</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 构造函数和析构函数都设置为protected</span></span><br><span class="line">    <span class="built_in">OnlyDynamic</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OnlyDynamic Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">OnlyDynamic</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OnlyDynamic Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 提供一个静态成员函数用于创建对象实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> OnlyDynamic* <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OnlyDynamic</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Display function of OnlyDynamic&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-继承机制中对象之间如何转换？指针和引用之间如何转换？"><a href="#3-继承机制中对象之间如何转换？指针和引用之间如何转换？" class="headerlink" title="3.继承机制中对象之间如何转换？指针和引用之间如何转换？"></a>3.继承机制中对象之间如何转换？指针和引用之间如何转换？</h4><ul><li><p><strong>向上类型转换:</strong> 派生类的指针或引用转换为基类的指针或引用。这种转换是安全的，并且在C++中会自动进行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line">Base* ptr = &amp;d;  <span class="comment">// 自动向上类型转换</span></span><br></pre></td></tr></table></figure></li><li><p><strong>向下类型转换:</strong> 将基类的指针或引用转换为派生类的指针或引用。向下类型转换不会自动进行，必须显式地执行,通常是通过<code>dynamic_cast</code> 来实现的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();  <span class="comment">// 假设我们知道这个基类指针实际指向一个派生类对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 dynamic_cast 进行向下类型转换，注意这里需要包含正确的头文件</span></span><br><span class="line">Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"><span class="keyword">if</span> (derivedPtr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 转换成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 转换失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-知道C-中的组合吗？它与继承相比有什么优缺点吗？"><a href="#4-知道C-中的组合吗？它与继承相比有什么优缺点吗？" class="headerlink" title="4.知道C++中的组合吗？它与继承相比有什么优缺点吗？"></a>4.知道C++中的组合吗？它与继承相比有什么优缺点吗？</h4><p><strong>继承：</strong></p><ul><li><p><strong>优点：</strong></p><ul><li>子类可以重写父类的方法来方便地扩展功能。</li></ul></li><li><p><strong>缺点：</strong></p><ul><li><strong>高耦合性</strong>：子类依赖于父类的实现细节，这增加了耦合度</li><li><strong>编译时绑定</strong>：子类从父类继承的方法在编译期就已经确定，无法在运行时改变行为。</li><li><strong>维护成本</strong>：如果修改了父类的方法（如添加参数），则所有相关的子类也需要相应调整，否则可能导致错误。</li></ul></li></ul><p><strong>组合：</strong>一个类中包含另一个类的对象作为成员变量，体现了“有一个”（Has-a）的关系。</p><ul><li><p><strong>优点：</strong></p><ul><li><strong>低耦合性</strong>：通过组合的方式，外部对象只能通过接口访问被包含对象的功能，因此内部实现细节对外部不可见。</li><li><strong>灵活性</strong>：由于当前对象和被包含的对象之间是低耦合的，所以对被包含对象的修改不需要修改当前对象的代码。</li><li><strong>动态绑定</strong>：可以在运行时动态地替换所包含的对象，提供了更大的灵活性。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个接口或抽象类，用于定义技能的行为</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Skill</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数，定义了技能的使用方法</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Skill</span>() &#123;&#125; <span class="comment">// 虚析构函数，确保派生类能正确释放</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现具体的技能A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkillA</span> : <span class="keyword">public</span> Skill &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using Skill A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现具体的技能B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkillB</span> : <span class="keyword">public</span> Skill &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using Skill B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏角色类，通过组合方式包含技能对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Skill&gt; skill; <span class="comment">// 使用智能指针管理技能对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 设置技能的方法，允许在运行时更换技能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSkill</span><span class="params">(std::unique_ptr&lt;Skill&gt; newSkill)</span> </span>&#123;</span><br><span class="line">        skill = std::<span class="built_in">move</span>(newSkill);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 角色使用当前装备的技能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">performSkill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (skill) &#123;</span><br><span class="line">            skill-&gt;<span class="built_in">use</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No skill available.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    GameCharacter character;</span><br><span class="line">    <span class="comment">// 初始设置为SkillA</span></span><br><span class="line">    character.<span class="built_in">setSkill</span>(std::<span class="built_in">make_unique</span>&lt;SkillA&gt;());</span><br><span class="line">    character.<span class="built_in">performSkill</span>(); <span class="comment">// 输出: Using Skill A</span></span><br><span class="line">    <span class="comment">// 动态替换为SkillB</span></span><br><span class="line">    character.<span class="built_in">setSkill</span>(std::<span class="built_in">make_unique</span>&lt;SkillB&gt;());</span><br><span class="line">    character.<span class="built_in">performSkill</span>(); <span class="comment">// 输出: Using Skill B</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>缺点</strong>：</p><ul><li><strong>对象管理复杂</strong>：过多使用组合可能会导致创建大量小对象，增加了系统的复杂性。</li><li><strong>接口设计要求高</strong>：为了有效地组合多个对象，必须仔细设计接口，确保它们能够良好协作。</li></ul></li></ul><h4 id="5-函数指针？"><a href="#5-函数指针？" class="headerlink" title="5.函数指针？"></a>5.函数指针？</h4><p><strong>函数指针的声明方法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*pf)(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;);</span><br></pre></td></tr></table></figure><p><em>注：<code>pf</code> 是一个指向函数的指针，该函数返回 <code>int</code> 类型并且接受两个 <code>const int&amp;</code> 类型的参数。注意这里的括号非常重要：`(</em>pf)<code>确保了</code><em><code>被应用到</code>pf<code>上，表明这是一个指针；如果没有这些括号，如</code>int </em>pf(const int&amp;, const int&amp;);<code>，这将被解析为一个返回</code>int<em>` 的函数声明。</em></p><p><strong>两种方法赋值：</strong></p><ul><li><p><strong>直接使用函数名：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pf = functionName;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用取地址运算符<code>&amp;</code>:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pf = &amp;functionName;</span><br></pre></td></tr></table></figure></li></ul><p><strong>函数指针的作用：动态选择函数执行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义几个基本的数学操作函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="number">0</span>) <span class="keyword">return</span> a / b;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error: Division by zero!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0作为错误处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数指针类型，简化声明</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*MathFunc)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeOperation</span><span class="params">(MathFunc operation, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; <span class="built_in">operation</span>(a, b) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">5</span>;</span><br><span class="line">    MathFunc operation;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Choose an operation (1: Add, 2: Subtract, 3: Multiply, 4: Divide): &quot;</span>;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    std::cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            operation = add; <span class="comment">// 函数名直接赋值给函数指针</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            operation = subtract;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            operation = multiply;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            operation = divide;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Invalid choice.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">executeOperation</span>(operation, x, y); <span class="comment">// 使用函数指针调用对应的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-结构体变量比较是否相等"><a href="#6-结构体变量比较是否相等" class="headerlink" title="6.结构体变量比较是否相等"></a>6.结构体变量比较是否相等</h4><p><strong>重载 <code>==</code> 操作符</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 == 操作符</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> foo&amp; rhs) <span class="type">const</span> &#123; <span class="comment">// 注意这里的 const 修饰符</span></span><br><span class="line">        <span class="built_in">return</span> (a == rhs.a) &amp;&amp; (b == rhs.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-函数调用过程栈的变化，返回值和参数变量哪个先入栈？"><a href="#7-函数调用过程栈的变化，返回值和参数变量哪个先入栈？" class="headerlink" title="7.函数调用过程栈的变化，返回值和参数变量哪个先入栈？"></a>7.函数调用过程栈的变化，返回值和参数变量哪个先入栈？</h4><ul><li><p><strong>参数入栈:</strong>调用者（caller）需要将被调函数（callee）所需的参数按照与形参顺序相反的顺序压入栈中。</p><p>对于函数调用 <code>func(a, b, c)</code>，则它们会以 <code>c</code>, <code>b</code>, <code>a</code> 的顺序依次压入栈中。</p></li><li><p><strong>调用和返回地址入栈:</strong> 使用 <code>call</code> 指令进行函数调用时，该指令除了跳转到被调函数的起始地址执行外，还会自动将 <code>call</code> 指令的下一条指令的地址（即返回地址）压入栈中。</p></li><li><strong>设置新的栈帧:</strong> 一旦控制权转移到被调函数，首先要做的就是设置一个新的栈帧。</li><li><strong>局部变量和临时变量入栈:</strong> 在新栈帧内，局部变量根据定义顺序分配空间，地址随栈的增长方向递减。</li></ul><h4 id="8-C-中类成员的访问权限和继承权限问题"><a href="#8-C-中类成员的访问权限和继承权限问题" class="headerlink" title="8.C++中类成员的访问权限和继承权限问题"></a>8.C++中类成员的访问权限和继承权限问题</h4><p><strong>三种访问权限:</strong></p><ul><li>一个类的public成员变量、成员函数，可以通过类的成员函数、类的实例变量进行访问</li><li>一个类的protected成员变量、成员函数，无法通过类的实例变量进行访问。但是可以通过<strong>类的友元函数、友元类</strong>进行访问。</li><li>一个类的private成员变量、成员函数，无法通过类的实例变量进行访问。但是<strong>可以通过类的友元函数、友元类进行访问。</strong></li></ul><p><strong>继承权限:</strong></p><ul><li><p><strong>public继承:</strong> 基类的各种权限不变 。</p></li><li><p><strong>protected继承:</strong> 派生类通过protected继承，基类的public成员在派生类中的权限变成了protected 。protected和private不变。</p></li><li><p><strong>private继承:</strong> private继承看成派生类将基类的public,protected成员囊括到派生类，全部作为派生类的private成员，但是不包括private成员。</p><p><em>注：基类的私有成员都不会直接被派生类继承</em></p></li></ul><h4 id="9-cout和printf有什么区别？"><a href="#9-cout和printf有什么区别？" class="headerlink" title="9.cout和printf有什么区别？"></a>9.cout和printf有什么区别？</h4><p><code>cout&lt;&lt;</code>是一个函数，<code>cout&lt;&lt;</code>后可以跟不同的类型是因为<code>cout&lt;&lt;</code>已存在针对各种类型数据的重载，所以会自动识别数据的类型。</p><p><strong>缓冲机制:</strong></p><ul><li><strong><code>cout</code>（有缓冲输出）</strong>: 输出到<code>cout</code>的内容首先会被放入缓冲区，然后根据特定条件（如遇到换行符<code>\n</code>、程序结束、手动刷新缓冲区等）才会从缓冲区输出到屏幕。为了确保立即输出内容，可以使用<code>endl</code>或者显式地调用<code>flush</code>方法（如<code>cout &lt;&lt; &quot;abc&quot; &lt;&lt; endl;</code> 或 <code>cout &lt;&lt; &quot;abc\n&quot; &lt;&lt; flush;</code>）。<code>endl</code>不仅插入了一个换行符，还会导致流被刷新；而<code>flush</code>仅刷新流而不添加任何字符。</li><li><strong><code>printf</code>（无缓冲输出）</strong>: 传统上认为<code>printf</code>是无缓冲输出，意味着当你调用<code>printf</code>时，输出几乎是立即显示的。</li></ul><h4 id="10-为什么可以为类的成员函数创建模板，但不能是虚函数和析构函数？"><a href="#10-为什么可以为类的成员函数创建模板，但不能是虚函数和析构函数？" class="headerlink" title="10.为什么可以为类的成员函数创建模板，但不能是虚函数和析构函数？"></a>10.为什么可以为类的成员函数创建模板，但不能是虚函数和析构函数？</h4><p>析构函数：没有参数，不需要使用模板</p><p>虚函数：由于模板成员函数的实例化是编译时的行为，而虚函数的动态绑定是运行时的行为，这两者无法同时满足。</p><h4 id="11-定义和声明的区别"><a href="#11-定义和声明的区别" class="headerlink" title="11.定义和声明的区别"></a>11.定义和声明的区别</h4><p><strong>变量的声明和定义：</strong></p><ul><li><strong>声明</strong>：当提到变量时，声明是指告诉编译器存在某个类型的变量，但并<strong>不会为这个变量分配内存空间</strong>。</li><li><strong>定义</strong>：而定义则是实际为变量<strong>分配内存空间</strong>的过程。这意味着系统会为该变量预留一定的存储空间，用于<strong>存放它的值</strong>。</li></ul><p><strong>函数的声明和定义：</strong></p><ul><li><strong>声明</strong>：对于函数来说，<strong>声明位于头文件（.h文件）中</strong>，其目的是通知编译器有关该函数的一些基本信息，比如函数名称、返回类型以及参数列表等。</li><li><strong>定义</strong>：函数的定义则包含了函数的实际实现代码，即函数体。它描述了函数执行的操作，并且<strong>位于源文件（.c或.cpp文件）中。</strong></li></ul><h4 id="12-静态成员与普通成员的区别是什么？"><a href="#12-静态成员与普通成员的区别是什么？" class="headerlink" title="12.静态成员与普通成员的区别是什么？"></a>12.静态成员与普通成员的区别是什么？</h4><p><strong>生命周期：</strong></p><ul><li><strong>静态成员变量</strong>：其生命周期从类被加载到内存开始，直到类被卸载为止。</li><li><strong>普通成员变量</strong>：它们的生命周期<strong>与对象实例</strong>紧密相关，只有当创建了一个类的对象时，普通成员变量才会存在</li></ul><p><strong>共享方式：</strong></p><ul><li><strong>静态成员变量</strong>：所有的对象都共享同一个静态成员变量</li><li><strong>普通成员变量</strong>：每个对象都有自己的一份副本</li></ul><p><strong>定义位置：</strong></p><ul><li><strong>普通成员变量</strong>：通常存储在栈或堆中，具体取决于它们是如何被声明和使用的。</li><li><strong>静态成员变量</strong>：存储在<strong>静态全局区</strong>，这意味着它们的存储空间是在程序启动时分配的，并且不会随对象的创建和销毁而变化。</li></ul><p><strong>初始化位置：</strong></p><ul><li><strong>普通成员变量</strong>：可以在类定义中直接初始化</li><li><strong>静态成员变量</strong>：必须<strong>在类外部进行初始化</strong>（除非是静态常量整型成员，可以直接在类定义中初始化）。</li></ul><h4 id="13-说一下你理解的-ifdef-endif代表着什么？"><a href="#13-说一下你理解的-ifdef-endif代表着什么？" class="headerlink" title="13.说一下你理解的 ifdef endif代表着什么？"></a>13.说一下你理解的 ifdef endif代表着什么？</h4><p><code>#ifdef</code>和<code>#endif</code>是C/C++语言中的预处理指令，用于<strong>实现条件编译</strong>。</p><p><strong>防止头文件重复包含</strong>（头文件卫士）：避免因多次包含同一头文件而导致的重定义问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEADER_FILE_NAME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEADER_FILE_NAME_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件的内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HEADER_FILE_NAME_H</span></span></span><br></pre></td></tr></table></figure><h4 id="14-隐式转换，如何消除隐式转换？"><a href="#14-隐式转换，如何消除隐式转换？" class="headerlink" title="14.隐式转换，如何消除隐式转换？"></a>14.隐式转换，如何消除隐式转换？</h4><p><strong>隐式转换:</strong></p><ul><li><strong>子类对象可以隐式地转换为父类对象(多态）</strong></li><li><strong>从小的数据类型（如<code>char</code>或<code>short</code>）向大的数据类型（如<code>int</code>或<code>long</code>）转换</strong></li></ul><p><strong>消除隐式转换的方法：</strong></p><ul><li><p><strong>使用<code>explicit</code>关键字</strong>：在构造函数声明时加上<code>explicit</code>关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="comment">/* 构造函数体 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="15-如果有一个空类，它会默认添加哪些函数？"><a href="#15-如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="15.如果有一个空类，它会默认添加哪些函数？"></a>15.如果有一个空类，它会默认添加哪些函数？</h4><ul><li><strong>默认构造函数</strong> (<code>Empty::Empty()</code>)</li><li><strong>拷贝构造函数</strong> (<code>Empty::Empty(const Empty&amp;)</code>)</li><li><strong>析构函数</strong> (<code>Empty::~Empty()</code>)</li><li><strong>赋值运算符重载函数</strong> (<code>Empty&amp; Empty::operator=(const Empty&amp;)</code>)</li></ul><h4 id="16-你知道const-char-与string之间的关系是什么吗？"><a href="#16-你知道const-char-与string之间的关系是什么吗？" class="headerlink" title="16.你知道const char* 与string之间的关系是什么吗？"></a>16.你知道const char* 与string之间的关系是什么吗？</h4><ul><li><strong><code>std::string</code></strong> 是C++标准库提供的一个类，用于封装字符串操作</li><li><strong><code>const char\*</code></strong> 是C风格的字符串表示形式，它实际上是一个指向以空字符（<code>\0</code>）结尾的字符数组的指针</li></ul><p>相互转换：</p><ul><li><p><strong>从 <code>std::string</code> 转换为 <code>const char\*</code></strong>： 使用 <code>std::string</code> 的成员函数 <code>c_str()</code> 可以获取一个 C 风格的字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = s.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure></li><li><p><strong>从 <code>const char\*</code> 转换为 <code>std::string</code></strong>： 可以直接通过构造函数将 <code>const char*</code> 转换为 <code>std::string</code>，这是隐式转换的一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(c_s)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="17-你什么情况用指针当参数，什么时候用引用，为什么？"><a href="#17-你什么情况用指针当参数，什么时候用引用，为什么？" class="headerlink" title="17.你什么情况用指针当参数，什么时候用引用，为什么？"></a>17.你什么情况用指针当参数，什么时候用引用，为什么？</h4><p>简单的数据类型：可以按值传递，因为复制成本低</p><p>数组只能使用指针</p><p>类对象使用引用传递</p><h4 id="18-如何设计一个类计算子类的个数？"><a href="#18-如何设计一个类计算子类的个数？" class="headerlink" title="18.如何设计一个类计算子类的个数？"></a>18.如何设计一个类计算子类的个数？</h4><p><strong>static静态变量coun计数：</strong></p><ul><li><p>为类设计一个static静态变量count作为计数器；</p></li><li><p>类定义结束后初始化count;</p></li><li><p>在构造函数中对count进行+1;</p></li><li><p>设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作；</p></li><li><p>设计复制构造函数，在进行复制函数中对count+1操作；</p></li><li><p>在析构函数中对count进行-1；</p></li></ul><h4 id="19-说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#19-说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="19.说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>19.说一说strcpy、sprintf与memcpy这三个函数的不同之处</h4><ul><li><p><strong><code>strcpy</code></strong>: 将<code>src</code>指向的字符串（包括终止符<code>\0</code>）复制到<code>dest</code>指向的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>sprintf</code></strong>: 根据提供的格式化字符串<code>format</code>和后续参数，生成一个格式化的字符串，并存储在<code>str</code>指向的缓冲区中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;The answer is %d&quot;</span>, number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>memcpy</code>:</strong> 从<code>src</code>指向的内存地址开始复制<code>n</code>个字节到<code>dest</code>指向的内存地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> src[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> dest[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="built_in">strlen</span>(src) + <span class="number">1</span>); <span class="comment">// 包括终止符&#x27;\0&#x27;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Copied string: %s\n&quot;</span>, dest);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="20-如何阻止一个类被实例化？有哪些方法？"><a href="#20-如何阻止一个类被实例化？有哪些方法？" class="headerlink" title="20.如何阻止一个类被实例化？有哪些方法？"></a>20.如何阻止一个类被实例化？有哪些方法？</h4><ul><li><p><strong>将类定义为抽象基类:</strong> <strong>抽象基类</strong>是一种不能实例化的类，它包含至少一个纯虚函数（即没有实现体的虚函数）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pureVirtualFunction</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractClass</span>() &#123;&#125; <span class="comment">// 虚析构函数确保派生类正确释放资源</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码会导致编译错误，因为不能实例化抽象类</span></span><br><span class="line"><span class="comment">// AbstractClass obj;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>将构造函数声明为<code>private</code></strong>: 提供静态成员函数来允许有限制地创建对象，或者根本不提供创建对象的方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonInstantiableClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">NonInstantiableClass</span>() &#123;&#125; <span class="comment">// 私有构造函数</span></span><br><span class="line">    ~<span class="built_in">NonInstantiableClass</span>() &#123;&#125; <span class="comment">// 私有析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以在这里执行一些操作，但不能创建对象实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码会导致编译错误，因为构造函数是私有的</span></span><br><span class="line"><span class="comment">// NonInstantiableClass obj;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>静态成员函数来允许有限制地创建对象:</strong></p><ul><li><p><strong>单例模式:</strong> 单例模式确保一个类只有一个实例，使用一个静态方法来返回唯一的实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonInstantiableClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="built_in">NonInstantiableClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有析构函数</span></span><br><span class="line">    ~<span class="built_in">NonInstantiableClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">NonInstantiableClass</span>(<span class="type">const</span> NonInstantiableClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    NonInstantiableClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonInstantiableClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态方法用于获取唯一实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> NonInstantiableClass&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> NonInstantiableClass instance; <span class="comment">// 局部静态变量保证线程安全</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Doing something...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过静态方法获取唯一实例并调用其方法</span></span><br><span class="line">    NonInstantiableClass&amp; obj = NonInstantiableClass::<span class="built_in">getInstance</span>();</span><br><span class="line">    obj.<span class="built_in">doSomething</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>工厂方法模式:</strong> 工厂方法模式允许类将对象的创建过程封装在一个或多个工厂方法中。这种方式可以控制对象的创建逻辑，并且可以隐藏具体的实现细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonInstantiableClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="built_in">NonInstantiableClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有析构函数</span></span><br><span class="line">    ~<span class="built_in">NonInstantiableClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">NonInstantiableClass</span>(<span class="type">const</span> NonInstantiableClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    NonInstantiableClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonInstantiableClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态工厂方法用于创建对象实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::unique_ptr&lt;NonInstantiableClass&gt; <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;NonInstantiableClass&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Doing something...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用工厂方法创建对象实例</span></span><br><span class="line">    std::unique_ptr&lt;NonInstantiableClass&gt; obj = NonInstantiableClass::<span class="built_in">createInstance</span>();</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        obj-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="21-虚基类"><a href="#21-虚基类" class="headerlink" title="21.虚基类"></a>21.虚基类</h4><p>虚基类主要用于解决多重继承中的菱形继承（多义性）问题</p><p>当一个类从多个类继承，而这些类又有一个共同的基类时，如果不使用虚基类，可能会导致基类部分被多次复制。通过将共同基类声明为虚基类，可以确保该基类在派生类中只存在一份实例。</p><p>在<code>FinalClass</code>类的构造函数中，需要显式调用 <code>Base</code> 类的构造函数，因为 <code>Base</code> 是虚基类，必须明确初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">// 定义基类 Base</span><br><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    int baseValue;</span><br><span class="line"></span><br><span class="line">    Base(int val) : baseValue(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Base constructor called, value = &quot; &lt;&lt; baseValue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void show() const &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Base value: &quot; &lt;&lt; baseValue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义 Derived1 类，从 Base 继承，并且 Base 是虚基类</span><br><span class="line">class Derived1 : virtual public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    Derived1(int val) : Base(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Derived1 constructor called&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义 Derived2 类，从 Base 继承，并且 Base 是虚基类</span><br><span class="line">class Derived2 : virtual public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    Derived2(int val) : Base(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Derived2 constructor called&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义 FinalClass 类，从 Derived1 和 Derived2 继承</span><br><span class="line">class FinalClass : public Derived1, public Derived2 &#123;</span><br><span class="line">public:</span><br><span class="line">    FinalClass(int val) : Base(val), Derived1(val), Derived2(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;FinalClass constructor called&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建 FinalClass 的对象</span><br><span class="line">    FinalClass obj(10);</span><br><span class="line"></span><br><span class="line">    // 调用 Base 类的方法</span><br><span class="line">    obj.show();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-怎样判断两个浮点数是否相等？&quot;&gt;&lt;a href=&quot;#1-怎样判断两个浮点数是否相等？&quot; class=&quot;headerlink&quot; title=&quot;1.怎样判断两个浮点数是否相等？&quot;&gt;&lt;/a&gt;1.怎样判断两个浮点数是否相等？&lt;/h4&gt;&lt;p&gt;由于浮点数在计算机中的表示方</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++泛编程</title>
    <link href="https://wangak.cc/posts/24f68203.html"/>
    <id>https://wangak.cc/posts/24f68203.html</id>
    <published>2025-03-22T16:00:00.000Z</published>
    <updated>2025-03-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-泛编程"><a href="#C-泛编程" class="headerlink" title="C++泛编程"></a>C++泛编程</h3><h4 id="1-auto"><a href="#1-auto" class="headerlink" title="1.auto"></a>1.auto</h4><p><strong>auto的主要用途：</strong>让编译器自动推断变量的类型</p><ul><li>代替冗长复杂的变量声明（函数指针）</li><li>在模板中，用于声明依赖模板参数的变量</li><li>函数模板依赖模板参数的返回值</li><li>用于Lambda表达式中</li></ul><h4 id="2-函数模板"><a href="#2-函数模板" class="headerlink" title="2.函数模板"></a>2.函数模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T &amp;a,T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注1：可以为类的成员函数创建模板，但不能是虚函数和析构函数。</em></p><p><em>注2：使用函数模板时，如果自动类型推导，不会发生隐式类型转换，而如果显式指定了函数模板的数据类型，则可以发生隐式类型转换。</em></p><p><strong>编译器使用各种函数的规则：</strong></p><ul><li><p>普通函数&gt;具体化&gt;常规模板</p></li><li><p>如果希望使用函数模板，可以用空模板参数强制使用函数模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;普通函数: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;函数模板: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认情况下，编译器可能优先选择普通函数</span></span><br><span class="line">    <span class="built_in">show</span>(value); <span class="comment">// 输出: 普通函数: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制使用函数模板</span></span><br><span class="line">    show&lt;&gt;(value); <span class="comment">// 输出: 函数模板: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果函数模板能产生更好的匹配，将优先于普通函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">long</span> a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;普通函数: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;函数模板: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽管有一个接受long类型的普通函数，</span></span><br><span class="line">    <span class="comment">// 但函数模板提供了对int类型更直接的匹配。</span></span><br><span class="line">    <span class="built_in">display</span>(value); <span class="comment">// 输出: 函数模板: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>函数模板分文件编写：</strong></p><ul><li><em>函数模板只是函数的描述，没有实体，创建函数模板的代码放在头文件中</em></li><li><em>函数模板具体化有实体，编译原理和普通函数一样，声明放在头文件中，定义放在源文件中。</em></li></ul><h4 id="3-类模板（泛化、全特化、偏特化）"><a href="#3-类模板（泛化、全特化、偏特化）" class="headerlink" title="3.类模板（泛化、全特化、偏特化）"></a>3.类模板（泛化、全特化、偏特化）</h4><p><strong>模板泛化</strong></p><p>模板泛化是不关心具体的类型，而是提供了通用的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 泛化的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic process: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>全特化</strong></p><p><strong>全特化：</strong>为某些类型提供更高效的实现</p><p>成员函数的全特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员函数的特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> MyClass&lt;<span class="type">int</span>&gt;::<span class="built_in">process</span>(<span class="type">int</span> data) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Specialized process for int: &quot;</span> &lt;&lt; data * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板全特化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板的特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized implementation for int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>偏特化</strong></p><p>模板偏特化是指在泛化的模板基础上，对其中的某一部分进行特化。</p><p><strong>模板参数数量的偏特化：</strong>特化部分参数，还存在一部分参数使用通用的模板定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板，有两个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T first;</span><br><span class="line">    U second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板参数数量的偏特化，对第一个模板参数进行特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;<span class="type">int</span>, U&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> first;</span><br><span class="line">    U second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>模板参数范围的偏特化：</strong>对模板的参数范围进行缩小</p><ul><li><strong>const 特化:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic process: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const 特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">const</span> T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> T data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized process for const type: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>指针特化：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic setValue: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span>&lt;T*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized setValue for pointers: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>左值引用特化:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyReference</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic printValue: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左值引用特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyReference</span>&lt;T&amp;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp; ref)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized printValue for lvalue references: &quot;</span> &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>右值引用特化:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRValueReference</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic printValue: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右值引用特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRValueReference</span>&lt;T&amp;&amp;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp;&amp; rvalue)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized printValue for rvalue references: &quot;</span> &lt;&lt; rvalue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>注：函数模板是不能偏特化的，只有类模板可以进行偏特化。函数模板可以不显式指定类型。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;C-泛编程&quot;&gt;&lt;a href=&quot;#C-泛编程&quot; class=&quot;headerlink&quot; title=&quot;C++泛编程&quot;&gt;&lt;/a&gt;C++泛编程&lt;/h3&gt;&lt;h4 id=&quot;1-auto&quot;&gt;&lt;a href=&quot;#1-auto&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++八股4</title>
    <link href="https://wangak.cc/posts/4d7fcbd3.html"/>
    <id>https://wangak.cc/posts/4d7fcbd3.html</id>
    <published>2025-03-19T16:00:00.000Z</published>
    <updated>2025-03-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-malloc、realloc、calloc的区别"><a href="#1-malloc、realloc、calloc的区别" class="headerlink" title="1.malloc、realloc、calloc的区别"></a>1.malloc、realloc、calloc的区别</h4><ul><li><p><strong><code>malloc</code>函数：</strong></p><ul><li><p>用于分配指定大小的内存块，并返回指向该内存块的指针。如果分配失败，则返回 <code>NULL</code>。</p></li><li><p>使用 <code>malloc</code> 分配的内存不会被初始化，其中的数据是随机的。</p></li></ul></li><li><p><strong><code>calloc</code> 函数</strong>：</p><ul><li>原型为 <code>void* calloc(size_t n, size_t size);</code></li><li>第一个参数 <code>n</code> 表示要分配多少个元素；第二个参数 <code>size</code> 表示每个元素的大小（以字节为单位）。</li><li><code>calloc</code> 会将分配的内存初始化为零。</li></ul></li><li><p><strong><code>realloc</code> 函数</strong>：</p><ul><li><p>原型为 <code>void* realloc(void *p, size_t new_size);</code></p></li><li><p><code>realloc</code> 函数用来改变已经分配的内存块的大小。它可以扩大或缩小已有的内存块。如果新的内存大小大于原来的大小，那么新增的部分内容未定义（即可能包含任何值）。如果缩小内存块，超出部分会被丢弃。</p><p><em>注：C++中可以通过使用STL容器来避免使用<code>realloc</code>的情况,可以减少由于手动管理内存而引发错误的可能。</em></p></li></ul></li></ul><h4 id="2-类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？"><a href="#2-类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？" class="headerlink" title="2.类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"></a>2.类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</h4><p><strong>类成员初始化方式：</strong></p><ul><li><strong>赋值初始化</strong>：这是通过在<strong>构造函数体内</strong>对成员变量进行赋值来实现的。</li><li><strong>成员初始化列表</strong>：使用冒号(<code>:</code>)后跟随初始化列表的方式，在构造函数体执行前对成员变量进行初始化。</li></ul><p><strong>构造函数的执行顺序：</strong>（在创建派生类对象时，<strong>基类的构造函数会在派生类的构造函数之前执行</strong>。）</p><ol><li><strong>首先执行虚拟基类的构造函数</strong>（如果有多个虚拟基类，则按照它们被继承的顺序）。</li><li><strong>然后是普通基类的构造函数</strong>（如果有多个普通基类，则按照它们在派生类继承列表中的顺序）。</li><li><strong>接着是派生类中对象成员（包含其他类类型的对象作为其成员变量）的构造函数</strong>（这些成员对象按照它们在类定义中的声明顺序进行初始化，而不是按照初始化列表中的顺序）。</li><li><strong>最后是派生类自己的构造函数</strong>。</li></ol><p><strong>使用成员初始化列表更快的原因：</strong></p><ul><li><strong>C++的赋值操作是会产生临时对象的</strong>：使用赋值初始化时，首先会调用默认构造函数为成员变量分配空间并创建一个临时对象，然后将这个临时对象赋值给成员变量，这会产生额外的开销。</li><li>使用成员初始化列表直接在<strong>成员变量创建时就对其进行初始化</strong>，避免了创建临时对象的过程。</li></ul><h4 id="3-有哪些情况必须用到成员列表初始化？作用是什么？"><a href="#3-有哪些情况必须用到成员列表初始化？作用是什么？" class="headerlink" title="3.有哪些情况必须用到成员列表初始化？作用是什么？"></a>3.有哪些情况必须用到成员列表初始化？作用是什么？</h4><p><strong>成员列表初始化的四种必须使用的情况：</strong></p><ul><li><p><strong>初始化引用成员</strong>：引用成员必须在创建时初始化，且不能重新赋值。因此，必须在成员初始化列表中进行初始化。</p></li><li><p><strong>初始化常量成员</strong>：常量成员（<code>const</code>）一旦初始化后不能修改，因此必须在成员初始化列表中初始化。</p></li><li><p><strong>调用基类的构造函数</strong>：如果<strong>基类没有默认构造函数</strong>，或者需要传递参数给基类构造函数，必须在成员初始化列表中调用基类的构造函数。</p></li><li><p><strong>调用成员类的构造函数</strong>：如果类的成员是另一个类的对象，并且该<strong>成员类没有默认构造函数</strong>，或者需要传递参数，必须在成员初始化列表中调用该成员类的构造函数。</p><p><em>注：在函数体内进行赋值初始化时，成员就已经存在了</em></p></li></ul><p><strong>成员初始化列表的作用：</strong></p><ul><li><strong>初始化顺序</strong>：编译器会按照成员初始化列表中的顺序，在构造函数体内插入初始化操作，且这些操作在任何用户代码之前执行。</li><li><strong>初始化顺序的决定</strong>：初始化列表的顺序并不决定实际的初始化顺序，实际的初始化顺序由类中成员的<strong>声明顺序决定。</strong></li></ul><h4 id="4-C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的？"><a href="#4-C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的？" class="headerlink" title="4.C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？"></a>4.C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？</h4><ul><li><strong>string是对char*进行了封装</strong>，封装的string包含了char*数组，容量，长度等等属性。</li><li><strong>string可以进行动态扩展</strong>，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</li></ul><h4 id="5-什么是内存泄露，如何检测与避免"><a href="#5-什么是内存泄露，如何检测与避免" class="headerlink" title="5.什么是内存泄露，如何检测与避免"></a>5.什么是内存泄露，如何检测与避免</h4><p><strong>内存泄露：</strong>指的是堆内存的泄露，分配的内存块在使用完成后没有正确地释放。</p><p><strong>避免内存的泄露的方式：</strong></p><ul><li><p><strong>计数法：</strong>使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</p></li><li><p><strong>将基类的析构函数声明为虚函数：</strong>这可以保证当通过基类指针删除派生类对象时，派生类的析构函数能够被正确调用，从而避免因未正确调用析构函数导致的内存泄漏。</p><p><em>注：如果基类的析构函数不是<code>virtual</code>，通过基类指针删除派生类对象只会调用基类的析构函数。</em></p></li><li><p><strong>正确释放对象数组</strong>：对于使用 <code>new[]</code> 分配的对象数组，应使用 <code>delete[]</code> 来释放，而不是 <code>delete</code>，以避免内存泄漏。</p></li><li><strong>成对出现原则</strong>：确保每一对 <code>new</code>/<code>delete</code> 和 <code>malloc</code>/<code>free</code> 成对出现，即每次分配内存后都必须有相应的释放操作</li></ul><p><strong>检测工具</strong></p><ul><li>Linux下可以使用<strong>Valgrind工具</strong></li><li>Windows下可以使用<strong>CRT库</strong></li></ul><h4 id="6-对象复用的了解，零拷贝的了解"><a href="#6-对象复用的了解，零拷贝的了解" class="headerlink" title="6.对象复用的了解，零拷贝的了解"></a>6.对象复用的了解，零拷贝的了解</h4><p><strong>对象复用</strong>：在设计模式中通常指的是<strong>Flyweight（享元）模式</strong>。该模式旨在通过共享尽可能多的数据来最小化内存使用，特别是当系统需要创建大量细粒度的对象时。通过<strong>将相似或相同的对象存储在一个“对象池”中，并在需要时重复利用这些对象</strong>，可以有效<strong>减少内存占用和对象创建的开销。</strong></p><ul><li><p><strong>亨元模式：</strong> 由亨元工厂创建新的亨元对象前，先检查“对象池”中是否有相同属性对象，若有可以重复使用这些对象，而不是创建新的对象。</p><p>eg:假设我们正在开发一个<strong>文本编辑器</strong>，其中每个字符都由一个独立的对象表示。如果我们直接为每个字符创建一个新的对象实例，那么对于长文档来说，这将导致大量的内存消耗。Flyweight模式可以帮助我们通过共享相同字符的属性（如字体、颜色等）来优化这一过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Flyweight接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Character</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体Flyweight类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCharacter</span> : <span class="keyword">public</span> Character &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> font_family_;</span><br><span class="line">    <span class="type">int</span> font_size_;</span><br><span class="line">    std::string color_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCharacter</span>(<span class="type">char</span> font_family, <span class="type">int</span> font_size, <span class="type">const</span> std::string&amp; color)</span><br><span class="line">        : <span class="built_in">font_family_</span>(font_family), <span class="built_in">font_size_</span>(font_size), <span class="built_in">color_</span>(color) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character: &quot;</span> &lt;&lt; ch </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, Font Family: &quot;</span> &lt;&lt; font_family_ </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, Font Size: &quot;</span> &lt;&lt; font_size_ </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, Color: &quot;</span> &lt;&lt; color_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flyweight工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CharacterFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, Character*&gt; characters_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">CharacterFactory</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : characters_) &#123;</span><br><span class="line">            <span class="keyword">delete</span> pair.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Character* <span class="title">getCharacter</span><span class="params">(<span class="type">char</span> font_family, <span class="type">int</span> font_size, <span class="type">const</span> std::string&amp; color)</span> </span>&#123;</span><br><span class="line">        std::string key = std::<span class="built_in">string</span>(<span class="number">1</span>, font_family) + std::<span class="built_in">to_string</span>(font_size) + color;</span><br><span class="line">        <span class="keyword">if</span> (characters_.<span class="built_in">find</span>(key) == characters_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            characters_[key] = <span class="keyword">new</span> <span class="built_in">ConcreteCharacter</span>(font_family, font_size, color);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> characters_[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CharacterFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一些字符对象，但共享相同的属性</span></span><br><span class="line">    Character* charA = factory.<span class="built_in">getCharacter</span>(<span class="string">&#x27;T&#x27;</span>, <span class="number">12</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">    Character* charB = factory.<span class="built_in">getCharacter</span>(<span class="string">&#x27;T&#x27;</span>, <span class="number">12</span>, <span class="string">&quot;red&quot;</span>); <span class="comment">// 应该复用charA的实例</span></span><br><span class="line"></span><br><span class="line">    charA-&gt;<span class="built_in">display</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    charB-&gt;<span class="built_in">display</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即使请求了两次相同的属性组合，实际上只会有一个ConcreteCharacter实例被创建</span></span><br><span class="line">    <span class="keyword">if</span> (charA == charB) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;charA and charB are the same instance.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;charA and charB are different instances.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码中分别请求了两个具有相同属性的字符对象，但实际上它们引用的是同一个<code>ConcreteCharacter</code>实例,实现了对象复用的目的。</strong></p></li></ul><p><strong>零拷贝</strong>：一种优化技术，目的是<strong>减少数据从一处存储到另一处传输过程中CPU的参与程度</strong>，从而提高效率并降低资源消耗。传统上，数据传输可能涉及多次复制操作，比如从磁盘读取数据到内核空间，再复制到用户空间等。零拷贝技术减少了这种不必要的数据复制次数，降低了CPU的工作量和总线活动。</p><p><strong>*注：<code>vector</code>的一个成员函数emplace_back()很好地体现了零拷贝技术。</strong><code>emplace_back()</code> 是在容器内部直接构造对象，而不是先创建一个临时对象再进行拷贝或移动。这意味着它可以在不调用拷贝构造函数或移动构造函数的情况下，在容器预留的位置原地构造对象，这通常更高效。*</p><h4 id="7-介绍面向对象的三大特性，并且举例说明"><a href="#7-介绍面向对象的三大特性，并且举例说明" class="headerlink" title="7.介绍面向对象的三大特性，并且举例说明"></a>7.介绍面向对象的三大特性，并且举例说明</h4><ul><li><strong>继承：</strong> 让某种类型对象获得另一个类型对象的属性和方法。<ul><li>实现继承：指使用基类的属性和方法而无需额外编码的能力</li><li>接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力</li></ul></li><li><strong>封装：</strong> <strong>把客观事物封装成抽象的类</strong>，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏</li><li><strong>多态：</strong> 同一事物表现出不同事物的能力<ul><li><strong>实现多态有二种方式：覆盖（override），重载（overload）</strong></li><li>重载实现编译时多态，虚函数实现运行时多态</li></ul></li></ul><h4 id="8-C-的四种强制转换"><a href="#8-C-的四种强制转换" class="headerlink" title="8.C++的四种强制转换"></a>8.C++的四种强制转换</h4><p>C++提供了四种类型的显式类型转换运算符：<code>reinterpret_cast</code>、<code>const_cast</code>、<code>static_cast</code> 和 <code>dynamic_cast</code></p><ul><li><p><strong><code>reinterpret_cast</code></strong>：在不相关的类型之间进行低级别的强制转换。它可以将任何指针类型转换为另一个指针类型，或指针到整数类型的转换等。<strong>转换后的数和原来的数有相同的比特位。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *c = reinterpret_cast&lt;char*&gt;(p); // 将int指针转换为char指针</span><br></pre></td></tr></table></figure><p><em>注：<code>reinterpret_cast</code>没有进行任何的类型检查,因此很容易发生由于指针类型不匹配而引发的内存错误</em></p></li><li><p><strong><code>const_cast</code></strong>：主要用于添加或移除变量的<code>const</code>或<code>volatile</code>属性。它只能改变这些限定符，不能改变对象的实际类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char *p = &quot;hello&quot;;</span><br><span class="line">char *q = const_cast&lt;char*&gt;(p);</span><br></pre></td></tr></table></figure><p><em>注：这里将 `const char</em><code>类型的指针</code>p<code>转换为</code>char<em><code>类型的指针</code>q`。</em></p></li><li><p><strong><code>static_cast</code></strong>：用于类层次结构中的上行转换（派生类到基类）和下行转换（基类到派生类），以及基本数据类型之间的转换。</p><ul><li><p><strong>特点</strong>：<strong>不进行运行时类型检查</strong>，因此在下行转换时可能不安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">65</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(n);<span class="comment">//这里将 int 类型的变量 n 转换为 char 类型的变量 c。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>dynamic_cast</code>:</strong> 主要用于类层次结构中的上行转换和下行转换，特别是用于多态类型的转换。</p><ul><li><p><strong>特点：</strong>在运行时<strong>进行类型检查</strong>，如果转换不安全（如下行转换时基类指针不指向派生类对象），则返回 <code>nullptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Base *b = <span class="keyword">new</span> Son;</span><br><span class="line">Son *s = <span class="built_in">dynamic_cast</span>&lt;Son*&gt;(b);<span class="comment">//这里将 Base* 类型的指针 b 转换为 Son* 类型的指针 s，并在转换失败时返回 nullptr。</span></span><br><span class="line"><span class="keyword">if</span> (s) &#123;</span><br><span class="line">    <span class="comment">// 转换成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 转换失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="9-C-函数调用的压栈过程"><a href="#9-C-函数调用的压栈过程" class="headerlink" title="9.C++函数调用的压栈过程"></a>9.C++函数调用的压栈过程</h4><p><strong>函数调用的压栈过程:</strong></p><ul><li><strong>分配栈空间</strong>：为被调用函数分配栈空间，用于存储函数的局部变量、参数和返回地址等信息。</li><li><strong>参数压栈</strong>：将实参的值复制到形参的栈空间中。C++中，参数是从右到左依次压栈的。</li><li><strong>保存返回地址</strong>：将当前函数的返回地址（即调用函数的下一条指令地址）压入栈中，以便函数执行完毕后能正确返回到调用点。</li><li><strong>保存调用函数的运行状态</strong>：将调用函数的寄存器状态、局部变量等信息压入栈中，以便函数调用结束后恢复。</li><li><strong>执行被调用函数</strong>：跳转到被调用函数的代码并执行。</li><li><strong>函数返回</strong>：函数执行完毕后，从栈中弹出返回地址、恢复调用函数的运行状态，并释放栈空间。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> param1, <span class="type">int</span> param2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var1 = param1;</span><br><span class="line">    <span class="type">int</span> var2 = param2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;var1=%d,var2=%d&quot;</span>, <span class="built_in">f</span>(var1), <span class="built_in">f</span>(var2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">var1=1,var2=2</span><br></pre></td></tr></table></figure><h4 id="10-说说移动构造函数"><a href="#10-说说移动构造函数" class="headerlink" title="==10.说说移动构造函数=="></a>==10.说说移动构造函数==</h4><p><strong>既要实现资源的有效转移，又要避免潜在的双重释放的风险</strong></p><p><strong>移动构造函数：</strong>用“转移”代替“复制”来提高性能</p><p><strong>拷贝构造 vs 移动构造</strong></p><ul><li><strong>拷贝构造函数</strong>：通常涉及到深拷贝，特别是对于包含动态分配资源的对象。例如，如果一个类含有指针成员变量，那么在拷贝构造时需要为新对象分配新的内存，并将原始对象的数据复制过去。这增加了额外的时间和空间开销。</li><li><strong>移动构造函数</strong>：则是采用<strong>浅层复制</strong>的方式，直接<strong>将资源的所有权从一个对象转移到另一个对象</strong>，而不进行实际的数据复制。这样做的前提是确保源对象不再持有这些资源，以防止重复释放同一块内存导致的错误。</li><li><strong>参数类型差异</strong><ul><li><strong>拷贝构造函数</strong>：接受一个<strong>左值引用</strong>作为参数，意味着它可以接受任何有效的已有对象。</li><li><strong>移动构造函数</strong>：接受一个<strong>右值引用</strong>（或称为将亡值引用）作为参数。这意味着它只能用于那些即将销毁或不再使用的对象，比如临时对象或者通过<code>std::move</code>显式转换成右值的对象。</li></ul></li></ul><p><strong>如何实现安全的资源转移？</strong></p><p>​    为了避免因浅层复制导致的双重释放问题，移动构造函数会在获取源对象资源的同时，将源对象中的相应指针置为<code>nullptr</code>（或其他适当值）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 确保other不会在析构时释放data指向的内存</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass</code> 的移动构造函数接收一个右值引用 <code>MyClass&amp;&amp;</code>，并将<code>other</code>对象的数据成员<code>data</code>直接赋值给当前对象的<code>data</code>成员，然后将<code>other.data</code>设置为<code>nullptr</code>。这样做既实现了资源的有效转移，又避免了潜在的双重释放风险。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass a;</span><br><span class="line">MyClass b = std::<span class="built_in">move</span>(a); <span class="comment">// 调用移动构造函数</span></span><br></pre></td></tr></table></figure><p>注：<code>std::move(a)</code>使得<code>a</code>被视为一个右值，从而触发<code>MyClass</code>的移动构造函数。</p><h4 id="11-说一下C-左值引用和右值引用"><a href="#11-说一下C-左值引用和右值引用" class="headerlink" title="11.说一下C++左值引用和右值引用"></a>11.说一下C++左值引用和右值引用</h4><p><strong>左值（lvalue）:</strong></p><ul><li><p>可以获取地址的表达式。</p></li><li><p>通常有名字，可以出现在赋值语句的左边。</p></li><li><p>例如：变量、对象、函数返回的引用等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// a 是左值</span></span><br><span class="line"><span class="type">int</span>&amp; b = a;  <span class="comment">// b 是左值引用</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>右值（rvalue）</strong>：</p><ul><li><p>不能获取地址的表达式。</p></li><li><p>通常是临时的、没有名字的值。</p></li><li><p>例如：常量、临时对象、函数返回值（非引用）、表达式结果等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c = <span class="number">5</span> + <span class="number">10</span>;  <span class="comment">// 5 + 10 是右值</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; d = <span class="number">10</span>;    <span class="comment">// 10 是右值</span></span><br></pre></td></tr></table></figure><ul><li><strong>纯右值（prvalue）</strong>：如字面量、临时对象、表达式结果等。</li><li><strong>将亡值（xvalue）</strong>：与右值引用相关的表达式，通常是通过 <code>std::move</code> 或返回右值引用的函数得到的值。</li></ul></li></ul><p><strong>左值引用</strong>：用 <code>&amp;</code> 声明。</p><p><strong>右值引用</strong>：用 <code>&amp;&amp;</code> 声明。主要用于实现 <strong>移动语义</strong> 和 <strong>完美转发</strong>。</p><p><strong>右值引用的特点:</strong></p><ul><li><p><strong>延长右值的生命周期</strong>：右值引用可以将临时对象（右值）的生命周期延长到与右值引用变量的生命周期一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; d = <span class="number">10</span>;  <span class="comment">// 临时对象 10 的生命周期被延长</span></span><br></pre></td></tr></table></figure></li><li><p><strong>右值引用可能是左值或右值</strong>：右值引用类型的变量本身可能是左值或右值，取决于其初始化方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; e = <span class="number">10</span>;  <span class="comment">// e 是右值引用，但 e 本身是左值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>自动类型推断中的右值引用</strong>：在模板函数中，<code>T&amp;&amp;</code> 可以是左值引用或右值引用，取决于传入的参数类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">fun</span>(a);  <span class="comment">// t 是左值引用</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="number">10</span>); <span class="comment">// t 是右值引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>移动语义</strong>：通过 <code>std::move</code> 将左值强制转换为右值引用，从而避免不必要的拷贝操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2 = std::<span class="built_in">move</span>(v1);  <span class="comment">// v1 的资源被移动到 v2</span></span><br></pre></td></tr></table></figure><p><strong>完美转发</strong>：通过右值引用和 <code>std::forward</code>，将参数按照其原始类型转发给其他函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 完美转发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-C-中将临时变量作为返回值时的处理过程"><a href="#12-C-中将临时变量作为返回值时的处理过程" class="headerlink" title="12.C++中将临时变量作为返回值时的处理过程"></a>12.C++中将临时变量作为返回值时的处理过程</h4><p>在C++中，当函数返回临时变量时，虽然该临时变量会在函数退出时被销毁，但由于<strong>返回值是通过寄存器而非栈或堆内存进行传递的</strong>，因此返回值的正确性和完整性得到了保证。</p><h4 id="13-静态类型和动态类型，静态绑定和动态绑定的介绍"><a href="#13-静态类型和动态类型，静态绑定和动态绑定的介绍" class="headerlink" title="13.静态类型和动态类型，静态绑定和动态绑定的介绍"></a>13.静态类型和动态类型，静态绑定和动态绑定的介绍</h4><p><strong>静态类型与动态类型</strong></p><ul><li><p><strong>静态类型：</strong>对象在声明时采⽤的类型，在编译期既已确定；例如，<code>A* pa</code>的静态类型是<code>A*</code>，无论<code>pa</code>指向的是哪个子类对象。</p></li><li><p><strong>动态类型：</strong>指针或引用实际指向的对象的类型，是在运行期决定的。例如，<code>A* pa = new B();</code>，<code>pa</code>的静态类型是<code>A*</code>，但动态类型是<code>B*</code>。</p></li></ul><p><strong>静态绑定与动态绑定</strong></p><ul><li><strong>静态绑定</strong>：绑定的是静态类型，函数或属性的调用依赖于对象的静态类型，发生在编译期。<strong>非虚函数通常使用静态绑定。</strong></li><li><strong>动态绑定</strong>：绑定的是动态类型，函数或属性的调用依赖于对象的动态类型，发生在运行期。<strong>虚函数使用动态绑定，从而实现多态性。</strong></li></ul><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*virtual*/</span> <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C* pc = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line">    B* pb = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    A* pa = pc;</span><br><span class="line">    pa = pb;</span><br><span class="line"></span><br><span class="line">    pa-&gt;<span class="built_in">func</span>(); <span class="comment">// 如果func不是虚函数，则总是调用A::func()</span></span><br><span class="line">    pc-&gt;<span class="built_in">func</span>(); <span class="comment">// 总是调用C::func()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pc;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注1：如果 <code>A</code> 中的 <code>func</code> 不是虚函数，那么 <code>pa-&gt;func()</code> 将总是调用 <code>A::func()</code>，因为这是基于 <code>pa</code> 的静态类型（即 `A</em>`）进行的静态绑定。*</p><p><em>注2：如果将 <code>func</code> 声明为虚函数（取消注释 <code>virtual</code>），那么 <code>pa-&gt;func()</code> 将根据 <code>pa</code> 所指向的实际对象类型（即动态类型）调用相应的 <code>func</code> 函数，实现动态绑定。</em></p><h4 id="14-引用是否能实现动态绑定，为什么可以实现？"><a href="#14-引用是否能实现动态绑定，为什么可以实现？" class="headerlink" title="14.引用是否能实现动态绑定，为什么可以实现？"></a>14.引用是否能实现动态绑定，为什么可以实现？</h4><p><strong>引用</strong>和<strong>指针</strong>都可以实现动态绑定，但这种动态绑定仅适用于<strong>虚函数</strong>。</p><p><strong>动态绑定的条件</strong></p><ul><li><strong>虚函数</strong>：只有当一个函数被声明为<code>virtual</code>时，才能通过基类的引用或指针调用派生类中的重写版本。这是因为<strong>虚函数支持运行期确定实际调用哪个函数</strong>，这被称为动态绑定或多态性。</li><li><strong>引用必须初始化</strong>：创建引用时必须同时初始化它，这意味着你必须指定引用所绑定的具体对象。一旦初始化完成，引用就不能再指向其他对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base :: fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;son :: fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;son :: not virtual function&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    Base&amp; b = s; <span class="comment">// 基类类型引用绑定到Son对象</span></span><br><span class="line">    s.<span class="built_in">fun</span>();     <span class="comment">// 输出: son::fun()</span></span><br><span class="line">    b.<span class="built_in">fun</span>();     <span class="comment">// 输出: son::fun()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-malloc、realloc、calloc的区别&quot;&gt;&lt;a href=&quot;#1-malloc、realloc、calloc的区别&quot; class=&quot;headerlink&quot; title=&quot;1.malloc、realloc、calloc的区别&quot;&gt;&lt;/a&gt;1.malloc</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++八股3</title>
    <link href="https://wangak.cc/posts/d31b5e70.html"/>
    <id>https://wangak.cc/posts/d31b5e70.html</id>
    <published>2025-03-17T16:00:00.000Z</published>
    <updated>2025-03-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么是大小端存储？"><a href="#1-什么是大小端存储？" class="headerlink" title="1.什么是大小端存储？"></a>1.什么是大小端存储？</h4><p><strong>大端存储：</strong>数据的最高有效字节存放在内存地址的最低位置</p><p><strong>小端存储：</strong>最低有效字节被存放在内存地址的最低位置</p><p><em>注：在网络协议中通常使用大端序</em></p><h4 id="2-volatile、mutable和explicit关键字的用法"><a href="#2-volatile、mutable和explicit关键字的用法" class="headerlink" title="2.volatile、mutable和explicit关键字的用法"></a>2.volatile、mutable和explicit关键字的用法</h4><ul><li><strong>volatile：</strong></li></ul><p><strong><code>volatile</code></strong>关键字用于告诉编译器，该变量的值可能会在程序控制之外被改变（如硬件中断、操作系统、其他线程等）。因此，<strong>编译器不应该对涉及该变量的操作进行优化。</strong></p><p><strong>每次访问<code>volatile</code>变量时，都会从内存重新读取数据，而不是使用寄存器中的缓存副本。（这样可以防止变量被其他线程修改后读到错误的变量值）</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503191910704.png" alt="image-20250318133449499" style="zoom: 50%;"></p><p><em>注：现代编译器为了提高性能，通常会将经常访问的变量值保存在CPU寄存器中，以便快速访问。</em></p><ul><li><strong>mutable：</strong> <code>mutable</code>关键字用于<strong>允许对象的某些成员变量即使在<code>const</code>成员函数内也可以被修改。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> accessCount; <span class="comment">// 可变成员变量，用于记录访问次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a) : <span class="built_in">age</span>(a), <span class="built_in">accessCount</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 成员函数，理论上不应该修改类的数据成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 在 const 函数中修改非 mutable 成员会导致编译错误</span></span><br><span class="line">        <span class="comment">// age = 30; // 错误：不能修改</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改 mutable 成员是允许的</span></span><br><span class="line">        ++accessCount;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This method has been called &quot;</span> &lt;&lt; accessCount &lt;&lt; <span class="string">&quot; times.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> Person <span class="title">person</span><span class="params">(<span class="number">25</span>)</span></span>; <span class="comment">// 创建一个常量对象</span></span><br><span class="line">    person.<span class="built_in">getAge</span>(); <span class="comment">// 第一次调用</span></span><br><span class="line">    person.<span class="built_in">getAge</span>(); <span class="comment">// 第二次调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>explicit: </strong> <code>explicit</code>关键字用于<strong>防止单参数构造函数的隐式类型转换</strong>。只能应用于类内部的<strong>构造函数声明</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Integer</span><span class="params">(<span class="type">int</span> x)</span> : value(x) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 假设我们需要提供获取值的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printInteger</span><span class="params">(<span class="type">const</span> Integer&amp; i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印 Integer 对象的内容</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The integer value is: &quot;</span> &lt;&lt; i.<span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面这一行会导致编译错误，因为不允许隐式转换</span></span><br><span class="line">    <span class="comment">// printInteger(10);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确的做法是显式地构造 Integer 对象</span></span><br><span class="line">    <span class="built_in">printInteger</span>(<span class="built_in">Integer</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-什么情况下会调用拷贝构造函数"><a href="#3-什么情况下会调用拷贝构造函数" class="headerlink" title="3.什么情况下会调用拷贝构造函数"></a>3.什么情况下会调用拷贝构造函数</h4><ul><li><p><strong>对象初始化：</strong> 用类的一个<strong>实例化对象去初始化另一个对象</strong>的时候</p></li><li><p><strong>按值传递参数</strong>： 当一个函数的参数是类的对象且通过值传递（非引用传递），在函数调用时<strong>会创建一个参数的副本</strong>，此时会调用拷贝构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useClassA</span><span class="params">(A a)</span> </span>&#123;&#125;  <span class="comment">// 函数定义</span></span><br><span class="line"><span class="built_in">useClassA</span>(a1);          <span class="comment">// 调用时会调用拷贝构造函数</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-C-中有几种类型的new"><a href="#4-C-中有几种类型的new" class="headerlink" title="4.C++中有几种类型的new"></a>4.C++中有几种类型的new</h4><ul><li><strong>Plain New</strong></li></ul><p>​    <code>Plain new</code>指的是标准的、普通的<code>new</code>操作符，用于动态分配内存。它不仅负责分配所需的内存空间，还会调用对象的构造函数（如果是对象的话）。</p><p>​    <strong>异常处理</strong>: 在C++中，当使用<code>plain new</code>进行内存分配且分配失败时（例如，系统无法提供请求的内存大小），它会抛出一个<code>std::bad_alloc</code>异常，而不是返回<code>NULL</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试分配一个极大的内存空间，可能会失败</span></span><br><span class="line">        <span class="type">char</span> *p = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10e11</span>];  <span class="comment">// 这里尝试分配大约100GB的空间，很可能导致std::bad_alloc异常被抛出</span></span><br><span class="line">        <span class="keyword">delete</span>[] p;  <span class="comment">// 如果分配成功，则释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc &amp;ex) &#123;  <span class="comment">// 捕捉std::bad_alloc异常</span></span><br><span class="line">        cout &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">// 输出异常信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>nothrow new</strong></p><p><code>nothrow new</code>在空间分配失败的情况下是不抛出异常，而是返回NULL</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="number">10e11</span>];</span><br><span class="line"> <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;alloc failed&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">delete</span> p;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//运⾏结果：alloc failed</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Placement New</strong></p></li></ul><p>​    <code>placement new</code>允许在⼀块已经分配成功的内存上新构造对象或对象数组。<code>placement new</code>不用担心内存分配失败，因为它根本不分配内存，它做的唯⼀⼀件事情就是调⽤对象的构造函数。</p><p>​    <strong>用途</strong>: 主要用于<strong>优化性能和控制内存管理</strong>，例如<strong>在一个循环中反复创建和销毁对象时，可以避免频繁的内存分配和释放操作</strong>，从而提高效率。</p><p>​    <em>注1：<strong>显式调用析构函数</strong>：由于 <code>placement new</code> 只负责调用对象的构造函数，并不负责释放内存，因此当你不再需要对象时，必须手动调用对象的析构函数来清理资源。</em></p><p>​    <em>注2：<strong>不要使用 <code>delete</code></strong>：不能对通过 <code>placement new</code> 创建的对象直接使用 <code>delete</code>，因为这可能导致内存泄漏或其他运行时错误。应该首先显式调用对象的析构函数，然后根据情况决定是否释放底层内存。（因为 <code>delete</code> 预期的是由 <code>new</code> 返回的一个指针，它只知道如何释放这块特定类型的内存。）</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ADT</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ADT</span>() : <span class="built_in">i</span>(<span class="number">10</span>), <span class="built_in">j</span>(<span class="number">100</span>) &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ADT construct i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j=&quot;</span> &lt;&lt; j &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ADT</span>() &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ADT destruct&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="built_in">sizeof</span>(ADT)]; <span class="comment">// 动态分配足够大的内存来容纳一个ADT对象</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123; <span class="comment">// 注意：这里应该是检查 p 是否为 nullptr 而不是 NULL</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;alloc failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ADT *q = <span class="built_in">new</span>(p) ADT; <span class="comment">// 使用 placement new 在 p 所指向的内存上构造 ADT 对象</span></span><br><span class="line">    <span class="comment">// 不可以直接 delete q;</span></span><br><span class="line">    q-&gt;~<span class="built_in">ADT</span>(); <span class="comment">// 显式调用 ADT 的析构函数</span></span><br><span class="line">    <span class="keyword">delete</span>[] p; <span class="comment">// 最后释放最初分配的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-C-的异常处理的方法"><a href="#5-C-的异常处理的方法" class="headerlink" title="5.C++的异常处理的方法"></a>5.C++的异常处理的方法</h4><ul><li><p><strong>try、throw和catch关键字</strong></p><ul><li><p><strong>try</strong>:  <code>try</code>块用于包裹可能抛出异常的代码段。当<code>try</code>块中的任何代码抛出了一个异常，程序会立即寻找与之匹配的<code>catch</code>块进行处理。</p></li><li><p><strong>throw</strong>: 当程序检测到一个无法处理的错误时，可以使用<code>throw</code>语句抛出一个异常。这个异常可以是任意类型的数据（例如整数、浮点数、字符串或者自定义类对象），它包含了关于错误的信息。</p></li><li><p><strong>catch</strong>: <code>catch</code>块用于捕获由<code>throw</code>语句抛出的异常。每个<code>catch</code>后面都跟着一个参数列表，指定了它可以处理的异常类型。一旦某个异常被抛出，程序会查找最近的匹配<code>catch</code>块，并将控制权转移到该块。如果找不到匹配的<code>catch</code>块，程序将终止运行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> m = <span class="number">1</span>, n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">-1</span>; <span class="comment">// 抛出int型异常</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">-1.0</span>; <span class="comment">// 抛出 double 型异常</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; m / n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">double</span> d) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;catch (double)&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通用的catch(...)块</span></span><br><span class="line"><span class="built_in">catch</span> (...) &#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;catch (...)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;finished&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>函数的异常声明列表:</strong> 在定义函数的时候知道函数可能发⽣的异常，可以在函数声明和定义时，指出所能抛出异常的列表.</p><p><code>int fun() throw(int,double,A,B,C)&#123;...&#125;;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义三个可能被抛出的异常类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionA</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionB</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionC</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数fun声明和定义时指定了它可能抛出的异常类型：int, double, ExceptionA, ExceptionB, ExceptionC</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>, ExceptionA, ExceptionB, ExceptionC)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> condition = <span class="number">3</span>; <span class="comment">// 假设根据某种条件决定抛出何种异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (condition == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">1</span>; <span class="comment">// 抛出int型异常</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">2.0</span>; <span class="comment">// 抛出double型异常</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ExceptionA</span>(); <span class="comment">// 抛出自定义异常ExceptionA</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ExceptionB</span>(); <span class="comment">// 抛出自定义异常ExceptionB</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ExceptionC</span>(); <span class="comment">// 抛出自定义异常ExceptionC</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">fun</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an int exception: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">double</span> e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught a double exception: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (ExceptionA&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an ExceptionA&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (ExceptionB&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an ExceptionB&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (ExceptionC&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an ExceptionC&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; <span class="comment">// 捕获所有其他未列出的异常</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an unspecified exception&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>C++标准异常类exception</strong></p><p>C++ 标准库中有⼀些类代表异常，这些类都是从 exception 类派⽣⽽来的</p><ul><li><p><code>std::bad_typeid:</code> 当使用<code>typeid</code>运算符对一个多态类的指针进行操作时，如果该指针的值为<code>NULL</code>（即指向空），则会抛出<code>std::bad_typeid</code>异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">typeid</span>(*ptr).<span class="built_in">name</span>() &lt;&lt; std::endl; <span class="comment">// 这里会抛出 std::bad_typeid 异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_typeid&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_typeid: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>std::bad_cast:</code> 当使用<code>dynamic_cast</code>进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的（例如，基类指针实际上并不指向正确的派生类对象），则会抛出<code>std::bad_cast</code>异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="keyword">public</span>: <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Derived&amp; derivedRef = <span class="built_in">dynamic_cast</span>&lt;Derived&amp;&gt;(*basePtr); <span class="comment">// 这里会抛出 std::bad_cast 异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_cast&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_cast: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>std::bad_alloc</code>: 当使用<code>new</code>运算符进行动态内存分配时，如果没有足够的内存，则会引发<code>std::bad_alloc</code>异常。</p></li><li><p><code>std::out_of_range</code>: 当你使用<code>vector</code>或<code>string</code>的<code>at()</code>成员函数根据下标访问元素时，如果提供的下标越界了，则会抛出<code>std::out_of_range</code>异常。</p></li></ul></li></ul><h4 id="6-形参与实参的区别？"><a href="#6-形参与实参的区别？" class="headerlink" title="6.形参与实参的区别？"></a>6.形参与实参的区别？</h4><ul><li><strong>形参变量的作用范围</strong>：形参是在定义函数时声明的变量，它们只有在函数被调用时才会分配内存单元，并且<strong>仅在函数内部有效。</strong></li><li><strong>实参的类型与值确定性</strong>：这就要求在调用函数之前，确保所有实参都有明确的值。</li><li><strong>实参与形参的一致性</strong>：实参和形参的数量、类型以及顺序需要严格匹配。</li><li><strong>非指针类型的形参与实参的独立性</strong>：如果形参和实参都不是指针类型，那么在函数执行期间，形参会创建实参的一个副本，即形参获得的是实参值的一份拷贝。这样，在函数内部对形参所做的任何改变都不会影响到外部的实参。当函数执行完毕后，形参占用的内存被释放，而实参保持不变。</li></ul><h4 id="7-值传递、指针传递、引用传递的区别和效率"><a href="#7-值传递、指针传递、引用传递的区别和效率" class="headerlink" title="7.值传递、指针传递、引用传递的区别和效率"></a>7.值传递、指针传递、引用传递的区别和效率</h4><ul><li><strong>值传递：</strong>将实际参数的值<strong>复制</strong>一份传递给函数的形式参数。函数内部对形参的修改不会影响到实参。如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。<strong>实参和形参在不同的内存位置，它们占用不同的存储空间。</strong>形参是实参的一个副本，当<strong>函数调用结束后，形参占用的内存空间会被释放。</strong></li><li><strong>指针传递：</strong>函数参数为指针类型。通过传递变量的地址，<strong>函数内部可以通过这个地址访问和修改原始变量的值。</strong>（<strong>传值</strong>，传递的是固定为<strong>4字节的地址值</strong>）</li><li><strong>引用传递：</strong>在函数调用时，将实际参数的引用（别名）传递给函数的形式参数。对形参的操作<strong>实际上就是对实参的操作</strong>。（<strong>传地址</strong>）</li></ul><p><strong>效率上，指针传递和引用传递比值传递效率高。</strong></p><p>注：<strong>需要返回多个值时可以使用指针作为参数</strong>：当一个函数需要返回多个值时，可以使用指针作为参数来允许函数修改传入的变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor, <span class="type">int</span>* quotient, <span class="type">int</span>* remainder)</span> </span>&#123;</span><br><span class="line">    *quotient = dividend / divisor;</span><br><span class="line">    *remainder = dividend % divisor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-局部变量什么时候初始化"><a href="#8-局部变量什么时候初始化" class="headerlink" title="8.局部变量什么时候初始化"></a>8.局部变量什么时候初始化</h4><ul><li><p><strong>普通局部变量：</strong></p><ul><li><strong>初始化时机</strong>：普通局部变量在每次进入其作用域时被创建，并且可以在声明时或者之后进行初始化。<strong>初始化不是自动的</strong>，需要显式地给它们赋值。</li></ul></li><li><p><strong>静态局部变量：</strong></p><ul><li><strong>初始化时机</strong>：在<strong>首次用到时初始化</strong>，可使用变量初始化，这是因为初始化要执行构造函数</li><li><strong>析构顺序</strong>：当程序结束时，静态局部变量会按照它们构造的逆序进行析构。此外，C++通过<code>atexit()</code>函数来管理这些对象的析构顺序，确保它们能以正确的顺序被销毁。</li></ul></li><li><p><strong>全局静态变量：</strong></p><ul><li><strong>初始化时机</strong>：全局静态变量和静态局部变量类似，在程序开始执行前就已初始化。然而，在不同编译单元中的全局静态对象的初始化顺序是不确定的，这可能导致依赖于特定初始化顺序的问题。</li><li><strong>解决方法</strong>：一种常用的解决方案是使用单例模式中的静态局部变量。由于静态局部变量具有“延迟初始化”的特点，即只有在首次使用时才会初始化，因此可以用来控制初始化顺序，避免跨编译单元初始化顺序导致的问题。</li></ul></li></ul><h4 id="9-深拷贝与浅拷贝"><a href="#9-深拷贝与浅拷贝" class="headerlink" title="9.深拷贝与浅拷贝"></a>9.<strong>深拷贝与浅拷贝</strong></h4><ul><li><strong>浅拷贝：</strong>浅拷贝是指简单地将原对象的<strong>基本数据类型</strong>的值<strong>复制</strong>给新对象，并且对于<strong>引用类型的数据</strong>（如指针），只是<strong>复制了指向实际数据的引用</strong>（即<strong>内存地址</strong>），并<strong>没有为引用类型的数据开辟新的内存空间。</strong></li><li><strong>深拷贝：</strong>深拷贝不仅复制了基本数据类型的值，而且对于引用类型的成员变量，还<strong>会在堆上为其指向的数据分配新的内存空间</strong>，并将这些数据复制到新的内存位置，从而使得<strong>新对象拥有自己的独立数据副本</strong>。</li></ul><h4 id="10-new、delete-p、delete-p、allocator都有什么作用？"><a href="#10-new、delete-p、delete-p、allocator都有什么作用？" class="headerlink" title="10.new、delete p、delete [] p、allocator都有什么作用？"></a>10.new、delete p、delete [] p、allocator都有什么作用？</h4><ul><li><p><strong><code>new[]</code>创建动态数组</strong>：当使用<code>new</code>分配一个数组时，方括号<code>[]</code>内的值必须是整数类型，它<strong>可以是变量</strong>（即运行时确定的值），而不必是常量表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 合法，size可以是变量</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>new</code>返回元素类型的指针:</strong> 当使用<code>new[]</code>来动态创建数组时，<strong>返回的是指向数组第一个元素的指针</strong>，而不是一个数组类型的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arrayPtr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// arrayPtr 是一个 int 类型的指针</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>delete[]</code>销毁顺序:</strong> 使用<code>delete[]</code>删除通过<code>new[]</code>分配的数组时，数组中的对象会按照它们被构造的逆序进行析构。因为C++保证了对象的析构顺序与它们的构造顺序相反，以确保资源正确释放。</p></li><li><p><strong><code>new/delete</code> vs <code>allocator</code></strong></p><ul><li><p><strong><code>new/delete</code>局限性</strong>：将构造函数/析构函数与内存管理绑定在一起不够灵活</p></li><li><p><strong><code>std::allocator</code>（分配器）的作用</strong>：<code>std::allocator</code>是C++标准库提供的一个工具，用于分离内存分配和对象构造的过程。它允许程序员先申请一块未初始化的内存，然后根据需要手动构造对象。这种方式提供了更大的灵活性，比如延迟对象的初始化时间或者复用已分配的内存块，从而可能提高性能或减少内存碎片。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::allocator&lt;<span class="type">int</span>&gt; alloc; <span class="comment">// 创建一个 allocator 对象</span></span><br><span class="line"><span class="type">int</span>* p = alloc.<span class="built_in">allocate</span>(<span class="number">10</span>); <span class="comment">// 分配内存但不初始化</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(p, <span class="number">100</span>); <span class="comment">// 初始化某个位置的对象</span></span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p, <span class="number">10</span>); <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="11-new和delete的实现原理，-delete是如何知道释放内存的大小的额？"><a href="#11-new和delete的实现原理，-delete是如何知道释放内存的大小的额？" class="headerlink" title="11.new和delete的实现原理， delete是如何知道释放内存的大小的额？"></a>11.new和delete的实现原理， delete是如何知道释放内存的大小的额？</h4><p>对于数组，<code>new[]</code>会额外存储数组的大小，<code>delete[]</code>会根据这个大小正确地调用析构函数并释放内存。</p><h4 id="12-malloc与free的实现原理？"><a href="#12-malloc与free的实现原理？" class="headerlink" title="12.malloc与free的实现原理？"></a>12.malloc与free的实现原理？</h4><p><code>alloc</code> 和 <code>free</code> 的底层实现依赖于操作系统提供的系统调用，主要包括：</p><ul><li><code>brk</code>：通过调整堆的边界来分配内存。</li><li><code>mmap</code>：在进程的虚拟地址空间中映射一块内存区域。</li><li><code>munmap</code>：释放由 <code>mmap</code> 分配的内存。</li></ul><p><strong>内存分配的两种方式:</strong></p><ul><li><p><strong><code>brk</code> 系统调用(小于 128KB)</strong>：调整堆的边界（即数据段的最高地址指针 <code>_edata</code>）来分配内存； <strong>分配的内存是连续的，释放时需要从高地址向低地址依次释放。</strong></p><ul><li><code>brk</code> 将 <code>_edata</code> 指针向高地址方向移动，扩展堆的大小。</li><li>分配的内存是虚拟内存，物理内存并未立即分配。</li><li>当程序首次访问这块内存时，操作系统会触发缺页中断，分配物理内存并建立虚拟内存与物理内存的映射关系。</li></ul></li><li><p><strong><code>mmap</code> 系统调用(大于 128KB)</strong>：<code>mmap</code> 在进程的虚拟地址空间中（<strong>堆和栈之间的文件映射区域</strong>）找一块空闲的虚拟内存。； <strong>分配的内存可以单独释放，灵活性更高。</strong></p><ul><li><code>mmap</code> 在文件映射区域中分配一块虚拟内存。</li><li>同样，物理内存并未立即分配，而是在首次访问时通过缺页中断分配。</li></ul></li><li><p><strong>内存紧缩（trim）</strong>：</p><ul><li>当 <code>free</code> 释放内存后，如果堆顶的空闲内存超过一定阈值（默认 128KB，可通过 <code>M_TRIM_THRESHOLD</code> 调节），操作系统会执行内存紧缩操作（trim）。</li><li>内存紧缩会将空闲的内存归还给操作系统，减少进程的内存占用。</li></ul></li></ul><p><strong><code>malloc</code> 的具体实现机制：</strong></p><ul><li><p><strong>空闲内存链表</strong>：</p><ul><li>操作系统中维护一个记录空闲内存地址的链表。</li><li>当程序<strong>调用 <code>malloc</code></strong> 时，操作系统会<strong>遍历这个链表</strong>，寻找第一个大小满足需求的空闲内存块。</li><li>如果找到合适的内存块，则将其从空闲链表中删除，并分配给程序。</li><li>如果<strong>没有找到合适的内存块，则会通过 <code>brk</code> 或 <code>mmap</code> 系统调用</strong>向操作系统申请更多的内存。</li></ul></li><li><p><strong>内存分配算法</strong>：</p><ul><li><code>malloc</code> 通常使用一些内存分配算法（如首次适应、最佳适应或伙伴系统）来管理空闲内存链表，以提高内存分配的效率。</li></ul></li></ul><p><strong><code>free</code> 的具体实现机制：</strong></p><ul><li><strong>释放内存</strong>：<ul><li>当程序调用 <code>free</code> 时，操作系统会将释放的内存块重新加入到空闲内存链表中。</li><li>如果释放的内存是通过 <strong><code>brk</code> 分配的</strong>，且位于堆的顶部，则<strong>可能会触发内存紧缩操作，将空闲内存归还给操作系统。</strong></li><li>如果释放的内存是通过 <code>mmap</code> 分配的，则直接调用 <strong><code>munmap</code> 系统调用</strong>将内存归还给操作系统。</li></ul></li></ul><h4 id="13-内联函数和普通函数的区别"><a href="#13-内联函数和普通函数的区别" class="headerlink" title="13.内联函数和普通函数的区别"></a>13.内联函数和普通函数的区别</h4><ul><li><p><strong>执行效率</strong>：内联函数效率高</p><ul><li><strong>内联函数</strong>：当一个函数被声明为内联函数时，编译器会在每次调用该函数的地方将其代码展开，而不是进行常规的函数调用（如保存当前环境、跳转到函数入口地址执行等）。这样做可以<strong>减少函数调用带来的开销</strong>，特别是对于简单的、短小的函数来说，能提高程序运行效率。</li><li><strong>普通函数</strong>：普通函数调用涉及到栈帧的创建与销毁、参数传递、返回值处理等一系列操作，这些都会带来一定的性能开销。</li></ul></li><li><p><strong>代码大小</strong>：内联函数会增大代码量</p><ul><li><strong>内联函数</strong>：由于内联函数是将函数体直接插入到调用点，如果一个内联函数在一个程序中被多次调用，那么这个函数的代码就会被复制多份，这可能导致生成的可执行文件变大。</li><li><strong>普通函数</strong>：普通函数只有一份副本，无论它被调用多少次，都不会增加代码量。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-什么是大小端存储？&quot;&gt;&lt;a href=&quot;#1-什么是大小端存储？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是大小端存储？&quot;&gt;&lt;/a&gt;1.什么是大小端存储？&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;大端存储：&lt;/strong&gt;数据的最高有效字节存放在</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++八股2</title>
    <link href="https://wangak.cc/posts/a41c6ee6.html"/>
    <id>https://wangak.cc/posts/a41c6ee6.html</id>
    <published>2025-03-15T16:00:00.000Z</published>
    <updated>2025-03-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-八股2"><a href="#C-八股2" class="headerlink" title="C++八股2"></a>C++八股2</h2><h4 id="1-C-中const和static的作用"><a href="#1-C-中const和static的作用" class="headerlink" title="1.C++中const和static的作用"></a>1.C++中const和static的作用</h4><p><strong>static：</strong></p><ul><li><p><strong>不考虑类的情况</strong></p><ul><li><p><strong>隐藏</strong>：当使用<code>static</code>修饰全局变量或函数时，它们将仅在定义它们的文件内可见（即具有内部链接性），而没有<code>static</code>修饰的全局变量和函数则可以在其他文件中通过声明来引用。</p><p><strong><em>注：当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</em></strong></p></li><li><p><strong>默认初始化为0</strong>：无论是未初始化的全局静态变量还是局部静态变量，默认情况下都会被初始化为0，并且这些变量都存储在全局未初始化区。</p></li><li><p><strong>持久存在与记忆性</strong>：如果在函数内部定义了静态变量，那么这个变量在整个程序运行期间一直存在，只会被初始化一次，并且即使函数退出后仍然存在，但它的作用域是局部的。</p></li></ul></li><li><p><strong>考虑类的情况</strong></p><ul><li><strong>static成员变量</strong>：必须在类外部进行初始化</li><li><strong>static成员函数</strong>：没有<code>this</code>指针，不能访问类的非静态成员变量或调用非静态成员函数。</li></ul></li></ul><p><strong>const:</strong></p><ul><li><strong>不考虑类的情况:</strong><ul><li><strong>不可变性</strong>：一旦定义了一个<code>const</code>常量，就必须同时对其进行初始化，之后其值不能再被修改。</li><li><strong>参数传递：</strong>用const修饰传入参数，则函数保证传入参数不发生改变</li></ul></li><li><strong>考虑类的情况</strong><ul><li><strong>const成员变量</strong>：必须通过构造函数的初始化列表进行初始化，不能在类定义之外进行初始化。</li><li><strong>const成员函数</strong>：这种函数承诺不会修改对象的数据成员（除非数据成员被声明为<code>mutable</code>），<code>const</code>成员函数不可以调用非<code>const</code>成员函数；<code>const</code>对象只能调用<code>const</code>成员函数，而非<code>const</code>对象既可以调用<code>const</code>也可以调用非<code>const</code>成员函数。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非const成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modifyValue</span><span class="params">(<span class="type">int</span> newVal)</span> </span>&#123;</span><br><span class="line">        value = newVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不能修改任何非mutable数据成员</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> MyClass <span class="title">constObj</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 创建一个const对象</span></span><br><span class="line">    <span class="function">MyClass <span class="title">nonConstObj</span><span class="params">(<span class="number">20</span>)</span></span>;    <span class="comment">// 创建一个非const对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行会导致编译错误，因为尝试在一个const对象上调用非const成员函数</span></span><br><span class="line">    <span class="comment">// constObj.modifyValue(30);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在一个const对象上调用const成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;constObj value: &quot;</span> &lt;&lt; constObj.<span class="built_in">getValue</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在非const对象上调用const成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;nonConstObj value: &quot;</span> &lt;&lt; nonConstObj.<span class="built_in">getValue</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以在非const对象上调用非const成员函数</span></span><br><span class="line">    nonConstObj.<span class="built_in">modifyValue</span>(<span class="number">40</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After modification, nonConstObj value: &quot;</span> &lt;&lt; nonConstObj.<span class="built_in">getValue</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-C-的顶层const和底层const"><a href="#2-C-的顶层const和底层const" class="headerlink" title="2.C++的顶层const和底层const"></a>2.C++的顶层const和底层const</h4><p><strong>顶层const（*在左边）</strong>：表示被修饰的对象本身是一个常量，不能通过这个对象改变它的值。（指针指向不可变）</p><p><strong>底层const（*在右边）</strong>：指针所指向的对象是不可变的。（指针指向的对象是常量）</p><p><em>注：标准的<code>const int</code>是顶层; const用于声明引用变量是底层</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> b1 = &amp;a;        <span class="comment">// 顶层const，b1本身是一个常量，即b1必须始终指向a</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* b2 = &amp;a;        <span class="comment">// 底层const，b2本身可变，但b2指向的对象（即*a）是常量，不可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b3 = <span class="number">20</span>;         <span class="comment">// 顶层const，b3是常量不可变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> b4 = &amp;a;  <span class="comment">// 前一个const为底层，后一个为顶层，b4不可变且*b4也不可变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; b5 = a;         <span class="comment">// 用于声明引用变量，都是底层const，a的值可通过非const引用改变，但b5无法修改a</span></span><br></pre></td></tr></table></figure><p>注：具有底层<code>const</code>的指针或引用不能直接赋值给没有<code>const</code>限定的指针或引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demonstrateConstRestrictions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向普通int类型的指针（无底层const）</span></span><br><span class="line">    <span class="type">int</span>* nonConstPtr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向const int类型的指针（有底层const）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* constPtr = &amp;b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行会导致编译错误：</span></span><br><span class="line">    <span class="comment">// error: invalid conversion from &#x27;const int*&#x27; to &#x27;int*&#x27;</span></span><br><span class="line">    <span class="comment">// nonConstPtr = constPtr;  // 错误：试图将底层const转换为非const</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确的做法是使用const_cast，但要小心使用，确保原始数据确实是可修改的</span></span><br><span class="line">    <span class="comment">// 在这个特定情况下，由于&#x27;b&#x27;是一个const int，这样做实际上是不安全的</span></span><br><span class="line">    <span class="comment">// nonConstPtr = const_cast&lt;int*&gt;(constPtr);  // 不建议这么做</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是，从非const到const的转换总是安全的</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* safePtr = &amp;a;  <span class="comment">// 安全：增加const限定不会有问题</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value via safePtr: &quot;</span> &lt;&lt; *safePtr &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">demonstrateConstRestrictions</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-数组名和指针（这里为指向数组首元素的指针）区别"><a href="#3-数组名和指针（这里为指向数组首元素的指针）区别" class="headerlink" title="3.数组名和指针（这里为指向数组首元素的指针）区别"></a>3.数组名和指针（这里为指向数组首元素的指针）区别</h4><ul><li><p>数组名不是真正意义上的指针，可以理解为常指针，所以<strong>数组名没有自增、自减等操作。</strong></p></li><li><p>当数组名当<strong>做形参</strong>传递给调用函数后，就失去了原有特性，<strong>退化成一般指针，多了自增、自减操作</strong>，但sizeof运算符不能再得到原数组的大小了。</p></li></ul><h4 id="4-final和override关键字"><a href="#4-final和override关键字" class="headerlink" title="4.final和override关键字"></a>4.final和override关键字</h4><p><strong>override:</strong> </p><p>​    指定了子类的这个虚函数是重写的父类的,如果函数名输错，编译器会报错</p><p><strong>final：</strong></p><p>​    当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;    </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">           <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// foo 被override并且是最后一个override，在其子类中不可以重写&#125;;</span></span><br></pre></td></tr></table></figure><h4 id="5-拷贝初始化和直接初始化"><a href="#5-拷贝初始化和直接初始化" class="headerlink" title="5.拷贝初始化和直接初始化"></a>5.拷贝初始化和直接初始化</h4><ul><li><p><strong>直接初始化</strong>：直接调用与实参匹配的构造函数来初始化对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;I am a string&quot;</span>)</span></span>; <span class="comment">// 语句1：直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(str1)</span></span>;            <span class="comment">// 语句2：直接初始化，使用另一个对象进行初始化</span></span><br></pre></td></tr></table></figure></li><li><p><strong>拷贝初始化</strong>：首先<strong>创建一个临时对象</strong>，然后使用拷贝构造函数将这个临时对象的内容拷贝到正在创建的对象中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str3 = <span class="string">&quot;I am a string&quot;</span>; <span class="comment">// 语句3：拷贝初始化</span></span><br><span class="line">string str4 = str1;            <span class="comment">// 语句4：拷贝初始化</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="6-野指针和悬空指针"><a href="#6-野指针和悬空指针" class="headerlink" title="6.野指针和悬空指针"></a>6.野指针和悬空指针</h4><p><strong>野指针：</strong></p><p>​    没有被初始化过的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;         </span><br><span class="line"><span class="type">int</span>* p;     <span class="comment">// 未初始化    </span></span><br><span class="line">std::cout&lt;&lt; *p &lt;&lt; std::endl; <span class="comment">// 未初始化就被使用,可能会报错        </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：确保指针在声明时就被初始化。如果暂时没有有效的内存地址可以赋值给指针，应该将其设置为<code>nullptr</code>。这样，如果尝试解引用一个<code>nullptr</code>，大多数现代编译器会在运行时抛出异常或给出错误提示，从而帮助开发者快速定位问题。</p><p><strong>悬空指针:</strong></p><p>​    最初指向的内存已经被释放了的一种指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;   </span><br><span class="line"><span class="type">int</span> * p = <span class="literal">nullptr</span>;  </span><br><span class="line"><span class="type">int</span>* p2 = <span class="keyword">new</span> <span class="type">int</span>;   </span><br><span class="line"> p = p2;  <span class="keyword">delete</span> p2;</span><br><span class="line">&#125; <span class="comment">// 此时p和p2都变成了悬空指针</span></span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：</p><ul><li>在释放指针所指向的内存之后，立即将指针设置为<code>nullptr</code>。</li><li>C++引入了智能指针（如<code>std::unique_ptr</code>和<code>std::shared_ptr</code>），它们能够自动管理内存的分配和释放，从而有效避免悬空指针的产生。</li></ul><h4 id="7-C-中的重载、重写（覆盖）和隐藏的区别"><a href="#7-C-中的重载、重写（覆盖）和隐藏的区别" class="headerlink" title="7.C++中的重载、重写（覆盖）和隐藏的区别"></a>7.C++中的重载、重写（覆盖）和隐藏的区别</h4><p><strong>重载： </strong>重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，<strong>不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。</strong></p><p><strong>重写（override）：</strong>在派生类中覆盖基类中的同名函数，<strong>重写就是重写函数体</strong>，<strong>要求基类函数必须是虚函数</strong>且：</p><ul><li>与基类的虚函数有相同的参数个数</li><li>与基类的虚函数有相同的参数类型</li><li>与基类的虚函数有相同的返回值类型</li></ul><p><strong>隐藏（hide）:</strong> 派生类中的函数屏蔽了基类中的同名函数</p><p><strong>隐藏和重写的区别：</strong>  重写可以体现多态性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base: &quot;</span> &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; endl; &#125; <span class="comment">// 重写了基类中的foo(int x)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl; &#125; <span class="comment">// 隐藏了基类中的foo(int x, int y)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *pb = <span class="keyword">new</span> Derived;</span><br><span class="line">    pb-&gt;<span class="built_in">foo</span>(<span class="number">1</span>);     <span class="comment">// 调用的是Derived::foo(int x)，因为Base::foo(int x)是虚函数且被重写</span></span><br><span class="line">    pb-&gt;<span class="built_in">foo</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 调用的是Base::foo(int x, int y)，因为Derived::foo(int x, int y)隐藏了基类的同名函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503162026007.png" alt="image-20250316202637727" style="zoom:67%;"></p><h4 id="8-C-有哪几种的构造函数"><a href="#8-C-有哪几种的构造函数" class="headerlink" title="8.C++有哪几种的构造函数"></a>8.C++有哪几种的构造函数</h4><ul><li><p><strong>默认构造函数:</strong> 不带任何参数的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="comment">// 默认构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj; <span class="comment">// 调用默认构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化构造函数:</strong> 接受一个或多个参数以初始化对象的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123; <span class="comment">// 初始化构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameterized Constructor with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 调用有参数的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>拷贝构造函数:</strong>  使用<strong>同一类型的另一个对象</strong>来初始化新创建的对象时调用的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass &amp;other) : <span class="built_in">value</span>(other.value) &#123; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy Constructor, value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    MyClass obj2 = obj1; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>移动构造函数（Move和右值引用）：</strong>用于实现资源转移而非复制，避免不必要的深拷贝操作。它通常与右值引用一起使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123; <span class="comment">// 移动构造函数</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">//确保原对象不再拥有对资源的所有权,防止悬空指针</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> size) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[size]) &#123;&#125; <span class="comment">// 简化的构造函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    MyClass obj2 = std::<span class="built_in">move</span>(obj1); <span class="comment">// 调用移动构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>委托构造函数： </strong>允许在一个构造函数内部调用同一个类的其他构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">MyClass</span>(<span class="number">0</span>) &#123; &#125; <span class="comment">// 委托构造函数，委托给下面的构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123; <span class="comment">// 初始化构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameterized Constructor with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj; <span class="comment">// 调用默认构造函数，但实际通过委托构造函数间接调用了有参数的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>转换构造函数:</strong> 允许编译器隐式地将一种类型的值转换为类的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Temperature</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> celsius;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换构造函数：从 double 到 Temperature 的转换</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Temperature</span><span class="params">(<span class="type">double</span> c)</span> : celsius(c) &#123;</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Conversion Constructor, Celsius: &quot;</span> &lt;&lt; celsius &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示当前温度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Temperature is &quot;</span> &lt;&lt; celsius &lt;&lt; <span class="string">&quot; degrees Celsius.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，接受一个 Temperature 对象并显示其值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayTemperature</span><span class="params">(<span class="type">const</span> Temperature&amp; temp)</span> </span>&#123;</span><br><span class="line">    temp.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用显式构造函数调用创建对象</span></span><br><span class="line">    <span class="function">Temperature <span class="title">t1</span><span class="params">(<span class="number">36.5</span>)</span></span>; <span class="comment">// 正确：显式调用转换构造函数</span></span><br><span class="line">    t1.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行会导致编译错误，因为构造函数被声明为 explicit</span></span><br><span class="line">    <span class="comment">// Temperature t2 = 40.0; // 错误：不允许隐式转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过辅助函数传递 double 值，但需要显式转换</span></span><br><span class="line">    <span class="built_in">displayTemperature</span>(<span class="built_in">Temperature</span>(<span class="number">25.0</span>)); <span class="comment">// 正确：显式创建临时对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果去掉 explicit 关键字，则下面的语句也会合法</span></span><br><span class="line">    <span class="comment">// Temperature t3 = 37.0; // 如果构造函数不是 explicit，则这是合法的隐式转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-浅拷贝和深拷贝的区别"><a href="#9-浅拷贝和深拷贝的区别" class="headerlink" title="9.浅拷贝和深拷贝的区别"></a>9.浅拷贝和深拷贝的区别</h4><p><strong>浅拷贝共享数据：</strong> 浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p><p><strong>深拷贝各自拥有独立的数据副本：</strong> 开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。</p><p><em>注：浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源</em></p><h4 id="10-内联函数和宏定义的区别"><a href="#10-内联函数和宏定义的区别" class="headerlink" title="10.内联函数和宏定义的区别"></a>10.内联函数和宏定义的区别</h4><ul><li><strong>处理时机</strong>：宏定义是在预处理阶段进行简单的文本替换； 内联函数则是在编译时进行处理，并且可以进行参数类型检查。这使得内联函数更加安全和可靠。</li><li><strong>类型检查与返回值</strong>：由于宏只是简单的字符串替换，它无法进行任何类型检查，也无法直接拥有返回值的概念。内联函数支持参数类型检查，确保传入参数的类型正确，并能够像普通函数一样有明确的返回值。</li></ul><p><strong>内联函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 定义一个内联函数来计算两个整数的和</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 使用内联函数计算两数之和</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">add</span>(num1, num2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>宏：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 定义一个宏来计算两个整数的和</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(a, b) ((a) + (b))</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 使用宏计算两数之和</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">ADD</span>(num1, num2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title=" "></a> </h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-八股2&quot;&gt;&lt;a href=&quot;#C-八股2&quot; class=&quot;headerlink&quot; title=&quot;C++八股2&quot;&gt;&lt;/a&gt;C++八股2&lt;/h2&gt;&lt;h4 id=&quot;1-C-中const和static的作用&quot;&gt;&lt;a href=&quot;#1-C-中const和static的作</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
</feed>
