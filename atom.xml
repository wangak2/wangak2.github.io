<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>丹青两幻</title>
  
  <subtitle>欢迎~</subtitle>
  <link href="https://wangak.cc/atom.xml" rel="self"/>
  
  <link href="https://wangak.cc/"/>
  <updated>2023-11-28T00:00:00.000Z</updated>
  <id>https://wangak.cc/</id>
  
  <author>
    <name>丹青两幻</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>局部光照模型及着色方法</title>
    <link href="https://wangak.cc/posts/af9d8c8.html"/>
    <id>https://wangak.cc/posts/af9d8c8.html</id>
    <published>2023-11-29T16:00:00.000Z</published>
    <updated>2023-11-28T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-局部光照模型"><a href="#1-局部光照模型" class="headerlink" title="1.局部光照模型"></a>1.局部光照模型</h3><p><strong>光线的简单分类：</strong></p><ul><li><p><strong>镜面反射</strong></p></li><li><p><strong>漫反射</strong></p></li></ul><ul><li><strong>环境光</strong></li></ul><h4 id="1-1-泛光模型"><a href="#1-1-泛光模型" class="headerlink" title="1.1 泛光模型"></a>1.1 泛光模型</h4><p>泛光模型即<strong>只考虑环境光</strong>，这是最简单的<strong>经验</strong>模型，只会去考虑环境光的影响，并且不会去精确的描述，而只是用一个简单的式子表示：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952046.png" alt="image-20231130091038413" style="zoom:50%;"></p><script type="math/tex; mode=display">注：K_a表示物体表面对环境光的反射率，I_a代表入射环境光的亮度，I_{env}存储结果，即人眼所能看到从物体表面反射的环境光的亮度。</script><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952312.png" alt="image-20231130091806017" style="zoom: 67%;"></p><h4 id="1-2-Lambert漫反射模型"><a href="#1-2-Lambert漫反射模型" class="headerlink" title="1.2 Lambert漫反射模型"></a>1.2 Lambert漫反射模型</h4><ul><li><p>在泛光模型的基础之上增加了<strong>漫反射项</strong></p><ul><li>每个不同方向反射的光的强度相等</li><li>产生漫反射的原因是物体表面的粗糙</li></ul></li><li><p><strong>漫反射光照强度与光线照射方向和表面法线之间的夹角余弦成正比</strong></p><p><em>注：漫反射与观察方向无关，光线照射方向和表面法线之间的夹角反应了对于光照的接受率</em></p></li><li><p><strong>公式表示：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952975.png" alt="image-20231130091906700" style="zoom:50%;"></p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952973.png" alt="image-20231130091824267"></p><h4 id="1-3-Blinn-Phong反射模型"><a href="#1-3-Blinn-Phong反射模型" class="headerlink" title="1.3 Blinn-Phong反射模型"></a>1.3 Blinn-Phong反射模型</h4><p>Blinn-Phong反射模型是Phong光照模型的一种改进，在模拟高光方面表现更为自然。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952864.png" alt="image-20231130092346846" style="zoom: 50%;"></p><p>注：$k_s$为镜面反射系数， I为入射光强， r为光源到入射点距离,指数p加速衰减(用于减小可以看到高光的角度）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952037.png" alt="image-20231130092850361" style="zoom:50%;"></p><p>注：使用半程向量简化了反射向量与人眼观察夹角的计算（Phong光照模型，即下图中R与v的夹角的计算）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952906.png" alt="image-20231130092457821" style="zoom:50%;"></p><p><strong>整体计算公式：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952426.png" alt="image-20231130092944573" style="zoom:50%;"></p><p><em>注：L=泛光（环境光）+漫反射项+高光</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953544.png" alt="image-20231130093045061" style="zoom:50%;"></p><h3 id="2-着色方法-频率"><a href="#2-着色方法-频率" class="headerlink" title="2.着色方法(频率)"></a>2.着色方法(频率)</h3><h4 id="2-1-Flat-Shading（面着色）"><a href="#2-1-Flat-Shading（面着色）" class="headerlink" title="2.1 Flat Shading（面着色）"></a>2.1 Flat Shading（面着色）</h4><p>模型数据大多以很多个三角面进行存储，因此也就记录了每个面的法线向量，利用每个面的法线向量进行一次Blinn-Phong反射光照模型的计算，将该颜色赋予整个面。</p><p>效果如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953328.png" alt="image-20231130093503703" style="zoom:50%;"></p><h4 id="2-2-Gouraud-Shading（顶点着色）"><a href="#2-2-Gouraud-Shading（顶点着色）" class="headerlink" title="2.2 Gouraud Shading（顶点着色）"></a>2.2 Gouraud Shading（顶点着色）</h4><p>Gouraud Shading会对每个三角形的顶点进行一次着色</p><p><strong>点法线：将所有共享这个点的面的法线向量加起来求均值，最后再标准化</strong></p><p><strong>三角形内部的每一个点：</strong>利用<strong>重心坐标来插值</strong></p><p>重心坐标：给定的三角形ABC和其中的一个点P，其重心坐标$(w_a,w_b,w_c)$满足以下条件：</p><ul><li>$w_a+w_b+w_c=1$</li><li>$P=w_a⋅A+w_b⋅B+w_c⋅C$</li></ul><p>重心坐标可以通过面积的比值求出：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312010916393.png" alt="image-20231130134307989" style="zoom:50%;"></p><p>注：三角形的重心为（1/3，1/3，1/3），其将三角形分为了面积相等的三份。</p><p>重心坐标一般的表达式：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312010916494.png" alt="image-20231130134715691" style="zoom:50%;"></p><p>重心插值公式如下:</p><p>$P_{interpolated}=w_a⋅P_A+w_b⋅P_B+w_c⋅P_C$</p><p><em>注：$P_A、P_B、P_C$分别是三个顶点上的属性值</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953992.png" alt="image-20231130094402265" style="zoom:50%;"></p><p><em>注：重心坐标经过投影之后可能会改变，在三维空间中插值一些属性时，要计算三维空间中重心的坐标。</em></p><h4 id="2-3-Phong-Shading-像素着色"><a href="#2-3-Phong-Shading-像素着色" class="headerlink" title="2.3 Phong Shading(像素着色)"></a>2.3 Phong Shading(像素着色)</h4><p>要对每个点都进行光照计算，三角形内部的每一个点的法线向量如插值颜色一样得到：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953798.png" alt="image-20231130094638524" style="zoom:50%;"></p><p><em>注：$n_0,n_1,n_2$分别是三角形三个顶点的法线向量,α,β,γ为三角形面内点的重心坐标</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953475.png" alt="image-20231130094743068" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-局部光照模型&quot;&gt;&lt;a href=&quot;#1-局部光照模型&quot; class=&quot;headerlink&quot; title=&quot;1.局部光照模型&quot;&gt;&lt;/a&gt;1.局部光照模型&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;光线的简单分类：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;str</summary>
      
    
    
    
    <category term="图形学" scheme="https://wangak.cc/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>SG-Former</title>
    <link href="https://wangak.cc/posts/c53f4cce.html"/>
    <id>https://wangak.cc/posts/c53f4cce.html</id>
    <published>2023-11-29T16:00:00.000Z</published>
    <updated>2023-11-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SG-Former"><a href="#SG-Former" class="headerlink" title="SG-Former"></a>SG-Former</h2><p><strong>论文：《SG-Former: Self-guided Transformer with Evolving Token Reallocation》（ICCV 2023)</strong></p><h4 id="1-探究动机"><a href="#1-探究动机" class="headerlink" title="1.探究动机"></a>1.探究动机</h4><p>ViT使用全局的自注意力机制，但带来了较高的计算成本。</p><p>Swin Transformer设计了窗口注意力，而牺牲了建模全局信息的能力。</p><p><strong>提出SG-Fomer（Self-guided Transformer):</strong>利用<strong>显著性</strong>图，根据每个区域的显著性来分配token，将更多的token分配给显著性区域以获取细粒度的注意力，而将更少的token分配给次要的区域以换取计算效率和全局的感受野。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145871.png" alt="image-20231130202913356"></p><p><em>注：在显著性区域（狗脸）分配更多的token</em></p><h4 id="2-网络设计"><a href="#2-网络设计" class="headerlink" title="2.网络设计"></a>2.网络设计</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145135.png" alt="image-20231130203138889" style="zoom:80%;"></p><p><strong>Hybrid-Scale Transformer blocks:</strong>提取多尺度的信息并为Self-Guided Transformer Block提供显著性图</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145630.png" alt="image-20231129153810548" style="zoom: 67%;"></p><p>把H个注意力头分成h组，在第j组的注意力头有一个尺度因子$S_j$,即对于K,V的每$S_j<em>S_j$个token合并为一个token，把K、V的窗口大小设为M,Q的窗口大小设为$S_jM</em>S_jM$(使Q中token与K、V中的token对齐）</p><p><em>注：</em></p><p><em>（1）K,V的窗口大小在所有组中都是固定的，均为M,而Q的窗口大小还和$S_j$有关</em>，每一组的输出均为N*M,N为token序列的长度</p><p><em>（2）token的合并是通过卷积实现的</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145504.png" alt="image-20231130205331048" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145396.png" alt="image-20231130205438728" style="zoom: 67%;"></p><p>Token 的重要性被视为所有 Token 和当前 Token 的乘积之和：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145068.png" alt="image-20231129153230302" style="zoom: 67%;"></p><p><em>注：S是对所有的$S_i$求和的结果，即为最终的注意力图，用于混合尺度引导</em></p><p><strong>Self-Guided Transformer Block：</strong></p><p>为了降低计算成本，同时保持计算后特征映射的大小不变，固定Q的大小，使用IAM（importance guided aggregation module)对K和V的token进行聚合</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145350.png" alt="image-20231130211007377" style="zoom: 80%;"></p><p><em>注：S为显著性图，r为合并比率</em></p><p>将S平均分为n个子区域S1，S2,……Sn,每个区域设置不同的合并比率r1,r2,……，rn,子区域越重要，合并比率越小，输入特征X按X1,X2,……,Xn分组，每组有不同的合并比率</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145872.png" alt="image-20231130212526902" style="zoom: 67%;"></p><p><em>注：token的合并通过全连接层实现</em></p><h4 id="3-实验"><a href="#3-实验" class="headerlink" title="3.实验"></a>3.实验</h4><p>与其他结构在语义分割任务中的对比：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312010859765.png" alt="image-20231130215028355" style="zoom: 50%;"></p>]]></content>
    
    
    <summary type="html">记录了SG-Former的网络结构及实验结果</summary>
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>games作业1</title>
    <link href="https://wangak.cc/posts/ab1a849b.html"/>
    <id>https://wangak.cc/posts/ab1a849b.html</id>
    <published>2023-11-27T16:00:00.000Z</published>
    <updated>2023-11-28T00:00:00.000Z</updated>
    
    
    
    
    <category term="图形学" scheme="https://wangak.cc/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>智能指针</title>
    <link href="https://wangak.cc/posts/38a918c7.html"/>
    <id>https://wangak.cc/posts/38a918c7.html</id>
    <published>2023-11-25T16:00:00.000Z</published>
    <updated>2023-09-26T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>C++中的指针：</p><ul><li>原始指针</li><li>智能指针</li></ul><p>智能指针是原始指针的封装，其优点是会自动分配内存，不用担心潜在的内存泄露</p><p><em>注：智能指针只解决了独占/共享所有权指针的释放、传输，没有从根本上解决C++内存安全问题，不加以注意依然会造成内存安全问题</em></p><h3 id="2-独占指针：unique-ptr"><a href="#2-独占指针：unique-ptr" class="headerlink" title="2.独占指针：unique_ptr"></a>2.独占指针：unique_ptr</h3><p><strong>unique_ptr:</strong>在任何给定的时刻，只能有一个指针管理内存，当指针超出作用域时，内存将自动释放</p><p><em>注:该类型的指针不可Copy,只可以Move</em></p><p><strong>unique_ptr的三种创建方式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &quot;cat.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    // 1.栈</span><br><span class="line">    // 对象是在栈上创建的(而不是使用 new 操作符在堆上分配对象）,那么在对象的作用域结束时，其析构函数会被自动调用。</span><br><span class="line">    Cat c1(&quot;OK&quot;);</span><br><span class="line">    c1.cat_info();</span><br><span class="line">    &#123;</span><br><span class="line">        Cat c2(&quot;OK&quot;);</span><br><span class="line">        c2.cat_info();</span><br><span class="line">    &#125; // 在这个代码块结束时，c2 对象将被销毁，调用析构函数</span><br><span class="line"> </span><br><span class="line">    // 2.堆</span><br><span class="line">    //2.1 原始指针（不安全）</span><br><span class="line">    Cat *c_p1=new Cat(&quot;yy&quot;);</span><br><span class="line">    c_p1-&gt;cat_info();</span><br><span class="line">    &#123;</span><br><span class="line">        Cat *c_p1=new Cat(&quot;yy&quot;);</span><br><span class="line">        c_p1-&gt;cat_info();</span><br><span class="line">        delete c_p1;//原始指针不会自动调用析构函数，要使用delete方法</span><br><span class="line">    &#125;</span><br><span class="line">    delete c_p1;</span><br><span class="line">    // 2.2 智能指针</span><br><span class="line">    // 2.2.3 unique_pointer的三种创建方式</span><br><span class="line">    // 2.2.3.1 第一种方式</span><br><span class="line">    Cat *c_p2=new Cat(&quot;ok&quot;);</span><br><span class="line">    unique_ptr&lt;Cat&gt; u_c_p2&#123;c_p2&#125;;</span><br><span class="line">    c_p2=nullptr;//原始指针一般需要置空，否则其还能使用</span><br><span class="line">    u_c_p2-&gt;cat_info();</span><br><span class="line">    // 2.2.3.2 第二种方式</span><br><span class="line">    unique_ptr&lt;Cat&gt; u_c_p3&#123;new Cat(&quot;dd&quot;)&#125;;</span><br><span class="line">    u_c_p3-&gt;cat_info();</span><br><span class="line">    // 2.2.3.2 第三种方式（推荐）</span><br><span class="line">    unique_ptr&lt;Cat&gt; u_c_p4=make_unique&lt;Cat&gt;(&quot;ook&quot;);</span><br><span class="line">    u_c_p4-&gt;cat_info();</span><br><span class="line">    std::cout &lt;&lt; &quot;-----yz ------&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;智能指针&quot;&gt;&lt;a href=&quot;#智能指针&quot; class=&quot;headerlink&quot; title=&quot;智能指针&quot;&gt;&lt;/a&gt;智能指针&lt;/h2&gt;&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Transformation</title>
    <link href="https://wangak.cc/posts/ac17f787.html"/>
    <id>https://wangak.cc/posts/ac17f787.html</id>
    <published>2023-11-25T16:00:00.000Z</published>
    <updated>2023-11-26T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h2><h3 id="1-2D变换"><a href="#1-2D变换" class="headerlink" title="1. 2D变换"></a>1. 2D变换</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207409.png" alt="image-20231126190707151" style="zoom:50%;"></p><h4 id="1-1-缩放-scaling"><a href="#1-1-缩放-scaling" class="headerlink" title="1.1 缩放(scaling)"></a>1.1 缩放(scaling)</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207653.png" alt="image-20231126190747793" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207767.png" alt="image-20231126190853847" style="zoom: 50%;"></p><h4 id="1-2-镜像变换"><a href="#1-2-镜像变换" class="headerlink" title="1.2 镜像变换"></a>1.2 镜像变换</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207557.png" alt="image-20231126191121990" style="zoom:50%;"></p><h4 id="1-3-切变（Shear-Matrix）"><a href="#1-3-切变（Shear-Matrix）" class="headerlink" title="1.3 切变（Shear Matrix）"></a>1.3 切变（Shear Matrix）</h4><p>如下图，变换过程中y坐标始终不变</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207966.png" alt="image-20231126192230389" style="zoom:50%;"></p><h4 id="1-4-旋转-Rotate"><a href="#1-4-旋转-Rotate" class="headerlink" title="1.4 旋转(Rotate)"></a>1.4 旋转(Rotate)</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208542.png" alt="image-20231126192327264" style="zoom:50%;"></p><h4 id="1-5-齐次坐标"><a href="#1-5-齐次坐标" class="headerlink" title="1.5 齐次坐标"></a>1.5 齐次坐标</h4><p><strong>平移：</strong><br><img src="https://typoraimg.wangak.cc/2023/img/202311271208287.png" alt="image-20231126193641073" style="zoom:50%;"></p><p><strong>为了表示平移操作引入了第三维坐标：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208639.png" alt="image-20231126193653818" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208486.png" alt="image-20231126193714639" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208369.png" alt="image-20231126193731535" style="zoom:50%;"></p><p><em>注：<strong>point+point</strong>的结果为两个点的中点</em></p><p><strong>仿射变换的两种形式：</strong><br><img src="https://typoraimg.wangak.cc/2023/img/202311271208436.png" alt="image-20231126194003729" style="zoom:50%;"></p><p><em>注：齐次坐标变换矩阵中的a,b,c,d与线性变换中的变换矩阵是对应的</em></p><h4 id="1-6-逆变换"><a href="#1-6-逆变换" class="headerlink" title="1.6 逆变换"></a>1.6 逆变换</h4><p><strong>逆变换：</strong>变换矩阵为原变换的逆矩阵</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208337.png" alt="image-20231126194715152" style="zoom:50%;"></p><h3 id="2-3D变换"><a href="#2-3D变换" class="headerlink" title="2. 3D变换"></a>2. 3D变换</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208498.png" alt="image-20231126195736702" style="zoom:50%;"></p><h4 id="2-1-仿射变换"><a href="#2-1-仿射变换" class="headerlink" title="2.1 仿射变换"></a>2.1 仿射变换</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208171.png" alt="image-20231126195828157" style="zoom:50%;"></p><p><em>注：该表示方法是先做线性变换，然后再平移</em></p><h4 id="2-2-旋转"><a href="#2-2-旋转" class="headerlink" title="2.2 旋转"></a>2.2 旋转</h4><ul><li><strong>在轴上</strong></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033304.png" alt="image-20231127122527405" style="zoom:50%;"></p><ul><li><p><strong>一般的旋转</strong>：可以将任意的旋转分为在三个轴上的旋转，其中在三个轴上的旋转角度称为欧拉角</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033703.png" alt="image-20231127122758750" style="zoom:50%;"></p></li></ul><p>​    <strong>罗德里格斯公式(Rodrigues’ Rotation Formula):</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033828.png" alt="image-20231127123545604"></p><p>注：四元数的应用</p><h3 id="2-3-视图-相机变换（View-Camera-Transformation）"><a href="#2-3-视图-相机变换（View-Camera-Transformation）" class="headerlink" title="2.3 视图/相机变换（View / Camera Transformation）"></a>2.3 视图/相机变换（View / Camera Transformation）</h3><p><strong>相机的参数：</strong>初始位置、观看角度（向量）、竖直角度（向量）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033677.png" alt="image-20231127125538822"></p><p><strong>标准化：</strong>观看位置为原点、观看角度为-Z、向上方向为Y</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033142.png" alt="image-20231127125835234" style="zoom:50%;"></p><p>变换的方法：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033832.png" alt="image-20231127125907343" style="zoom:50%;"></p><p>由于正向变换比较复杂，考虑<strong>通过其逆矩阵来实现</strong>：R为旋转变换矩阵、T为平移变换矩阵、M为整个过程的变换矩阵</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033482.png" alt="image-20231127130030303" style="zoom:50%;"></p><p><em>注：旋转矩阵为正交矩阵，逆矩阵即是其转置</em></p><p><em>注：视图变换变换的是相机，其他的物体随着相机一起变换</em></p><h3 id="3-投影变换"><a href="#3-投影变换" class="headerlink" title="3 投影变换"></a>3 投影变换</h3><h4 id="3-1-正交投影变换"><a href="#3-1-正交投影变换" class="headerlink" title="3.1 正交投影变换"></a>3.1 正交投影变换</h4><p><strong>正交投影变换：</strong>平移+压缩</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033623.png" alt="image-20231127131958838" style="zoom:50%;"></p><p><em>注：l,r为x轴上的距离，b,t为y轴上的距离</em></p><h4 id="3-2-透视投影变换"><a href="#3-2-透视投影变换" class="headerlink" title="3.2 透视投影变换"></a>3.2 透视投影变换</h4><p>透视投影类似人眼所看东西的方式，遵循近大远小,平行线也会变得不平行</p><p><strong>用正交变换表示透视投影变换：</strong><script type="math/tex">M_{ortho}M_{persp->ortho}</script></p><p>将透视变换压成投影<script type="math/tex">M_{persp->ortho}</script></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033023.png" alt="image-20231127212210693" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033371.png" alt="image-20231127212333846" style="zoom:50%;"></p><p><em>注：其中n是近平面，f是远平面，在公式推导的过程中是<strong>默认n、f</strong>均为负数</em></p><p>因而透视投影矩阵为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311301248538.png" alt="image-20231130123159569" style="zoom: 67%;"></p><p>又当投影接口的参数是张角fov，横纵比为aspect，近平面到原点的距离为near,远平面到原点的距离为far</p><p>由于长方体视窗体是轴对称，故有l=−r,b=−t,从原点看向−z方向看去，有n=−near,f=−far<br>                                                                    <img src="https://typoraimg.wangak.cc/2023/img/202311301247698.png" alt="image-20231130124140613" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311301248703.png" alt="image-20231130124220304" style="zoom:67%;"></p><p>所以透视投影矩阵可化简为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311301248469.png" alt="image-20231130124301880" style="zoom: 67%;"></p><h3 id="4-视口变换"><a href="#4-视口变换" class="headerlink" title="4.视口变换"></a>4.视口变换</h3><p><strong>视口变换</strong>用于将标准平面映射到屏幕的分辨率范围之内（缩放+平移），变换矩阵如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033944.png" alt="image-20231128150643474" style="zoom:50%;"></p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>将虚拟世界中以(x,y,z)为坐标的物体变换到以一个个像素位置(x,y) 来表示的屏幕坐标系之中(2维)的步骤：</p><ul><li><strong>模型变换(modeling tranformation)：</strong>这一步的目的是将虚拟世界中或者更具体点，游戏场景中的物体调整至他们应该在的位置</li><li><strong>摄像机变换(camera tranformation)：</strong>在游戏中我们真正在乎的是摄像机(或者说眼睛)所看到的东西，也就是需要得到物体与摄像机的相对位置</li><li><strong>投影变换(projection tranformation)：</strong>根据摄像机变换得到了所有可视范围内的物体对于摄像机的相对位置坐标(x,y,z)之后，便是根据是平行投影还是透视投影，将三维空间投影至标准二维平面([-1,1]^2)之上 （tips：这里的z并没有丢掉，为了之后的遮挡关系检测）</li><li><strong>视口变换(viewport transformation)：</strong>将处于标准平面映射到屏幕分辨率范围之内，即[-1,1]^2→[0,width]*[0,height], 其中width和height指屏幕分辨率大小</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Transformation&quot;&gt;&lt;a href=&quot;#Transformation&quot; class=&quot;headerlink&quot; title=&quot;Transformation&quot;&gt;&lt;/a&gt;Transformation&lt;/h2&gt;&lt;h3 id=&quot;1-2D变换&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="图形学" scheme="https://wangak.cc/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>光栅化及深度测试</title>
    <link href="https://wangak.cc/posts/499d8707.html"/>
    <id>https://wangak.cc/posts/499d8707.html</id>
    <published>2023-11-25T16:00:00.000Z</published>
    <updated>2023-11-28T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p><strong>光栅化（Rasterization）</strong>是图形学中一种常用的渲染技术，用于将三维场景中的图形对象转换为二维像素表示，以便在计算机屏幕上显示，即将图形对象（通常是三角形）映射到屏幕上的像素格子，并确定每个像素的颜色值。</p><p><strong>选择三角形作为渲染的基本图元的原因：</strong></p><ul><li>因为三角形是最简单的几何形状之一，任意三个点可以确定一个平面上的三角形</li><li><p>任意多边形都可以被分解为若干个三角形，这种分解使得处理复杂的多边形图形变得更加容易。</p></li><li><p>三角形在仿射变换下保持平面性，对三角形的变换相对简单，而不会引入复杂的扭曲。</p></li></ul><h3 id="1-直线光栅化算法"><a href="#1-直线光栅化算法" class="headerlink" title="1.直线光栅化算法"></a>1.直线光栅化算法</h3><h4 id="1-1-DDA数值微分算法"><a href="#1-1-DDA数值微分算法" class="headerlink" title="1.1 DDA数值微分算法"></a>1.1 DDA数值微分算法</h4><p>通过两点确定一条直线的斜率（k)，若|k|&lt;=1,选择x方向作为步长（选择变换快的方向），若|k|&gt;1,选择y方向作为步长。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033642.png" alt="image-20231128195221236" style="zoom:50%;"></p><p>注：在所选的步长方向上，从起始点 <code>(x0, y0)</code> 开始，计算每个下一个点的坐标 <code>(xi, yi)</code>。对于x方向的步长，使用 <code>xi+1 = xi + 1</code>；对于 y 方向的步长，使用 <code>yi+1 = yi + m</code>。(y的结果要四舍五入)</p><h4 id="1-2-Bresenham直线绘制算法"><a href="#1-2-Bresenham直线绘制算法" class="headerlink" title="1.2 Bresenham直线绘制算法"></a>1.2 Bresenham直线绘制算法</h4><p>Bresenham直线绘制算法通过在每个步骤中选择最接近理想路径上的点来逐步绘制线段，从而避免了使用浮点数运算，提高了计算效率。</p><p><strong>pass</strong></p><h3 id="2-三角形光栅化算法"><a href="#2-三角形光栅化算法" class="headerlink" title="2.三角形光栅化算法"></a>2.三角形光栅化算法</h3><p><strong>每一个像素进行采样:</strong>判断像素中心是否在三角形内部</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034020.png" alt="image-20231128200407428" style="zoom: 50%;"></p><p><strong>判断一个点在三角形内部的方法：</strong>利用叉乘的性质</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034363.png" alt="image-20231128200536862" style="zoom:50%;"></p><p>​        分别计算 $P_0P_1×P_0Q、 P_1P_2×P_1Q、P_2P_0×P_2Q$，如果三者同号则代表点P在三条线段的同一边，那么必然处于三角形内部，如果不同号则代表该点一定在三角形外部<br><strong>利用bouding box减少点的计算：</strong>三角形通常只占屏幕很小的一部分，只对该bounding box内的点进行采样测试</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034364.png" alt="image-20231128201223186" style="zoom:50%;"></p><p><strong>锯齿现象：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034128.png" alt="image-20231128201443202" style="zoom:50%;"></p><p>产生的原因：只用了有限的采样点去逼近连续的三角形</p><h3 id="3-解决走样的方法"><a href="#3-解决走样的方法" class="headerlink" title="3.解决走样的方法"></a>3.解决走样的方法</h3><h4 id="3-1超采样反走样-Super-Sampling-AA"><a href="#3-1超采样反走样-Super-Sampling-AA" class="headerlink" title="3.1超采样反走样(Super Sampling AA)"></a>3.1超采样反走样(Super Sampling AA)</h4><p>用更多的采样点去逼近连续的三角形</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034872.png" alt="image-20231128201847832" style="zoom:50%;"></p><p>对着四个采样点分别计算颜色值，将这四个点的采样点的颜色值取均值，如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034448.png" alt="image-20231128202001340" style="zoom:50%;"></p><p><em>注：超采样的缺点是对计算资源的更高要求</em></p><h4 id="3-2多采样反走样-Multi-Sampling-AA"><a href="#3-2多采样反走样-Multi-Sampling-AA" class="headerlink" title="3.2多采样反走样(Multi-Sampling AA)"></a>3.2多采样反走样(Multi-Sampling AA)</h4><p>MSAA是对SSAA的改进，不再为每个采样点都计算颜色值，而只计算像素中采样点被覆盖的比例，而后在中心点处计算颜色值。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034470.png" alt="image-20231128202605057" style="zoom:50%;"></p><h4 id="3-3-先模糊（滤波），再采样"><a href="#3-3-先模糊（滤波），再采样" class="headerlink" title="3.3 先模糊（滤波），再采样"></a>3.3 先模糊（滤波），再采样</h4><p>通过在采样前进行滤波，可以去除信号中的高频分量，从而在采样时避免混叠效应，减少走样。</p><p>在频域中限制高频成分的影响，有助于避免走样问题</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034171.png" alt="image-20231128203246227" style="zoom:50%;"></p><h3 id="4-深度测试"><a href="#4-深度测试" class="headerlink" title="4.深度测试"></a>4.深度测试</h3><p>深度测试是指在渲染图像时确定像素的深度值（或称为Z值）以确定哪些像素应该显示在屏幕上。</p><p><em>注：深度测试是一种解决图形学中遮挡关系的技术，确保在屏幕上只显示最前面的像素，而将被遮挡的像素隐藏起来，从而呈现出正确的三维场景。</em></p><h4 id="Z-Buffer（深度缓冲）算法"><a href="#Z-Buffer（深度缓冲）算法" class="headerlink" title="Z-Buffer（深度缓冲）算法"></a>Z-Buffer（深度缓冲）算法</h4><p><strong>算法的基本思想：</strong>每个采样点（像素）存储当前的最小深度值，假设深度值（z值）始终为正值。如果一个像素的深度值较小，表示它离观察者更近；反之，如果深度值较大，则表示它离观察者更远。<strong>帧缓冲用于存储屏幕上每个像素的颜色信息，深度缓冲专门用于存储每个像素的深度值</strong>，如果当前像素的深度值较小（即更接近观察者），则更新深度缓冲和帧缓冲中的值；否则，将其视为被遮挡，不进行更新。</p><p>伪代码如下:</p><p><img src="/posts/499d8707.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20231130085326419.png" alt="image-20231130085326419" style="zoom:50%;"></p><p><img src="/posts/499d8707.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20231130085351796.png" alt="image-20231130085351796" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;光栅化&quot;&gt;&lt;a href=&quot;#光栅化&quot; class=&quot;headerlink&quot; title=&quot;光栅化&quot;&gt;&lt;/a&gt;光栅化&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;光栅化（Rasterization）&lt;/strong&gt;是图形学中一种常用的渲染技术，用于将三维场景中的图形对象转换为</summary>
      
    
    
    
    <category term="图形学" scheme="https://wangak.cc/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>SPM</title>
    <link href="https://wangak.cc/posts/236d2982.html"/>
    <id>https://wangak.cc/posts/236d2982.html</id>
    <published>2023-11-18T06:23:40.209Z</published>
    <updated>2023-11-28T12:35:31.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SPM"><a href="#SPM" class="headerlink" title="SPM"></a>SPM</h2><p><strong>论文：《Learning with Explicit Shape Priors for Medical Image Segmentation》（TMI 2023)</strong></p><p><strong>探索形状先验(shape priors)对分割性能的影响</strong></p><p>基于unet的医学图像分割模型的局限性:cnn的感受野有限，无法利用器官或组织之间的远距离和全局空间关系，无法实现精细的形状表示。（注意力模块扩大模型的感受野，隐式地捕获形状信息）</p><p><em>注：通过设计特定的损失函数，而不是Dice损失或交叉熵损失，将明确的形状先验集成到分割框架中。但这些损失函数是特定于任务的，不能很容易地扩展到不同的数据集</em></p><p>提出了显式形状模型（SPM），以形状先验作为额外的输入来增强模型的形状表示能力。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436431.png" alt="image-20231120152537182" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436712.png" alt="image-20231120163304452" style="zoom:67%;"></p><p>其中F代表模型的前向传播，S代表构造图像I和标签L之间映射的形状先验。</p><p><strong>注意力图：</strong>生成的形状先验在推断阶段充当了注意力图，用于定位感兴趣的区域，并抑制背景区域</p><p><strong>SPM模块：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436670.png" alt="image-20231120153357914" style="zoom:67%;"></p><p>SPM模块由the self-update block (SUB)、cross-update block (CUB)</p><p><strong>the self-update block (SUB)：</strong>以形状先验作为输入，用于生成全局形状先验</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436041.png" alt="image-20231120154358605" style="zoom:50%;"></p><p>SUB的结构缺乏对局部视觉结构的建模，全局形状先验不具有精确的形状和轮廓信息。</p><p><strong>cross-update block (CUB)：</strong>建模局部形状先验</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436616.png" alt="image-20231120160130787" style="zoom: 50%;"></p><p><script type="math/tex">C_{map}</script>:一个C × N矩阵,用于评估C通道特征映射Fo和N通道形状先验之间的关系。</p><p>下采样<script type="math/tex">F_e</script>生成局部形状先验<script type="math/tex">S_L</script>:</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436429.png" alt="image-20231120160808202" style="zoom:50%;"></p><p>增强的形状先验融合了SUB生成全局形状先验及CUB生成的局部形状先验</p><h3 id="实验部分："><a href="#实验部分：" class="headerlink" title="实验部分："></a>实验部分：</h3><p><strong>与其他方法的对比：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436022.png" alt="image-20231120202559717" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436614.png" alt="image-20231120202723390" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436085.png" alt="image-20231120202732327" style="zoom: 67%;"></p><p><strong>消融实验：</strong>在BRATS 2020（脑肿瘤）、<strong>VerSe2019</strong>(脊柱)、ACDC（心脏）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436828.png" alt="image-20231120201045294" style="zoom: 80%;"></p><p>表明SPM有增强模型对相对规则的形状区域的表示能力</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SPM&quot;&gt;&lt;a href=&quot;#SPM&quot; class=&quot;headerlink&quot; title=&quot;SPM&quot;&gt;&lt;/a&gt;SPM&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;论文：《Learning with Explicit Shape Priors for Medical Image </summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>MedNeXt</title>
    <link href="https://wangak.cc/posts/9ce6c01f.html"/>
    <id>https://wangak.cc/posts/9ce6c01f.html</id>
    <published>2023-11-12T16:00:00.000Z</published>
    <updated>2023-11-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MedNeXt-Transformer-driven-Scaling-of-ConvNets-for-Medical-Image-Segmentation"><a href="#MedNeXt-Transformer-driven-Scaling-of-ConvNets-for-Medical-Image-Segmentation" class="headerlink" title="MedNeXt: Transformer-driven Scaling of ConvNets for Medical Image Segmentation"></a>MedNeXt: Transformer-driven Scaling of ConvNets for Medical Image Segmentation</h2><p><strong>论文：《MedNeXt: Transformer-driven Scaling of ConvNets for Medical Image Segmentation》(MICCAI 2023)</strong></p><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311130851990.png" alt="image-20231108195751803"></p><p><strong>MedNeXt Block:</strong></p><ul><li><p>深度卷积层（DW）：k × k × k的深度卷积，归一化使用channel-wise GroupNorm</p></li><li><p>Expansion Layer:较大的 R 值允许网络在宽度方向上扩展，而 1×1×1 核限制了计算量</p></li><li><p>Compression Layer:1×1×1卷积层对输出通道进行压缩</p></li></ul><p><strong>MedNeXt Down Block和MedNeXt Up Block：</strong></p><ul><li>添加了一个残差连接1×1×1卷积或转置卷积，步幅为2</li></ul><p>​    解码器层使用<strong>深度监督</strong>，在较低分辨率下具有较低的损失权值（深度监督：在网络的中间部分添加了额外的loss，不同位置的loss按系数求和。深度监督的目的是为了浅层能够得到更加充分的训练，解决深度神经网络训练梯度消失和收敛速度过慢等问题。）</p><p><strong>UpKern 初始化：</strong></p><p>大卷积核的缺陷：大卷积核性能可能更容易达到一个瓶颈，无法再进一步提高。(大卷积核模型有更多的参数，因此更容易过拟合训练数据)</p><p>医学图像分割任务的数据少之又少，性能更容易饱和。</p><p>为了帮助大卷积核网络在医学图像分割等任务中更好地利用有限数据，从而改善性能。</p><p>对预训练小核网络进行三线性上采样来初始化大核网络，从而<strong>迭代地增加核大小</strong>。其他的大小相同的层（包括归一化层）都通过直接复制预训练层的权重来初始化。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311130851317.png" alt="image-20231108204926791" style="zoom:67%;"></p><p><strong>MedNeXt四种配置及消融实验：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311130851800.png" alt="image-20231108211021855"></p><p>通道数（C)均设置为32</p><ul><li>在重采样时保留了特征映射中的语义丰富性</li><li>没有UpKern的大内核和小内核的性能是没有区别的</li><li>大卷积核中的性能提升是由于UpKern与大卷积核的结合，而不仅仅是更长的训练</li></ul><h3 id="2-实验结果"><a href="#2-实验结果" class="headerlink" title="2.实验结果"></a>2.实验结果</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311130851293.png" alt="image-20231108214400563"></p>]]></content>
    
    
    <summary type="html">记录了MedNeXt的网络结构及实验结果</summary>
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>C++编程出现的错误及解决</title>
    <link href="https://wangak.cc/posts/f3261b08.html"/>
    <id>https://wangak.cc/posts/f3261b08.html</id>
    <published>2023-11-11T07:07:32.208Z</published>
    <updated>2023-11-11T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-编程出现的错误及解决"><a href="#C-编程出现的错误及解决" class="headerlink" title="C++编程出现的错误及解决"></a>C++编程出现的错误及解决</h2><h3 id="1-Undefined-reference"><a href="#1-Undefined-reference" class="headerlink" title="1.Undefined reference"></a>1.Undefined reference</h3><p><strong>1.1目标文件未正确链接:</strong></p><p><strong>原因：</strong>有多个源文件，会独立编译它们,会导致对象没有正确链</p><p><strong>解决方法：同时编译这两个文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ cat.cpp test.cpp -o test//同时编译cat.cpp和test.cpp，并生成可执行文件test</span><br><span class="line">./test  //运行test.exe</span><br></pre></td></tr></table></figure><p>注：有多个源文件时使用如下指令进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ *.cpp -o main</span><br><span class="line">./main</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-编程出现的错误及解决&quot;&gt;&lt;a href=&quot;#C-编程出现的错误及解决&quot; class=&quot;headerlink&quot; title=&quot;C++编程出现的错误及解决&quot;&gt;&lt;/a&gt;C++编程出现的错误及解决&lt;/h2&gt;&lt;h3 id=&quot;1-Undefined-reference&quot;&gt;</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>nnUNet v2模型训练</title>
    <link href="https://wangak.cc/posts/4a35a285.html"/>
    <id>https://wangak.cc/posts/4a35a285.html</id>
    <published>2023-11-06T16:00:00.000Z</published>
    <updated>2023-11-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nnUNet-v2模型训练"><a href="#nnUNet-v2模型训练" class="headerlink" title="nnUNet v2模型训练"></a>nnUNet v2模型训练</h2><h3 id="1-数据集处理"><a href="#1-数据集处理" class="headerlink" title="1.数据集处理"></a>1.数据集处理</h3><p><strong>nnUnet要求rgb-png格式的数据</strong>，故将原数据集由单通道堆叠成三通道的RGB图像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line">import os</span><br><span class="line">def gray_to_rgb(image_gray):</span><br><span class="line">    # 创建一个全零的三通道图像</span><br><span class="line">    height, width = image_gray.shape</span><br><span class="line">    image_rgb = np.zeros((height, width, 3), dtype=np.uint8)</span><br><span class="line">    # 将灰度图像的值复制到红通道</span><br><span class="line">    image_rgb[:, :, 2] = image_gray</span><br><span class="line">    image_rgb[:, :, 1] = image_gray</span><br><span class="line">    image_rgb[:, :, 0] = image_gray</span><br><span class="line">    return image_rgb</span><br><span class="line"># 设置目标文件夹路径</span><br><span class="line"> # 包含灰度PNG图像的文件夹路径</span><br><span class="line">output_folder = # 用于保存RGB图像的文件夹路径</span><br><span class="line">root_folder=</span><br><span class="line"># 创建输出文件夹（如果不存在）</span><br><span class="line">if not os.path.exists(output_folder):</span><br><span class="line">    os.makedirs(output_folder)</span><br><span class="line">for root, dirs, files in os.walk(root_folder):</span><br><span class="line">    # 遍历目标文件夹中的所有图像文件</span><br><span class="line">    if root == root_folder:</span><br><span class="line">        for dir_name in dirs:</span><br><span class="line">            input_folder = os.path.join(root, dir_name, dir_name + &quot;_label&quot;)</span><br><span class="line">            print(input_folder)</span><br><span class="line">            for filename in os.listdir(input_folder):</span><br><span class="line">                if filename.endswith(&#x27;.png&#x27;):</span><br><span class="line">                    # 构造图像文件的完整输入路径</span><br><span class="line">                    input_image_path = os.path.join(input_folder, filename)</span><br><span class="line">                    # 读取灰度图像</span><br><span class="line">                    image_gray = cv2.imread(input_image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">                    if image_gray is not None:</span><br><span class="line">                        # 转换为RGB图像</span><br><span class="line">                        image_rgb = gray_to_rgb(image_gray)</span><br><span class="line">                        # 构造保存的RGB图像文件名（输出路径）</span><br><span class="line">                        output_image_path = os.path.join(output_folder, filename.replace(&#x27;.png&#x27;, &#x27;_rgb.png&#x27;))</span><br><span class="line">                        # 保存RGB图像到指定输出路径</span><br><span class="line">                        cv2.imwrite(output_image_path, image_rgb)</span><br><span class="line">            print(&quot;Conversion completed.&quot;)</span><br></pre></td></tr></table></figure><p><strong>原先数据集的格式要求：</strong></p><ul><li><strong>train</strong><ul><li><strong>images</strong></li><li><strong>labels</strong></li></ul></li><li><strong>test</strong><ul><li><strong>images</strong></li><li><strong>labels</strong></li></ul></li></ul><p><strong>将数据集转化为nnUnet标准格式，改写nnUNet/nnunetv2/dataset_conversion/Dataset120_RoadSegmentation.py</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # extracted archive from https://www.kaggle.com/datasets/insaff/massachusetts-roads-dataset?resource=download</span><br><span class="line">    source = &#x27;/root/autodl-tmp/nnUNet/Coronary&#x27;</span><br><span class="line">    print(source)</span><br><span class="line">    dataset_name = &#x27;Dataset150_Segmentation&#x27;</span><br><span class="line">    nnUNet_raw = &#x27;/root/autodl-tmp/nnUNet/dataset/nnUNet_raw&#x27;</span><br><span class="line">    imagestr = join(nnUNet_raw, dataset_name, &#x27;imagesTr&#x27;)</span><br><span class="line">    imagests = join(nnUNet_raw, dataset_name, &#x27;imagesTs&#x27;)</span><br><span class="line">    labelstr = join(nnUNet_raw, dataset_name, &#x27;labelsTr&#x27;)</span><br><span class="line">    labelsts = join(nnUNet_raw, dataset_name, &#x27;labelsTs&#x27;)</span><br><span class="line">   </span><br><span class="line">    maybe_mkdir_p(imagestr)</span><br><span class="line">    maybe_mkdir_p(imagests)</span><br><span class="line">    maybe_mkdir_p(labelstr)</span><br><span class="line">    maybe_mkdir_p(labelsts)</span><br><span class="line"></span><br><span class="line">    train_source = join(source, &#x27;train&#x27;)</span><br><span class="line">    test_source = join(source, &#x27;test&#x27;)</span><br><span class="line"></span><br><span class="line">    with multiprocessing.get_context(&quot;spawn&quot;).Pool(8) as p:</span><br><span class="line"></span><br><span class="line">        # not all training images have a segmentation</span><br><span class="line">        valid_ids = subfiles(join(train_source, &#x27;labels&#x27;), join=False, suffix=&#x27;png&#x27;)</span><br><span class="line">        num_train = len(valid_ids)</span><br><span class="line">        r = []</span><br><span class="line">        for v in valid_ids:</span><br><span class="line">            r.append(</span><br><span class="line">                p.starmap_async(</span><br><span class="line">                    load_and_covnert_case,</span><br><span class="line">                    ((</span><br><span class="line">                         join(train_source, &#x27;images&#x27;, v),</span><br><span class="line">                         join(train_source, &#x27;labels&#x27;, v),</span><br><span class="line">                         join(imagestr, v[:-4] + &#x27;_0000.png&#x27;),</span><br><span class="line">                         join(labelstr, v),</span><br><span class="line">                         50</span><br><span class="line">                     ),)</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        # test set</span><br><span class="line">        valid_ids = subfiles(join(test_source, &#x27;labels&#x27;), join=False, suffix=&#x27;png&#x27;)</span><br><span class="line">        for v in valid_ids:</span><br><span class="line">            r.append(</span><br><span class="line">                p.starmap_async(</span><br><span class="line">                    load_and_covnert_case,</span><br><span class="line">                    ((</span><br><span class="line">                         join(test_source, &#x27;images&#x27;, v),</span><br><span class="line">                         join(test_source, &#x27;labels&#x27;, v),</span><br><span class="line">                         join(imagests, v[:-4] + &#x27;_0000.png&#x27;),</span><br><span class="line">                         join(labelsts, v),</span><br><span class="line">                         50</span><br><span class="line">                     ),)</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        _ = [i.get() for i in r]</span><br><span class="line"></span><br><span class="line">    generate_dataset_json(join(nnUNet_raw, dataset_name), &#123;0: &#x27;R&#x27;, 1: &#x27;G&#x27;, 2: &#x27;B&#x27;&#125;, &#123;&#x27;background&#x27;: 0, &#x27;coronary&#x27;: 1&#125;,</span><br><span class="line">                          num_train, &#x27;.png&#x27;, dataset_name=dataset_name)</span><br></pre></td></tr></table></figure><p><strong>生成的数据集：</strong></p><ul><li>数据集名称<ul><li>imagesTr</li><li>imagesTs</li><li>labelsTr</li><li>labelsTs</li><li>dataset.json</li></ul></li></ul><p><strong>添加环境变量：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export nnUNet_raw=&quot;/root/autodl-tmp/nnUNet/dataset/nnUNet_raw&quot;</span><br><span class="line">export nnUNet_preprocessed=&quot;/root/autodl-tmp/nnUNet/dataset/nnUNet_preprocessed&quot;</span><br><span class="line">export nnUNet_results=&quot;/root/autodl-tmp/nnUNet/dataset/nnUnet_results&quot;</span><br></pre></td></tr></table></figure><p><strong>预处理数据集：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNetv2_plan_and_preprocess -d 150 --verify_dataset_integrity #150为任务id</span><br></pre></td></tr></table></figure><h3 id="2-模型训练"><a href="#2-模型训练" class="headerlink" title="2.模型训练"></a>2.模型训练</h3><p><strong>开始训练：</strong></p><p><code>nnUNetv2_train CONFIGURATION TRAINER_CLASS_NAME TASK_NAME_OR_ID FOLD (additional options)</code></p><ul><li><code>CONFIGURATION：</code> 模型架构，三种Unet: 2D U-Net, 3D U-Net and a U-Net Cascade(U-Net级联)。</li><li><code>TASK_NAME_OR_ID：</code> 任务全名TaskXXX_MYTASK或者是ID号</li><li><code>FOLD：</code> 第几折交叉验证，可选 [0, 1, 2, 3, 4]，一共五折。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNetv2_train 666 2d 4</span><br></pre></td></tr></table></figure><p><strong>loss曲线：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115385.png" alt="image-20231106164804089" style="zoom: 67%;"></p><h3 id="3-模型测试"><a href="#3-模型测试" class="headerlink" title="3.模型测试"></a>3.模型测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNetv2_predict -i “测试集路径” -o “输出路径” -chk checkpoint_best.pth -c 2d -f 4 -d 150 --save_probabilities</span><br></pre></td></tr></table></figure><p>将二值掩码转换为0或255</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def process_images_in_folder(input_folder, output_folder):</span><br><span class="line">    for root, dirs, files in os.walk(input_folder):</span><br><span class="line">        for file in files:</span><br><span class="line">            if file.endswith(&quot;.png&quot;):</span><br><span class="line">                input_image_path = os.path.join(root, file)</span><br><span class="line">                output_image_path = os.path.join(output_folder, file)</span><br><span class="line"></span><br><span class="line">                # 打开输入图像</span><br><span class="line">                image = Image.open(input_image_path)</span><br><span class="line"></span><br><span class="line">                # 将像素值为1的通道变为255</span><br><span class="line">                image = image.convert(&quot;RGB&quot;)</span><br><span class="line">                data = image.getdata()</span><br><span class="line">                new_data = [(r, g, b) if r != 1 and g != 1 and b != 1 else (255, 255, 255) for (r, g, b) in data]</span><br><span class="line">                image.putdata(new_data)</span><br><span class="line"></span><br><span class="line">                # 保存修改后的图像</span><br><span class="line">                image.save(output_image_path)</span><br><span class="line"></span><br><span class="line"># 指定输入文件夹和输出文件夹的路径</span><br><span class="line">input_folder_path = &quot;&quot;</span><br><span class="line">output_folder_path = &quot;&quot;</span><br><span class="line"></span><br><span class="line">if not os.path.exists(output_folder_path):</span><br><span class="line">    os.makedirs(output_folder_path)</span><br><span class="line"></span><br><span class="line">process_images_in_folder(input_folder_path, output_folder_path)</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202311062116900.png" alt="image-20231106200912078"></p><p><strong>评价指标：</strong></p><p><strong>HD95: 5.20</strong></p><p><strong>Average Dice: 0.8144</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;nnUNet-v2模型训练&quot;&gt;&lt;a href=&quot;#nnUNet-v2模型训练&quot; class=&quot;headerlink&quot; title=&quot;nnUNet v2模型训练&quot;&gt;&lt;/a&gt;nnUNet v2模型训练&lt;/h2&gt;&lt;h3 id=&quot;1-数据集处理&quot;&gt;&lt;a href=&quot;#1-</summary>
      
    
    
    
    <category term="模型训练" scheme="https://wangak.cc/categories/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/"/>
    
    
    <category term="模型训练" scheme="https://wangak.cc/tags/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/"/>
    
  </entry>
  
  <entry>
    <title>3D UX-NET</title>
    <link href="https://wangak.cc/posts/eabf9f8.html"/>
    <id>https://wangak.cc/posts/eabf9f8.html</id>
    <published>2023-11-06T16:00:00.000Z</published>
    <updated>2023-11-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3D-UX-NET"><a href="#3D-UX-NET" class="headerlink" title="3D UX-NET"></a>3D UX-NET</h2><p><strong>论文：《3D UX-NET: A LARGE KERNEL VOLUMETRIC CONVNET MODERNIZING HIERARCHICAL TRANSFORMER</strong><br><strong>FOR MEDICAL IMAGE SEGMENTATION》（ICLR 2023）</strong></p><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115336.png" alt="image-20231106201433865"></p><p>采用具备大卷积核的投影层来提取 patch-wise 特征作为编码器的输入</p><p><strong>对Swin transformer的transformer block做了替换：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115856.png" alt="image-20231106202256333" style="zoom:67%;"></p><p>使用大卷积核(7 × 7 × 7)的深度卷积来模仿Swin Transformer的局部自注意力和窗口移动。</p><p>使用2 × 2 × 2、步幅为2的标准卷积块来实现下采样</p><p>在Swin Transformer中MLP隐藏层维度比输入维度宽四倍，引入了具有 1 × 1 × 1 卷积核大小的深度卷积缩放(DCS)，以独立地线性缩放每个通道特征，减少跨通道上下文产生的冗余信息</p><p>DCS：1x1x1的深度卷积+1x1x1的分组卷积</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115037.png" alt="image-20231106205655475" style="zoom:67%;"></p><p>从实验中发现：使用深度卷积缩放(DCS)参数量得到了减小，效果并没有下降</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115199.png" alt="image-20231106204002121"></p><p>编码器的输出特征由残差块作进一步的处理，以稳定提取的特征。（残差块由两个经过实例归一化的后归一化3 × 3 × 3卷积层组成）</p><p>转置卷积层实现上采样，其输出的特征与编码器的输出进行连接后，再次输入到残差块中。</p><h3 id="2-实验结果"><a href="#2-实验结果" class="headerlink" title="2.实验结果"></a>2.实验结果</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115341.png" alt="image-20231106210428239"></p><p>3D UX-Net 在这几个分割任务中均展示出最佳性能，并且 Dice 分数有了一定的提高</p>]]></content>
    
    
    <summary type="html">记录了3D UX-NET的网络结构及实验结果</summary>
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>图像分割常用指标</title>
    <link href="https://wangak.cc/posts/70fa35a7.html"/>
    <id>https://wangak.cc/posts/70fa35a7.html</id>
    <published>2023-11-01T16:00:00.000Z</published>
    <updated>2023-11-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图像分割常用指标"><a href="#图像分割常用指标" class="headerlink" title="图像分割常用指标"></a>图像分割常用指标</h3><h4 id="1-DSC（Dice相似系数）"><a href="#1-DSC（Dice相似系数）" class="headerlink" title="1.DSC（Dice相似系数）"></a>1.DSC（Dice相似系数）</h4><p><strong>DSC：用于衡量区域的重合程度</strong></p><p><strong>计算公式：</strong></p><script type="math/tex; mode=display">DSC = (2 * |A ∩ B|) / (|A| + |B|)</script><p>其中，A为算法生成的分割结果的像素集合，B为参考分割结果的像素集合</p><ul><li><p>DSC值范围在0到1之间，其中0表示完全不相似，1表示完全相似。</p></li><li><p>DSC值越接近1，表示算法生成的分割结果与参考分割结果越相似</p></li></ul><p><em>注：Dice相似系数仅考虑了像素的重叠情况，而没有考虑像素之间的空间关系，在存在模糊边界的分割任务中,Dice系数可能无法准确评估模型的性能。</em></p><h4 id="2-HD-豪斯多夫距离"><a href="#2-HD-豪斯多夫距离" class="headerlink" title="2.HD(豪斯多夫距离)"></a>2.HD(豪斯多夫距离)</h4><p><strong>HD:表示预测分割区域边界与真实区域边界之间的最大距离，其值越小代表预测边界分割误差越小、质量越好。</strong></p><p><strong>计算公式：</strong></p><p><img src="/posts/70fa35a7.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20231102100120629.png" alt="image-20231102100120629" style="zoom:67%;"></p><p><img src="/posts/70fa35a7.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20231102100057838.png" alt="image-20231102100057838" style="zoom:67%;"></p><p><strong>计算步骤：</strong></p><p>​    (1)对点集X中的每一个点x计算其到点集Y中的每一个点y的距离，保留最短距离，然后找出保留的最短距离中的最大距离记为Dxy。</p><p>​    (2)对点集Y中的每一个点y计算其到点集X中的每一个点x的距离，保留最短距离，然后找出保留最短距离中的最大距离记为Dyx。</p><p>​    (3)取Dxy和Dyx最大值作为点集X和Y之间的豪斯多夫距离。</p><p><strong>HD95(95％ 豪斯多夫距离):</strong></p><p>为了排除一些离群点造成的不合理距离，保持整体数值稳定性，一般选择从小到大排名前 95%的距离作为实际豪斯多夫距离，称之为 95% 豪斯多夫距离。</p><p><strong>注：Dice相似系数主要关注分割结果的整体准确性，HD95则更侧重于考虑分割边界的精确性</strong></p><p><strong>注： 豪斯多夫距离目标是捕捉两个集合之间的最大不一致，对于孤立的离群点或噪声非常敏感，不适用于噪声较多的图像。</strong></p><h4 id="3-ASD（平均表面距离）"><a href="#3-ASD（平均表面距离）" class="headerlink" title="3.ASD（平均表面距离）"></a>3.ASD（平均表面距离）</h4><p>平均表面距离：用来测量分割结果中的边界与真实标签中的边界之间的距离。</p><p><strong>计算分割结果中的每个像素与真实标签中的最近像素之间的距离，然后取平均值。</strong></p><p><img src="/posts/70fa35a7.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20231102102746435.png" alt="image-20231102102746435" style="zoom: 50%;"></p><p><strong>ASSD(平均对称表面距离):</strong></p><p>​                                                            <script type="math/tex">\large ASSD(X,Y)={ASD(X,Y)+ASD(Y,X)}/2</script></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;图像分割常用指标&quot;&gt;&lt;a href=&quot;#图像分割常用指标&quot; class=&quot;headerlink&quot; title=&quot;图像分割常用指标&quot;&gt;&lt;/a&gt;图像分割常用指标&lt;/h3&gt;&lt;h4 id=&quot;1-DSC（Dice相似系数）&quot;&gt;&lt;a href=&quot;#1-DSC（Dice相似系数</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>nnFormer</title>
    <link href="https://wangak.cc/posts/9e11ec23.html"/>
    <id>https://wangak.cc/posts/9e11ec23.html</id>
    <published>2023-10-30T16:00:00.000Z</published>
    <updated>2023-10-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nnFormer"><a href="#nnFormer" class="headerlink" title="nnFormer"></a>nnFormer</h2><p><strong>论文：《nnFormer: Volumetric Medical Image Segmentation via a 3D Transformer》（TMI2022）</strong></p><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310252011844.png" alt="image-20231025201100423" style="zoom: 80%;"></p><h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h4><p><strong>nnFormer的输入：</strong>对原始图像中随机裁剪（HxWxD)，数据增强技术，有助于模型更好地学习不同部分的特征。</p><p><strong>The embedding layer:</strong>（将输入数据转换成高维张量）</p><ul><li><strong>使用卷积的好处：</strong>对比transformer使用线性层对patch的向量进行映射，卷积层能够更细致地捕获图像中的像素级信息（减少了训练的参数数量，卷积核在处理特定区域时更加专注）</li><li><strong>在初始阶段使用小卷积核的连续卷积层，相对于大卷积核的好处：</strong>降低计算复杂度,同时保持相同大小的感受野(非线性激活函数多了，语义表达能力增强了)</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202310252109346.png" alt="image-20231025210627610"></p><p><em>注：根据输入的patch大小卷积步长也会有相应的变化</em></p><p><strong>Local Volume-based Multi-head Self-attention (LV-MSA)：</strong>将不同尺度的信息和高分辨率的空间信息相互关联</p><p>不同尺度的特征由下采样层生成，高分辨率的空间信息则由嵌入层编码</p><p>使用的是一种基于局部三维图像块的self-attention计算方式（跟Swin-UNet类似)</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310252129451.png" alt="image-20231025212855680" style="zoom: 80%;"></p><p><strong>SLV-MSA:</strong>是LV-MSA的shifted版本（类似于Swin-UNet，目的是使局部的三维图像块之间产生联系）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310252130572.png" alt="image-20231025213050517" style="zoom: 67%;"></p><p><em>注：$S_H、S_W、S_D$代表每个图像块中的patch的数量</em></p><p>使用LV-MSA减少了计算的复杂度，计算复杂度和图像之间是线性的关系</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310252139215.png" alt="image-20231025213709821" style="zoom: 80%;"></p><p>使用相对位置偏置B来引入位置信息</p><p><strong>The down-sampling layer：</strong></p><p>与Swin-UNet使用patch merging不同，作者选择了使用简单的卷积来实现下采样，卷积下采样可以在不同空间维度上应用不同的步长，以根据问题的要求调整下采样率。（可以根据数据的特点来灵活设置，避免过度下采样，对于三维的图像在某些维度上数据切片数量有限，这时可以将该维度的步长设置为1）</p><h4 id="Bottleneck"><a href="#Bottleneck" class="headerlink" title="Bottleneck"></a>Bottleneck</h4><p>不同于编码器使用局部自注意力机制，Bottleneck中使用全局自注意力。</p><p>计算复杂度：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310271637998.png" alt="image-20231027153408838" style="zoom: 80%;"></p><p>编码器部分减小了h、w、d，这为GV-MSA的应用创造了条件，与LV-MSA相比，GV-MSA能够提供更大的感受野</p><h4 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h4><p><strong>上采样操作</strong>：使用转置卷积</p><p><strong>Skip Attention：</strong>（使不同层之间的信息交流变得更加灵活）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310271636161.png" alt="image-20231027155805206" style="zoom: 67%;"></p><h3 id="2-实验部分"><a href="#2-实验部分" class="headerlink" title="2.实验部分"></a>2.实验部分</h3><h4 id="与基于Transformer的方法学的比较"><a href="#与基于Transformer的方法学的比较" class="headerlink" title="与基于Transformer的方法学的比较"></a>与基于Transformer的方法学的比较</h4><p><strong>脑肿瘤分割</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310271636932.png" alt="image-20231027162254249" style="zoom: 67%;"></p><p>列出了所有模型在脑瘤分割任务上的实验结果,nnFormer在所有类别中取得了最低的HD95和最高的DSC分数。</p><p><strong>多器官分割（Synapse）</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310302100261.png" alt="image-20231029163515666"></p><p>与以前基于Transformer的方法相比，nnFormer在分割胰腺(Pancreas)和胃(Stomach)方面更有优势</p><p><strong>与nnUNet的比较</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310302100944.png" alt="image-20231030203836841"></p><p>nnFormer的HD95似乎更有优势，其可以更好地划分对象边界。</p><p>nnAvg：对nnFormer和nnUNet的预测结果进行平均化，发现整体的性能得到了提高，表明nnFormer和nnUNet是可以互补的。</p><h4 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202310302100685.png" alt="image-20231030205355146"></p><ul><li><p>嵌入层使用小卷积核大小的连续卷积层</p></li><li><p>卷积下采样层替换掉了patch Merging层</p></li><li><p>GV-MSA替换了Bottleneck的LV-MSA</p></li><li><p>Skip Attention代替跳跃连接</p></li><li>SLV-MSA层与LV-MSA层级联，全局自注意力层的数量增加一倍</li></ul>]]></content>
    
    
    <summary type="html">记录了nnFormer的网络结构及实验结果</summary>
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>File类</title>
    <link href="https://wangak.cc/posts/c8b66f0a.html"/>
    <id>https://wangak.cc/posts/c8b66f0a.html</id>
    <published>2023-10-18T12:44:09.000Z</published>
    <updated>2023-11-26T02:41:35.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><h3 id="1-创建File类的对象"><a href="#1-创建File类的对象" class="headerlink" title="1.创建File类的对象"></a>1.创建File类的对象</h3><p><img src="https://typoraimg.wangak.cc/2023/img/1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//创建一个File对象，指向某个具体的文件</span><br><span class="line">      File f1=new File(&quot;./data/test.txt&quot;);</span><br><span class="line">      System.out.println(f1.length());//文件大小</span><br><span class="line"></span><br><span class="line">      File f2=new File(&quot;./data/aaa.txt&quot;);//File对象可以指向空路径</span><br><span class="line">      System.out.println(f2.length());//0</span><br><span class="line">      System.out.println(f2.exists());//false</span><br></pre></td></tr></table></figure><h3 id="2-判断文件类型、获取文件信息"><a href="#2-判断文件类型、获取文件信息" class="headerlink" title="2.判断文件类型、获取文件信息"></a>2.判断文件类型、获取文件信息</h3><p><img src="https://typoraimg.wangak.cc/2023/img/2.png" alt="img" style="zoom: 50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//1.创建一个File对象，指向某个具体的文件</span><br><span class="line">      File f1=new File(&quot;./data/test.txt&quot;);</span><br><span class="line">      //2.判断文件路径是否存在</span><br><span class="line">      System.out.println(f1.exists());</span><br><span class="line">      //3.判断文件对象是否是文件</span><br><span class="line">      System.out.println(f1.isFile());</span><br><span class="line">      //4.判断文件对象是否是文件夹</span><br><span class="line">      System.out.println(f1.isDirectory());</span><br><span class="line">      //5.获取文件的名称</span><br><span class="line">      System.out.println(f1.getName());</span><br><span class="line">      //6.获取文件的大小，返回字节个数</span><br><span class="line">      System.out.println(f1.length());</span><br><span class="line">      //7.获取文件最后的修改时间</span><br><span class="line">      long time = f1.lastModified();</span><br><span class="line">      SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);</span><br><span class="line">      System.out.println(sdf.format(time));//2023/10/18</span><br><span class="line">      //8.获取创建文件对象时使用的路径</span><br><span class="line">      System.out.println(f1.getPath());</span><br><span class="line">      //9.获取文件对象的绝对路径</span><br><span class="line">      System.out.println(f1.getAbsolutePath());</span><br></pre></td></tr></table></figure><h3 id="3-创建、删除文件"><a href="#3-创建、删除文件" class="headerlink" title="3.创建、删除文件"></a>3.创建、删除文件</h3><p><strong>public boolean creatNewFile():</strong>创建一个新文件，创建成功返回true</p><p><strong>public boolean mkdir():</strong>创建文件夹（只能创建一级文件夹）</p><p><strong>public boolean mkdirs():</strong>创建文件夹,可以创建多级文件夹</p><p><strong>public boolean delete():</strong>删除文件或文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//1.创建一个新文件</span><br><span class="line">      File f1=new File(&quot;./data/test2.txt&quot;);</span><br><span class="line">      System.out.println(f1.createNewFile());</span><br><span class="line">      //2.创建文件夹</span><br><span class="line">      File f2=new File(&quot;./data/a&quot;);</span><br><span class="line">      System.out.println(f2.mkdir());</span><br><span class="line">      //3.创建多个文件夹</span><br><span class="line">      File f3=new File(&quot;./data/1/2&quot;);</span><br><span class="line">      System.out.println(f3.mkdirs());</span><br><span class="line">      //4.删除文件或文件夹</span><br><span class="line">      System.out.println(f1.delete());</span><br><span class="line">      System.out.println(f2.delete());</span><br><span class="line">      System.out.println(f3.delete());</span><br><span class="line">      //&quot;./data/1&quot;这个文件夹还存在</span><br></pre></td></tr></table></figure><h3 id="4-遍历文件夹"><a href="#4-遍历文件夹" class="headerlink" title="4.遍历文件夹"></a>4.遍历文件夹</h3><p><img src="https://typoraimg.wangak.cc/2023/img/3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">File f1=new File(&quot;./data&quot;);</span><br><span class="line">      //获取目录下文件的名称</span><br><span class="line">      String[] names=f1.list();</span><br><span class="line">      for(String x:names)&#123;</span><br><span class="line">          System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">      //获取当前目录下的文件对象</span><br><span class="line">      File[] files=f1.listFiles();</span><br><span class="line">      for (File file:files)&#123;</span><br><span class="line">          System.out.println(file.getPath());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;File类&quot;&gt;&lt;a href=&quot;#File类&quot; class=&quot;headerlink&quot; title=&quot;File类&quot;&gt;&lt;/a&gt;File类&lt;/h2&gt;&lt;h3 id=&quot;1-创建File类的对象&quot;&gt;&lt;a href=&quot;#1-创建File类的对象&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="java" scheme="https://wangak.cc/categories/java/"/>
    
    
    <category term="java" scheme="https://wangak.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>卷积编码位置信息</title>
    <link href="https://wangak.cc/posts/a8dea67.html"/>
    <id>https://wangak.cc/posts/a8dea67.html</id>
    <published>2023-10-13T06:56:14.000Z</published>
    <updated>2023-10-14T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>论文：《HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE?》（ICLR2020）</strong></p><h3 id="论文内容："><a href="#论文内容：" class="headerlink" title="论文内容："></a>论文内容：</h3><h4 id="初步实验："><a href="#初步实验：" class="headerlink" title="初步实验："></a>初步实验：</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412926.png" alt="1"></p><p>对原始图像和裁剪过的图像进行显著性检测。</p><p>显著的区域分析，对于相同的物体，在不同的边缘下，显著性区域始终靠近图像中心。</p><p>推测：<strong>位置信息在 CNN 网络提取的特征图中被隐式编码</strong></p><h4 id="Position-Encoding-Network："><a href="#Position-Encoding-Network：" class="headerlink" title="Position Encoding Network："></a>Position Encoding Network：</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412136.png" alt="2"></p><p><strong>a feed forward convolutional encoder network $f_{enc} $:</strong>使用预训练的VGG或者 ResNet，仅作为前馈网络，其参数不参与训练。为前馈网络的在五个卷积层产生的特征图，使用双线性插值缩放到统一尺寸进行拼接，之后输入到 Position Encoding Module 中。</p><p><strong>position encoding module：</strong>一般卷积网络，其卷积核未使用Padding。</p><p>作者使用该网络判断卷积层产生的特征图中是否包含位置信息。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412155.png" alt="3" style="zoom: 80%;"></p><p>垂直（H)和水平(V)方向的梯度掩码、应用高斯滤波器来设计另一种类型的真值图，高斯分布(G)、水平和垂直条纹（HS、VS)，使用这五种图像表示位置信息，作为Ground Truth，每次训练选择其中一种，<strong>所有样本的标签都是一样的</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412681.png" alt="4" style="zoom:80%;"></p><p>除了使用数据集中的原始图像，作者还分别将<strong>纯黑、纯白、高斯噪声图像作为输入</strong>，这是为了验证在没有语义信息的情况下，特征中是否包含绝对位置信息。</p><p><strong>评价指标：</strong> Spearmen Correlation (<strong>SPC</strong>) and Mean Absoute Error (<strong>MAE</strong>)，前者越高说明输出与目标图像的相关性越高，后者则相反。</p><p><strong>实验结果:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412217.png" alt="5"></p><p>单独使用PosENet得到的分数要低很多，这一结果表明，仅从输入图像中提取位置信息是非常困难的，<strong>PosENet要与编码器网络相结合才能更好地提取出位置信息</strong></p><p>发现基于ResNet的模型比基于VGG16的模型实现了更高的性能。</p><h4 id="探究卷积的参数对提取位置信息的影响"><a href="#探究卷积的参数对提取位置信息的影响" class="headerlink" title="探究卷积的参数对提取位置信息的影响"></a>探究卷积的参数对提取位置信息的影响</h4><p><strong>length of convolutional layers：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412853.png" alt="6" style="zoom: 67%;"></p><p><strong>kernel size:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412339.png" alt="7" style="zoom: 80%;"></p><p>​                                                                <strong>更大的感受野可以更好地解析位置信息</strong></p><p><strong>zero-padding：</strong>作者认为卷积中zero-padding 是 CNN 中位置信息的来源</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412058.png" alt="8" style="zoom:80%;"></p><p>从结果中可以看出，未添加 zero-padding 的 VGG16 的性能比默认设置（padding =  1）低得多。PosENet（padding = 1）实现了比原始（padding = 0）更高的性能，而当 padding 设置为 2  时，位置信息的作用更加明显。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;论文：《HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE?》（ICLR2020）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;论文内容：&quot;&gt;&lt;a href=&quot;#论文内容：</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="深度学习" scheme="https://wangak.cc/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="CNN" scheme="https://wangak.cc/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架</title>
    <link href="https://wangak.cc/posts/9753a2e.html"/>
    <id>https://wangak.cc/posts/9753a2e.html</id>
    <published>2023-10-03T08:31:34.000Z</published>
    <updated>2023-10-13T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><h3 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1.泛型"></a>1.泛型</h3><p><strong>泛型：</strong>允许在编写类、接口和方法时使用类型参数，以在运行时确定具体的数据类型，用于增强类型安全性和代码的可重用性</p><h4 id="1-1-泛型类"><a href="#1-1-泛型类" class="headerlink" title="1.1 泛型类"></a>1.1 泛型类</h4><p><strong>泛型类：</strong><code>类名&lt;T,...&gt;</code>,T是类型占位符，表示一种引用类型，如果编写多个用逗号隔开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGeneric</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//1.创建变量</span></span><br><span class="line">    T t;</span><br><span class="line">    <span class="comment">//2.使用泛型作为方法的参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T y)</span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.使用泛型作为方法的返回值</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用泛型类创建对象</span></span><br><span class="line">        MyGeneric&lt;String&gt; myGeneric1=<span class="keyword">new</span> <span class="title class_">MyGeneric</span>&lt;&gt;();</span><br><span class="line">        myGeneric1.t=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        MyGeneric&lt;Integer&gt; myGeneric2=<span class="keyword">new</span> <span class="title class_">MyGeneric</span>&lt;&gt;();</span><br><span class="line">        myGeneric2.t=<span class="number">100</span>;</span><br><span class="line">        myGeneric1.show();</span><br><span class="line">        myGeneric2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p>1.泛型只能是引用类型</p><p>2.不同泛型类型的对象之间不能相互赋值</p><h4 id="1-2-泛型接口"><a href="#1-2-泛型接口" class="headerlink" title="1.2 泛型接口"></a>1.2 泛型接口</h4><p><strong>泛型接口：</strong><code>接口名&lt;T&gt;</code></p><p><strong><em>注：不能使用泛型创建静态常量</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">server</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口实现方式一：class确定泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyImpl1</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&lt;String&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">server</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口实现方式二：class不确定泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyImpl2</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">server</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyImpl1 myImpl1=<span class="keyword">new</span> <span class="title class_">MyImpl1</span>();</span><br><span class="line">        myImpl1.server(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        MyImpl2&lt;Integer&gt; myImpl2a=<span class="keyword">new</span> <span class="title class_">MyImpl2</span>&lt;&gt;();</span><br><span class="line">        myImpl2a.server(<span class="number">100</span>);</span><br><span class="line">        MyImpl2&lt;String&gt; myImpl2b=<span class="keyword">new</span> <span class="title class_">MyImpl2</span>&lt;&gt;();</span><br><span class="line">        myImpl2b.server(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">hello</span><br><span class="line"><span class="number">100</span></span><br><span class="line">world</span><br></pre></td></tr></table></figure><h4 id="1-3-泛型方法"><a href="#1-3-泛型方法" class="headerlink" title="1.3 泛型方法"></a>1.3 泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenernicMod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">show</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;泛型方法:&quot;</span>+t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test4</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GenernicMod genernicMod=<span class="keyword">new</span> <span class="title class_">GenernicMod</span>();</span><br><span class="line">        genernicMod.show(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        genernicMod.show(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">泛型方法:hello</span><br><span class="line">泛型方法:<span class="number">123</span></span><br></pre></td></tr></table></figure><h4 id="1-4-泛型集合"><a href="#1-4-泛型集合" class="headerlink" title="1.4 泛型集合"></a>1.4 泛型集合</h4><p><strong>泛型集合：</strong>参数化类型、类型安全的集合，强制集合元素的类型必须一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;yyy&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; iterator=arrayList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String string=iterator.next();</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Collection体系集合"><a href="#2-Collection体系集合" class="headerlink" title="2.Collection体系集合"></a>2.Collection体系集合</h3><p><strong>集合和数组的区别：</strong></p><p>(1).数组长度固定，集合长度不固定</p><p>(2).数组可以存储基本类型和引用类型，集合只能存储引用类型。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201402167.png" alt="1"></p><ul><li><p><strong>Collection</strong> 接口存储一组不唯一，无序的对象</p></li><li><p><strong>List</strong> 接口存储一组不唯一，有序的对象。</p></li><li><p><strong>Set</strong> 接口存储一组唯一，无序的对象</p></li><li><p><strong>Map</strong> 接口存储一组键值对象，提供key到value的映射</p><p><strong>Collection的使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">       <span class="comment">//1.添加元素</span></span><br><span class="line">        collection.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">        <span class="comment">//*2.删除元素</span></span><br><span class="line"><span class="comment">//        collection.remove(&quot;a&quot;);//一次remove操作只删除一个元素，即使Collection中有相同元素</span></span><br><span class="line"><span class="comment">//        System.out.println(collection);</span></span><br><span class="line">        <span class="comment">//*3.1使用增强for遍历</span></span><br><span class="line"><span class="comment">//        for (Object object:collection) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(object);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//*3.2使用迭代器进行遍历</span></span><br><span class="line">        <span class="comment">//hasNext();判断有没有下一个元素</span></span><br><span class="line">        <span class="comment">//next();获取下一个元素</span></span><br><span class="line">        <span class="comment">//remove();删除当前元素</span></span><br><span class="line">        Iterator it= collection.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String s=(String)it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line"><span class="comment">//            it.remove();//删除当前元素</span></span><br><span class="line">        &#125;<span class="comment">//使用迭代器遍历时禁止使用Collection的其他的一些方法如remove()来改变集合的元素，可以使用迭代器的方法(it.remove())</span></span><br><span class="line"><span class="comment">//        System.out.println(collection);</span></span><br><span class="line">        <span class="comment">//*4.判断元素是否存在</span></span><br><span class="line">        System.out.println(collection.contains(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-1-List子接口"><a href="#2-1-List子接口" class="headerlink" title="2.1 List子接口"></a>2.1 List子接口</h4><p><strong>List：</strong>有序、有下标、元素可以重复</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201402726.png" alt="2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">List_test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//1.添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="number">0</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//2.删除元素</span></span><br><span class="line"><span class="comment">//        list.remove(&quot;c&quot;);//按元素删除</span></span><br><span class="line">        list.remove(<span class="number">0</span>);<span class="comment">//按下标删除</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//3.遍历</span></span><br><span class="line">        <span class="comment">//3.1使用for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.1使用for&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2使用增强for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.2使用增强for&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object object:list)&#123;</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.3使用迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.3使用迭代器&quot;</span>);</span><br><span class="line">        Iterator iterator=list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.4使用列表迭代器，ListIterator可以向前或向后遍历，可以添加、删除、修改元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.4使用列表迭代器向后遍历&quot;</span>);</span><br><span class="line">        ListIterator lit=list.listIterator();</span><br><span class="line">        <span class="keyword">while</span>(lit.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;3.4使用列表迭代器向前遍历&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(lit.hasPrevious())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.previous());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.获取元素的索引位置</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ArrayList存储结构：</strong>数组，查找速度快，增删速度慢，运行效率快，线程不安全</p><p><strong>Vector存储结构：</strong>数组，查找速度快，增删速度慢，运行效率慢，线程安全</p><p><strong>LinkedList存储结构:</strong>双向链表，增删速度快，查询速度慢</p><h4 id="2-2-set子接口"><a href="#2-2-set子接口" class="headerlink" title="2.2 set子接口"></a>2.2 set子接口</h4><h5 id="2-2-1-Set"><a href="#2-2-1-Set" class="headerlink" title="2.2.1 Set"></a>2.2.1 Set</h5><p><strong>Set:无序、无下标、元素不可重复</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set &lt;String&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[a, b, c]</span><br></pre></td></tr></table></figure><h5 id="2-2-2-HashSet"><a href="#2-2-2-HashSet" class="headerlink" title="2.2.2 HashSet"></a>2.2.2 HashSet</h5><p><strong>HashSet存储结构:</strong>哈希表（数组+链表+红黑树）</p><p><strong>存储过程：</strong></p><p>（1）根据hashcode计算保存的位置，如果此位置为空，则直接保存，如果不为空执行第二步。</p><p>（2）再执行equals方法，如果equals方法为true，则认为是重复，否则，形成链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet &lt;Person&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Person person1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;wang&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        Person person2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        set.add(person1);</span><br><span class="line">        set.add(person2);</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[Person@<span class="number">41629346</span>, Person@4eec7777, Person@3b07d329]</span><br></pre></td></tr></table></figure><p><strong>问题：相同name，age的对象于集合中重复添加</strong></p><p><strong>解决方法：重写hashcode、equals方法</strong></p><p><em>注：hashcode、equals方法定义了hashset的重复依据</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写hashCode和equals方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> n1=<span class="built_in">this</span>.name.hashCode();</span><br><span class="line">        <span class="type">int</span> n2=<span class="built_in">this</span>.age;</span><br><span class="line">        <span class="keyword">return</span> n1+n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>==obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Person)</span><br><span class="line">        &#123;</span><br><span class="line">            Person p=(Person) obj;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.name.equals(p.getName())&amp;&amp;<span class="built_in">this</span>.age==p.getAge())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet &lt;Person&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Person person1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;wang&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        Person person2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        set.add(person1);</span><br><span class="line">        set.add(person2);</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">2</span></span><br><span class="line">[Person<span class="meta">@f13</span>, Person@37921a]</span><br></pre></td></tr></table></figure><h5 id="2-2-3-TreeSet"><a href="#2-2-3-TreeSet" class="headerlink" title="2.2.3 TreeSet"></a>2.2.3 TreeSet</h5><p><strong>TreeSet:</strong></p><ul><li>基于排序顺序实现元素不重复</li><li>实现了SortedSet接口，对集合元素自动排序</li><li><strong>元素对象的类型必须实现Comparable接口，指定排序规则</strong></li><li>通过CompareTo方法确定是否为重复元素</li></ul><p><strong>TreeSet存储结构:</strong>红黑树</p><p><strong>TreeSet的使用一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt;&#123;<span class="comment">//TreeSet的元素类型必须实现Comparable接口</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;<span class="comment">//重写Comparable接口的compareTo方法，compareTo方法返回值为0认为是重复元素</span></span><br><span class="line">        <span class="type">int</span> n1=<span class="built_in">this</span>.name.compareTo(o.getName());</span><br><span class="line">        <span class="type">int</span> n2=<span class="built_in">this</span>.age-o.getAge();</span><br><span class="line">        <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        String str=<span class="built_in">this</span>.getName()+<span class="string">&quot;:&quot;</span>+<span class="built_in">this</span>.getAge();</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       TreeSet &lt;Person&gt; persons=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        Person person1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;wang&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        Person person2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        Person person3=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        persons.add(person1);</span><br><span class="line">        persons.add(person2);</span><br><span class="line">        persons.add(person3);</span><br><span class="line">        persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        System.out.println(persons.size());</span><br><span class="line">        System.out.println(persons.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[wang:<span class="number">23</span>, xu:<span class="number">22</span>, xu:<span class="number">24</span>]</span><br></pre></td></tr></table></figure><p><strong>TreeSet的使用二：Comparator实现比较器，无需实现Comparable接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TreeSet &lt;Person&gt; persons=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">               <span class="type">int</span> n1=o1.getName().compareTo(o2.getName());</span><br><span class="line">               <span class="type">int</span> n2=o1.getAge()-o2.getAge();</span><br><span class="line">               <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p><strong>利用TreeSet实现字符串排序：</strong>先按长度排，长度相同比大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;String&gt; treeSet=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">                <span class="type">int</span> n1=o1.length()-o2.length();</span><br><span class="line">                <span class="type">int</span> n2=o1.compareTo(o2);</span><br><span class="line">                <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeSet.add(<span class="string">&quot;peng&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;xu&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;an&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-Map集合体系"><a href="#3-Map集合体系" class="headerlink" title="3.Map集合体系"></a>3.Map集合体系</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201402328.png" alt="3" style="zoom: 80%;"></p><p><strong>Map:</strong>存储一对数据（Key-Value),无序、无下标、键不可重复、值可重复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class demo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;String, String&gt; map=new HashMap&lt;&gt;();</span><br><span class="line">        //1.添加元素</span><br><span class="line">        map.put(&quot;a&quot;,&quot;1&quot;);</span><br><span class="line">        map.put(&quot;b&quot;,&quot;2&quot;);</span><br><span class="line">        map.put(&quot;c&quot;,&quot;3&quot;);</span><br><span class="line">        map.put(&quot;d&quot;,&quot;4&quot;);</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">        //2.删除元素</span><br><span class="line">        map.remove(&quot;b&quot;);</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">        //3.1 使用keySet()遍历</span><br><span class="line">        System.out.println(&quot;使用keySet()遍历&quot;);</span><br><span class="line">//        Set&lt;String&gt; keys=map.keySet();</span><br><span class="line">        for (String key:map.keySet())&#123;</span><br><span class="line">            System.out.println(key+&quot;:&quot;+map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        //3.2 使用entrySet()遍历(效率高于keySet())</span><br><span class="line">        System.out.println(&quot;使用entrySet()遍历&quot;);</span><br><span class="line">//        Set&lt;Map.Entry&lt;String,String&gt; &gt; entrySet=map.entrySet();</span><br><span class="line">        for (Map.Entry&lt;String,String&gt; entry:map.entrySet())&#123;</span><br><span class="line">            System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        //4.判断是否包含</span><br><span class="line">        System.out.println(map.containsKey(&quot;a&quot;));</span><br><span class="line">        System.out.println(map.containsValue(&quot;1&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HashMap的存储结构：哈希表（数组+链表+红黑树）</strong></p><p>注：HashMap使用key的hashcode和equals作为重复的依据</p><p><strong>TreeMap:</strong>实现了SortedMap接口，可以对key自动排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        String str=this.getName()+&quot;:&quot;+this.getAge();</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       TreeMap &lt;Person,String&gt; persons=new TreeMap&lt;&gt;(new Comparator&lt;Person&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public int compare(Person o1, Person o2) &#123;</span><br><span class="line">               int n1=o1.getName().compareTo(o2.getName());</span><br><span class="line">               int n2=o1.getAge()-o2.getAge();</span><br><span class="line">               return n1==0?n2:n1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">        Person person1=new Person(&quot;wang&quot;,23);</span><br><span class="line">        Person person2=new Person(&quot;xu&quot;,22);</span><br><span class="line">        Person person3=new Person(&quot;xu&quot;,24);</span><br><span class="line">        persons.put(person1,&quot;a&quot;);</span><br><span class="line">        persons.put(person2,&quot;b&quot;);</span><br><span class="line">        persons.put(person3,&quot;c&quot;);</span><br><span class="line">        persons.put(new Person(&quot;xu&quot;,22),&quot;d&quot;);</span><br><span class="line">        System.out.println(persons.size());</span><br><span class="line">        System.out.println(persons.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Collections工具类"><a href="#4-Collections工具类" class="headerlink" title="4.Collections工具类"></a>4.Collections工具类</h3><p>Collections工具类：集合工具类，定义了除存取以外的集合常用方法。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201402950.png" alt="4"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;集合框架&quot;&gt;&lt;a href=&quot;#集合框架&quot; class=&quot;headerlink&quot; title=&quot;集合框架&quot;&gt;&lt;/a&gt;集合框架&lt;/h2&gt;&lt;h3 id=&quot;1-泛型&quot;&gt;&lt;a href=&quot;#1-泛型&quot; class=&quot;headerlink&quot; title=&quot;1.泛型&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="java" scheme="https://wangak.cc/categories/java/"/>
    
    
    <category term="java" scheme="https://wangak.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SegFormer</title>
    <link href="https://wangak.cc/posts/9e1703d2.html"/>
    <id>https://wangak.cc/posts/9e1703d2.html</id>
    <published>2023-10-02T07:28:00.000Z</published>
    <updated>2023-10-07T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SegFormer"><a href="#SegFormer" class="headerlink" title="SegFormer"></a>SegFormer</h2><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407750.png" alt="1" style="zoom:75%;"></p><p><strong>编码器:</strong>通过在不同阶段进行下采样，生成多尺度特征。</p><p><strong>Efficient Self-Attention:</strong></p><p><strong>原始的自注意力计算：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407939.png" alt="2" style="zoom: 67%;"></p><p>计算复杂度为O($N^2$),其中N为w*h</p><p><strong>高效的自关注机制:</strong>通过一个压缩比R对K进行处理，改进的计算过程如下.0</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407713.png" alt="3" style="zoom:67%;"></p><p>复杂度从O($N^2$)将至O($N^2 \over R$),降低了计算复杂度</p><p><em>注：论文中的R分别取64, 16, 4, 1</em></p><p>通过将K进行reshape将空间维度N的信息转移到通道维度C上，可以得到$\widehat K$；然后通过线性变换层将通道为降到原始维度C上，得到K’，实现空间下采样。</p><p><strong>Mix-FFN:</strong>为了解决使用位置编码引入位置信息，但由于在测试时的分辨率发生变化时，<strong>会引起精度下降的问题</strong>。</p><p>注：训练时生成的位置编码长度小于预测时的需要时，一种处理方法是使用<strong>插值</strong>将训练时的位置编码扩展到预测时所需的长度。</p><p>位置信息在语义分割中不是必需的</p><p>Mix-FFN：直接使用<strong>3*3卷积</strong>捕获一定程度上的位置信息</p><p>计算过程如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407101.png" alt="4" style="zoom:67%;"></p><p>注：$x_{in}$为自注意力模块的输出</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408906.png" alt="8"></p><p><strong>Overlapped Patch Merging:保持patch周围的局部连续性</strong></p><p>patch尺寸K、步长S、填充尺寸P，在网络中设置参了2套参数：<em>K</em> = 7, <em>S</em> = 4, <em>P</em> = 3 ；<em>K</em> = 3, <em>S</em> = 2, <em>P</em> = 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class OverlapPatchEmbed(nn.Layer):</span><br><span class="line">    def __init__(self,</span><br><span class="line">                 img_size=224,</span><br><span class="line">                 patch_size=7,          # 卷积核大小</span><br><span class="line">                 stride=4,                 # 下采样倍数</span><br><span class="line">                 in_chans=3,            # 输入通道数</span><br><span class="line">                 embed_dim=768):  # 输出通道数</span><br><span class="line">        super().__init__()</span><br><span class="line">        img_size = to_2tuple(img_size)</span><br><span class="line">        patch_size = to_2tuple(patch_size)</span><br><span class="line"></span><br><span class="line">        self.img_size = img_size</span><br><span class="line">        self.patch_size = patch_size</span><br><span class="line">        self.H, self.W = img_size[0] // patch_size[0], img_size[</span><br><span class="line">            1] // patch_size[1]</span><br><span class="line">        self.num_patches = self.H * self.W</span><br><span class="line">        # 定义投影变换所用的卷积</span><br><span class="line">        self.proj = nn.Conv2D(</span><br><span class="line">            in_chans,</span><br><span class="line">            embed_dim,</span><br><span class="line">            kernel_size=patch_size,</span><br><span class="line">            stride=stride,</span><br><span class="line">            padding=(patch_size[0] // 2, patch_size[1] // 2))</span><br><span class="line">        # 定义layer norm层</span><br><span class="line">        self.norm = nn.LayerNorm(embed_dim)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        x = self.proj(x)    # 通过卷积进行特征重投影，实现下采样、通道变换</span><br><span class="line">        x_shape = paddle.shape(x)</span><br><span class="line">        H, W = x_shape[2], x_shape[3]</span><br><span class="line">        x = x.flatten(2).transpose([0, 2, 1])  # 将H*W维度压缩成1个维度</span><br><span class="line">        x = self.norm(x)          # 标准化</span><br><span class="line"></span><br><span class="line">        return x, H, W</span><br></pre></td></tr></table></figure><p><strong>解码器</strong></p><p><strong>Lightweight All-MLP Decoder</strong>：在解码器部分，SegFormer采用了简单的结构，仅由MLP组成</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310212052806.jpg" alt="6" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408838.png" alt="5" style="zoom: 80%;"></p><p><strong>有效感受野分析</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408040.png" alt="7" style="zoom:80%;"></p><p>如图3的放大图所示，MLP头部(蓝框)的ERF与阶段4(红框)不同，除了非局部注意外，局部注意明显更强。</p><p>在上采样阶段，Head的感受野除了具有非局部关注外，还有较强的局部关注。</p><p>作者认为之所以这种简单的Decoder能够很好地工作，关键在于分层的Transformer Encoder比传统的基于CNN的Encoder具有更大的感受野。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408701.png" alt="9" style="zoom:80%;"></p><h3 id="2-实验结果"><a href="#2-实验结果" class="headerlink" title="2.实验结果"></a>2.实验结果</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408211.png" alt="10" style="zoom: 67%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SegFormer&quot;&gt;&lt;a href=&quot;#SegFormer&quot; class=&quot;headerlink&quot; title=&quot;SegFormer&quot;&gt;&lt;/a&gt;SegFormer&lt;/h2&gt;&lt;h3 id=&quot;1-网络结构&quot;&gt;&lt;a href=&quot;#1-网络结构&quot; class=&quot;head</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>MISSFormer</title>
    <link href="https://wangak.cc/posts/d6b0e04e.html"/>
    <id>https://wangak.cc/posts/d6b0e04e.html</id>
    <published>2023-10-02T05:11:58.000Z</published>
    <updated>2023-11-26T02:42:45.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MISSFormer"><a href="#MISSFormer" class="headerlink" title="MISSFormer"></a>MISSFormer</h2><p><strong>论文：《MISSFormer: An Effective Medical Image Segmentation Transformer》（TMI2022）</strong></p><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404731.png" alt="1"></p><p><strong>编码器</strong>由Overlap Patch Embedding、Overlap Patch Merging以及Transformer Block with ReMix-FFN组成。</p><p><strong>EMix-FFN:</strong>在Enhanced Mix块中引入递归跳跃连接，给定输入特征映射xin，应用深度卷积层捕获局部上下文，然后进行递归跳跃连接</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404884.png" alt="2"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404240.png" alt="5" style="zoom: 80%;"></p><p><strong>Enhanced Transformer Context Bridge来捕获不同尺度特征的局部和全局相关性</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404308.png" alt="3" style="zoom: 50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404818.png" alt="4" style="zoom:50%;"></p><p>步骤：</p><p>1.将编码器生成的多尺度的特征的h、w，变成一个序列</p><p>2.将四个输出拼接到一起</p><p>3.对拼接后的结果进行注意力的计算</p><p>4.自注意力输出的结果和输出拼接的结果进行跳跃连接，然后进行层归一化</p><p>5.把归一化的结果再分成四个输出</p><p>6.将这四个输出再进行EMix-FFN</p><p>7.将四个输出的N（h*w)拼接到一起,再与归一化的结果进行跳跃连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class BridgeLayer_4(nn.Module):</span><br><span class="line">    def __init__(self, dims, head, reduction_ratios):</span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">        self.norm1 = nn.LayerNorm(dims)</span><br><span class="line">        self.attn = M_EfficientSelfAtten(dims, head, reduction_ratios)</span><br><span class="line">        self.norm2 = nn.LayerNorm(dims)</span><br><span class="line">        self.mixffn1 = MixFFN_skip(dims,dims*4)</span><br><span class="line">        self.mixffn2 = MixFFN_skip(dims*2,dims*8)</span><br><span class="line">        self.mixffn3 = MixFFN_skip(dims*5,dims*20)</span><br><span class="line">        self.mixffn4 = MixFFN_skip(dims*8,dims*32)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    def forward(self, inputs):</span><br><span class="line">        B = inputs[0].shape[0]</span><br><span class="line">        C = 64</span><br><span class="line">        if (type(inputs) == list):</span><br><span class="line">            # print(&quot;-----1-----&quot;)</span><br><span class="line">            c1, c2, c3, c4 = inputs</span><br><span class="line">            B, C, _, _= c1.shape</span><br><span class="line">            c1f = c1.permute(0, 2, 3, 1).reshape(B, -1, C)  # 3136*64</span><br><span class="line">            c2f = c2.permute(0, 2, 3, 1).reshape(B, -1, C)  # 1568*64</span><br><span class="line">            c3f = c3.permute(0, 2, 3, 1).reshape(B, -1, C)  # 980*64</span><br><span class="line">            c4f = c4.permute(0, 2, 3, 1).reshape(B, -1, C)  # 392*64</span><br><span class="line">            </span><br><span class="line">            # print(c1f.shape, c2f.shape, c3f.shape, c4f.shape)</span><br><span class="line">            inputs = torch.cat([c1f, c2f, c3f, c4f], -2)</span><br><span class="line">        else:</span><br><span class="line">            B,_,C = inputs.shape </span><br><span class="line"></span><br><span class="line">        tx1 = inputs + self.attn(self.norm1(inputs))</span><br><span class="line">        tx = self.norm2(tx1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        tem1 = tx[:,:3136,:].reshape(B, -1, C) </span><br><span class="line">        tem2 = tx[:,3136:4704,:].reshape(B, -1, C*2)</span><br><span class="line">        tem3 = tx[:,4704:5684,:].reshape(B, -1, C*5)</span><br><span class="line">        tem4 = tx[:,5684:6076,:].reshape(B, -1, C*8)</span><br><span class="line"></span><br><span class="line">        m1f = self.mixffn1(tem1, 56, 56).reshape(B, -1, C)</span><br><span class="line">        m2f = self.mixffn2(tem2, 28, 28).reshape(B, -1, C)</span><br><span class="line">        m3f = self.mixffn3(tem3, 14, 14).reshape(B, -1, C)</span><br><span class="line">        m4f = self.mixffn4(tem4, 7, 7).reshape(B, -1, C)</span><br><span class="line"></span><br><span class="line">        t1 = torch.cat([m1f, m2f, m3f, m4f], -2)</span><br><span class="line">        </span><br><span class="line">        tx2 = tx1 + t1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return tx2</span><br></pre></td></tr></table></figure><p><strong>上下文桥循环了四次：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class BridegeBlock_4(nn.Module):   #这是MISSFormer模型图中，上下文桥循环四次的代码</span><br><span class="line">    def __init__(self, dims, head, reduction_ratios):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.bridge_layer1 = BridgeLayer_4(dims, head, reduction_ratios) #定义上下文桥</span><br><span class="line">        self.bridge_layer2 = BridgeLayer_4(dims, head, reduction_ratios) </span><br><span class="line">        self.bridge_layer3 = BridgeLayer_4(dims, head, reduction_ratios) </span><br><span class="line">        self.bridge_layer4 = BridgeLayer_4(dims, head, reduction_ratios) </span><br><span class="line"></span><br><span class="line">    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:</span><br><span class="line">        bridge1 = self.bridge_layer1(x)    #输入数据至第一个上下文桥，得到第一个输出</span><br><span class="line">        bridge2 = self.bridge_layer2(bridge1)#将上一个输出输入至第二个上下文桥</span><br><span class="line">        bridge3 = self.bridge_layer3(bridge2)#将上一个输出输入至第三个上下文桥</span><br><span class="line">        bridge4 = self.bridge_layer4(bridge3)#将上一个输出输入至第四个上下文桥</span><br><span class="line"></span><br><span class="line">        B,_,C = bridge4.shape  #提取B和C大小</span><br><span class="line">        outs = []              #建立空列表，存储输出结果</span><br><span class="line"></span><br><span class="line">        sk1 = bridge4[:,:3136,:].reshape(B, 56, 56, C).permute(0,3,1,2)      #输出转换为二维形式</span><br><span class="line">        sk2 = bridge4[:,3136:4704,:].reshape(B, 28, 28, C*2).permute(0,3,1,2) </span><br><span class="line">        sk3 = bridge4[:,4704:5684,:].reshape(B, 14, 14, C*5).permute(0,3,1,2) </span><br><span class="line">        sk4 = bridge4[:,5684:6076,:].reshape(B, 7, 7, C*8).permute(0,3,1,2) </span><br><span class="line"></span><br><span class="line">        outs.append(sk1)  #将结果存储到列表中</span><br><span class="line">        outs.append(sk2)</span><br><span class="line">        outs.append(sk3)</span><br><span class="line">        outs.append(sk4)</span><br><span class="line"></span><br><span class="line">        return outs</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404365.png" alt="6"></p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404746.png" alt="7"></p>]]></content>
    
    
    <summary type="html">记录了MISSFormer的网络结构及实验结果</summary>
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Java常用类</title>
    <link href="https://wangak.cc/posts/df13c63f.html"/>
    <id>https://wangak.cc/posts/df13c63f.html</id>
    <published>2023-09-30T08:31:34.000Z</published>
    <updated>2023-10-03T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="1-Object类"><a href="#1-Object类" class="headerlink" title="1.Object类"></a>1.Object类</h3><h4 id="1-1-clone方法"><a href="#1-1-clone方法" class="headerlink" title="1.1 clone方法"></a>1.1 clone方法</h4><p><strong>clone方法：</strong>clone方法执行的是浅拷贝</p><p><em>注：<strong>clone方法</strong>创建了一个新对象，但这个新对象和原始对象的引用变量相同（浅拷贝）。</em></p><p><strong>验证clone方法是浅拷贝的：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 声明静态内部类 Body，实现 Cloneable 接口以支持克隆</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Body</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Head head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Body</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Body</span><span class="params">(Head head)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.head = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">            <span class="comment">// 调用父类的 clone 方法以执行浅拷贝</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明静态内部类 Head，这个类不需要克隆功能</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Head</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Head</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个 Body 对象，并将其关联的 Head 对象初始化</span></span><br><span class="line">        <span class="type">Body</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Body</span>(<span class="keyword">new</span> <span class="title class_">Head</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用克隆方法复制 Body 对象，得到一个新的 Body 对象 body1</span></span><br><span class="line">        <span class="type">Body</span> <span class="variable">body1</span> <span class="operator">=</span> (Body) body.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查两个对象是否相同</span></span><br><span class="line">        System.out.println(<span class="string">&quot;body == body1 : &quot;</span> + (body == body1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查两个对象的 head 属性是否相同（因为是浅拷贝，所以 head 属性相同）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;body.head == body1.head : &quot;</span> + (body.head == body1.head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">body == body1 : <span class="literal">false</span></span><br><span class="line">body.head == body1.head : <span class="literal">true</span><span class="comment">//新对象和原对象共享相同的引用对象,故clone方法执行的是浅拷贝</span></span><br></pre></td></tr></table></figure><h4 id="1-2-toString-方法"><a href="#1-2-toString-方法" class="headerlink" title="1.2 toString()方法"></a>1.2 toString()方法</h4><p>Object 类的 toString 方法返回一个字符串，该字符串由类名、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。</p><p><em>注：通常情况下，<strong>应重写 <code>toString()</code> 方法</strong>，以便返回一个更有意义的、描述对象状态的字符串。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;, age=&quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 toString() 方法输出对象的字符串表示形式</span></span><br><span class="line">        System.out.println(person.toString()); <span class="comment">// 输出：Person&#123;name=&#x27;Alice&#x27;, age=30&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Alice&#x27;</span>, age=<span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-getClass-方法"><a href="#1-3-getClass-方法" class="headerlink" title="1.3 getClass()方法"></a>1.3 getClass()方法</h4><p><strong>getClass()方法：</strong>返回对象的运行时类，所有 Java 类都继承了这个方法，不可重写，要调用的话，一般和getName()联合使用，如getClass().getName()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetClassExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        <span class="comment">// 使用 getClass() 方法获取对象的运行时类</span></span><br><span class="line">        Class&lt;?&gt; cls = vehicle.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出类的名称</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName()); <span class="comment">// 输出：Class name: Car</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Class name: Car</span><br></pre></td></tr></table></figure><h4 id="1-4-equals-方法"><a href="#1-4-equals-方法" class="headerlink" title="1.4 equals()方法"></a>1.4 equals()方法</h4><p> Object中的equals方法是直接判断this和obj本身的值是否相等,如果this和obj指向的是同一块内存对象，则返回true,如果</p><p>this和obj指向的不是同一块内存，则返回false。</p><p><em>注：即便是内容完全相等的两块不同的内存对象，也返回false。</em></p><p>String类已经重写了object中的equals方法（比较内容是否相等）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">// 输出：true，内容相同</span></span><br><span class="line">System.out.println(str1.equals(str3)); <span class="comment">// 输出：true，内容相同</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="1-5-wait-方法"><a href="#1-5-wait-方法" class="headerlink" title="1.5 wait()方法"></a>1.5 wait()方法</h4><p>pass</p><h4 id="1-6-notify-方法"><a href="#1-6-notify-方法" class="headerlink" title="1.6  notify()方法"></a>1.6  notify()方法</h4><p>pass</p><h3 id="2-包装类"><a href="#2-包装类" class="headerlink" title="2.包装类"></a>2.包装类</h3><p>基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用,故Java为每种基本数据类型分别设计了对应的类，称之为<strong>包装类</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201401558.png" alt="1" style="zoom: 67%;"></p><h4 id="自动拆箱和装箱"><a href="#自动拆箱和装箱" class="headerlink" title="自动拆箱和装箱"></a>自动拆箱和装箱</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">500</span>;            <span class="comment">// 创建一个基本数据类型变量 m 并赋值为 500</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> m;        <span class="comment">// 自动装箱：将基本数据类型 m 装箱为 Integer 对象 obj</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obj;            <span class="comment">// 自动拆箱：将 Integer 对象 obj 拆箱为基本数据类型 n</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n = &quot;</span> + n);  <span class="comment">// 输出 n 的值</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="number">500</span>;     <span class="comment">// 创建一个 Integer 对象 obj1 并初始化为 500</span></span><br><span class="line">        System.out.println(<span class="string">&quot;obj 等价于 obj1？&quot;</span> + obj.equals(obj1));  <span class="comment">// 比较 obj 和 obj1 是否相等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">n = <span class="number">500</span></span><br><span class="line">obj 等价于 obj1？<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><em>注：所有的包装类（Integer、Long、Byte、Double、Float、Short）都是<strong>抽象类 Number</strong> 的子类。</em></p><h3 id="3-String类"><a href="#3-String类" class="headerlink" title="3.String类"></a>3.String类</h3><h4 id="3-1-创建字符串对象方式"><a href="#3-1-创建字符串对象方式" class="headerlink" title="3.1 创建字符串对象方式"></a>3.1 创建字符串对象方式</h4><p><strong>String类对象一旦声明则不可以改变，而改变的只是地址，原来的字符串还是存在的，并且产生垃圾。</strong></p><p><strong>直接赋值方式：</strong>创建对象是在方法区的<strong>常量池</strong></p><p><code>String str=&quot;hello&quot;;//直接赋值的方式</code></p><p><strong>构造方法：</strong>通过构造方法创建字符串对象是在<strong>堆内存</strong></p><p><code>String str=new String(&quot;hello&quot;);//实例化的方式</code></p><p><strong>两种实例化方式的比较:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Lance&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Lance&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;Lance&quot;</span>;</span><br><span class="line"><span class="comment">//String类对象==比较，比较的是地址，而不是内容</span></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str1==str3);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3==str2);<span class="comment">//true</span></span><br><span class="line">System.out.println(str1==str4);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//str1和str4引用的是字符串常量池中的同一个对象，因此它们的引用相等</span></span><br></pre></td></tr></table></figure><h4 id="3-2-字符串常量池"><a href="#3-2-字符串常量池" class="headerlink" title="3.2 字符串常量池"></a>3.2 字符串常量池</h4><p>​       在字符串中，如果采用直接赋值的方式（String str=”Lance”）进行对象的实例化，则会将匿名对象“Lance”放入对象池，每当下一次对不同的对象进行直接赋值的时候会直接利用池中原有的匿名对象</p><p><strong>两种实例化方式的区别:</strong></p><p><strong>直接赋值（String str = “hello”）：</strong>只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。</p><p><strong>构造方法（String str= new String(“hello”)）:</strong>连续两次new一个String对象，会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过public String intern();方法进行手工入池。</p><p><em>注：在开发的过程中不会采用构造方法进行字符串的实例化</em></p><h4 id="3-3-空指向异常"><a href="#3-3-空指向异常" class="headerlink" title="3.3 空指向异常"></a>3.3 空指向异常</h4><p><strong>equals</strong>比较的是字符串内容，在开发的过程中，equals()通过接受参数，可以避免空指向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(str.equals(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//此时会出现空指向异常 ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;hello&quot;</span>.equals(str))</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//此时equals会处理null值，可以避免空指向异常 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-StringBuilder-和-StringBuffer"><a href="#4-StringBuilder-和-StringBuffer" class="headerlink" title="4.StringBuilder 和 StringBuffer"></a>4.StringBuilder 和 StringBuffer</h3><p>pass</p><h3 id="5-File类"><a href="#5-File类" class="headerlink" title="5.File类"></a>5.File类</h3><p>pass</p>]]></content>
    
    
    <summary type="html">记录了Java常用类的学习笔记</summary>
    
    
    
    <category term="java" scheme="https://wangak.cc/categories/java/"/>
    
    
    <category term="java" scheme="https://wangak.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础语法</title>
    <link href="https://wangak.cc/posts/ea538f2a.html"/>
    <id>https://wangak.cc/posts/ea538f2a.html</id>
    <published>2023-09-27T07:52:05.000Z</published>
    <updated>2023-09-30T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h2><h3 id="1-浮点型拓展"><a href="#1-浮点型拓展" class="headerlink" title="1.浮点型拓展"></a>1.浮点型拓展</h3><h4 id="1-1浮点类型的舍入误差"><a href="#1-1浮点类型的舍入误差" class="headerlink" title="1.1浮点类型的舍入误差"></a>1.1浮点类型的舍入误差</h4><p>浮点类型<strong>float, double</strong>的数据不适合在<strong>不容许舍入误差</strong>的领域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 定义一个float类型变量f并赋值为0.1</span><br><span class="line">        float f = 0.1f;</span><br><span class="line"></span><br><span class="line">        // 定义一个double类型变量d并赋值为1.0除以10，即0.1</span><br><span class="line">        double d = 1.0 / 10;</span><br><span class="line">        System.out.println(f == d); // 输出：false，由于精度差异，比较结果为false</span><br><span class="line">        float d1 = 2131231231f;</span><br><span class="line"></span><br><span class="line">        // 定义一个float类型变量d2，将d1加1后的结果赋值给d2</span><br><span class="line">        float d2 = d1 + 1;</span><br><span class="line">        System.out.println(&quot;d1=&quot;+d1);</span><br><span class="line">        System.out.println(&quot;d2=&quot;+d2);</span><br><span class="line">        // 检查d1是否等于d2</span><br><span class="line">        if (d1 == d2) &#123;</span><br><span class="line">            // 如果d1等于d2，输出&quot;d1==d2&quot;</span><br><span class="line">            System.out.println(&quot;d1==d2&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果d1不等于d2，输出&quot;d1!=d2&quot;</span><br><span class="line">            System.out.println(&quot;d1!=d2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">false</span><br><span class="line">d1=2.13123123E9</span><br><span class="line">d2=2.13123123E9</span><br><span class="line">d1==d2</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p><em>1.浮点数一般都存在舍入误差，很多数字无法精确表示，其结果只能是接近，但不等于。</em></p><p><strong><em>2.避免比较中使用浮点数</em></strong></p><p><em>3.需要进行不产生舍入误差的精确数字计算，需要使用<strong>BigDecimal</strong>类</em></p><h4 id="1-2-BigDecimal类"><a href="#1-2-BigDecimal类" class="headerlink" title="1.2 BigDecimal类"></a><strong>1.2 BigDecimal类</strong></h4><p><strong>BigDecimal类：</strong>用于高精度数值运算的类，它允许你精确地表示和执行各种数学运算，包括加法、减法、乘法、除法等，而不会丢失精度。</p><p><strong>常用方法：</strong></p><p>1.BigDecimal(String val)：构造方法，将String类型转换成BigDecimal类型数据。</p><p>2.BigDecimal(double val)：构造方法，将double类型转换成BigDecimal类型数据。</p><p>3.BigDecimal(int val)：构造方法，将int类型转换成BigDecimal类型数据。</p><p>4.BigDecimal add(BigDecimal value)：加法，求两个BigDecimal类型数据的和。</p><p>5.BigDecimal subtract(BigDecimal value)：减法，求两个BigDecimal类型数据的差。</p><p>6.BigDecimal multiply(BigDecimal  value)：乘法，求两个BigDecimal类型数据的积。</p><p>7.BigDecimal divide(BigDecimal divisor)：除法，求两个BigDecimal类型数据的商。</p><p>8.BigDecimal remainder(BigDecimal divisor)：求余数，求BigDecimal类型数据除以divisor的余数。</p><p>9.BigDecimal max(BigDecimal value)：最大数，求两个BigDecimal类型数据的最大值。</p><p>10.BigDecimal min(BigDecimal value)：最小数，求两个BigDecimal类型数据的最小值。</p><p>11.BigDecimal abs()：绝对值，求BigDecimal类型数据的绝对值。</p><p>12.BigDecimal negate()：相反数，求BigDecimal类型数据的相反数。</p><p>13.BigDecimal compareTo()：比较两个BigDecimal 对象的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.math.BigDecimal;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal num1 = new BigDecimal(&quot;0.1&quot;);//字符串带双引号被解释为确切的数值,若不加会存在一个微小的舍入误差</span><br><span class="line">        BigDecimal num2 = new BigDecimal(&quot;0.2&quot;);</span><br><span class="line">        BigDecimal num3=num1.multiply(new BigDecimal(&quot;2&quot;));</span><br><span class="line">        BigDecimal sum = num1.add(num2);</span><br><span class="line">        System.out.println(num3.compareTo(num2));</span><br><span class="line">        System.out.println(&quot;sum=&quot;+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">0</span><br><span class="line">sum=0.3</span><br></pre></td></tr></table></figure><h3 id="2-Scanner对象"><a href="#2-Scanner对象" class="headerlink" title="2.Scanner对象"></a>2.Scanner对象</h3><h4 id="2-1-创建-Scanner-对象的基本语法："><a href="#2-1-创建-Scanner-对象的基本语法：" class="headerlink" title="2.1 创建 Scanner 对象的基本语法："></a>2.1 创建 Scanner 对象的基本语法：</h4><p><code>Scanner s = new Scanner(System.in)</code></p><p>通过 Scanner 类的 <strong>next()</strong> 或<strong>nextLine()</strong> 方法获取输入的字符串</p><p>读取前一般需要使用 <strong>hasNext()</strong> 或<strong>hasNextLine()</strong> 判断是否还有输入的数据</p><h4 id="2-2-next-amp-nextLine"><a href="#2-2-next-amp-nextLine" class="headerlink" title="2.2 next &amp; nextLine"></a>2.2 next &amp; nextLine</h4><p>使用<strong>next方式</strong>接收一下输入的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext()) &#123;</span><br><span class="line">            String token = scanner.next();</span><br><span class="line">            System.out.println(&quot;Next Token: &quot; + token);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in: </span><br><span class="line">hello world</span><br><span class="line">out:</span><br><span class="line">Next Token: hello</span><br><span class="line">Next Token: world</span><br></pre></td></tr></table></figure><p>使用<strong>nextLine方式</strong>接收一下输入的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNextLine()) &#123;</span><br><span class="line">            String token = scanner.nextLine();</span><br><span class="line">            System.out.println(&quot;Next Token: &quot; + token);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in:</span><br><span class="line">hello world</span><br><span class="line">out：</span><br><span class="line">Next Token: hello world</span><br></pre></td></tr></table></figure><p><strong>两者区别：</strong></p><p>1.next() 不能得到带有空格的字符串，nextLine()可以获得空白。</p><p>2.nextLine()：以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</p><h4 id="2-3-其他数据类型"><a href="#2-3-其他数据类型" class="headerlink" title="2.3 其他数据类型"></a>2.3 其他数据类型</h4><p>如果要输入int、float等类型的数据，在 Scanner 类中也有支持，使用<strong>hasNextXxx() 方法、 nextXxx() 方法</strong>来读取</p><h3 id="3-可变参数"><a href="#3-可变参数" class="headerlink" title="3.可变参数"></a>3.可变参数</h3><p><strong>可变参数的声明:</strong></p><p><code>typeName... parameterName</code></p><p><strong>注：一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Main&#123;</span><br><span class="line">    public static void printMax(double... num)&#123;</span><br><span class="line">        if(num.length==0)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;wrong!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        double result=0;</span><br><span class="line">        for (int i = 1; i &lt; num.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (num[i] &gt; result)</span><br><span class="line">            &#123; result = num[i]; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num[num.length-1]);</span><br><span class="line">    &#125;;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        printMax(1,2.3,5.0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">5.0</span><br></pre></td></tr></table></figure><h3 id="4-Arrays-类"><a href="#4-Arrays-类" class="headerlink" title="4.Arrays 类"></a>4.Arrays 类</h3><p>数组的工具类<strong>java.util.Arrays</strong></p><p><strong>常用功能：</strong></p><h4 id="4-1-打印数组"><a href="#4-1-打印数组" class="headerlink" title="4.1 打印数组"></a>4.1 打印数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        int []num=new int[10];</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            num[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure><h4 id="4-2-数组排序"><a href="#4-2-数组排序" class="headerlink" title="4.2 数组排序"></a>4.2 数组排序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        int []num= &#123;5,8,9,4,2&#125;;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        System.out.println(Arrays.toString(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[2, 4, 5, 8, 9]</span><br></pre></td></tr></table></figure><h4 id="4-3-二分法查找"><a href="#4-3-二分法查找" class="headerlink" title="4.3 二分法查找"></a>4.3 二分法查找</h4><p><strong>在进行此调用之前对数组进行排序(通 过sort方法等)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        int []num= &#123;5,8,9,4,2&#125;;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        System.out.println(&quot;索引为：&quot;+Arrays.binarySearch(num,4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">索引为：1</span><br></pre></td></tr></table></figure><h4 id="4-4-将数组转换成List集合"><a href="#4-4-将数组转换成List集合" class="headerlink" title="4.4 将数组转换成List集合"></a>4.4 将数组转换成List集合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int []num= &#123;5,2,9,4,2,3,10&#125;;</span><br><span class="line">List&lt;int[]&gt; list= Arrays.asList(num);</span><br></pre></td></tr></table></figure><h3 id="5-内部类"><a href="#5-内部类" class="headerlink" title="5.内部类"></a>5.内部类</h3><h4 id="5-1-成员内部类"><a href="#5-1-成员内部类" class="headerlink" title="5.1 成员内部类"></a>5.1 成员内部类</h4><p><strong>实例化内部类，首先需要实例化外部类，通过外部类去调用内部类</strong></p><p><em>注：成员内部类中不能写静态属性和方法</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ppublic class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1.实例化外部类</span><br><span class="line">        Outer out=new Outer();</span><br><span class="line">        //2.通过外部类调用内部类</span><br><span class="line">        Outer.Inner inObject = out.new Inner();</span><br><span class="line">        inObject.In();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Outer&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    public void out()&#123;</span><br><span class="line">        System.out.println(&quot;外部类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Outer()</span><br><span class="line">    &#123;</span><br><span class="line">        id=10;</span><br><span class="line">    &#125;</span><br><span class="line">    class Inner&#123;</span><br><span class="line">        private int id;</span><br><span class="line">        public void In()&#123;</span><br><span class="line">            System.out.println(&quot;内部类&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Inner()&#123;</span><br><span class="line">            id=1;</span><br><span class="line">            System.out.println(&quot;外部：&quot;+Outer.this.id);//Outer.this.显式调用外部类的变量</span><br><span class="line">            System.out.println(&quot;内部：&quot;+id);//内部类中的变量会暂时将外部类的成员变量给隐藏</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out：</span><br><span class="line">外部：10</span><br><span class="line">内部：1</span><br><span class="line">内部类</span><br></pre></td></tr></table></figure><h4 id="5-2-静态内部类"><a href="#5-2-静态内部类" class="headerlink" title="5.2 静态内部类"></a>5.2 静态内部类</h4><p>静态内部类能够直接被外部类给实例化，不需要使用外部类对象</p><p><strong>静态内部类只能访问自己属性和方法及外部类的静态属性和方法</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private static int outerStaticField = 42;</span><br><span class="line"></span><br><span class="line">    // 静态内部类</span><br><span class="line">    public static class StaticInnerClass &#123;</span><br><span class="line">        private int innerField;</span><br><span class="line"></span><br><span class="line">        public StaticInnerClass(int innerField) &#123;</span><br><span class="line">            this.innerField = innerField;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void printValues() &#123;</span><br><span class="line">            System.out.println(&quot;Outer static field: &quot; + outerStaticField);</span><br><span class="line">            System.out.println(&quot;Inner field: &quot; + innerField);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建静态内部类的实例</span><br><span class="line">        StaticInnerClass innerObj = new StaticInnerClass(10);</span><br><span class="line">        // 调用静态内部类的方法</span><br><span class="line">        innerObj.printValues();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-局部内部类"><a href="#5-3-局部内部类" class="headerlink" title="5.3 局部内部类"></a>5.3 局部内部类</h4><p><strong>局部内部类是在一个方法内部声明的一个类</strong></p><p>在局部内部类中，如果要<strong>访问局部变量</strong>，那么该<strong>局部变量</strong>要用<strong>final修饰</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class LocalInnerClassTest &#123;</span><br><span class="line">    // 外部类的成员变量</span><br><span class="line">    private String name;</span><br><span class="line">    private static int age;</span><br><span class="line">    LocalInnerClassTest(String name,int age)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">        this.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 外部类的实例方法</span><br><span class="line">    public void run() &#123;&#125;</span><br><span class="line">    // 外部类的静态方法</span><br><span class="line">    public static void go() &#123;&#125;</span><br><span class="line">    // 外部类的实例方法，包含局部内部类的定义</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        // 定义一个 final 局部变量</span><br><span class="line">        final String myname = &quot;xxx&quot;;</span><br><span class="line">        // 定义局部内部类 LocalInnerClass</span><br><span class="line">        class LocalInnerClass &#123;</span><br><span class="line">            // 局部内部类的成员变量</span><br><span class="line">            private String name;</span><br><span class="line">            // 局部内部类的方法，接受一个参数 name</span><br><span class="line">            public void test(String name) &#123;</span><br><span class="line">                // 在方法中访问参数 name</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                // 在局部内部类的成员方法中，可以使用 this 关键字访问局部内部类的成员变量</span><br><span class="line">                System.out.println(this.name);</span><br><span class="line">                // 在局部内部类中访问外部方法中的 final 变量 myname</span><br><span class="line">                System.out.println(myname);</span><br><span class="line">                // 在局部内部类中访问外部类的成员变量 name</span><br><span class="line">                System.out.println(LocalInnerClassTest.this.name);</span><br><span class="line">                // 在局部内部类中调用外部类的实例方法 run()</span><br><span class="line">                LocalInnerClassTest.this.run();</span><br><span class="line">                // 在局部内部类中调用外部类的静态方法 go()</span><br><span class="line">                LocalInnerClassTest.go();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 创建局部内部类的实例</span><br><span class="line">        LocalInnerClass lic = new LocalInnerClass();</span><br><span class="line">        // 修改局部内部类的成员变量 name</span><br><span class="line">        lic.name = &quot;tom&quot;;</span><br><span class="line">        // 调用局部内部类的方法 test()，传入参数 &quot;test&quot;</span><br><span class="line">        lic.test(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalInnerClassTest inner=new LocalInnerClassTest(&quot;wang&quot;,22);</span><br><span class="line">        inner.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">test</span><br><span class="line">tom</span><br><span class="line">xxx</span><br><span class="line">wang</span><br></pre></td></tr></table></figure><p><em>注：局部内部类不能通过外部类对象直接实例化，而是在方法中实例化出自己来，然后通过内部类对象调用自己类中的方法。</em></p><h4 id="5-4-匿名内部类"><a href="#5-4-匿名内部类" class="headerlink" title="5.4 匿名内部类"></a>5.4 匿名内部类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个接口</span><br><span class="line">interface Greeting &#123;</span><br><span class="line">    void greet();</span><br><span class="line">&#125;</span><br><span class="line">public class AnonymousInnerClassExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 使用匿名内部类创建实现 Greeting 接口并调用greet方法</span><br><span class="line">        new Greeting() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void greet() &#123;</span><br><span class="line">                System.out.println(&quot;Hello, world!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.greet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java基础语法&quot;&gt;&lt;a href=&quot;#Java基础语法&quot; class=&quot;headerlink&quot; title=&quot;Java基础语法&quot;&gt;&lt;/a&gt;Java基础语法&lt;/h2&gt;&lt;h3 id=&quot;1-浮点型拓展&quot;&gt;&lt;a href=&quot;#1-浮点型拓展&quot; class=&quot;header</summary>
      
    
    
    
    <category term="java" scheme="https://wangak.cc/categories/java/"/>
    
    
    <category term="java" scheme="https://wangak.cc/tags/java/"/>
    
  </entry>
  
</feed>
