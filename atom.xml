<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>丹青两幻</title>
  
  <subtitle>欢迎~</subtitle>
  <link href="https://wangak.cc/atom.xml" rel="self"/>
  
  <link href="https://wangak.cc/"/>
  <updated>2025-03-19T16:00:00.000Z</updated>
  <id>https://wangak.cc/</id>
  
  <author>
    <name>丹青两幻</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++八股4</title>
    <link href="https://wangak.cc/posts/4d7fcbd3.html"/>
    <id>https://wangak.cc/posts/4d7fcbd3.html</id>
    <published>2025-03-19T16:00:00.000Z</published>
    <updated>2025-03-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-malloc、realloc、calloc的区别"><a href="#1-malloc、realloc、calloc的区别" class="headerlink" title="1.malloc、realloc、calloc的区别"></a>1.malloc、realloc、calloc的区别</h4><ul><li><p><strong><code>malloc</code>函数：</strong></p><ul><li><p>用于分配指定大小的内存块，并返回指向该内存块的指针。如果分配失败，则返回 <code>NULL</code>。</p></li><li><p>使用 <code>malloc</code> 分配的内存不会被初始化，其中的数据是随机的。</p></li></ul></li><li><p><strong><code>calloc</code> 函数</strong>：</p><ul><li>原型为 <code>void* calloc(size_t n, size_t size);</code></li><li>第一个参数 <code>n</code> 表示要分配多少个元素；第二个参数 <code>size</code> 表示每个元素的大小（以字节为单位）。</li><li><code>calloc</code> 会将分配的内存初始化为零。</li></ul></li><li><p><strong><code>realloc</code> 函数</strong>：</p><ul><li><p>原型为 <code>void* realloc(void *p, size_t new_size);</code></p></li><li><p><code>realloc</code> 函数用来改变已经分配的内存块的大小。它可以扩大或缩小已有的内存块。如果新的内存大小大于原来的大小，那么新增的部分内容未定义（即可能包含任何值）。如果缩小内存块，超出部分会被丢弃。</p><p><em>注：C++中可以通过使用STL容器来避免使用<code>realloc</code>的情况,可以减少由于手动管理内存而引发错误的可能。</em></p></li></ul></li></ul><h4 id="2-类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？"><a href="#2-类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？" class="headerlink" title="2.类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"></a>2.类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</h4><p><strong>类成员初始化方式：</strong></p><ul><li><strong>赋值初始化</strong>：这是通过在<strong>构造函数体内</strong>对成员变量进行赋值来实现的。</li><li><strong>成员初始化列表</strong>：使用冒号(<code>:</code>)后跟随初始化列表的方式，在构造函数体执行前对成员变量进行初始化。</li></ul><p><strong>构造函数的执行顺序：</strong>（在创建派生类对象时，<strong>基类的构造函数会在派生类的构造函数之前执行</strong>。）</p><ol><li><strong>首先执行虚拟基类的构造函数</strong>（如果有多个虚拟基类，则按照它们被继承的顺序）。</li><li><strong>然后是普通基类的构造函数</strong>（如果有多个普通基类，则按照它们在派生类继承列表中的顺序）。</li><li><strong>接着是派生类中对象成员（包含其他类类型的对象作为其成员变量）的构造函数</strong>（这些成员对象按照它们在类定义中的声明顺序进行初始化，而不是按照初始化列表中的顺序）。</li><li><strong>最后是派生类自己的构造函数</strong>。</li></ol><p><strong>使用成员初始化列表更快的原因：</strong></p><ul><li><strong>C++的赋值操作是会产生临时对象的</strong>：使用赋值初始化时，首先会调用默认构造函数为成员变量分配空间并创建一个临时对象，然后将这个临时对象赋值给成员变量，这会产生额外的开销。</li><li>使用成员初始化列表直接在<strong>成员变量创建时就对其进行初始化</strong>，避免了创建临时对象的过程。</li></ul><h4 id="3-有哪些情况必须用到成员列表初始化？作用是什么？"><a href="#3-有哪些情况必须用到成员列表初始化？作用是什么？" class="headerlink" title="3.有哪些情况必须用到成员列表初始化？作用是什么？"></a>3.有哪些情况必须用到成员列表初始化？作用是什么？</h4><p><strong>成员列表初始化的四种必须使用的情况：</strong></p><ul><li><p><strong>初始化引用成员</strong>：引用成员必须在创建时初始化，且不能重新赋值。因此，必须在成员初始化列表中进行初始化。</p></li><li><p><strong>初始化常量成员</strong>：常量成员（<code>const</code>）一旦初始化后不能修改，因此必须在成员初始化列表中初始化。</p></li><li><p><strong>调用基类的构造函数</strong>：如果<strong>基类没有默认构造函数</strong>，或者需要传递参数给基类构造函数，必须在成员初始化列表中调用基类的构造函数。</p></li><li><p><strong>调用成员类的构造函数</strong>：如果类的成员是另一个类的对象，并且该<strong>成员类没有默认构造函数</strong>，或者需要传递参数，必须在成员初始化列表中调用该成员类的构造函数。</p><p><em>注：在函数体内进行赋值初始化时，成员就已经存在了</em></p></li></ul><p><strong>成员初始化列表的作用：</strong></p><ul><li><strong>初始化顺序</strong>：编译器会按照成员初始化列表中的顺序，在构造函数体内插入初始化操作，且这些操作在任何用户代码之前执行。</li><li><strong>初始化顺序的决定</strong>：初始化列表的顺序并不决定实际的初始化顺序，实际的初始化顺序由类中成员的<strong>声明顺序决定。</strong></li></ul><h4 id="4-C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的？"><a href="#4-C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的？" class="headerlink" title="4.C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？"></a>4.C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？</h4><ul><li><strong>string是对char*进行了封装</strong>，封装的string包含了char*数组，容量，长度等等属性。</li><li><strong>string可以进行动态扩展</strong>，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</li></ul><h4 id="5-什么是内存泄露，如何检测与避免"><a href="#5-什么是内存泄露，如何检测与避免" class="headerlink" title="5.什么是内存泄露，如何检测与避免"></a>5.什么是内存泄露，如何检测与避免</h4><p><strong>内存泄露：</strong>指的是堆内存的泄露，分配的内存块在使用完成后没有正确地释放。</p><p><strong>避免内存的泄露的方式：</strong></p><ul><li><p><strong>计数法：</strong>使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</p></li><li><p><strong>将基类的析构函数声明为虚函数：</strong>这可以保证当通过基类指针删除派生类对象时，派生类的析构函数能够被正确调用，从而避免因未正确调用析构函数导致的内存泄漏。</p><p><em>注：如果基类的析构函数不是<code>virtual</code>，通过基类指针删除派生类对象只会调用基类的析构函数。</em></p></li><li><p><strong>正确释放对象数组</strong>：对于使用 <code>new[]</code> 分配的对象数组，应使用 <code>delete[]</code> 来释放，而不是 <code>delete</code>，以避免内存泄漏。</p></li><li><strong>成对出现原则</strong>：确保每一对 <code>new</code>/<code>delete</code> 和 <code>malloc</code>/<code>free</code> 成对出现，即每次分配内存后都必须有相应的释放操作</li></ul><p><strong>检测工具</strong></p><ul><li>Linux下可以使用<strong>Valgrind工具</strong></li><li>Windows下可以使用<strong>CRT库</strong></li></ul><h4 id="6-对象复用的了解，零拷贝的了解"><a href="#6-对象复用的了解，零拷贝的了解" class="headerlink" title="6.对象复用的了解，零拷贝的了解"></a>6.对象复用的了解，零拷贝的了解</h4><p><strong>对象复用</strong>：在设计模式中通常指的是<strong>Flyweight（享元）模式</strong>。该模式旨在通过共享尽可能多的数据来最小化内存使用，特别是当系统需要创建大量细粒度的对象时。通过<strong>将相似或相同的对象存储在一个“对象池”中，并在需要时重复利用这些对象</strong>，可以有效<strong>减少内存占用和对象创建的开销。</strong></p><p><strong>零拷贝</strong>：一种优化技术，目的是<strong>减少数据从一处存储到另一处传输过程中CPU的参与程度</strong>，从而提高效率并降低资源消耗。传统上，数据传输可能涉及多次复制操作，比如从磁盘读取数据到内核空间，再复制到用户空间等。零拷贝技术减少了这种不必要的数据复制次数，降低了CPU的工作量和总线活动。</p><p><strong>*注：<code>vector</code>的一个成员函数emplace_back()很好地体现了零拷贝技术。</strong><code>emplace_back()</code> 是在容器内部直接构造对象，而不是先创建一个临时对象再进行拷贝或移动。这意味着它可以在不调用拷贝构造函数或移动构造函数的情况下，在容器预留的位置原地构造对象，这通常更高效。*</p><h4 id="7-介绍面向对象的三大特性，并且举例说明"><a href="#7-介绍面向对象的三大特性，并且举例说明" class="headerlink" title="7.介绍面向对象的三大特性，并且举例说明"></a>7.介绍面向对象的三大特性，并且举例说明</h4><ul><li><strong>继承：</strong> 让某种类型对象获得另一个类型对象的属性和方法。<ul><li>实现继承：指使用基类的属性和方法而无需额外编码的能力</li><li>接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力</li></ul></li><li><strong>封装：</strong> <strong>把客观事物封装成抽象的类</strong>，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏</li><li><strong>多态：</strong> 同一事物表现出不同事物的能力<ul><li><strong>实现多态有二种方式：覆盖（override），重载（overload）</strong></li><li>重载实现编译时多态，虚函数实现运行时多态</li></ul></li></ul><h4 id="8-C-的四种强制转换"><a href="#8-C-的四种强制转换" class="headerlink" title="8.C++的四种强制转换"></a>8.C++的四种强制转换</h4><p>C++提供了四种类型的显式类型转换运算符：<code>reinterpret_cast</code>、<code>const_cast</code>、<code>static_cast</code> 和 <code>dynamic_cast</code></p><ul><li><p><strong><code>reinterpret_cast</code></strong>：在不相关的类型之间进行低级别的强制转换。它可以将任何指针类型转换为另一个指针类型，或指针到整数类型的转换等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *c = reinterpret_cast&lt;char*&gt;(p); // 将int指针转换为char指针</span><br></pre></td></tr></table></figure></li><li><p><strong><code>const_cast</code></strong>：主要用于添加或移除变量的<code>const</code>或<code>volatile</code>属性。它只能改变这些限定符，不能改变对象的实际类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char *p = &quot;hello&quot;;</span><br><span class="line">char *q = const_cast&lt;char*&gt;(p);</span><br></pre></td></tr></table></figure><p><em>注：这里将 `const char</em><code>类型的指针</code>p<code>转换为</code>char<em><code>类型的指针</code>q`。</em></p></li><li><p><strong><code>static_cast</code></strong>：用于类层次结构中的上行转换（派生类到基类）和下行转换（基类到派生类），以及基本数据类型之间的转换。</p><ul><li><p><strong>特点</strong>：不进行运行时类型检查，因此在下行转换时可能不安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">65</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(n);<span class="comment">//这里将 int 类型的变量 n 转换为 char 类型的变量 c。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>dynamic_cast</code>:</strong> 主要用于类层次结构中的上行转换和下行转换，特别是用于多态类型的转换。</p><ul><li><p><strong>特点：</strong>在运行时进行类型检查，如果转换不安全（如下行转换时基类指针不指向派生类对象），则返回 <code>nullptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Base *b = <span class="keyword">new</span> Son;</span><br><span class="line">Son *s = <span class="built_in">dynamic_cast</span>&lt;Son*&gt;(b);<span class="comment">//这里将 Base* 类型的指针 b 转换为 Son* 类型的指针 s，并在转换失败时返回 nullptr。</span></span><br><span class="line"><span class="keyword">if</span> (s) &#123;</span><br><span class="line">    <span class="comment">// 转换成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 转换失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="9-C-函数调用的压栈过程"><a href="#9-C-函数调用的压栈过程" class="headerlink" title="9.C++函数调用的压栈过程"></a>9.C++函数调用的压栈过程</h4><p><strong>函数调用的压栈过程:</strong></p><ul><li><strong>分配栈空间</strong>：为被调用函数分配栈空间，用于存储函数的局部变量、参数和返回地址等信息。</li><li><strong>参数压栈</strong>：将实参的值复制到形参的栈空间中。C++中，参数是从右到左依次压栈的。</li><li><strong>保存返回地址</strong>：将当前函数的返回地址（即调用函数的下一条指令地址）压入栈中，以便函数执行完毕后能正确返回到调用点。</li><li><strong>保存调用函数的运行状态</strong>：将调用函数的寄存器状态、局部变量等信息压入栈中，以便函数调用结束后恢复。</li><li><strong>执行被调用函数</strong>：跳转到被调用函数的代码并执行。</li><li><strong>函数返回</strong>：函数执行完毕后，从栈中弹出返回地址、恢复调用函数的运行状态，并释放栈空间。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> param1, <span class="type">int</span> param2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var1 = param1;</span><br><span class="line">    <span class="type">int</span> var2 = param2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;var1=%d,var2=%d&quot;</span>, <span class="built_in">f</span>(var1), <span class="built_in">f</span>(var2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">var1=1,var2=2</span><br></pre></td></tr></table></figure><h4 id="10-说说移动构造函数"><a href="#10-说说移动构造函数" class="headerlink" title="10.说说移动构造函数"></a>10.说说移动构造函数</h4><p><strong>既要实现资源的有效转移，又要避免潜在的双重释放的风险</strong></p><p><strong>移动构造函数：</strong>用“转移”代替“复制”来提高性能</p><p><strong>拷贝构造 vs 移动构造</strong></p><ul><li><strong>拷贝构造函数</strong>：通常涉及到深拷贝，特别是对于包含动态分配资源的对象。例如，如果一个类含有指针成员变量，那么在拷贝构造时需要为新对象分配新的内存，并将原始对象的数据复制过去。这增加了额外的时间和空间开销。</li><li><strong>移动构造函数</strong>：则是采用<strong>浅层复制</strong>的方式，直接<strong>将资源的所有权从一个对象转移到另一个对象</strong>，而不进行实际的数据复制。这样做的前提是确保源对象不再持有这些资源，以防止重复释放同一块内存导致的错误。</li><li><strong>参数类型差异</strong><ul><li><strong>拷贝构造函数</strong>：接受一个<strong>左值引用</strong>作为参数，意味着它可以接受任何有效的已有对象。</li><li><strong>移动构造函数</strong>：接受一个<strong>右值引用</strong>（或称为将亡值引用）作为参数。这意味着它只能用于那些即将销毁或不再使用的对象，比如临时对象或者通过<code>std::move</code>显式转换成右值的对象。</li></ul></li></ul><p><strong>如何实现安全的资源转移？</strong></p><p>​    为了避免因浅层复制导致的双重释放问题，移动构造函数会在获取源对象资源的同时，将源对象中的相应指针置为<code>nullptr</code>（或其他适当值）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 确保other不会在析构时释放data指向的内存</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass</code> 的移动构造函数接收一个右值引用 <code>MyClass&amp;&amp;</code>，并将<code>other</code>对象的数据成员<code>data</code>直接赋值给当前对象的<code>data</code>成员，然后将<code>other.data</code>设置为<code>nullptr</code>。这样做既实现了资源的有效转移，又避免了潜在的双重释放风险。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass a;</span><br><span class="line">MyClass b = std::<span class="built_in">move</span>(a); <span class="comment">// 调用移动构造函数</span></span><br></pre></td></tr></table></figure><p>注：<code>std::move(a)</code>使得<code>a</code>被视为一个右值，从而触发<code>MyClass</code>的移动构造函数。</p><h4 id="11-说一下C-左值引用和右值引用"><a href="#11-说一下C-左值引用和右值引用" class="headerlink" title="11.说一下C++左值引用和右值引用"></a>11.说一下C++左值引用和右值引用</h4><p><strong>左值（lvalue）:</strong></p><ul><li><p>可以获取地址的表达式。</p></li><li><p>通常有名字，可以出现在赋值语句的左边。</p></li><li><p>例如：变量、对象、函数返回的引用等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// a 是左值</span></span><br><span class="line"><span class="type">int</span>&amp; b = a;  <span class="comment">// b 是左值引用</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>右值（rvalue）</strong>：</p><ul><li><p>不能获取地址的表达式。</p></li><li><p>通常是临时的、没有名字的值。</p></li><li><p>例如：常量、临时对象、函数返回值（非引用）、表达式结果等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c = <span class="number">5</span> + <span class="number">10</span>;  <span class="comment">// 5 + 10 是右值</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; d = <span class="number">10</span>;    <span class="comment">// 10 是右值</span></span><br></pre></td></tr></table></figure><ul><li><strong>纯右值（prvalue）</strong>：如字面量、临时对象、表达式结果等。</li><li><strong>将亡值（xvalue）</strong>：与右值引用相关的表达式，通常是通过 <code>std::move</code> 或返回右值引用的函数得到的值。</li></ul></li></ul><p><strong>左值引用</strong>：用 <code>&amp;</code> 声明。</p><p><strong>右值引用</strong>：用 <code>&amp;&amp;</code> 声明。主要用于实现 <strong>移动语义</strong> 和 <strong>完美转发</strong>。</p><p><strong>右值引用的特点:</strong></p><ul><li><p><strong>延长右值的生命周期</strong>：右值引用可以将临时对象（右值）的生命周期延长到与右值引用变量的生命周期一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; d = <span class="number">10</span>;  <span class="comment">// 临时对象 10 的生命周期被延长</span></span><br></pre></td></tr></table></figure></li><li><p><strong>右值引用可能是左值或右值</strong>：右值引用类型的变量本身可能是左值或右值，取决于其初始化方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; e = <span class="number">10</span>;  <span class="comment">// e 是右值引用，但 e 本身是左值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>自动类型推断中的右值引用</strong>：在模板函数中，<code>T&amp;&amp;</code> 可以是左值引用或右值引用，取决于传入的参数类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">fun</span>(a);  <span class="comment">// t 是左值引用</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="number">10</span>); <span class="comment">// t 是右值引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>移动语义</strong>：通过 <code>std::move</code> 将左值强制转换为右值引用，从而避免不必要的拷贝操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2 = std::<span class="built_in">move</span>(v1);  <span class="comment">// v1 的资源被移动到 v2</span></span><br></pre></td></tr></table></figure><p><strong>完美转发</strong>：通过右值引用和 <code>std::forward</code>，将参数按照其原始类型转发给其他函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 完美转发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-C-中将临时变量作为返回值时的处理过程"><a href="#12-C-中将临时变量作为返回值时的处理过程" class="headerlink" title="12.C++中将临时变量作为返回值时的处理过程"></a>12.C++中将临时变量作为返回值时的处理过程</h4><p>在C++中，当函数返回临时变量时，虽然该临时变量会在函数退出时被销毁，但由于<strong>返回值是通过寄存器而非栈或堆内存进行传递的</strong>，因此返回值的正确性和完整性得到了保证。</p><h4 id="13-静态类型和动态类型，静态绑定和动态绑定的介绍"><a href="#13-静态类型和动态类型，静态绑定和动态绑定的介绍" class="headerlink" title="13.静态类型和动态类型，静态绑定和动态绑定的介绍"></a>13.静态类型和动态类型，静态绑定和动态绑定的介绍</h4><p><strong>静态类型与动态类型</strong></p><ul><li><p><strong>静态类型：</strong>对象在声明时采⽤的类型，在编译期既已确定；例如，<code>A* pa</code>的静态类型是<code>A*</code>，无论<code>pa</code>指向的是哪个子类对象。</p></li><li><p><strong>动态类型：</strong>指针或引用实际指向的对象的类型，是在运行期决定的。例如，<code>A* pa = new B();</code>，<code>pa</code>的静态类型是<code>A*</code>，但动态类型是<code>B*</code>。</p></li></ul><p><strong>静态绑定与动态绑定</strong></p><ul><li><strong>静态绑定</strong>：绑定的是静态类型，函数或属性的调用依赖于对象的静态类型，发生在编译期。<strong>非虚函数通常使用静态绑定。</strong></li><li><strong>动态绑定</strong>：绑定的是动态类型，函数或属性的调用依赖于对象的动态类型，发生在运行期。<strong>虚函数使用动态绑定，从而实现多态性。</strong></li></ul><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*virtual*/</span> <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C* pc = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line">    B* pb = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    A* pa = pc;</span><br><span class="line">    pa = pb;</span><br><span class="line"></span><br><span class="line">    pa-&gt;<span class="built_in">func</span>(); <span class="comment">// 如果func不是虚函数，则总是调用A::func()</span></span><br><span class="line">    pc-&gt;<span class="built_in">func</span>(); <span class="comment">// 总是调用C::func()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pc;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注1：如果 <code>A</code> 中的 <code>func</code> 不是虚函数，那么 <code>pa-&gt;func()</code> 将总是调用 <code>A::func()</code>，因为这是基于 <code>pa</code> 的静态类型（即 `A</em>`）进行的静态绑定。*</p><p><em>注2：如果将 <code>func</code> 声明为虚函数（取消注释 <code>virtual</code>），那么 <code>pa-&gt;func()</code> 将根据 <code>pa</code> 所指向的实际对象类型（即动态类型）调用相应的 <code>func</code> 函数，实现动态绑定。</em></p><h4 id="14-引用是否能实现动态绑定，为什么可以实现？"><a href="#14-引用是否能实现动态绑定，为什么可以实现？" class="headerlink" title="14.引用是否能实现动态绑定，为什么可以实现？"></a>14.引用是否能实现动态绑定，为什么可以实现？</h4><p><strong>引用</strong>和<strong>指针</strong>都可以实现动态绑定，但这种动态绑定仅适用于<strong>虚函数</strong>。</p><p><strong>动态绑定的条件</strong></p><ul><li><strong>虚函数</strong>：只有当一个函数被声明为<code>virtual</code>时，才能通过基类的引用或指针调用派生类中的重写版本。这是因为<strong>虚函数支持运行期确定实际调用哪个函数</strong>，这被称为动态绑定或多态性。</li><li><strong>引用必须初始化</strong>：创建引用时必须同时初始化它，这意味着你必须指定引用所绑定的具体对象。一旦初始化完成，引用就不能再指向其他对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base :: fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;son :: fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;son :: not virtual function&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    Base&amp; b = s; <span class="comment">// 基类类型引用绑定到Son对象</span></span><br><span class="line">    s.<span class="built_in">fun</span>();     <span class="comment">// 输出: son::fun()</span></span><br><span class="line">    b.<span class="built_in">fun</span>();     <span class="comment">// 输出: son::fun()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-malloc、realloc、calloc的区别&quot;&gt;&lt;a href=&quot;#1-malloc、realloc、calloc的区别&quot; class=&quot;headerlink&quot; title=&quot;1.malloc、realloc、calloc的区别&quot;&gt;&lt;/a&gt;1.malloc</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++八股3</title>
    <link href="https://wangak.cc/posts/d31b5e70.html"/>
    <id>https://wangak.cc/posts/d31b5e70.html</id>
    <published>2025-03-17T16:00:00.000Z</published>
    <updated>2025-03-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么是大小端存储？"><a href="#1-什么是大小端存储？" class="headerlink" title="1.什么是大小端存储？"></a>1.什么是大小端存储？</h4><p><strong>大端存储：</strong>数据的最高有效字节存放在内存地址的最低位置</p><p><strong>小端存储：</strong>最低有效字节被存放在内存地址的最低位置</p><p><em>注：在网络协议中通常使用大端序</em></p><h4 id="2-volatile、mutable和explicit关键字的用法"><a href="#2-volatile、mutable和explicit关键字的用法" class="headerlink" title="2.volatile、mutable和explicit关键字的用法"></a>2.volatile、mutable和explicit关键字的用法</h4><ul><li><strong>volatile：</strong></li></ul><p><strong><code>volatile</code></strong>关键字用于告诉编译器，该变量的值可能会在程序控制之外被改变（如硬件中断、操作系统、其他线程等）。因此，<strong>编译器不应该对涉及该变量的操作进行优化。</strong></p><p><strong>每次访问<code>volatile</code>变量时，都会从内存重新读取数据，而不是使用寄存器中的缓存副本。（这样可以防止变量被其他线程修改后读到错误的变量值）</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503191910704.png" alt="image-20250318133449499" style="zoom: 50%;"></p><p><em>注：现代编译器为了提高性能，通常会将经常访问的变量值保存在CPU寄存器中，以便快速访问。</em></p><ul><li><strong>mutable：</strong> <code>mutable</code>关键字用于<strong>允许对象的某些成员变量即使在<code>const</code>成员函数内也可以被修改。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> accessCount; <span class="comment">// 可变成员变量，用于记录访问次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a) : <span class="built_in">age</span>(a), <span class="built_in">accessCount</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 成员函数，理论上不应该修改类的数据成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 在 const 函数中修改非 mutable 成员会导致编译错误</span></span><br><span class="line">        <span class="comment">// age = 30; // 错误：不能修改</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改 mutable 成员是允许的</span></span><br><span class="line">        ++accessCount;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This method has been called &quot;</span> &lt;&lt; accessCount &lt;&lt; <span class="string">&quot; times.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> Person <span class="title">person</span><span class="params">(<span class="number">25</span>)</span></span>; <span class="comment">// 创建一个常量对象</span></span><br><span class="line">    person.<span class="built_in">getAge</span>(); <span class="comment">// 第一次调用</span></span><br><span class="line">    person.<span class="built_in">getAge</span>(); <span class="comment">// 第二次调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>explicit: </strong> <code>explicit</code>关键字用于<strong>防止单参数构造函数的隐式类型转换</strong>。只能应用于类内部的<strong>构造函数声明</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Integer</span><span class="params">(<span class="type">int</span> x)</span> : value(x) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 假设我们需要提供获取值的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printInteger</span><span class="params">(<span class="type">const</span> Integer&amp; i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印 Integer 对象的内容</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The integer value is: &quot;</span> &lt;&lt; i.<span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面这一行会导致编译错误，因为不允许隐式转换</span></span><br><span class="line">    <span class="comment">// printInteger(10);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确的做法是显式地构造 Integer 对象</span></span><br><span class="line">    <span class="built_in">printInteger</span>(<span class="built_in">Integer</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-什么情况下会调用拷贝构造函数"><a href="#3-什么情况下会调用拷贝构造函数" class="headerlink" title="3.什么情况下会调用拷贝构造函数"></a>3.什么情况下会调用拷贝构造函数</h4><ul><li><p><strong>对象初始化：</strong> 用类的一个<strong>实例化对象去初始化另一个对象</strong>的时候</p></li><li><p><strong>按值传递参数</strong>： 当一个函数的参数是类的对象且通过值传递（非引用传递），在函数调用时<strong>会创建一个参数的副本</strong>，此时会调用拷贝构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useClassA</span><span class="params">(A a)</span> </span>&#123;&#125;  <span class="comment">// 函数定义</span></span><br><span class="line"><span class="built_in">useClassA</span>(a1);          <span class="comment">// 调用时会调用拷贝构造函数</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-C-中有几种类型的new"><a href="#4-C-中有几种类型的new" class="headerlink" title="4.C++中有几种类型的new"></a>4.C++中有几种类型的new</h4><ul><li><strong>Plain New</strong></li></ul><p>​    <code>Plain new</code>指的是标准的、普通的<code>new</code>操作符，用于动态分配内存。它不仅负责分配所需的内存空间，还会调用对象的构造函数（如果是对象的话）。</p><p>​    <strong>异常处理</strong>: 在C++中，当使用<code>plain new</code>进行内存分配且分配失败时（例如，系统无法提供请求的内存大小），它会抛出一个<code>std::bad_alloc</code>异常，而不是返回<code>NULL</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试分配一个极大的内存空间，可能会失败</span></span><br><span class="line">        <span class="type">char</span> *p = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10e11</span>];  <span class="comment">// 这里尝试分配大约100GB的空间，很可能导致std::bad_alloc异常被抛出</span></span><br><span class="line">        <span class="keyword">delete</span>[] p;  <span class="comment">// 如果分配成功，则释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc &amp;ex) &#123;  <span class="comment">// 捕捉std::bad_alloc异常</span></span><br><span class="line">        cout &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">// 输出异常信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>nothrow new</strong></p><p><code>nothrow new</code>在空间分配失败的情况下是不抛出异常，而是返回NULL</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="number">10e11</span>];</span><br><span class="line"> <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;alloc failed&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">delete</span> p;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//运⾏结果：alloc failed</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Placement New</strong></p></li></ul><p>​    <code>placement new</code>允许在⼀块已经分配成功的内存上新构造对象或对象数组。<code>placement new</code>不用担心内存分配失败，因为它根本不分配内存，它做的唯⼀⼀件事情就是调⽤对象的构造函数。</p><p>​    <strong>用途</strong>: 主要用于<strong>优化性能和控制内存管理</strong>，例如<strong>在一个循环中反复创建和销毁对象时，可以避免频繁的内存分配和释放操作</strong>，从而提高效率。</p><p>​    <em>注1：<strong>显式调用析构函数</strong>：由于 <code>placement new</code> 只负责调用对象的构造函数，并不负责释放内存，因此当你不再需要对象时，必须手动调用对象的析构函数来清理资源。</em></p><p>​    <em>注2：<strong>不要使用 <code>delete</code></strong>：不能对通过 <code>placement new</code> 创建的对象直接使用 <code>delete</code>，因为这可能导致内存泄漏或其他运行时错误。应该首先显式调用对象的析构函数，然后根据情况决定是否释放底层内存。（因为 <code>delete</code> 预期的是由 <code>new</code> 返回的一个指针，它只知道如何释放这块特定类型的内存。）</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ADT</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ADT</span>() : <span class="built_in">i</span>(<span class="number">10</span>), <span class="built_in">j</span>(<span class="number">100</span>) &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ADT construct i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j=&quot;</span> &lt;&lt; j &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ADT</span>() &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ADT destruct&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="built_in">sizeof</span>(ADT)]; <span class="comment">// 动态分配足够大的内存来容纳一个ADT对象</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123; <span class="comment">// 注意：这里应该是检查 p 是否为 nullptr 而不是 NULL</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;alloc failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ADT *q = <span class="built_in">new</span>(p) ADT; <span class="comment">// 使用 placement new 在 p 所指向的内存上构造 ADT 对象</span></span><br><span class="line">    <span class="comment">// 不可以直接 delete q;</span></span><br><span class="line">    q-&gt;~<span class="built_in">ADT</span>(); <span class="comment">// 显式调用 ADT 的析构函数</span></span><br><span class="line">    <span class="keyword">delete</span>[] p; <span class="comment">// 最后释放最初分配的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-C-的异常处理的方法"><a href="#5-C-的异常处理的方法" class="headerlink" title="5.C++的异常处理的方法"></a>5.C++的异常处理的方法</h4><ul><li><p><strong>try、throw和catch关键字</strong></p><ul><li><p><strong>try</strong>:  <code>try</code>块用于包裹可能抛出异常的代码段。当<code>try</code>块中的任何代码抛出了一个异常，程序会立即寻找与之匹配的<code>catch</code>块进行处理。</p></li><li><p><strong>throw</strong>: 当程序检测到一个无法处理的错误时，可以使用<code>throw</code>语句抛出一个异常。这个异常可以是任意类型的数据（例如整数、浮点数、字符串或者自定义类对象），它包含了关于错误的信息。</p></li><li><p><strong>catch</strong>: <code>catch</code>块用于捕获由<code>throw</code>语句抛出的异常。每个<code>catch</code>后面都跟着一个参数列表，指定了它可以处理的异常类型。一旦某个异常被抛出，程序会查找最近的匹配<code>catch</code>块，并将控制权转移到该块。如果找不到匹配的<code>catch</code>块，程序将终止运行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> m = <span class="number">1</span>, n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">-1</span>; <span class="comment">// 抛出int型异常</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">-1.0</span>; <span class="comment">// 抛出 double 型异常</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; m / n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">double</span> d) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;catch (double)&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通用的catch(...)块</span></span><br><span class="line"><span class="built_in">catch</span> (...) &#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;catch (...)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;finished&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>函数的异常声明列表:</strong> 在定义函数的时候知道函数可能发⽣的异常，可以在函数声明和定义时，指出所能抛出异常的列表.</p><p><code>int fun() throw(int,double,A,B,C)&#123;...&#125;;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义三个可能被抛出的异常类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionA</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionB</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionC</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数fun声明和定义时指定了它可能抛出的异常类型：int, double, ExceptionA, ExceptionB, ExceptionC</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>, ExceptionA, ExceptionB, ExceptionC)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> condition = <span class="number">3</span>; <span class="comment">// 假设根据某种条件决定抛出何种异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (condition == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">1</span>; <span class="comment">// 抛出int型异常</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">2.0</span>; <span class="comment">// 抛出double型异常</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ExceptionA</span>(); <span class="comment">// 抛出自定义异常ExceptionA</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ExceptionB</span>(); <span class="comment">// 抛出自定义异常ExceptionB</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ExceptionC</span>(); <span class="comment">// 抛出自定义异常ExceptionC</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">fun</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an int exception: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">double</span> e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught a double exception: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (ExceptionA&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an ExceptionA&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (ExceptionB&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an ExceptionB&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (ExceptionC&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an ExceptionC&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; <span class="comment">// 捕获所有其他未列出的异常</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an unspecified exception&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>C++标准异常类exception</strong></p><p>C++ 标准库中有⼀些类代表异常，这些类都是从 exception 类派⽣⽽来的</p><ul><li><p><code>std::bad_typeid:</code> 当使用<code>typeid</code>运算符对一个多态类的指针进行操作时，如果该指针的值为<code>NULL</code>（即指向空），则会抛出<code>std::bad_typeid</code>异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">typeid</span>(*ptr).<span class="built_in">name</span>() &lt;&lt; std::endl; <span class="comment">// 这里会抛出 std::bad_typeid 异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_typeid&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_typeid: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>std::bad_cast:</code> 当使用<code>dynamic_cast</code>进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的（例如，基类指针实际上并不指向正确的派生类对象），则会抛出<code>std::bad_cast</code>异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="keyword">public</span>: <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Derived&amp; derivedRef = <span class="built_in">dynamic_cast</span>&lt;Derived&amp;&gt;(*basePtr); <span class="comment">// 这里会抛出 std::bad_cast 异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_cast&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_cast: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>std::bad_alloc</code>: 当使用<code>new</code>运算符进行动态内存分配时，如果没有足够的内存，则会引发<code>std::bad_alloc</code>异常。</p></li><li><p><code>std::out_of_range</code>: 当你使用<code>vector</code>或<code>string</code>的<code>at()</code>成员函数根据下标访问元素时，如果提供的下标越界了，则会抛出<code>std::out_of_range</code>异常。</p></li></ul></li></ul><h4 id="6-形参与实参的区别？"><a href="#6-形参与实参的区别？" class="headerlink" title="6.形参与实参的区别？"></a>6.形参与实参的区别？</h4><ul><li><strong>形参变量的作用范围</strong>：形参是在定义函数时声明的变量，它们只有在函数被调用时才会分配内存单元，并且<strong>仅在函数内部有效。</strong></li><li><strong>实参的类型与值确定性</strong>：这就要求在调用函数之前，确保所有实参都有明确的值。</li><li><strong>实参与形参的一致性</strong>：实参和形参的数量、类型以及顺序需要严格匹配。</li><li><strong>非指针类型的形参与实参的独立性</strong>：如果形参和实参都不是指针类型，那么在函数执行期间，形参会创建实参的一个副本，即形参获得的是实参值的一份拷贝。这样，在函数内部对形参所做的任何改变都不会影响到外部的实参。当函数执行完毕后，形参占用的内存被释放，而实参保持不变。</li></ul><h4 id="7-值传递、指针传递、引用传递的区别和效率"><a href="#7-值传递、指针传递、引用传递的区别和效率" class="headerlink" title="7.值传递、指针传递、引用传递的区别和效率"></a>7.值传递、指针传递、引用传递的区别和效率</h4><ul><li><strong>值传递：</strong>将实际参数的值<strong>复制</strong>一份传递给函数的形式参数。函数内部对形参的修改不会影响到实参。如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。<strong>实参和形参在不同的内存位置，它们占用不同的存储空间。</strong>形参是实参的一个副本，当<strong>函数调用结束后，形参占用的内存空间会被释放。</strong></li><li><strong>指针传递：</strong>函数参数为指针类型。通过传递变量的地址，<strong>函数内部可以通过这个地址访问和修改原始变量的值。</strong>（<strong>传值</strong>，传递的是固定为<strong>4字节的地址值</strong>）</li><li><strong>引用传递：</strong>在函数调用时，将实际参数的引用（别名）传递给函数的形式参数。对形参的操作<strong>实际上就是对实参的操作</strong>。（<strong>传地址</strong>）</li></ul><p><strong>效率上，指针传递和引用传递比值传递效率高。</strong></p><h4 id="8-局部变量什么时候初始化"><a href="#8-局部变量什么时候初始化" class="headerlink" title="8.局部变量什么时候初始化"></a>8.局部变量什么时候初始化</h4><ul><li><p><strong>普通局部变量：</strong></p><ul><li><strong>初始化时机</strong>：普通局部变量在每次进入其作用域时被创建，并且可以在声明时或者之后进行初始化。<strong>初始化不是自动的</strong>，需要显式地给它们赋值。</li></ul></li><li><p><strong>静态局部变量：</strong></p><ul><li><strong>初始化时机</strong>：在<strong>首次用到时初始化</strong>，可使用变量初始化，这是因为初始化要执行构造函数</li><li><strong>析构顺序</strong>：当程序结束时，静态局部变量会按照它们构造的逆序进行析构。此外，C++通过<code>atexit()</code>函数来管理这些对象的析构顺序，确保它们能以正确的顺序被销毁。</li></ul></li><li><p><strong>全局静态变量：</strong></p><ul><li><strong>初始化时机</strong>：全局静态变量和静态局部变量类似，在程序开始执行前就已初始化。然而，在不同编译单元中的全局静态对象的初始化顺序是不确定的，这可能导致依赖于特定初始化顺序的问题。</li><li><strong>解决方法</strong>：一种常用的解决方案是使用单例模式中的静态局部变量。由于静态局部变量具有“延迟初始化”的特点，即只有在首次使用时才会初始化，因此可以用来控制初始化顺序，避免跨编译单元初始化顺序导致的问题。</li></ul></li></ul><h4 id="9-深拷贝与浅拷贝"><a href="#9-深拷贝与浅拷贝" class="headerlink" title="9.深拷贝与浅拷贝"></a>9.<strong>深拷贝与浅拷贝</strong></h4><ul><li><strong>浅拷贝：</strong>浅拷贝是指简单地将原对象的<strong>基本数据类型</strong>的值<strong>复制</strong>给新对象，并且对于<strong>引用类型的数据</strong>（如指针），只是<strong>复制了指向实际数据的引用</strong>（即<strong>内存地址</strong>），并<strong>没有为引用类型的数据开辟新的内存空间。</strong></li><li><strong>深拷贝：</strong>深拷贝不仅复制了基本数据类型的值，而且对于引用类型的成员变量，还<strong>会在堆上为其指向的数据分配新的内存空间</strong>，并将这些数据复制到新的内存位置，从而使得<strong>新对象拥有自己的独立数据副本</strong>。</li></ul><h4 id="10-new、delete-p、delete-p、allocator都有什么作用？"><a href="#10-new、delete-p、delete-p、allocator都有什么作用？" class="headerlink" title="10.new、delete p、delete [] p、allocator都有什么作用？"></a>10.new、delete p、delete [] p、allocator都有什么作用？</h4><ul><li><p><strong><code>new[]</code>创建动态数组</strong>：当使用<code>new</code>分配一个数组时，方括号<code>[]</code>内的值必须是整数类型，它<strong>可以是变量</strong>（即运行时确定的值），而不必是常量表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 合法，size可以是变量</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>new</code>返回元素类型的指针:</strong> 当使用<code>new[]</code>来动态创建数组时，<strong>返回的是指向数组第一个元素的指针</strong>，而不是一个数组类型的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arrayPtr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// arrayPtr 是一个 int 类型的指针</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>delete[]</code>销毁顺序:</strong> 使用<code>delete[]</code>删除通过<code>new[]</code>分配的数组时，数组中的对象会按照它们被构造的逆序进行析构。因为C++保证了对象的析构顺序与它们的构造顺序相反，以确保资源正确释放。</p></li><li><p><strong><code>new/delete</code> vs <code>allocator</code></strong></p><ul><li><p><strong><code>new/delete</code>局限性</strong>：将构造函数/析构函数与内存管理绑定在一起不够灵活</p></li><li><p><strong><code>std::allocator</code>（分配器）的作用</strong>：<code>std::allocator</code>是C++标准库提供的一个工具，用于分离内存分配和对象构造的过程。它允许程序员先申请一块未初始化的内存，然后根据需要手动构造对象。这种方式提供了更大的灵活性，比如延迟对象的初始化时间或者复用已分配的内存块，从而可能提高性能或减少内存碎片。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::allocator&lt;<span class="type">int</span>&gt; alloc; <span class="comment">// 创建一个 allocator 对象</span></span><br><span class="line"><span class="type">int</span>* p = alloc.<span class="built_in">allocate</span>(<span class="number">10</span>); <span class="comment">// 分配内存但不初始化</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(p, <span class="number">100</span>); <span class="comment">// 初始化某个位置的对象</span></span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p, <span class="number">10</span>); <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="11-new和delete的实现原理，-delete是如何知道释放内存的大小的额？"><a href="#11-new和delete的实现原理，-delete是如何知道释放内存的大小的额？" class="headerlink" title="11.new和delete的实现原理， delete是如何知道释放内存的大小的额？"></a>11.new和delete的实现原理， delete是如何知道释放内存的大小的额？</h4><p>对于数组，<code>new[]</code>会额外存储数组的大小，<code>delete[]</code>会根据这个大小正确地调用析构函数并释放内存。</p><h4 id="12-malloc与free的实现原理？"><a href="#12-malloc与free的实现原理？" class="headerlink" title="12.malloc与free的实现原理？"></a>12.malloc与free的实现原理？</h4><p><code>alloc</code> 和 <code>free</code> 的底层实现依赖于操作系统提供的系统调用，主要包括：</p><ul><li><code>brk</code>：通过调整堆的边界来分配内存。</li><li><code>mmap</code>：在进程的虚拟地址空间中映射一块内存区域。</li><li><code>munmap</code>：释放由 <code>mmap</code> 分配的内存。</li></ul><p><strong>内存分配的两种方式:</strong></p><ul><li><p><strong><code>brk</code> 系统调用(小于 128KB)</strong>：调整堆的边界（即数据段的最高地址指针 <code>_edata</code>）来分配内存； <strong>分配的内存是连续的，释放时需要从高地址向低地址依次释放。</strong></p><ul><li><code>brk</code> 将 <code>_edata</code> 指针向高地址方向移动，扩展堆的大小。</li><li>分配的内存是虚拟内存，物理内存并未立即分配。</li><li>当程序首次访问这块内存时，操作系统会触发缺页中断，分配物理内存并建立虚拟内存与物理内存的映射关系。</li></ul></li><li><p><strong><code>mmap</code> 系统调用(大于 128KB)</strong>：<code>mmap</code> 在进程的虚拟地址空间中（<strong>堆和栈之间的文件映射区域</strong>）找一块空闲的虚拟内存。； <strong>分配的内存可以单独释放，灵活性更高。</strong></p><ul><li><code>mmap</code> 在文件映射区域中分配一块虚拟内存。</li><li>同样，物理内存并未立即分配，而是在首次访问时通过缺页中断分配。</li></ul></li><li><p><strong>内存紧缩（trim）</strong>：</p><ul><li>当 <code>free</code> 释放内存后，如果堆顶的空闲内存超过一定阈值（默认 128KB，可通过 <code>M_TRIM_THRESHOLD</code> 调节），操作系统会执行内存紧缩操作（trim）。</li><li>内存紧缩会将空闲的内存归还给操作系统，减少进程的内存占用。</li></ul></li></ul><p><strong><code>malloc</code> 的具体实现机制：</strong></p><ul><li><p><strong>空闲内存链表</strong>：</p><ul><li>操作系统中维护一个记录空闲内存地址的链表。</li><li>当程序<strong>调用 <code>malloc</code></strong> 时，操作系统会<strong>遍历这个链表</strong>，寻找第一个大小满足需求的空闲内存块。</li><li>如果找到合适的内存块，则将其从空闲链表中删除，并分配给程序。</li><li>如果<strong>没有找到合适的内存块，则会通过 <code>brk</code> 或 <code>mmap</code> 系统调用</strong>向操作系统申请更多的内存。</li></ul></li><li><p><strong>内存分配算法</strong>：</p><ul><li><code>malloc</code> 通常使用一些内存分配算法（如首次适应、最佳适应或伙伴系统）来管理空闲内存链表，以提高内存分配的效率。</li></ul></li></ul><p><strong><code>free</code> 的具体实现机制：</strong></p><ul><li><strong>释放内存</strong>：<ul><li>当程序调用 <code>free</code> 时，操作系统会将释放的内存块重新加入到空闲内存链表中。</li><li>如果释放的内存是通过 <strong><code>brk</code> 分配的</strong>，且位于堆的顶部，则<strong>可能会触发内存紧缩操作，将空闲内存归还给操作系统。</strong></li><li>如果释放的内存是通过 <code>mmap</code> 分配的，则直接调用 <strong><code>munmap</code> 系统调用</strong>将内存归还给操作系统。</li></ul></li></ul><h4 id="13-内联函数和普通函数的区别"><a href="#13-内联函数和普通函数的区别" class="headerlink" title="13.内联函数和普通函数的区别"></a>13.内联函数和普通函数的区别</h4><ul><li><p><strong>执行效率</strong>：内联函数效率高</p><ul><li><strong>内联函数</strong>：当一个函数被声明为内联函数时，编译器会在每次调用该函数的地方将其代码展开，而不是进行常规的函数调用（如保存当前环境、跳转到函数入口地址执行等）。这样做可以<strong>减少函数调用带来的开销</strong>，特别是对于简单的、短小的函数来说，能提高程序运行效率。</li><li><strong>普通函数</strong>：普通函数调用涉及到栈帧的创建与销毁、参数传递、返回值处理等一系列操作，这些都会带来一定的性能开销。</li></ul></li><li><p><strong>代码大小</strong>：内联函数会增大代码量</p><ul><li><strong>内联函数</strong>：由于内联函数是将函数体直接插入到调用点，如果一个内联函数在一个程序中被多次调用，那么这个函数的代码就会被复制多份，这可能导致生成的可执行文件变大。</li><li><strong>普通函数</strong>：普通函数只有一份副本，无论它被调用多少次，都不会增加代码量。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-什么是大小端存储？&quot;&gt;&lt;a href=&quot;#1-什么是大小端存储？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是大小端存储？&quot;&gt;&lt;/a&gt;1.什么是大小端存储？&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;大端存储：&lt;/strong&gt;数据的最高有效字节存放在</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++八股2</title>
    <link href="https://wangak.cc/posts/a41c6ee6.html"/>
    <id>https://wangak.cc/posts/a41c6ee6.html</id>
    <published>2025-03-15T16:00:00.000Z</published>
    <updated>2025-03-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-八股2"><a href="#C-八股2" class="headerlink" title="C++八股2"></a>C++八股2</h2><h4 id="1-C-中const和static的作用"><a href="#1-C-中const和static的作用" class="headerlink" title="1.C++中const和static的作用"></a>1.C++中const和static的作用</h4><p><strong>static：</strong></p><ul><li><p><strong>不考虑类的情况</strong></p><ul><li><p><strong>隐藏</strong>：当使用<code>static</code>修饰全局变量或函数时，它们将仅在定义它们的文件内可见（即具有内部链接性），而没有<code>static</code>修饰的全局变量和函数则可以在其他文件中通过声明来引用。</p><p><strong><em>注：当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</em></strong></p></li><li><p><strong>默认初始化为0</strong>：无论是未初始化的全局静态变量还是局部静态变量，默认情况下都会被初始化为0，并且这些变量都存储在全局未初始化区。</p></li><li><p><strong>持久存在与记忆性</strong>：如果在函数内部定义了静态变量，那么这个变量在整个程序运行期间一直存在，只会被初始化一次，并且即使函数退出后仍然存在，但它的作用域是局部的。</p></li></ul></li><li><p><strong>考虑类的情况</strong></p><ul><li><strong>static成员变量</strong>：必须在类外部进行初始化</li><li><strong>static成员函数</strong>：没有<code>this</code>指针，不能访问类的非静态成员变量或调用非静态成员函数。</li></ul></li></ul><p><strong>const:</strong></p><ul><li><strong>不考虑类的情况:</strong><ul><li><strong>不可变性</strong>：一旦定义了一个<code>const</code>常量，就必须同时对其进行初始化，之后其值不能再被修改。</li><li><strong>参数传递：</strong>用const修饰传入参数，则函数保证传入参数不发生改变</li></ul></li><li><strong>考虑类的情况</strong><ul><li><strong>const成员变量</strong>：必须通过构造函数的初始化列表进行初始化，不能在类定义之外进行初始化。</li><li><strong>const成员函数</strong>：这种函数承诺不会修改对象的数据成员（除非数据成员被声明为<code>mutable</code>），<code>const</code>成员函数不可以调用非<code>const</code>成员函数；<code>const</code>对象只能调用<code>const</code>成员函数，而非<code>const</code>对象既可以调用<code>const</code>也可以调用非<code>const</code>成员函数。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非const成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modifyValue</span><span class="params">(<span class="type">int</span> newVal)</span> </span>&#123;</span><br><span class="line">        value = newVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不能修改任何非mutable数据成员</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> MyClass <span class="title">constObj</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 创建一个const对象</span></span><br><span class="line">    <span class="function">MyClass <span class="title">nonConstObj</span><span class="params">(<span class="number">20</span>)</span></span>;    <span class="comment">// 创建一个非const对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行会导致编译错误，因为尝试在一个const对象上调用非const成员函数</span></span><br><span class="line">    <span class="comment">// constObj.modifyValue(30);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在一个const对象上调用const成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;constObj value: &quot;</span> &lt;&lt; constObj.<span class="built_in">getValue</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在非const对象上调用const成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;nonConstObj value: &quot;</span> &lt;&lt; nonConstObj.<span class="built_in">getValue</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以在非const对象上调用非const成员函数</span></span><br><span class="line">    nonConstObj.<span class="built_in">modifyValue</span>(<span class="number">40</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After modification, nonConstObj value: &quot;</span> &lt;&lt; nonConstObj.<span class="built_in">getValue</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-C-的顶层const和底层const"><a href="#2-C-的顶层const和底层const" class="headerlink" title="2.C++的顶层const和底层const"></a>2.C++的顶层const和底层const</h4><p><strong>顶层const（*在左边）</strong>：表示被修饰的对象本身是一个常量，不能通过这个对象改变它的值。（指针指向不可变）</p><p><strong>底层const（*在右边）</strong>：指针所指向的对象是不可变的。（指针指向的对象是常量）</p><p><em>注：标准的<code>const int</code>是顶层; const用于声明引用变量是底层</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> b1 = &amp;a;        <span class="comment">// 顶层const，b1本身是一个常量，即b1必须始终指向a</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* b2 = &amp;a;        <span class="comment">// 底层const，b2本身可变，但b2指向的对象（即*a）是常量，不可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b3 = <span class="number">20</span>;         <span class="comment">// 顶层const，b3是常量不可变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> b4 = &amp;a;  <span class="comment">// 前一个const为底层，后一个为顶层，b4不可变且*b4也不可变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; b5 = a;         <span class="comment">// 用于声明引用变量，都是底层const，a的值可通过非const引用改变，但b5无法修改a</span></span><br></pre></td></tr></table></figure><p>注：具有底层<code>const</code>的指针或引用不能直接赋值给没有<code>const</code>限定的指针或引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demonstrateConstRestrictions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向普通int类型的指针（无底层const）</span></span><br><span class="line">    <span class="type">int</span>* nonConstPtr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向const int类型的指针（有底层const）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* constPtr = &amp;b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行会导致编译错误：</span></span><br><span class="line">    <span class="comment">// error: invalid conversion from &#x27;const int*&#x27; to &#x27;int*&#x27;</span></span><br><span class="line">    <span class="comment">// nonConstPtr = constPtr;  // 错误：试图将底层const转换为非const</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确的做法是使用const_cast，但要小心使用，确保原始数据确实是可修改的</span></span><br><span class="line">    <span class="comment">// 在这个特定情况下，由于&#x27;b&#x27;是一个const int，这样做实际上是不安全的</span></span><br><span class="line">    <span class="comment">// nonConstPtr = const_cast&lt;int*&gt;(constPtr);  // 不建议这么做</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是，从非const到const的转换总是安全的</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* safePtr = &amp;a;  <span class="comment">// 安全：增加const限定不会有问题</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value via safePtr: &quot;</span> &lt;&lt; *safePtr &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">demonstrateConstRestrictions</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-数组名和指针（这里为指向数组首元素的指针）区别"><a href="#3-数组名和指针（这里为指向数组首元素的指针）区别" class="headerlink" title="3.数组名和指针（这里为指向数组首元素的指针）区别"></a>3.数组名和指针（这里为指向数组首元素的指针）区别</h4><ul><li><p>数组名不是真正意义上的指针，可以理解为常指针，所以<strong>数组名没有自增、自减等操作。</strong></p></li><li><p>当数组名当<strong>做形参</strong>传递给调用函数后，就失去了原有特性，<strong>退化成一般指针，多了自增、自减操作</strong>，但sizeof运算符不能再得到原数组的大小了。</p></li></ul><h4 id="4-final和override关键字"><a href="#4-final和override关键字" class="headerlink" title="4.final和override关键字"></a>4.final和override关键字</h4><p><strong>override:</strong> </p><p>​    指定了子类的这个虚函数是重写的父类的,如果函数名输错，编译器会报错</p><p><strong>final：</strong></p><p>​    当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;    </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">           <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// foo 被override并且是最后一个override，在其子类中不可以重写&#125;;</span></span><br></pre></td></tr></table></figure><h4 id="5-拷贝初始化和直接初始化"><a href="#5-拷贝初始化和直接初始化" class="headerlink" title="5.拷贝初始化和直接初始化"></a>5.拷贝初始化和直接初始化</h4><ul><li><p><strong>直接初始化</strong>：直接调用与实参匹配的构造函数来初始化对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;I am a string&quot;</span>)</span></span>; <span class="comment">// 语句1：直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(str1)</span></span>;            <span class="comment">// 语句2：直接初始化，使用另一个对象进行初始化</span></span><br></pre></td></tr></table></figure></li><li><p><strong>拷贝初始化</strong>：首先<strong>创建一个临时对象</strong>，然后使用拷贝构造函数将这个临时对象的内容拷贝到正在创建的对象中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str3 = <span class="string">&quot;I am a string&quot;</span>; <span class="comment">// 语句3：拷贝初始化</span></span><br><span class="line">string str4 = str1;            <span class="comment">// 语句4：拷贝初始化</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="6-野指针和悬空指针"><a href="#6-野指针和悬空指针" class="headerlink" title="6.野指针和悬空指针"></a>6.野指针和悬空指针</h4><p><strong>野指针：</strong></p><p>​    没有被初始化过的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;         </span><br><span class="line"><span class="type">int</span>* p;     <span class="comment">// 未初始化    </span></span><br><span class="line">std::cout&lt;&lt; *p &lt;&lt; std::endl; <span class="comment">// 未初始化就被使用,可能会报错        </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：确保指针在声明时就被初始化。如果暂时没有有效的内存地址可以赋值给指针，应该将其设置为<code>nullptr</code>。这样，如果尝试解引用一个<code>nullptr</code>，大多数现代编译器会在运行时抛出异常或给出错误提示，从而帮助开发者快速定位问题。</p><p><strong>悬空指针:</strong></p><p>​    最初指向的内存已经被释放了的一种指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;   </span><br><span class="line"><span class="type">int</span> * p = <span class="literal">nullptr</span>;  </span><br><span class="line"><span class="type">int</span>* p2 = <span class="keyword">new</span> <span class="type">int</span>;   </span><br><span class="line"> p = p2;  <span class="keyword">delete</span> p2;</span><br><span class="line">&#125; <span class="comment">// 此时p和p2都变成了悬空指针</span></span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：</p><ul><li>在释放指针所指向的内存之后，立即将指针设置为<code>nullptr</code>。</li><li>C++引入了智能指针（如<code>std::unique_ptr</code>和<code>std::shared_ptr</code>），它们能够自动管理内存的分配和释放，从而有效避免悬空指针的产生。</li></ul><h4 id="7-C-中的重载、重写（覆盖）和隐藏的区别"><a href="#7-C-中的重载、重写（覆盖）和隐藏的区别" class="headerlink" title="7.C++中的重载、重写（覆盖）和隐藏的区别"></a>7.C++中的重载、重写（覆盖）和隐藏的区别</h4><p><strong>重载： </strong>重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，<strong>不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。</strong></p><p><strong>重写（override）：</strong>在派生类中覆盖基类中的同名函数，<strong>重写就是重写函数体</strong>，<strong>要求基类函数必须是虚函数</strong>且：</p><ul><li>与基类的虚函数有相同的参数个数</li><li>与基类的虚函数有相同的参数类型</li><li>与基类的虚函数有相同的返回值类型</li></ul><p><strong>隐藏（hide）:</strong> 派生类中的函数屏蔽了基类中的同名函数</p><p><strong>隐藏和重写的区别：</strong>  重写可以体现多态性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base: &quot;</span> &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; endl; &#125; <span class="comment">// 重写了基类中的foo(int x)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl; &#125; <span class="comment">// 隐藏了基类中的foo(int x, int y)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *pb = <span class="keyword">new</span> Derived;</span><br><span class="line">    pb-&gt;<span class="built_in">foo</span>(<span class="number">1</span>);     <span class="comment">// 调用的是Derived::foo(int x)，因为Base::foo(int x)是虚函数且被重写</span></span><br><span class="line">    pb-&gt;<span class="built_in">foo</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 调用的是Base::foo(int x, int y)，因为Derived::foo(int x, int y)隐藏了基类的同名函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503162026007.png" alt="image-20250316202637727" style="zoom:67%;"></p><h4 id="8-C-有哪几种的构造函数"><a href="#8-C-有哪几种的构造函数" class="headerlink" title="8.C++有哪几种的构造函数"></a>8.C++有哪几种的构造函数</h4><ul><li><p><strong>默认构造函数:</strong> 不带任何参数的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="comment">// 默认构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj; <span class="comment">// 调用默认构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化构造函数:</strong> 接受一个或多个参数以初始化对象的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123; <span class="comment">// 初始化构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameterized Constructor with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 调用有参数的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>拷贝构造函数:</strong>  使用<strong>同一类型的另一个对象</strong>来初始化新创建的对象时调用的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass &amp;other) : <span class="built_in">value</span>(other.value) &#123; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy Constructor, value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    MyClass obj2 = obj1; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>移动构造函数（Move和右值引用）：</strong>用于实现资源转移而非复制，避免不必要的深拷贝操作。它通常与右值引用一起使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123; <span class="comment">// 移动构造函数</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">//确保原对象不再拥有对资源的所有权,防止悬空指针</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> size) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[size]) &#123;&#125; <span class="comment">// 简化的构造函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    MyClass obj2 = std::<span class="built_in">move</span>(obj1); <span class="comment">// 调用移动构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>委托构造函数： </strong>允许在一个构造函数内部调用同一个类的其他构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">MyClass</span>(<span class="number">0</span>) &#123; &#125; <span class="comment">// 委托构造函数，委托给下面的构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123; <span class="comment">// 初始化构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameterized Constructor with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj; <span class="comment">// 调用默认构造函数，但实际通过委托构造函数间接调用了有参数的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>转换构造函数:</strong> 允许编译器隐式地将一种类型的值转换为类的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Temperature</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> celsius;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换构造函数：从 double 到 Temperature 的转换</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Temperature</span><span class="params">(<span class="type">double</span> c)</span> : celsius(c) &#123;</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Conversion Constructor, Celsius: &quot;</span> &lt;&lt; celsius &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示当前温度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Temperature is &quot;</span> &lt;&lt; celsius &lt;&lt; <span class="string">&quot; degrees Celsius.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，接受一个 Temperature 对象并显示其值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayTemperature</span><span class="params">(<span class="type">const</span> Temperature&amp; temp)</span> </span>&#123;</span><br><span class="line">    temp.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用显式构造函数调用创建对象</span></span><br><span class="line">    <span class="function">Temperature <span class="title">t1</span><span class="params">(<span class="number">36.5</span>)</span></span>; <span class="comment">// 正确：显式调用转换构造函数</span></span><br><span class="line">    t1.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行会导致编译错误，因为构造函数被声明为 explicit</span></span><br><span class="line">    <span class="comment">// Temperature t2 = 40.0; // 错误：不允许隐式转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过辅助函数传递 double 值，但需要显式转换</span></span><br><span class="line">    <span class="built_in">displayTemperature</span>(<span class="built_in">Temperature</span>(<span class="number">25.0</span>)); <span class="comment">// 正确：显式创建临时对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果去掉 explicit 关键字，则下面的语句也会合法</span></span><br><span class="line">    <span class="comment">// Temperature t3 = 37.0; // 如果构造函数不是 explicit，则这是合法的隐式转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-浅拷贝和深拷贝的区别"><a href="#9-浅拷贝和深拷贝的区别" class="headerlink" title="9.浅拷贝和深拷贝的区别"></a>9.浅拷贝和深拷贝的区别</h4><p><strong>浅拷贝共享数据：</strong> 浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p><p><strong>深拷贝各自拥有独立的数据副本：</strong> 开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。</p><p><em>注：浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源</em></p><h4 id="10-内联函数和宏定义的区别"><a href="#10-内联函数和宏定义的区别" class="headerlink" title="10.内联函数和宏定义的区别"></a>10.内联函数和宏定义的区别</h4><ul><li><strong>处理时机</strong>：宏定义是在预处理阶段进行简单的文本替换； 内联函数则是在编译时进行处理，并且可以进行参数类型检查。这使得内联函数更加安全和可靠。</li><li><strong>类型检查与返回值</strong>：由于宏只是简单的字符串替换，它无法进行任何类型检查，也无法直接拥有返回值的概念。内联函数支持参数类型检查，确保传入参数的类型正确，并能够像普通函数一样有明确的返回值。</li></ul><p><strong>内联函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 定义一个内联函数来计算两个整数的和</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 使用内联函数计算两数之和</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">add</span>(num1, num2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>宏：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 定义一个宏来计算两个整数的和</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(a, b) ((a) + (b))</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 使用宏计算两数之和</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">ADD</span>(num1, num2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title=" "></a> </h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-八股2&quot;&gt;&lt;a href=&quot;#C-八股2&quot; class=&quot;headerlink&quot; title=&quot;C++八股2&quot;&gt;&lt;/a&gt;C++八股2&lt;/h2&gt;&lt;h4 id=&quot;1-C-中const和static的作用&quot;&gt;&lt;a href=&quot;#1-C-中const和static的作</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>CMake</title>
    <link href="https://wangak.cc/posts/42cbd3c8.html"/>
    <id>https://wangak.cc/posts/42cbd3c8.html</id>
    <published>2025-03-12T16:00:00.000Z</published>
    <updated>2025-03-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h3><h4 id="CMake编译过程"><a href="#CMake编译过程" class="headerlink" title="CMake编译过程"></a>CMake编译过程</h4><ul><li>创建CMakeLists.txt文件：<code>touch CMakeLists.txt</code></li><li>使⽤cmake，生成makefile文件</li><li>使⽤make命令编译，生成了可执行程序</li></ul><p><strong>PROJECT</strong></p><p><code>PROJECT:</code>来指定工程的名称</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span> (HELLO)</span><br></pre></td></tr></table></figure><p><strong>add_executable</strong>：定义工程会生成一个可执行程序</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(可执行程序名 源文件名称)</span><br></pre></td></tr></table></figure><h4 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h4><ul><li><p><strong>显示地指定变量</strong></p><p><code>SET(SRC_LIST main.cpp)</code> SRC_LIST变量就包含了main.cpp</p><p>多个cpp文件：<code>SET(SRC_LIST main.cpp t1.cpp t2.cpp)</code></p></li><li><p><strong>在 CMakeLists.txt 中通过 set 命令指定所使用的C++标准：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加-std=c++11</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment">#增加-std=c++14</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="comment">#增加-std=c++17</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>指定输出的路径：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(HOME /home/robin/Linux/Sort)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>/bin)</span><br></pre></td></tr></table></figure><p><em>注：<code>EXECUTABLE_OUTPUT_PATH</code>是可执行程序输出的路径对应的宏，如果这个路径中的子目录不存在，会自动生成，无需自己手动创建</em></p></li></ul><h4 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h4><ul><li><p><strong><code>aux_source_directory</code> 命令可以查找某个路径下的所有源文件</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 搜索 src 目录下的源文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src SRC_LIST)</span><br><span class="line"><span class="keyword">add_executable</span>(app  <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure></li></ul><p>​    <em>注1：<code>PROJECT_SOURCE_DIR</code>是执行<code>cmake</code>命令时指定的路径； <code>CMAKE_CURRENT_SOURCE_DIR</code>是当前的CMakeLists.txt所对应的路径</em></p><p>​    <em>注2：<code>PROJECT_SOURCE_DIR</code>和<code>CMAKE_CURRENT_SOURCE_DIR</code>存储的值是一样的</em></p><ul><li><p><strong><code>file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</code></strong></p><ul><li><p><code>GLOB</code>: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。</p></li><li><p><code>GLOB_RECURSE</code>：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>include_directories</code>: 用于指定头文件的路径</strong></p></li></ul><h4 id="制作动态库和静态库"><a href="#制作动态库和静态库" class="headerlink" title="制作动态库和静态库"></a>制作动态库和静态库</h4><ul><li><strong>制作静态库：<code>add_library(&lt;库名称&gt; STATIC &lt;源文件&gt;)</code></strong></li></ul><p>​    <em>注1：在Linux中，静态库名分为三部分：<code>lib+库名称+.a</code></em></p><ul><li><p><strong>制作动态库：<code>add_library(&lt;库名称&gt; SHARE &lt;源文件&gt;)</code></strong></p></li><li><p><strong>使用<code>LIBRARY_OUTPUT_PATH</code>指定生成的库文件的路径</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="comment"># 设置动态库/静态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment">#add_library(calc SHARED $&#123;SRC_LIST&#125;)</span></span><br><span class="line"><span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>链接静态库：</strong><code>link_libraries(&lt;库名称&gt;...)</code></p><p><em>注：如果静态库是自定义的，要使用<code>link_directories(&lt;lib path&gt;)</code>来指定库路径</em></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="comment"># 搜索指定目录下源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="comment"># 包含头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 包含静态库路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line"><span class="keyword">link_libraries</span>(calc)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>链接动态库：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">    &lt;需要链接动态库的文件&gt; </span><br><span class="line">    &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;库名称&gt;... </span><br><span class="line">    [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;库名称&gt;...]...)</span><br></pre></td></tr></table></figure><p>注：默认权限为<code>PUBLIC</code>,<code>PUBLIC</code>具有传递性； <code>INTERFACE</code>只会导出符号</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 添加并指定最终生成的可执行程序名</span></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 指定可执行程序要链接的动态库名字</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread)</span><br></pre></td></tr></table></figure></li></ul><h4 id="日志信息"><a href="#日志信息" class="headerlink" title="日志信息"></a>日志信息</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] <span class="string">&quot;message to display&quot;</span> ...)</span><br></pre></td></tr></table></figure><ul><li>(无) ：重要消息</li><li><code>STATUS</code>：非重要消息</li><li><code>WARNING</code>：CMake 警告, 会继续执行</li><li><code>AUTHOR_WARNING</code>：CMake 警告 (dev), 会继续执行</li><li><code>SEND_ERROR</code>：CMake 错误, 继续执行，但是会跳过生成的步骤</li><li><code>FATAL_ERROR</code>：CMake 错误, 终止所有处理过程</li></ul><h4 id="变量的操作"><a href="#变量的操作" class="headerlink" title="变量的操作"></a>变量的操作</h4><ul><li><p><strong>字符串拼接：</strong></p><ul><li><p><code>set(变量名1 $&#123;变量名1&#125; $&#123;变量名2&#125; ...)</code></p></li><li><p><code>list(APPEND &lt;list&gt; [&lt;element&gt; ...])</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">set</span>(TEMP <span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src1/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_2 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src2/*.cpp)</span><br><span class="line"><span class="comment"># 追加(拼接)</span></span><br><span class="line"><span class="keyword">list</span>(APPEND SRC_1 <span class="variable">$&#123;SRC_1&#125;</span> <span class="variable">$&#123;SRC_2&#125;</span> <span class="variable">$&#123;TEMP&#125;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>字符串移除:</strong></p><p><code>list(REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...])</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 移除 main.cpp</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/main.cpp)</span><br></pre></td></tr></table></figure></li></ul><h4 id="定义宏"><a href="#定义宏" class="headerlink" title="定义宏"></a>定义宏</h4><p><code>add_definitions(-D宏名称)</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="comment"># 自定义 DEBUG 宏</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-DDEBUG)</span><br><span class="line"><span class="keyword">add_executable</span>(app ./<span class="keyword">test</span>.c)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#define NUMBER  3</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">#ifdef DEBUG</span></span><br><span class="line">    printf(<span class="string">&quot;我是一个程序猿, 我不会爬树...\n&quot;</span>);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    for(int i=<span class="number">0</span>; i&lt;NUMBER; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;hello, GCC!!!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌套的CMake"><a href="#嵌套的CMake" class="headerlink" title="嵌套的CMake"></a>嵌套的CMake</h4><p><strong>建立父子节点之间的关系：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(source_dir)</span><br></pre></td></tr></table></figure><p><code>source_dir:</code> 子节点所在的目录</p><p><em>注：子节点可以使用根节点定义的变量，而根节点不可以使用子节点的变量</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CMake&quot;&gt;&lt;a href=&quot;#CMake&quot; class=&quot;headerlink&quot; title=&quot;CMake&quot;&gt;&lt;/a&gt;CMake&lt;/h3&gt;&lt;h4 id=&quot;CMake编译过程&quot;&gt;&lt;a href=&quot;#CMake编译过程&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="CMake" scheme="https://wangak.cc/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>Protobuf</title>
    <link href="https://wangak.cc/posts/608ca7e8.html"/>
    <id>https://wangak.cc/posts/608ca7e8.html</id>
    <published>2025-03-12T16:00:00.000Z</published>
    <updated>2025-03-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><h4 id="Protobuf序列化的步骤"><a href="#Protobuf序列化的步骤" class="headerlink" title="Protobuf序列化的步骤"></a>Protobuf序列化的步骤</h4><p><strong>protobuf中的数据类型 和 C++ 数据类型对照:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503131059638.png" alt="image-20250313100438695" style="zoom:67%;"></p><p><strong>使用protobuf进行序列化的步骤：</strong></p><ul><li><strong>定义.proto文件：</strong> <code>.proto</code>文件来描述要序列化的数据结构</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明所使用的protobuf版本号</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> id = <span class="number">2</span>;</span><br><span class="line">  <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：等号后面的编号要<strong>从1开始</strong>，每个成员都有一个<strong>唯一的编号</strong>，不能重复，一般连续编号即可。</em></p><ul><li><strong>编译.proto文件：</strong>使用<code>protoc</code>编译器将<code>user_info.proto</code>文件编译成C++代码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I path &lt;user_info.proto&gt; --cpp_out=输出路径(存储生成的c++文件)</span><br></pre></td></tr></table></figure><p><em>注1：<code>-I</code>: 参数后面可以跟随一个或多个路径，用于告诉编译器在哪些路径下查找导入的文件或依赖的文件,如<code>protoc -I path1 -I path2</code> 或 <code>protoc -I path1:path2</code></em></p><p><em>注2：这会在输出路径下生成<code>user_info.pb.h</code>和<code>user_info.pb.cc</code>两个文件。</em></p><ul><li><strong>在C++项目中集成：</strong></li></ul><p>在项目的源文件中包含生成的头文件：<code>#include &quot;user_info.pb.h&quot;</code></p><ul><li><p><strong>序列化和反序列化:</strong></p><ul><li><p><strong>序列化：</strong>创建一个<code>UserInfo</code>对象并设置其字段值，然后调用<code>SerializeToArray</code>或<code>SerializeToString</code>方法将其序列化为字节流。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UserInfo user;</span><br><span class="line">user.<span class="built_in">set_id</span>(<span class="number">1</span>);</span><br><span class="line">user.<span class="built_in">set_name</span>(<span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">user.<span class="built_in">set_email</span>(<span class="string">&quot;johndoe@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">std::string data;</span><br><span class="line"><span class="comment">//接受一个std::string类型的引用作为输出参数</span></span><br><span class="line">user.<span class="built_in">SerializeToString</span>(&amp;data);</span><br></pre></td></tr></table></figure></li><li><p><strong>反序列化</strong>：创建一个<code>UserInfo</code>对象，并通过调用<code>ParseFromArray</code>或<code>ParseFromString</code>方法从字节流中恢复数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UserInfo user;</span><br><span class="line"><span class="keyword">if</span> (user.<span class="built_in">ParseFromString</span>(data)) &#123;</span><br><span class="line">    <span class="comment">// 成功解析后，可以访问user的字段了</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; user.<span class="built_in">id</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; user.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Email: &quot;</span> &lt;&lt; user.<span class="built_in">email</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 解析失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="repeated-限定修饰符"><a href="#repeated-限定修饰符" class="headerlink" title="repeated 限定修饰符"></a>repeated 限定修饰符</h4><p><strong><code>repeated</code>：</strong> 用于定义可重复字段的关键字，与数组或列表概念相似。</p><p>eg:</p><ul><li><strong>定义 .proto 文件：</strong></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">string</span> title = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">string</span> authors = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int32</span> year_published = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用生成的类：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;book.pb.h&quot;</span> <span class="comment">// 假设生成的文件名为book.pb.h</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddBookInfo</span><span class="params">(Book &amp;book)</span> </span>&#123;</span><br><span class="line">    book.<span class="built_in">set_title</span>(<span class="string">&quot;Example Book Title&quot;</span>);</span><br><span class="line">    book.<span class="built_in">add_authors</span>(<span class="string">&quot;Author One&quot;</span>);</span><br><span class="line">    book.<span class="built_in">add_authors</span>(<span class="string">&quot;Author Two&quot;</span>);</span><br><span class="line">    book.<span class="built_in">set_year_published</span>(<span class="number">2025</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Book book;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加书籍信息</span></span><br><span class="line">    <span class="built_in">AddBookInfo</span>(book);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问并打印书籍信息</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Title: &quot;</span> &lt;&lt; book.<span class="built_in">title</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Year Published: &quot;</span> &lt;&lt; book.<span class="built_in">year_published</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Authors:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; book.<span class="built_in">authors_size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; book.<span class="built_in">authors</span>(i) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p><strong>c++中的枚举类型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    Red = <span class="number">5</span>,<span class="comment">// 可以不给初始值, 默认为0</span></span><br><span class="line">    Green,</span><br><span class="line">    Yellow,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <strong>.proto 文件中：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    Red = <span class="number">0</span>;</span><br><span class="line">    Green = <span class="number">3</span>;<span class="comment">// 第一个元素以外的元素值可以随意指定</span></span><br><span class="line">    Yellow = <span class="number">6</span>;</span><br><span class="line">    Blue = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：第一个元素的元素值必须为0，元素之间使用<code>;</code></em></p><h4 id="Protobuf中包的概念"><a href="#Protobuf中包的概念" class="headerlink" title="Protobuf中包的概念"></a>Protobuf中包的概念</h4><p>Protobuf使用包的概念避免消息类型之间的命名冲突</p><p>eg:</p><p><strong>定义 .proto 文件:</strong></p><ul><li><p><strong>user_info.proto:</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> user.profile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">2</span>;</span><br><span class="line">    <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>order_info.proto:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package order.details;</span><br><span class="line"></span><br><span class="line">message OrderInfo &#123;</span><br><span class="line">    string product_name = 1;</span><br><span class="line">    int32 order_id = 2;</span><br><span class="line">    string customer_email = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>在C++中使用:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user_info.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;order_info.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用user.profile.UserInfo(需要指定命名空间)</span></span><br><span class="line">    user::profile::UserInfo user;</span><br><span class="line">    user.<span class="built_in">set_name</span>(<span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">    user.<span class="built_in">set_id</span>(<span class="number">1234</span>);</span><br><span class="line">    user.<span class="built_in">set_email</span>(<span class="string">&quot;johndoe@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;User Info:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; user.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; user.<span class="built_in">id</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Email: &quot;</span> &lt;&lt; user.<span class="built_in">email</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用order.details.OrderInfo</span></span><br><span class="line">    order::details::OrderInfo order;</span><br><span class="line">    order.<span class="built_in">set_product_name</span>(<span class="string">&quot;Example Product&quot;</span>);</span><br><span class="line">    order.<span class="built_in">set_order_id</span>(<span class="number">5678</span>);</span><br><span class="line">    order.<span class="built_in">set_customer_email</span>(<span class="string">&quot;customer@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nOrder Info:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Product Name: &quot;</span> &lt;&lt; order.<span class="built_in">product_name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Order ID: &quot;</span> &lt;&lt; order.<span class="built_in">order_id</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Customer Email: &quot;</span> &lt;&lt; order.<span class="built_in">customer_email</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Protobuf&quot;&gt;&lt;a href=&quot;#Protobuf&quot; class=&quot;headerlink&quot; title=&quot;Protobuf&quot;&gt;&lt;/a&gt;Protobuf&lt;/h3&gt;&lt;h4 id=&quot;Protobuf序列化的步骤&quot;&gt;&lt;a href=&quot;#Protobuf序列化的步骤&quot;</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="Protobuf" scheme="https://wangak.cc/tags/Protobuf/"/>
    
  </entry>
  
  <entry>
    <title>Shell基础</title>
    <link href="https://wangak.cc/posts/4544560.html"/>
    <id>https://wangak.cc/posts/4544560.html</id>
    <published>2025-03-11T07:52:05.000Z</published>
    <updated>2025-03-11T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shell基础"><a href="#Shell基础" class="headerlink" title="Shell基础"></a>Shell基础</h2><p>shell是一个命令行解释器，用于接收用户（应用程序）命令来调用系统内核。</p><ul><li><p><strong>脚本格式：</strong>以<strong><code>#!/bin/bash</code></strong>开头（指定解析器）</p></li><li><p><strong>执行方式：</strong></p><ul><li><p><strong><code>1.bash/sh + 绝对路径（相对路径）</code></strong></p></li><li><p><strong><code>2.绝对路径（相对路径）</code></strong></p><p>需要可执行(x)权限</p></li><li><p><strong><code>3.source + 绝对路径（相对路径）</code>:</strong> 在当前的shell下执行</p></li></ul></li></ul><p><strong>子shell：</strong>在子shell中设置的当前的环境变量，对于父shell不可见</p><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h3><h4 id="1-1-常用系统变量"><a href="#1-1-常用系统变量" class="headerlink" title="1.1 常用系统变量"></a>1.1 常用系统变量</h4><p><strong>常用系统变量：</strong>$HOME、$PWD、$USR、$SHELL、$PATH</p><p><code>env</code>: 列出当前 shell 的所有环境变量</p><p><code>set</code>: 显示所有 shell 变量（包括环境变量和局部变量）</p><p><code>printenv+环境变量名</code>: 输出某个环境变量的值</p><p><code>$PATH</code>: 保存了搜索系统命令的路径(<code>/usr/bin</code>)</p><h4 id="1-2-自定义变量"><a href="#1-2-自定义变量" class="headerlink" title="1.2 自定义变量"></a>1.2 自定义变量</h4><p><strong>自定义变量（局部变量）：</strong><code>变量名=变量值</code><strong>(等号前后不能有空格)</strong></p><p><strong>局部变量导出为全局变量：</strong><code>export + 变量名</code></p><p><em>注：在子shell中修改全局变量对父shell不可见</em></p><p><strong>只读变量：</strong><code>readonly 变量名=变量值</code></p><p><strong>撤销变量：</strong><code>unset + 变量名</code></p><p><em>注1：在bash中，变量默认的类型都是字符串类型，无法直接进行数值计算。</em></p><p><em>注2：只读变量不能unset。</em></p><h4 id="1-3-特殊变量"><a href="#1-3-特殊变量" class="headerlink" title="1.3 特殊变量"></a>1.3 特殊变量</h4><ul><li><code>$n</code>: n为数字，<code>$0</code>代表脚本名称，<code>$1</code>-<code>$9</code>代表第一到第九个参数，十个以上使用<code>&#123;&#125;</code>，如<code>$&#123;10&#125;</code>。</li><li><code>$#</code>: 获取所有输入参数的个数，常用于循环，判断参数的个数是否正确。</li><li><code>$*</code>: 获取命令行中的所有参数，并将其看成一个整体</li><li><p><code>$@</code>: 获取命令行中的所有参数，将其看作一个集合</p></li><li><p><code>$?</code>: 获取上一个命令的返回状态，返回0表示正常结束</p></li></ul><h3 id="2-运算"><a href="#2-运算" class="headerlink" title="2.运算"></a>2.运算</h3><h4 id="2-1-运算符"><a href="#2-1-运算符" class="headerlink" title="2.1 运算符"></a>2.1 运算符</h4><p><strong>语法格式：<code>$((运算式))</code>或<code>$[运算式]</code></strong></p><p><em>注：(( ))中可用使用数学表达式进行运算</em></p><p><strong>使用expr:</strong> <code>a=$(expr 5 \* 2)</code></p><h4 id="2-2-条件判断"><a href="#2-2-条件判断" class="headerlink" title="2.2 条件判断"></a>2.2 条件判断</h4><ul><li><p><strong><code>test +判断条件</code> :</strong> <code>test $a = 2</code></p></li><li><p><strong><code>[ 判断条件 ]</code></strong>: “[ ]”前后要有空格</p></li></ul><p><strong>判断条件：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503112004717.png" alt="image-20250311151642241" style="zoom:67%;"></p><p>​                                                      <img src="https://typoraimg.wangak.cc/2023/img/202503112004656.png" alt="image-20250311151752312" style="zoom:67%;"></p><p>​                                                  <img src="https://typoraimg.wangak.cc/2023/img/202503112004116.png" alt="image-20250311152111395" style="zoom:67%;"></p><p>​                                              <img src="https://typoraimg.wangak.cc/2023/img/202503112004470.png" alt="image-20250311152834726" style="zoom:67%;"></p><p><strong>eg:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断<span class="built_in">test</span>文件是否有读的权限</span></span><br><span class="line">[ -r test ]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断8是否小于2</span></span><br><span class="line">[ 8 -lt 2 ]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断目录是否存在</span></span><br><span class="line">[ -d /home/ubuntu/scripts ] </span><br></pre></td></tr></table></figure><p><strong>“[ ]”中的逻辑条件连接使用：<code>-a</code>(and)和<code>-o</code>(or)</strong></p><h4 id="2-3-流程控制"><a href="#2-3-流程控制" class="headerlink" title="2.3 流程控制"></a>2.3 流程控制</h4><p><strong>if判断</strong></p><ul><li><p><strong>单分支：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断 ];then</span><br><span class="line">程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p><strong>双分支:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断 ];then</span><br><span class="line">程序1</span><br><span class="line">else</span><br><span class="line">程序2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p><strong>多分支：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断1 ]</span><br><span class="line">then</span><br><span class="line">程序1</span><br><span class="line">elif [ 条件判断2 ]</span><br><span class="line">then</span><br><span class="line">程序2</span><br><span class="line">else</span><br><span class="line">程序3</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li></ul><p><strong>for循环</strong></p><p><strong>用法一：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sum=0</span><br><span class="line">for (( i=1 ;i &lt;= $1; i++))</span><br><span class="line">do</span><br><span class="line">        sum=$[ $sum + $i ]</span><br><span class="line">done</span><br><span class="line">echo sum=$sum</span><br></pre></td></tr></table></figure><p><strong>用法二：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3...</span><br><span class="line">do </span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sum=0</span><br><span class="line">for i in &#123;1..100&#125;</span><br><span class="line">do</span><br><span class="line">        sum=$[$sum + $i]</span><br><span class="line">done</span><br><span class="line">echo sum=$sum</span><br></pre></td></tr></table></figure><p><strong>while循环</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [条件判断式]</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="2-4-Read读取控制台的输入"><a href="#2-4-Read读取控制台的输入" class="headerlink" title="2.4 Read读取控制台的输入"></a>2.4 Read读取控制台的输入</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202503112004690.png" alt="image-20250311163511274" style="zoom:67%;"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置超时时间为 5 秒</span></span><br><span class="line">read -t 5 -p &quot;请在 5 秒内输入您的名字: &quot; name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查用户是否输入</span></span><br><span class="line">if [ -z &quot;$name&quot; ]; then</span><br><span class="line">    echo &quot;您未在规定时间内输入名字。&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;您好, $name! 欢迎使用本脚本。&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="2-5-函数"><a href="#2-5-函数" class="headerlink" title="2.5 函数"></a>2.5 函数</h4><p><strong>系统函数</strong></p><p><code>data +%s</code>: 输出时间戳</p><p><code>basename 路径 [后缀]</code>: 用于从文件路径中提取文件名或目录名，去除路径前缀和后缀</p><p><code>dirname 路径</code>: 用于从文件路径中提取目录部分，即去掉文件名，返回路径的父目录。</p><p><strong>自定义函数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名() &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">function add() &#123;</span><br><span class="line">    s=$[$1 + $2]</span><br><span class="line">    echo $s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;输入第一个数&quot; a</span><br><span class="line">read -p &quot;输入第二个数&quot; b</span><br><span class="line">sum=$(add $a $b)</span><br><span class="line">echo &quot;和:&quot;$sum</span><br></pre></td></tr></table></figure><p><em>注：不使用<code>$?</code>接受返回值，<code>$?</code>接收的范围为[0~255]</em></p><h4 id="2-6-正则表达式"><a href="#2-6-正则表达式" class="headerlink" title="2.6 正则表达式"></a>2.6 正则表达式</h4><ul><li><p><strong>常规匹配:</strong> 匹配常规字符”xxxx”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | grep xxxx</span><br></pre></td></tr></table></figure></li><li><p><strong>模糊匹配：</strong></p><ul><li><p><code>^</code>: 匹配一行的开头</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匹配所有以a开头的行</span></span><br><span class="line">cat /etc/passwd |grep ^a</span><br></pre></td></tr></table></figure></li><li><p><code>$</code>: 匹配一行的结束</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匹配所有以a结束的行</span></span><br><span class="line">cat /etc/passwd |grep a$</span><br></pre></td></tr></table></figure></li><li><p><code>.</code>: 匹配任意的字符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匹配所有r..t的行</span></span><br><span class="line">cat /etc/passwd |grep r..t</span><br></pre></td></tr></table></figure></li><li><p><code>*</code>: 不单独使用，与上一个字符连用，表示匹配上个字符的<strong>0次</strong>或多次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匹配rt,rot,root,rooot等所有行</span></span><br><span class="line">cat /etc/passwd |grep ro*t</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匹配以a开头，bash结尾,中间为任意字符的所有行</span></span><br><span class="line">cat /etc/passwd |grep ^a.*bash$</span><br></pre></td></tr></table></figure><ul><li><code>[ ]</code>: 匹配某个范围内的字符</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202503112004742.png" alt="image-20250311195601295" style="zoom:67%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Shell基础&quot;&gt;&lt;a href=&quot;#Shell基础&quot; class=&quot;headerlink&quot; title=&quot;Shell基础&quot;&gt;&lt;/a&gt;Shell基础&lt;/h2&gt;&lt;p&gt;shell是一个命令行解释器，用于接收用户（应用程序）命令来调用系统内核。&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="shell" scheme="https://wangak.cc/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>C++八股1</title>
    <link href="https://wangak.cc/posts/c2c0fb72.html"/>
    <id>https://wangak.cc/posts/c2c0fb72.html</id>
    <published>2025-03-10T16:00:00.000Z</published>
    <updated>2025-03-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-八股"><a href="#C-八股" class="headerlink" title="C++八股"></a>C++八股</h2><h4 id="1-在main执行之前和之后执行的代码可能是什么"><a href="#1-在main执行之前和之后执行的代码可能是什么" class="headerlink" title="1.在main执行之前和之后执行的代码可能是什么"></a><strong>1.在main执行之前和之后执行的代码可能是什么</strong></h4><ul><li><p>main函数执行之前，主要就是<strong>初始化系统相关资源</strong>：</p><ul><li>设置栈指针</li><li>初始化静态static变量和global全局变量</li><li>调用构造函数</li></ul></li><li><p>main函数执行之后：</p><ul><li>全局对象的析构函数</li></ul></li></ul><h4 id="2-指针和引用的区别"><a href="#2-指针和引用的区别" class="headerlink" title="2.指针和引用的区别"></a><strong>2.指针和引用的区别</strong></h4><ul><li><p><strong>指针是一个变量</strong>，存储的是一个地址，<strong>引用是原变量的别名</strong></p></li><li><p>指针可以为空，引用不能为NULL且在定义时必须初始化</p></li></ul><h4 id="3-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"><a href="#3-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？" class="headerlink" title="3.在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"></a><strong>3.在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</strong></h4><ul><li><strong>需要返回函数内局部变量的内存的时候用指针。</strong>指针作为函数参数，需要在堆上动态分配内存，在函数外部仍然可以访问这块内存。完要记得释放指针，不然会内存泄漏。</li><li>对栈空间大小比较敏感（比如递归）的时候使用引用。<strong>使用引用传递不需要创建临时变量，开销要更小</strong></li><li><strong>类对象作为参数传递的时候使用引用</strong>，这是C++类对象传递的标准方式</li></ul><h4 id="4-堆和栈的区别"><a href="#4-堆和栈的区别" class="headerlink" title="4.堆和栈的区别"></a><strong>4.堆和栈的区别</strong></h4><ul><li><p>申请<strong>方式</strong>不同。</p><ul><li>栈由系统自动分配。</li><li>堆是自己申请和释放的。</li></ul></li><li><p>申请<strong>大小限制</strong>不同。</p><ul><li><p>栈顶和栈底是之前预设好的，栈是向栈底扩展（从高地址向低地址扩展），大小固定</p><p>注：栈空间耗尽（例如递归调用过深），会导致 <strong>栈溢出</strong></p></li><li><p>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</p></li></ul></li><li><p>申请<strong>效率</strong>不同。</p><ul><li>栈由系统分配，<strong>速度快</strong>，不会有碎片。</li><li>堆由程序员分配，速度慢，且会有碎片。</li></ul></li></ul><h4 id="5-new-delete-与-malloc-free的异同"><a href="#5-new-delete-与-malloc-free的异同" class="headerlink" title="5.new / delete 与 malloc / free的异同"></a>5.new / delete 与 malloc / free的异同</h4><p><strong>相同点：</strong></p><ul><li>都可用于内存的动态申请和释放</li></ul><p><strong>不同点：</strong></p><ul><li>前者是C++运算符，后者是C/C++语言标准库函数。</li><li><code>new</code><strong>自动</strong>计算要分配的空间大小，<code>malloc</code>需要<strong>手工</strong>计算。</li><li><code>new</code> 在分配内存后会调用对象的构造函数初始化对象，在使用 <code>delete</code> 时则会先调用对象的析构函数再释放内存。后者均没有相关调用。</li><li><p><strong>new是类型安全的，malloc不是。</strong></p></li><li><p><code>new</code>是封装了<code>malloc</code>，直接<code>free</code>不会报错，但是这只是释放内存，而不会析构对象</p></li><li><p><strong>malloc和free返回的是void类型指针(void*)（必须进行类型转换）</strong>，new和delete返回的是具体类型指针。</p><p><em>注：虽然 <code>new</code> 和 <code>malloc</code> 都能用于内存的动态分配，但由于C++中面向对象特性的引入，<code>new</code> 提供了更高级、更安全的内存管理机制，包括自动计算内存大小、类型安全性和自动调用构造函数与析构函数等特性。</em></p></li></ul><p><code>new/delete</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个整型对象</span></span><br><span class="line"><span class="type">int</span>* pInt = <span class="keyword">new</span> <span class="type">int</span>; </span><br><span class="line">*pInt = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放该对象</span></span><br><span class="line"><span class="keyword">delete</span> pInt;</span><br></pre></td></tr></table></figure><p><code>malloc/free</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配空间用于存储一个整型值，并将其初始化为10</span></span><br><span class="line"><span class="type">int</span>* pInt = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*pInt = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放该对象</span></span><br><span class="line"><span class="built_in">free</span>(pInt);</span><br></pre></td></tr></table></figure><h4 id="6-new和delete是如何实现的？"><a href="#6-new和delete是如何实现的？" class="headerlink" title="6.new和delete是如何实现的？"></a>6.new和delete是如何实现的？</h4><p><strong>new：</strong></p><ul><li><strong>分配内存：</strong>调用名为<strong>operator new</strong>的标准库函数</li><li><strong>初始化构造对象：</strong>调用构造函数</li><li><strong>返回指针：</strong>返回指向新分配并构造后的的对象的指针</li></ul><p><strong>delete：</strong></p><ul><li><strong>调用析构函数</strong></li><li><strong>释放所用内存：</strong>调用名为<strong>operator delete</strong>的标准库函数释放所用内存</li></ul><h4 id="7-被free回收的内存是立即返还给操作系统吗？"><a href="#7-被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="7.被free回收的内存是立即返还给操作系统吗？"></a>7.被free回收的内存是立即返还给操作系统吗？</h4><p>​    不是的，被free回收的内存会首先被ptmalloc使用<strong>双链表保存</strong>起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就<strong>避免了频繁的系统调用</strong>，占用过多的系统资源。同时ptmalloc也会尝试对小块<strong>内存进行合并</strong>，<strong>避免过多的内存碎片。</strong></p><h4 id="8-宏定义和函数有何区别？"><a href="#8-宏定义和函数有何区别？" class="headerlink" title="8.宏定义和函数有何区别？"></a>8.宏定义和函数有何区别？</h4><ul><li><strong>宏在编译时完成替换</strong>，<strong>执行起来更快</strong>；函数调用在运行时需要跳转到具体调用函数。</li><li>宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。 </li><li>宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。</li></ul><h4 id="9-宏定义和typedef区别？"><a href="#9-宏定义和typedef区别？" class="headerlink" title="9.宏定义和typedef区别？"></a>9.宏定义和typedef区别？</h4><ul><li><p><strong>typedef主要用于定义类型别名。</strong></p></li><li><p>宏替换发生在编译阶段之前（预处理阶段），属于文本插入替换；<strong>typedef是编译的一部分。</strong></p></li><li>宏不检查类型；typedef会检查数据类型。</li></ul><h4 id="10-strlen和sizeof区别？"><a href="#10-strlen和sizeof区别？" class="headerlink" title="10.strlen和sizeof区别？"></a>10.strlen和sizeof区别？</h4><ul><li><p><strong><code>sizeof</code>是运算符</strong>，并不是函数，结果<strong>在编译时得到而非运行中获得</strong>；<code>strlen</code>是字符处理的库函数。</p></li><li><p><strong><code>sizeof</code>参数可以是任何数据类型或数据；<code>strlen</code>的参数只能是字符指针且结尾是’\0’的字符串</strong>：</p></li><li>因为<code>sizeof</code>值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。 </li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sizeof</span>(str); <span class="comment">// 取的是指针str的长度，是8</span></span><br><span class="line">    <span class="built_in">strlen</span>(str); <span class="comment">// 取的是这个字符串的长度，不包含结尾的 \0。大小是4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-常量指针和指针常量区别"><a href="#11-常量指针和指针常量区别" class="headerlink" title="11.常量指针和指针常量区别"></a>11.常量指针和指针常量区别</h4><ul><li>指针常量，如<code>int const *p</code>或<code>const int *p</code>，是一个指针指向一个只读变量。</li><li>常量指针是一个不能给改变指向的指针,<code>int *const p</code></li></ul><h4 id="12-数组名-a和取地址操作符-amp-a有什么区别"><a href="#12-数组名-a和取地址操作符-amp-a有什么区别" class="headerlink" title="12.数组名 a和取地址操作符 &amp;a有什么区别?"></a>12.数组名 <code>a</code>和取地址操作符 <code>&amp;a</code>有什么区别?</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C++</span><br><span class="line">假设数组</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">10</span>] = &amp;a;</span><br></pre></td></tr></table></figure><p><strong>数组名 <code>a</code>:</strong></p><ul><li><strong>作为首元素的指针</strong>：指向数组第一个元素</li><li><strong>加法运算</strong>：<code>a + 1</code>，它会<strong>根据数组元素的数据类型</strong>（在这个例子中是 <code>int</code>）来增加地址,<code>a + 1</code> 将会指向下一个 <code>int</code> 的位置</li></ul><p><strong>取地址操作符 <code>&amp;a</code>:</strong></p><ul><li><strong>指向整个数组的指针</strong>：<code>&amp;a + 1</code>，它会跳过整个数组的长度（即10个 <code>int</code> 的大小），指向数组最后一个元素之后的位置。</li></ul><h4 id="13-C-中struct和class的区别"><a href="#13-C-中struct和class的区别" class="headerlink" title="13.C++中struct和class的区别"></a>13.C++中struct和class的区别</h4><p><strong>相同点:</strong></p><ul><li>两者都拥有成员函数、公有和私有部分</li><li>任何可以使用class完成的工作，同样可以使用struct完成</li></ul><p><strong>不同点：</strong></p><ul><li>两者中如果不对成员不指定公私有，<strong>struct默认是公有的</strong>，<strong>class则默认是私有的</strong></li><li>class默认是private继承，而struct模式是public继承</li><li>struct一般用于描述一个数据结构的集合，而class是对一个对象数据的封装</li></ul><h4 id="14-C-代码生成可执行文件的过程有几个阶段？"><a href="#14-C-代码生成可执行文件的过程有几个阶段？" class="headerlink" title="14.C++代码生成可执行文件的过程有几个阶段？"></a>14.C++代码生成可执行文件的过程有几个阶段？</h4><ul><li><strong>预处理：</strong> 预处理器会处理源代码中的预处理指令，如<code>#include</code>、<code>#define</code>等。</li><li><strong>编译：</strong> 经过预处理后的代码翻译成特定于目标机器的汇编语言代码，这个过程进行了语法检查，每个源文件都会被单独编译成一个对象文件（.obj或.o文件）。。</li><li><strong>汇编：</strong> 汇编器将编译阶段生成的汇编代码转换为目标机器的二进制指令集</li><li><strong>链接：</strong> 链接器负责将编译阶段产生的多个对象文件合并成一个最终的可执行文件。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-八股&quot;&gt;&lt;a href=&quot;#C-八股&quot; class=&quot;headerlink&quot; title=&quot;C++八股&quot;&gt;&lt;/a&gt;C++八股&lt;/h2&gt;&lt;h4 id=&quot;1-在main执行之前和之后执行的代码可能是什么&quot;&gt;&lt;a href=&quot;#1-在main执行之前和之后执行的代码</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="八股" scheme="https://wangak.cc/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>docker基础</title>
    <link href="https://wangak.cc/posts/5ae6092.html"/>
    <id>https://wangak.cc/posts/5ae6092.html</id>
    <published>2025-03-10T07:52:05.000Z</published>
    <updated>2025-03-10T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-docker与VM"><a href="#1-docker与VM" class="headerlink" title="1.docker与VM"></a>1.docker与VM</h4><p><strong>docker的作用：</strong>实现跨平台的快速运行应用</p><p><strong>docker为什么比VM快？</strong></p><p><strong>docker有着比虚拟机更少的抽象层：</strong>docker 容器共享宿主机的操作系统内核，不需要为每个容器启动一个完整的操作系统实例。而虚拟机需要为每个虚拟机启动一个完整的操作系统实例，这会占用更多的内存和 CPU 资源。</p><p><strong>区别：</strong></p><ul><li><strong>虚拟机：</strong>虚拟机是通过Hypervisor(虚拟机管理系统，常见的有VMWare、workstation、VirtualBox)，虚拟出网卡、cpu、内存等虚拟硬件，再在其上建立虚拟机，每个虚拟机是个独立的操作系统，拥有自己的<strong>系统内核(GuestOS)</strong>。</li><li><strong>容器：</strong>容器是利用<strong>namespace</strong>将文件系统、进程、网络、设备等资源进行隔离，利用<strong>cgroup</strong>对权限、cpu资源进行限制，最终让容器之间互不影响，容器无法影响宿主机。</li></ul><h4 id="2-docker基本组成"><a href="#2-docker基本组成" class="headerlink" title="2.docker基本组成"></a>2.docker基本组成</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202503101222301.png" alt="image-20250310122147161" style="zoom: 50%;"></p><h4 id="3-docker常用指令"><a href="#3-docker常用指令" class="headerlink" title="3.docker常用指令"></a>3.docker常用指令</h4><p><code>docker images</code>:查看容器列表</p><p><strong>启动容器：</strong></p><p><code>docker run [-d]  [--name] [-p] [-v] [--network] 容器名（指定） 容器 [-e]</code></p><p><code>docker run -d --name mynginx -p 88:80 -v /app/nghtml:/usr/share/nginx/html nginx</code></p><ul><li><p><code>-d:</code> 后台启动容器</p></li><li><p><code>--name:</code> 指定容器的名字</p></li><li><p><code>-p</code>: 端口映射，如<code>-p 88:80</code>(将内部端口80映射到外部端口88)</p></li><li><p><code>-v</code>: 目录挂载(挂载后的目录要修改权限) </p></li><li><p><strong>卷映射：</strong><code>-v ngconf:/etc/nginx</code></p><p><em>注：卷的存储位置：/var/lib/docker/volumes/&lt;卷名&gt;</em></p></li><li><p><code>--network</code>: 指定自定义网络</p></li><li><p><code>-e</code> :设置环境变量</p></li></ul><p><strong><em>注：目录挂载和卷映射的目的都是数据持久化，其允许容器和主机之间共享数据。</em></strong></p><p><strong>删除容器：</strong></p><p><code>rm [-f] 容器id</code> : 不加<code>-f</code>不能删除正在运行的容器</p><p><strong>进入容器：</strong></p><p><code>docker exec [-it] &lt;容器名&gt; /bin/bash</code></p><p><code>docker exec -it mynginx /bin/bash</code></p><p><strong>删除镜像：</strong></p><p><code>docker rmi  &lt;镜像名&gt;</code></p><p><strong>保存镜像：</strong></p><ul><li><p><strong>提交：</strong><code>docker commit</code></p><p><code>docker commit -m &quot;update index.html&quot; mynginx mynginx:v1.0</code></p></li><li><p><strong>保存：</strong><code>docker save</code></p></li></ul><p>​    <code>docker save -o mynginx.tar mynginx:v1.0</code></p><ul><li><p><strong>加载：</strong><code>docker load -i &lt;镜像包&gt;</code></p><p><code>docker load -i mynginx.tar</code></p></li></ul><p><strong>docker自定义网络：</strong>实现容器之间的相互访问</p><ul><li><p><strong>创建网络：</strong><code>docker network create mynet</code></p></li><li><p><strong>查看容器ip:</strong><code>docker inspect app1</code></p></li><li><p><strong>容器1\<app1>访问容器2\<app2>:</app2></app1></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it app1 bash</span><br><span class="line">curl http://app2:80</span><br></pre></td></tr></table></figure><p><em>注1：这里的80是内部端口号</em></p><p><em>注2：docker为每个容器分配唯一ip，使用容器ip+容器端口可以互相访问。但由于ip可能会变化，可以创建自定义网络，<strong>容器名可以当作稳定的域名进行访问。</strong></em></p></li></ul><h4 id="4-docker-compose"><a href="#4-docker-compose" class="headerlink" title="4.docker compose"></a>4.docker compose</h4><p>利用docker compose可以快速启动或停止所有服务</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 定义数据库服务</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db_data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/myconf:/etc/mysql/conf.d</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blog</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 定义WordPress服务</span></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_NAME:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">wordpress:/var/www/html</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db_data:</span> </span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">blog:</span></span><br></pre></td></tr></table></figure><p><strong>启动docker compose:</strong> <code>docker compose -f compose.yaml up -d</code></p><p><strong>下线docker compose:</strong> <code>docker compose -f compose.yaml down -d</code></p><h4 id="5-Dockerfile"><a href="#5-Dockerfile" class="headerlink" title="5.Dockerfile"></a>5.Dockerfile</h4><p><strong>Dockerfile的常见指令：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503101933618.png" alt="image-20250310190804854" style="zoom: 50%;"></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">17</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> author=aaa</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.jar /app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>构建镜像：</strong><code>docker build -f Dockerfile -t myjavaapp:v1.0 .</code></p><p>注：<code>-t</code>: 给镜像打上标签，<code>myjavaapp</code>是镜像名，<code>v1.0</code>是版本号</p><p><strong>镜像分层机制：</strong></p><ul><li><p><strong>基础层:</strong> 每个Docker镜像都始于一个基础层，这个基础层通常是操作系统的基础镜像，比如Ubuntu、Alpine等。</p></li><li><p><strong>中间层:</strong> 在基础层之上，你可以添加多个中间层。每执行一条指令（如安装软件包、复制文件等），都会创建一个新的层。这些层按照指令执行的顺序堆叠在一起。</p></li><li><strong>可写层: </strong>Docker会在镜像的最上层添加一个可写的容器层。在这个层中，可以进行修改（如写入数据、更改配置等）。但这些<strong>修改仅限于该容器，不会影响到原始镜像</strong>或其他使用同一镜像启动的容器。</li></ul><p><strong><em>注：镜像分层机制允许不同的镜像共享相同的层，减少了重复数据的存储需求。</em></strong></p><p><code>ARG DEBIAN_FRONTEND=noninteractive</code>: 禁用软件包安装时的交互式提示，确保自动化构建过程不会中断。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-docker与VM&quot;&gt;&lt;a href=&quot;#1-docker与VM&quot; class=&quot;headerlink&quot; title=&quot;1.docker与VM&quot;&gt;&lt;/a&gt;1.docker与VM&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;docker的作用：&lt;/strong&gt;实现跨平台的快</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
    <category term="docker" scheme="https://wangak.cc/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>C++设计模式</title>
    <link href="https://wangak.cc/posts/9725cb23.html"/>
    <id>https://wangak.cc/posts/9725cb23.html</id>
    <published>2024-11-26T16:00:00.000Z</published>
    <updated>2024-11-27T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="1-模板模式"><a href="#1-模板模式" class="headerlink" title="1.模板模式"></a>1.模板模式</h3><p><strong>应用场景：</strong>算法所需的关键步骤已知，但具体实现未知</p><ul><li><strong>抽象类</strong>：定义算法的主体框架，具体实现由子类完成</li><li><strong>具体子类</strong>：提供步骤的具体实现</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 抽象类，定义了模板方法和步骤</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 模板方法，定义了制作饮料的步骤</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prepareRecipe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">boilWater</span>();</span><br><span class="line">        <span class="built_in">brew</span>();             <span class="comment">// 抽象步骤，由子类实现</span></span><br><span class="line">        <span class="built_in">pourInCup</span>();</span><br><span class="line">        <span class="built_in">addCondiments</span>();    <span class="comment">// 抽象步骤，由子类实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本步骤，不需要子类改变</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Boiling water...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pouring into cup...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象步骤，由子类实现具体逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Beverage</span>() = <span class="keyword">default</span>; <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体类：茶</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> Beverage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">brew</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Steeping the tea...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addCondiments</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Adding lemon...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体类：咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> Beverage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">brew</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dripping coffee through filter...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addCondiments</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Adding sugar and milk...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数演示模板方法的使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Tea tea;</span><br><span class="line">    Coffee coffee;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Making tea:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    tea.<span class="built_in">prepareRecipe</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nMaking coffee:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    coffee.<span class="built_in">prepareRecipe</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-策略模式"><a href="#2-策略模式" class="headerlink" title="2.策略模式"></a>2.策略模式</h3><p><strong>应用场景：</strong>在需要动态选择不同算法的场景，如有大量的<strong><code>if-else</code></strong>语句时，可以使用策略模式来进行优化。策略模式使不同的算法实现独立于使用它们的客户端进行管理和调用。</p><ul><li><p><strong>策略接口</strong>：定义算法的<strong>公共接口。</strong></p></li><li><p><strong>具体策略类</strong>：实现策略接口的不同算法。<strong>（对于同一个任务有不同的算法）</strong></p></li><li><p><strong>上下文类</strong>：持有一个策略对象的引用，并在客户端需要时调用策略对象的算法。</p></li></ul><p><strong>计算支付金额的例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略接口，定义算法接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PaymentStrategy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">int</span> amount)</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 定义一个纯虚函数，具体策略类实现该方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略类：信用卡支付</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreditCardPayment</span> : <span class="keyword">public</span> PaymentStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">int</span> amount)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Paid &quot;</span> &lt;&lt; amount &lt;&lt; <span class="string">&quot; using Credit Card.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略类：PayPal支付</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PayPalPayment</span> : <span class="keyword">public</span> PaymentStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">int</span> amount)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Paid &quot;</span> &lt;&lt; amount &lt;&lt; <span class="string">&quot; using PayPal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略类：比特币支付</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BitcoinPayment</span> : <span class="keyword">public</span> PaymentStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">int</span> amount)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Paid &quot;</span> &lt;&lt; amount &lt;&lt; <span class="string">&quot; using Bitcoin.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类，使用策略进行支付</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentContext</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;PaymentStrategy&gt; strategy;  <span class="comment">// 使用智能指针管理策略对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 设置策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(std::unique_ptr&lt;PaymentStrategy&gt; newStrategy)</span> </span>&#123;</span><br><span class="line">        strategy = std::<span class="built_in">move</span>(newStrategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行支付</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executePayment</span><span class="params">(<span class="type">int</span> amount)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strategy) &#123;</span><br><span class="line">            strategy-&gt;<span class="built_in">pay</span>(amount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No payment strategy set!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数演示策略模式的使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PaymentContext context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用信用卡支付</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(std::<span class="built_in">make_unique</span>&lt;CreditCardPayment&gt;());</span><br><span class="line">    context.<span class="built_in">executePayment</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用PayPal支付</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(std::<span class="built_in">make_unique</span>&lt;PayPalPayment&gt;());</span><br><span class="line">    context.<span class="built_in">executePayment</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用比特币支付</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(std::<span class="built_in">make_unique</span>&lt;BitcoinPayment&gt;());</span><br><span class="line">    context.<span class="built_in">executePayment</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-观察者模式"><a href="#3-观察者模式" class="headerlink" title="3.观察者模式"></a>3.观察者模式</h3><p>当⼀个对象的改变需要同时改变其他对象，且不知道具体有多少对象有待改变时，应该考虑使⽤观察者模式。在观察者模式中，<strong>主体是通知的发布者</strong>，它发出通知时并不需要知道谁是它的观察者，<strong>可以有任意数目的观察者订阅并接收通知。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 定义一个纯虚函数，子类必须实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题类（被观察者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Observer*&gt; observers;  <span class="comment">// 保存观察者的列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Observer* observer)</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">(Observer* observer)</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(observers.<span class="built_in">begin</span>(), observers.<span class="built_in">end</span>(), observer), observers.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer* observer : observers) &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">update</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteObserver</span>(<span class="type">const</span> std::string&amp; observerName) : <span class="built_in">name</span>(observerName) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Observer &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; has been notified!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数演示</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建具体观察者</span></span><br><span class="line">    <span class="function">ConcreteObserver <span class="title">observer1</span><span class="params">(<span class="string">&quot;Observer 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ConcreteObserver <span class="title">observer2</span><span class="params">(<span class="string">&quot;Observer 2&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将观察者附加到主题</span></span><br><span class="line">    subject.<span class="built_in">attach</span>(&amp;observer1);</span><br><span class="line">    subject.<span class="built_in">attach</span>(&amp;observer2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知所有观察者</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Notifying observers...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    subject.<span class="built_in">notify</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除一个观察者</span></span><br><span class="line">    subject.<span class="built_in">detach</span>(&amp;observer1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次通知剩余的观察者</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Notifying observers after detaching one observer...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    subject.<span class="built_in">notify</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-装饰模式"><a href="#4-装饰模式" class="headerlink" title="4.装饰模式"></a>4.装饰模式</h3><p><strong>应用场景：</strong>通过组合来实现功能的扩展（通过减少继承关系，来减少代码冗余），允许向一个对象动态地添加新的行为，而不会影响其他同类对象。</p><p><strong>主要结构:</strong>装饰模式的组合是用于递归地增强对象的功能。</p><ul><li><strong>组件接口:</strong> 定义了可以被装饰的对象的接口。</li><li><strong>具体组件:</strong> 实现了组件接口，代表被装饰的对象。</li><li><strong>装饰器:</strong> 实现了组件接口，并持有一个组件对象的引用，可以在保持接口一致的情况下扩展组件的功能。</li><li><strong>具体装饰器:</strong> 继承自装饰器，实现具体的装饰功能。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件接口，定义对象的基础操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Component</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 定义了一个纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体组件，实现了组件接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Plain Text&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器基类，继承自组件接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::shared_ptr&lt;Component&gt; component;  <span class="comment">// 持有组件对象的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Decorator</span>(std::shared_ptr&lt;Component&gt; comp) : <span class="built_in">component</span>(comp) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (component) &#123;</span><br><span class="line">            component-&gt;<span class="built_in">operation</span>();  <span class="comment">// 转发给被装饰的组件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰器：加粗文本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BoldDecorator</span> : <span class="keyword">public</span> Decorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BoldDecorator</span>(std::shared_ptr&lt;Component&gt; comp) : <span class="built_in">Decorator</span>(comp) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&lt;b&gt;&quot;</span>;</span><br><span class="line">        Decorator::<span class="built_in">operation</span>();  <span class="comment">// 调用基础组件的操作</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&lt;/b&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰器：斜体文本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ItalicDecorator</span> : <span class="keyword">public</span> Decorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ItalicDecorator</span>(std::shared_ptr&lt;Component&gt; comp) : <span class="built_in">Decorator</span>(comp) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&lt;i&gt;&quot;</span>;</span><br><span class="line">        Decorator::<span class="built_in">operation</span>();  <span class="comment">// 调用基础组件的操作</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&lt;/i&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数演示装饰模式的使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建基础组件</span></span><br><span class="line">    std::shared_ptr&lt;Component&gt; text = std::<span class="built_in">make_shared</span>&lt;ConcreteComponent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将组件装饰为加粗文本</span></span><br><span class="line">    std::shared_ptr&lt;Component&gt; boldText = std::<span class="built_in">make_shared</span>&lt;BoldDecorator&gt;(text);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将组件装饰为斜体和加粗文本</span></span><br><span class="line">    std::shared_ptr&lt;Component&gt; italicBoldText = std::<span class="built_in">make_shared</span>&lt;ItalicDecorator&gt;(boldText);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Decorated text: &quot;</span>;</span><br><span class="line">    italicBoldText-&gt;<span class="built_in">operation</span>();  <span class="comment">// 输出 &lt;i&gt;&lt;b&gt;Plain Text&lt;/b&gt;&lt;/i&gt;</span></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-桥模式"><a href="#5-桥模式" class="headerlink" title="5.桥模式"></a>5.桥模式</h3><p><strong>应用场景：</strong>适用于需要分离抽象和实现，使它们可以分别进行扩展的场景。例如，图形绘制系统中形状（如圆、矩形）和颜色（如红色、蓝色）的组合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口（Implementor），定义绘制行为</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Color</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">applyColor</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数，具体实现由子类提供</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现类：红色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedColor</span> : <span class="keyword">public</span> Color &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">applyColor</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Red&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现类：蓝色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlueColor</span> : <span class="keyword">public</span> Color &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">applyColor</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Blue&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类（Abstraction），定义形状</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::shared_ptr&lt;Color&gt; color;  <span class="comment">// 持有实现接口的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>(std::shared_ptr&lt;Color&gt; col) : <span class="built_in">color</span>(col) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数，具体实现由子类提供</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展抽象类（RefinedAbstraction）：圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(std::shared_ptr&lt;Color&gt; col) : <span class="built_in">Shape</span>(col) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Circle drawn in &quot;</span>;</span><br><span class="line">        color-&gt;<span class="built_in">applyColor</span>();  <span class="comment">// 使用实现接口的功能</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; color.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展抽象类（RefinedAbstraction）：正方形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Square</span>(std::shared_ptr&lt;Color&gt; col) : <span class="built_in">Shape</span>(col) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Square drawn in &quot;</span>;</span><br><span class="line">        color-&gt;<span class="built_in">applyColor</span>();  <span class="comment">// 使用实现接口的功能</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; color.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数演示桥模式的使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建红色实现并绘制圆形</span></span><br><span class="line">    std::shared_ptr&lt;Color&gt; red = std::<span class="built_in">make_shared</span>&lt;RedColor&gt;();</span><br><span class="line">    std::shared_ptr&lt;Shape&gt; redCircle = std::<span class="built_in">make_shared</span>&lt;Circle&gt;(red);</span><br><span class="line">    redCircle-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建蓝色实现并绘制正方形</span></span><br><span class="line">    std::shared_ptr&lt;Color&gt; blue = std::<span class="built_in">make_shared</span>&lt;BlueColor&gt;();</span><br><span class="line">    std::shared_ptr&lt;Shape&gt; blueSquare = std::<span class="built_in">make_shared</span>&lt;Square&gt;(blue);</span><br><span class="line">    blueSquare-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-工厂方法"><a href="#6-工厂方法" class="headerlink" title="6.工厂方法"></a>6.工厂方法</h3><p><strong>应用场景：</strong>希望添加新产品时，只需添加新产品类和具体工厂类</p><ul><li><p><strong>抽象产品</strong>：定义产品的接口。</p></li><li><p><strong>具体产品</strong>：实现抽象产品接口的具体类。</p></li><li><p><strong>抽象工厂</strong>：声明工厂方法。</p></li><li><p><strong>具体工厂</strong>：实现工厂方法，返回具体产品实例。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品（Product）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Document</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">open</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Document</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：文本文档（ConcreteProduct）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextDocument</span> : <span class="keyword">public</span> Document &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Opening a text document.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：图像文档（ConcreteProduct）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageDocument</span> : <span class="keyword">public</span> Document &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Opening an image document.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂（Creator）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DocumentCreator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;Document&gt; <span class="title">createDocument</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">DocumentCreator</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂：文本文档工厂（ConcreteCreator）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextDocumentCreator</span> : <span class="keyword">public</span> DocumentCreator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Document&gt; <span class="title">createDocument</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;TextDocument&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂：图像文档工厂（ConcreteCreator）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageDocumentCreator</span> : <span class="keyword">public</span> DocumentCreator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Document&gt; <span class="title">createDocument</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;ImageDocument&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">openDocument</span><span class="params">(<span class="type">const</span> DocumentCreator&amp; creator)</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Document&gt; doc = creator.<span class="built_in">createDocument</span>();</span><br><span class="line">    doc-&gt;<span class="built_in">open</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TextDocumentCreator textCreator;</span><br><span class="line">    ImageDocumentCreator imageCreator;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using the text document creator:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">openDocument</span>(textCreator);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nUsing the image document creator:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">openDocument</span>(imageCreator);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-抽象工厂"><a href="#7-抽象工厂" class="headerlink" title="7.抽象工厂"></a>7.抽象工厂</h3><p>抽象工厂可以理解为在工厂方法的基础上再做一层的扩展。</p><p><strong>模式结构：</strong></p><ul><li><strong>抽象工厂</strong>：定义创建一系列相关对象的接口。</li><li><strong>具体工厂</strong>：实现抽象工厂接口，生成具体产品的实例。</li><li><strong>抽象产品</strong>：为每种产品声明接口。</li><li><strong>具体产品</strong>：实现抽象产品接口。</li><li><strong>客户端</strong>：使用抽象工厂和抽象产品接口来创建具体对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品：按钮</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">paint</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Button</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：Windows 按钮</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsButton</span> : <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rendering a button in Windows style.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：macOS 按钮</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButton</span> : <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rendering a button in macOS style.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品：文本框</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBox</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TextBox</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：Windows 文本框</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsTextBox</span> : <span class="keyword">public</span> TextBox &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Displaying a text box in Windows style.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：macOS 文本框</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacTextBox</span> : <span class="keyword">public</span> TextBox &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Displaying a text box in macOS style.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂：GUI 工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;Button&gt; <span class="title">createButton</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;TextBox&gt; <span class="title">createTextBox</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">GUIFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂：Windows 工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsFactory</span> : <span class="keyword">public</span> GUIFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Button&gt; <span class="title">createButton</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;WindowsButton&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;TextBox&gt; <span class="title">createTextBox</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;WindowsTextBox&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂：macOS 工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacFactory</span> : <span class="keyword">public</span> GUIFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Button&gt; <span class="title">createButton</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MacButton&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;TextBox&gt; <span class="title">createTextBox</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MacTextBox&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildInterface</span><span class="params">(<span class="type">const</span> GUIFactory&amp; factory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> button = factory.<span class="built_in">createButton</span>();</span><br><span class="line">    <span class="keyword">auto</span> textBox = factory.<span class="built_in">createTextBox</span>();</span><br><span class="line">    </span><br><span class="line">    button-&gt;<span class="built_in">paint</span>();</span><br><span class="line">    textBox-&gt;<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WindowsFactory windowsFactory;</span><br><span class="line">    MacFactory macFactory;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Building Windows interface:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">buildInterface</span>(windowsFactory);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nBuilding macOS interface:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">buildInterface</span>(macFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-原型模式"><a href="#8-原型模式" class="headerlink" title="8.原型模式"></a>8.原型模式</h3><p>通过复制现有对象来创建新的对象，而不是通过实例化类来创建。</p><p><strong>模式结构:</strong></p><ul><li><p><strong>抽象原型</strong>：定义一个接口，用于复制自身。</p></li><li><p><strong>具体原型</strong>：实现复制自身的方法。</p></li><li><p><strong>客户端</strong>：通过调用原型对象的 <code>clone</code> 方法来创建新的对象。</p></li></ul><p><strong>示例：</strong></p><p>一个简单的图形编辑器，需要频繁创建和复制不同类型的图形（如圆形和矩形）。在未使用原型模式的情况下，要会使用 <code>new</code> 关键字手动创建对象。使用原型模式后，可以更灵活地通过克隆已有对象来创建新对象。</p><p><strong><em>没有使用原型模式的实现：</em></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图形基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体图形：圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">int</span> r) : <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle with radius: &quot;</span> &lt;&lt; radius &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体图形：矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> width, height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">int</span> w, <span class="type">int</span> h) : <span class="built_in">width</span>(w), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle with width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="string">&quot; and height: &quot;</span> &lt;&lt; height &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码，手动创建对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Shape&gt; shape1 = std::<span class="built_in">make_unique</span>&lt;Circle&gt;(<span class="number">5</span>);</span><br><span class="line">    std::unique_ptr&lt;Shape&gt; shape2 = std::<span class="built_in">make_unique</span>&lt;Rectangle&gt;(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    shape1-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    shape2-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 想要复制时，需要手动创建</span></span><br><span class="line">    std::unique_ptr&lt;Shape&gt; anotherCircle = std::<span class="built_in">make_unique</span>&lt;Circle&gt;(<span class="number">5</span>);</span><br><span class="line">    anotherCircle-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>使用原型模式的实现：</em></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;Shape&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 克隆方法</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型：圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">int</span> r) : <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle with radius: &quot;</span> &lt;&lt; radius &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Shape&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Circle&gt;(*<span class="keyword">this</span>);  <span class="comment">// 使用复制构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型：矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> width, height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">int</span> w, <span class="type">int</span> h) : <span class="built_in">width</span>(w), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle with width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="string">&quot; and height: &quot;</span> &lt;&lt; height &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Shape&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Rectangle&gt;(*<span class="keyword">this</span>);  <span class="comment">// 使用复制构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码，通过克隆创建对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Shape&gt; originalCircle = std::<span class="built_in">make_unique</span>&lt;Circle&gt;(<span class="number">5</span>);</span><br><span class="line">    std::unique_ptr&lt;Shape&gt; originalRectangle = std::<span class="built_in">make_unique</span>&lt;Rectangle&gt;(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    originalCircle-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    originalRectangle-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原型克隆对象</span></span><br><span class="line">    std::unique_ptr&lt;Shape&gt; clonedCircle = originalCircle-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    std::unique_ptr&lt;Shape&gt; clonedRectangle = originalRectangle-&gt;<span class="built_in">clone</span>();</span><br><span class="line"></span><br><span class="line">    clonedCircle-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    clonedRectangle-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-构建器模式"><a href="#9-构建器模式" class="headerlink" title="9.构建器模式"></a>9.构建器模式</h3><p><strong>应用场景：</strong>适用于构建复杂对象，特别是当对象包含多个可选或可变部分时。</p><p><strong>结构：</strong></p><ul><li><strong>产品类</strong>：需要构建的复杂对象。</li><li><strong>构建器接口</strong>：定义构建产品各个部分的<strong>方法</strong>。</li><li><strong>具体构建器</strong>：实现 <code>Builder</code> 接口并提供构建产品的方法<strong>（可扩展的具体实现，与产品类用组合代替继承）</strong>。</li><li><strong>指挥者</strong>：使用 <code>Builder</code> 来控制构建过程的顺序<strong>（步骤，可扩展）</strong>。</li><li><strong>客户端</strong>：创建 <code>Builder</code> 和 <code>Director</code>，并启动构建过程。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string engine;</span><br><span class="line">    std::string wheels;</span><br><span class="line">    std::string body;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showCar</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Car with engine: &quot;</span> &lt;&lt; engine &lt;&lt; <span class="string">&quot;, wheels: &quot;</span> &lt;&lt; wheels &lt;&lt; <span class="string">&quot;, body: &quot;</span> &lt;&lt; body &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象构建器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CarBuilder</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildEngine</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildWheels</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildBody</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Car&gt; <span class="title">getCar</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体构建器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SportsCarBuilder</span> : <span class="keyword">public</span> CarBuilder &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Car&gt; car;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SportsCarBuilder</span>() &#123;</span><br><span class="line">        car = std::<span class="built_in">make_shared</span>&lt;Car&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildEngine</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        car-&gt;engine = <span class="string">&quot;V8 Engine&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildWheels</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        car-&gt;wheels = <span class="string">&quot;Sports Wheels&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildBody</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        car-&gt;body = <span class="string">&quot;Sleek Sports Body&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Car&gt; <span class="title">getCar</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指挥者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(std::shared_ptr&lt;CarBuilder&gt; builder)</span> </span>&#123;</span><br><span class="line">        builder-&gt;<span class="built_in">buildEngine</span>();</span><br><span class="line">        builder-&gt;<span class="built_in">buildWheels</span>();</span><br><span class="line">        builder-&gt;<span class="built_in">buildBody</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;CarBuilder&gt; sportsCarBuilder = std::<span class="built_in">make_shared</span>&lt;SportsCarBuilder&gt;();</span><br><span class="line">    Director director;</span><br><span class="line">    director.<span class="built_in">construct</span>(sportsCarBuilder);</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;Car&gt; car = sportsCarBuilder-&gt;<span class="built_in">getCar</span>();</span><br><span class="line">    car-&gt;<span class="built_in">showCar</span>();  <span class="comment">// 输出：Car with engine: V8 Engine, wheels: Sports Wheels, body: Sleek Sports Body</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-单例模式"><a href="#10-单例模式" class="headerlink" title="10.单例模式"></a>10.单例模式</h3><p><strong>应用场景：</strong>确保某个类只有一个实例，并提供一个全局访问点来访问该实例。常用于需要控制全局访问、限制资源或共享资源的场景。<strong>用于减少创建对象的数量</strong></p><p><strong>特点：</strong></p><ul><li><strong>唯一性</strong>：保证一个类只有一个实例。</li><li><strong>全局访问点</strong>：提供对该实例的全局访问。</li><li><strong>延迟实例化</strong>：实例化通常是在首次访问时才创建，节省资源。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="built_in">Logger</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Logger created&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造函数和赋值运算符，防止拷贝</span></span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Logger&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 提供全局访问点的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Logger instance;  <span class="comment">// 静态本地变量，保证只创建一次</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Log: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 getInstance() 获取唯一的实例</span></span><br><span class="line">    Logger&amp; logger1 = Logger::<span class="built_in">getInstance</span>();</span><br><span class="line">    Logger&amp; logger2 = Logger::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    logger1.<span class="built_in">log</span>(<span class="string">&quot;This is the first message&quot;</span>);</span><br><span class="line">    logger2.<span class="built_in">log</span>(<span class="string">&quot;This is the second message&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出验证是否为同一实例</span></span><br><span class="line">    <span class="keyword">if</span> (&amp;logger1 == &amp;logger2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Both loggers are the same instance&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注1：<strong>私有构造函数</strong>防止类的外部创建实例。</em></p><p><em>注2：通过<strong>删除拷贝构造函数和赋值运算符</strong>，防止实例被复制。</em></p><p><em>注3：<strong><code>static</code> 变量</strong> <code>instance</code> 保证实例只创建一次，并在程序结束时自动销毁。：</em></p><h3 id="11-享元模式"><a href="#11-享元模式" class="headerlink" title="11.享元模式"></a>11.享元模式</h3><p><strong>应用场景：</strong>用于减少创建对象的数量，从而减少内存消耗并提高性能。常用于系统中需要大量细粒度对象的场景，比如图形编辑器中的图元或文字处理器中的字符。</p><p><strong>共享的部分做成员，外部状态做参数，调用时提供</strong></p><p><strong>特点：</strong></p><ul><li><strong>共享</strong>：将对象的共享部分提取出来，通过共享减少内存开销。</li><li><strong>分离状态</strong>：对象可以分为内部状态和外部状态。内部状态是共享的，外部状态是每个对象特有的，不会被共享。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string color;  <span class="comment">// 共享的内部状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">const</span> std::string&amp; col) : <span class="built_in">color</span>(col) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制时传递外部状态作为参数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> radius)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Circle: Color=&quot;</span> &lt;&lt; color &lt;&lt; <span class="string">&quot;, x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, radius=&quot;</span> &lt;&lt; radius &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, std::shared_ptr&lt;Circle&gt;&gt; circleMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Circle&gt; <span class="title">getCircle</span><span class="params">(<span class="type">const</span> std::string&amp; color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = circleMap.<span class="built_in">find</span>(color);</span><br><span class="line">        <span class="keyword">if</span> (it != circleMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> newCircle = std::<span class="built_in">make_shared</span>&lt;Circle&gt;(color);</span><br><span class="line">        circleMap[color] = newCircle;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Creating circle of color: &quot;</span> &lt;&lt; color &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> newCircle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CircleFactory circleFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> circle1 = circleFactory.<span class="built_in">getCircle</span>(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">    circle1-&gt;<span class="built_in">draw</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">5</span>);  <span class="comment">// 使用外部状态</span></span><br><span class="line">    circle1-&gt;<span class="built_in">draw</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">10</span>); <span class="comment">// 传递不同的外部状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> circle2 = circleFactory.<span class="built_in">getCircle</span>(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">    circle2-&gt;<span class="built_in">draw</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">15</span>); <span class="comment">// 共享颜色，外部状态不同</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> circle3 = circleFactory.<span class="built_in">getCircle</span>(<span class="string">&quot;Green&quot;</span>);</span><br><span class="line">    circle3-&gt;<span class="built_in">draw</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li><p><strong>共享部分</strong>：颜色信息在 <code>Circle</code> 类中存储和共享。</p></li><li><p><strong>外部状态</strong>：<code>x</code>、<code>y</code> 和 <code>radius</code> 作为参数传递给 <code>draw()</code> 方法，每个调用时提供不同的值，不共享。</p></li></ul><h3 id="12-面门模式"><a href="#12-面门模式" class="headerlink" title="12.面门模式"></a>12.面门模式</h3><p><strong>应用场景：</strong>为子系统中的一组复杂接口提供一个统一的接口，使得子系统更容易使用。<strong>适用于简化接口调用</strong></p><p><strong>客户端-》面门类-》子系统类</strong></p><p><em>注：客户端不需要直接依赖子系统的具体实现，而是依赖门面接口，降低了耦合性。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioPlayer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playAudio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Playing audio...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoPlayer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playVideo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Playing video...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subtitles</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadSubtitles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Loading subtitles...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 门面类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MediaFacade</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;AudioPlayer&gt; audioPlayer;</span><br><span class="line">    std::unique_ptr&lt;VideoPlayer&gt; videoPlayer;</span><br><span class="line">    std::unique_ptr&lt;Subtitles&gt; subtitles;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MediaFacade</span>() &#123;</span><br><span class="line">        audioPlayer = std::<span class="built_in">make_unique</span>&lt;AudioPlayer&gt;();</span><br><span class="line">        videoPlayer = std::<span class="built_in">make_unique</span>&lt;VideoPlayer&gt;();</span><br><span class="line">        subtitles = std::<span class="built_in">make_unique</span>&lt;Subtitles&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playMedia</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        audioPlayer-&gt;<span class="built_in">playAudio</span>();</span><br><span class="line">        videoPlayer-&gt;<span class="built_in">playVideo</span>();</span><br><span class="line">        subtitles-&gt;<span class="built_in">loadSubtitles</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 客户端使用门面类进行简化调用</span></span><br><span class="line">    MediaFacade mediaFacade;</span><br><span class="line">    mediaFacade.<span class="built_in">playMedia</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-代理模式"><a href="#13-代理模式" class="headerlink" title="13.代理模式"></a>13.代理模式</h3><p><strong>应用场景：</strong>用于为另一个对象提供一种“代理”或占位符以控制对这个对象的访问。例如<strong>延迟</strong>加载、控制访问权限、日志记录等。</p><p><strong>例：</strong>使用虚代理来实现按需加载图像资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Image</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealImage</span> : <span class="keyword">public</span> Image &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealImage</span>(<span class="type">const</span> std::string&amp; fileName) : <span class="built_in">fileName</span>(fileName) &#123;</span><br><span class="line">        <span class="built_in">loadImage</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Displaying image: &quot;</span> &lt;&lt; fileName &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string fileName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Loading image from &quot;</span> &lt;&lt; fileName &lt;&lt; <span class="string">&quot;...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyImage</span> : <span class="keyword">public</span> Image &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProxyImage</span>(<span class="type">const</span> std::string&amp; fileName) : <span class="built_in">fileName</span>(fileName), <span class="built_in">realImage</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!realImage) &#123;</span><br><span class="line">            realImage = std::<span class="built_in">make_unique</span>&lt;RealImage&gt;(fileName);  <span class="comment">// 延迟加载图像</span></span><br><span class="line">        &#125;</span><br><span class="line">        realImage-&gt;<span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string fileName;</span><br><span class="line">    <span class="keyword">mutable</span> std::unique_ptr&lt;RealImage&gt; realImage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建代理对象，不会立即加载图像</span></span><br><span class="line">    std::unique_ptr&lt;Image&gt; image = std::<span class="built_in">make_unique</span>&lt;ProxyImage&gt;(<span class="string">&quot;photo.jpg&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Image created, but not loaded yet.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当需要时才加载并显示图像</span></span><br><span class="line">    image-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-适配器模式"><a href="#14-适配器模式" class="headerlink" title="14.适配器模式"></a>14.适配器模式</h3><p><strong>应用场景：</strong>适配器模式主要解决接口不匹配的问题。</p><p><strong>组成：</strong></p><ul><li><strong>目标接口</strong>：客户端期望的接口。</li><li><strong>需要适配的类</strong>：拥有不兼容接口的类。</li><li><strong>适配器</strong>：将目标接口与需要适配的类进行连接，转换接口以满足客户端需求。</li><li><strong>客户端</strong>：通过目标接口与适配器交互。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="comment">//被适配类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OldPrinter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">oldPrint</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Old Printer: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewPrinterInterface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">NewPrinterInterface</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象适配器：通过组合实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrinterAdapter</span> : <span class="keyword">public</span> NewPrinterInterface &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;OldPrinter&gt; oldPrinter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrinterAdapter</span>(std::shared_ptr&lt;OldPrinter&gt; oldPrinter) : <span class="built_in">oldPrinter</span>(oldPrinter) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        oldPrinter-&gt;<span class="built_in">oldPrint</span>(text);  <span class="comment">// 调用 OldPrinter 的 oldPrint 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> oldPrinter = std::<span class="built_in">make_shared</span>&lt;OldPrinter&gt;();</span><br><span class="line">    <span class="function">PrinterAdapter <span class="title">adapter</span><span class="params">(oldPrinter)</span></span>;</span><br><span class="line">    adapter.<span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-中介者模式"><a href="#15-中介者模式" class="headerlink" title="15.中介者模式"></a>15.中介者模式</h3><p><strong>应用场景：</strong>用于减少多个对象之间的直接相互依赖。通过引入一个中介者对象，所有对象之间的通信都通过中介者完成，降低了对象之间的耦合性。</p><p><strong>未使用中介者模式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">User</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendMessage</span><span class="params">(User&amp; receiver, <span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; receiver.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">user1</span><span class="params">(<span class="string">&quot;Alice&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">user2</span><span class="params">(<span class="string">&quot;Bob&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    user1.<span class="built_in">sendMessage</span>(user2, <span class="string">&quot;Hello, Bob!&quot;</span>);</span><br><span class="line">    user2.<span class="built_in">sendMessage</span>(user1, <span class="string">&quot;Hi, Alice!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用中介者模式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中介者接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatMediator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message, <span class="keyword">class</span> User* sender, <span class="type">const</span> std::string&amp; receiverName)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addUser</span><span class="params">(std::shared_ptr&lt;<span class="keyword">class</span> User&gt; user)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ChatMediator</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    ChatMediator* mediator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">User</span>(<span class="type">const</span> std::string&amp; name, ChatMediator* mediator) : <span class="built_in">name</span>(name), <span class="built_in">mediator</span>(mediator) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> std::string&amp; message, <span class="type">const</span> std::string&amp; receiverName)</span> </span>&#123;</span><br><span class="line">        mediator-&gt;<span class="built_in">sendMessage</span>(message, <span class="keyword">this</span>, receiverName);  <span class="comment">// 通过中介者发送消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">receive</span><span class="params">(<span class="type">const</span> std::string&amp; message, <span class="type">const</span> std::string&amp; senderName)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; received from &quot;</span> &lt;&lt; senderName &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体中介者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteChatMediator</span> : <span class="keyword">public</span> ChatMediator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;User&gt;&gt; users;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addUser</span><span class="params">(std::shared_ptr&lt;User&gt; user)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        users.<span class="built_in">push_back</span>(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message, User* sender, <span class="type">const</span> std::string&amp; receiverName)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user-&gt;<span class="built_in">getName</span>() == receiverName) &#123;  <span class="comment">// 找到目标用户</span></span><br><span class="line">                user-&gt;<span class="built_in">receive</span>(message, sender-&gt;<span class="built_in">getName</span>());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;User &quot;</span> &lt;&lt; receiverName &lt;&lt; <span class="string">&quot; not found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcreteChatMediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> user1 = std::<span class="built_in">make_shared</span>&lt;User&gt;(<span class="string">&quot;Alice&quot;</span>, &amp;mediator);</span><br><span class="line">    <span class="keyword">auto</span> user2 = std::<span class="built_in">make_shared</span>&lt;User&gt;(<span class="string">&quot;Bob&quot;</span>, &amp;mediator);</span><br><span class="line">    <span class="keyword">auto</span> user3 = std::<span class="built_in">make_shared</span>&lt;User&gt;(<span class="string">&quot;Charlie&quot;</span>, &amp;mediator);</span><br><span class="line">    mediator.<span class="built_in">addUser</span>(user1);</span><br><span class="line">    mediator.<span class="built_in">addUser</span>(user2);</span><br><span class="line">    mediator.<span class="built_in">addUser</span>(user3);</span><br><span class="line">    <span class="comment">// A 向 B 发送消息</span></span><br><span class="line">    user1-&gt;<span class="built_in">send</span>(<span class="string">&quot;Hello Bob!&quot;</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="comment">// C 向 A 发送消息</span></span><br><span class="line">    user3-&gt;<span class="built_in">send</span>(<span class="string">&quot;Hi Alice!&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    <span class="comment">// A 向不存在的用户发送消息</span></span><br><span class="line">    user1-&gt;<span class="built_in">send</span>(<span class="string">&quot;Hello David!&quot;</span>, <span class="string">&quot;David&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-状态模式"><a href="#16-状态模式" class="headerlink" title="16.状态模式"></a>16.状态模式</h3><p><strong>应用场景：</strong>对象的行为由对象的状态所决定，而通过使用状态模式实现了状态和行为的分离。</p><p><strong>实现行为固定时，对状态的扩展</strong></p><p><strong>示例：</strong></p><p>电梯有以下状态：</p><ul><li><strong>运行中（Moving）</strong></li><li><strong>停止中（Stopped）</strong></li><li><strong>开门（Open）</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象状态类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//行为：</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openDoor</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">closeDoor</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">move</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">State</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明上下文类（为状态类使用）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Elevator</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类：停止中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoppedState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Elevator* elevator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">StoppedState</span><span class="params">(Elevator* elevator)</span> : elevator(elevator) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openDoor</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeDoor</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类：运行中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MovingState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Elevator* elevator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MovingState</span><span class="params">(Elevator* elevator)</span> : elevator(elevator) &#123;</span>&#125;<span class="comment">//使用原始指针防止循环引用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openDoor</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeDoor</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类：开门</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Elevator* elevator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">OpenState</span><span class="params">(Elevator* elevator)</span> : elevator(elevator) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openDoor</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeDoor</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类：电梯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Elevator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;State&gt; currentState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Elevator</span><span class="params">(std::shared_ptr&lt;State&gt; initialState)</span> : currentState(std::move(initialState)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(std::shared_ptr&lt;State&gt; state)</span> </span>&#123;</span><br><span class="line">        currentState = std::<span class="built_in">move</span>(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState-&gt;<span class="built_in">openDoor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState-&gt;<span class="built_in">closeDoor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState-&gt;<span class="built_in">move</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState-&gt;<span class="built_in">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现具体状态类的方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StoppedState::openDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Opening door...\n&quot;</span>;</span><br><span class="line">    elevator-&gt;<span class="built_in">setState</span>(std::<span class="built_in">make_shared</span>&lt;OpenState&gt;(elevator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StoppedState::closeDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Door is already closed.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StoppedState::move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elevator is starting to move...\n&quot;</span>;</span><br><span class="line">    elevator-&gt;<span class="built_in">setState</span>(std::<span class="built_in">make_shared</span>&lt;MovingState&gt;(elevator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StoppedState::stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elevator is already stopped.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MovingState::openDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Cannot open door while moving.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MovingState::closeDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Door is already closed.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MovingState::move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elevator is already moving.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MovingState::stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elevator is stopping...\n&quot;</span>;</span><br><span class="line">    elevator-&gt;<span class="built_in">setState</span>(std::<span class="built_in">make_shared</span>&lt;StoppedState&gt;(elevator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenState::openDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Door is already open.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenState::closeDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Closing door...\n&quot;</span>;</span><br><span class="line">    elevator-&gt;<span class="built_in">setState</span>(std::<span class="built_in">make_shared</span>&lt;StoppedState&gt;(elevator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenState::move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Cannot move with door open.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenState::stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elevator is already stopped.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 延迟初始化 Elevator 和 StoppedState，避免使用未初始化对象</span></span><br><span class="line">    <span class="keyword">auto</span> elevator = std::<span class="built_in">make_shared</span>&lt;Elevator&gt;(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">auto</span> initialState = std::<span class="built_in">make_shared</span>&lt;StoppedState&gt;(elevator.<span class="built_in">get</span>());</span><br><span class="line">    elevator-&gt;<span class="built_in">setState</span>(initialState);</span><br><span class="line"></span><br><span class="line">    elevator-&gt;<span class="built_in">openDoor</span>();  <span class="comment">// Opening door...</span></span><br><span class="line">    elevator-&gt;<span class="built_in">closeDoor</span>(); <span class="comment">// Closing door...</span></span><br><span class="line">    elevator-&gt;<span class="built_in">move</span>();      <span class="comment">// Elevator is starting to move...</span></span><br><span class="line">    elevator-&gt;<span class="built_in">stop</span>();      <span class="comment">// Elevator is stopping...</span></span><br><span class="line">    elevator-&gt;<span class="built_in">openDoor</span>();  <span class="comment">// Opening door...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-备忘录模式"><a href="#17-备忘录模式" class="headerlink" title="17.备忘录模式"></a>17.备忘录模式</h3><p><strong>应用场景：</strong>允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态（如浏览器回退、编辑器撤销）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Memento</span><span class="params">(<span class="type">const</span> std::string&amp; state)</span> : state(state) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getState</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">type</span><span class="params">(<span class="type">const</span> std::string&amp; newText)</span> </span>&#123;</span><br><span class="line">        text += newText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showContent</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Current Content: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建备忘录</span></span><br><span class="line">    <span class="function">Memento <span class="title">save</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Memento</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从备忘录恢复</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">restore</span><span class="params">(<span class="type">const</span> Memento&amp; memento)</span> </span>&#123;</span><br><span class="line">        text = memento.<span class="built_in">getState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理者类：进行保存备份副本、回档</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Memento&gt; history;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">(<span class="type">const</span> Memento&amp; memento)</span> </span>&#123;</span><br><span class="line">        history.<span class="built_in">push_back</span>(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Memento <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= history.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Invalid index&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> history[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TextEditor editor;</span><br><span class="line">    Caretaker caretaker;</span><br><span class="line"></span><br><span class="line">    editor.<span class="built_in">type</span>(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">    caretaker.<span class="built_in">save</span>(editor.<span class="built_in">save</span>()); <span class="comment">// 保存状态</span></span><br><span class="line"></span><br><span class="line">    editor.<span class="built_in">type</span>(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">    caretaker.<span class="built_in">save</span>(editor.<span class="built_in">save</span>()); <span class="comment">// 保存状态</span></span><br><span class="line"></span><br><span class="line">    editor.<span class="built_in">type</span>(<span class="string">&quot; New content.&quot;</span>);</span><br><span class="line">    editor.<span class="built_in">showContent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复到上一个状态</span></span><br><span class="line">    editor.<span class="built_in">restore</span>(caretaker.<span class="built_in">get</span>(<span class="number">1</span>));</span><br><span class="line">    editor.<span class="built_in">showContent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复到初始状态</span></span><br><span class="line">    editor.<span class="built_in">restore</span>(caretaker.<span class="built_in">get</span>(<span class="number">0</span>));</span><br><span class="line">    editor.<span class="built_in">showContent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-组合模式"><a href="#18-组合模式" class="headerlink" title="18.组合模式"></a>18.组合模式</h3><p>组合模式将对象组合成树形结构，来一致地处理单个对象和对象的组合。</p><p><strong>结构：</strong></p><ul><li><strong>Component（抽象组件）：</strong>定义了对象的公共接口，包括对组合对象的常见操作</li><li><strong>Leaf（叶子节点）：</strong>表示树形结构的最小单元，不包含子节点。</li><li><strong>Composite（组合节点）：</strong>包含子节点的容器，可以是<code>Leaf</code>或<code>Composite</code>，实现管理子节点的操作，例如添加、移除和遍历子节点。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象组件类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystemComponent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> depth = <span class="number">0</span>)</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 显示组件内容</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">FileSystemComponent</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶子节点类：文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> : <span class="keyword">public</span> FileSystemComponent &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">File</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> depth = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; std::<span class="built_in">string</span>(depth, <span class="string">&#x27;-&#x27;</span>) &lt;&lt; <span class="string">&quot;File: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合节点类：文件夹</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Folder</span> : <span class="keyword">public</span> FileSystemComponent &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;FileSystemComponent&gt;&gt; children;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Folder</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(std::shared_ptr&lt;FileSystemComponent&gt; component)</span> </span>&#123;</span><br><span class="line">        children.<span class="built_in">push_back</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> depth = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; std::<span class="built_in">string</span>(depth, <span class="string">&#x27;-&#x27;</span>) &lt;&lt; <span class="string">&quot;Folder: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; child : children) &#123;</span><br><span class="line">            child-&gt;<span class="built_in">display</span>(depth + <span class="number">2</span>); <span class="comment">// 递归调用子节点的 display 方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> file1 = std::<span class="built_in">make_shared</span>&lt;File&gt;(<span class="string">&quot;file1.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> file2 = std::<span class="built_in">make_shared</span>&lt;File&gt;(<span class="string">&quot;file2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> subFolder = std::<span class="built_in">make_shared</span>&lt;Folder&gt;(<span class="string">&quot;SubFolder&quot;</span>);</span><br><span class="line">    subFolder-&gt;<span class="built_in">add</span>(file1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> mainFolder = std::<span class="built_in">make_shared</span>&lt;Folder&gt;(<span class="string">&quot;MainFolder&quot;</span>);</span><br><span class="line">    mainFolder-&gt;<span class="built_in">add</span>(subFolder);</span><br><span class="line">    mainFolder-&gt;<span class="built_in">add</span>(file2);</span><br><span class="line"></span><br><span class="line">    mainFolder-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h2&gt;&lt;h3 id=&quot;1-模板模式&quot;&gt;&lt;a href=&quot;#1-模板模式&quot; class=&quot;headerlink&quot; title=&quot;1.模板模</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Ori-Net: Orientation-guided Neural Network for Automated Coronary Arteries Segmentation</title>
    <link href="https://wangak.cc/posts/6e60e82b.html"/>
    <id>https://wangak.cc/posts/6e60e82b.html</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2024-10-22T13:03:17.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ori-Net-Orientation-guided-Neural-Network-for-Automated-Coronary-Arteries-Segmentation"><a href="#Ori-Net-Orientation-guided-Neural-Network-for-Automated-Coronary-Arteries-Segmentation" class="headerlink" title="Ori-Net: Orientation-guided Neural Network for Automated Coronary Arteries Segmentation"></a>Ori-Net: Orientation-guided Neural Network for Automated Coronary Arteries Segmentation</h2><p><strong>论文：《Ori-Net: Orientation-guided Neural Network for Automated Coronary Arteries Segmentation》（ESWA 2024)</strong></p><p><strong>主要贡献：</strong></p><p>提出了一种利用预测方向和半径的定向制导跟踪方法。该算法迭代重建冠状动脉，并将重建与粗分割融合，进一步提高分割性能。</p><p><strong>冠状动脉结构可以被表示为由不同半径的、以方向为指导的球体包络所重建的外包络</strong></p><p>用半径和方向作为冠状动脉的两个基本度量。</p><p><em>注1：半径：当前位置到冠状动脉边界的距离；方向：从当前位置确定下一个位置的指向</em></p><p><em>注2：半径信息有助于确定血管的边界，而方向信息则确定血管延伸的方向。</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059067.png" alt="image-20241017150109306" style="zoom: 50%;"></p><h3 id="Ori-Net"><a href="#Ori-Net" class="headerlink" title="Ori-Net"></a><strong>Ori-Net</strong></h3><p>Ori-Net模型与UNet结构相似，Ori-Net模型利用了这种基于几何信息的分割方法，同时预测了冠状动脉的分割结果、半径和方向，并通过一个导向追踪的方法，利用预测的半径和方向来重建冠状动脉。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059629.png" alt="image-20241017150543948"></p><p><strong>多任务学习：</strong>Ori-Net有三个预测分支（分割分支、半径分支和方向分支），每个分支都有一个核大小为1的卷积层，分别用于预测分割、半径和方向。</p><p><strong>损失函数：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059765.png" alt="image-20241017150822909" style="zoom: 80%;"></p><p><em>注1：<script type="math/tex">L_{SEG}、L_{RAD}、L_{ORI}</script>​分别表示分割损失、半径分类损失和方向分类损失</em></p><p><em>注2：<script type="math/tex">L_{SEG}</script>使用dice损失：</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059150.png" alt="image-20241017151212125"></p><p><strong>如何基于分割标签𝑌生成半径标签𝑍和方向标签𝑂？</strong></p><h4 id="半径分支"><a href="#半径分支" class="headerlink" title="半径分支"></a>半径分支</h4><p>将回归问题转换为分类问题：</p><p>通过离散化半径标签来创建半径类别。</p><p>半径分支负责预测半径类别图Z，该图对冠状动脉体素进行半径类别预测。</p><p><strong>生成半径标签：</strong></p><ul><li><p>通过分割掩码来生成与输入图像大小相同的距离图，图中的每个值表示了每个像素点到前景边界的距离</p></li><li><p>使用one-hot编码将每个距离值量化到K个类别中，于是连续的距离图就变成了离散的边界距离图。在这个图中，每个体素都有一个对应的半径类别</p><p><em>注：参数K的设定，来自于统计出的先验知识</em></p></li></ul><p><strong>半径分类损失使用交叉熵损失：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059538.png" alt="image-20241017194423854" style="zoom:50%;"></p><h4 id="方向分支"><a href="#方向分支" class="headerlink" title="方向分支"></a>方向分支</h4><p><strong>任务背景：</strong>现有的冠状动脉方法忽略了冠状动脉结构中的体素的几何信息</p><p><strong>方向分类损失使用交叉熵损失：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059930.png" alt="image-20241017200442413" style="zoom:67%;"></p><p><strong>方向类别图的生成：</strong></p><ul><li><p><strong>确定点的属性</strong>：</p><ul><li><p>对于每个连通域，首先通过八叉树数据结构计算中心线</p><p><em>注：利用八叉树数据结构，可以优化中心线计算，由于八叉树将图像划分成了多个子区域，只需对包含冠状动脉的子区域进行进一步处理。这减少了不必要的计算负担。</em></p></li><li><p>计算中心线半径图</p></li><li><p>使用最短路径算法确定起点<script type="math/tex">v_0</script> 和终点<script type="math/tex">v_e</script>​</p></li><li><p>下一个点<script type="math/tex">v_t</script>是以<script type="math/tex">v_0</script>为中心、半径为<script type="math/tex">R_{v_0}</script>​​的球与中心线的交点</p><p><em>注：球的中心是当前的中心点 <script type="math/tex">v_0</script>，而半径 <script type="math/tex">R_{v_0}</script> 是通过距离变换计算得到的。这个半径值表示从当前点<script type="math/tex">v_0</script>到血管边界的距离，反映了该点处血管的局部粗细程度。</em></p></li><li><p>根据点<script type="math/tex">v_t</script>的斜率<script type="math/tex">N(v_t)</script>​的和来判断点的属性(起点、终点、直线路段上的点以及分支点)</p><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059615.png" alt="image-20241021204408286" style="zoom:50%;"></p></li></ul></li></ul><p><em>注1：<script type="math/tex">N(v_t) = 1</script>，则该点是起点或终点，这意味着该点只连接到一个其他点。<script type="math/tex">N(v_t)=2</script>，则该点处于直线段上，这意味着该点与前后两个点相连，并且没有其他分支。<script type="math/tex">N(v_t) > 2</script>​，则该点是一个分支点,这意味着该点连接到多个不同方向的点。</em></p><p><em>注2：为了计算某个点 <script type="math/tex">v_t</script>的斜率<script type="math/tex">N(v_t)</script>，算法会检查该点在局部邻域内的连通性。</em></p><p><strong>一旦确定了下一个点<script type="math/tex">v_t</script>，算法将<script type="math/tex">v_t</script> 作为新的中心点，并重复这一过程,直到到达终点。</strong></p><ul><li><strong>方向类别的生成</strong></li></ul><p>​    每个点<script type="math/tex">v_t</script>需要生成一个方向类别，方向类别用来表示该点的运动方向。</p><p><strong>起点、终点或分支点：</strong>对于起点、终点或分支点，这些点在冠状动脉的几何结构中具有特殊的意义。因此，在这些点的方向生成过程中，系统不需要复杂的计算，而是直接<strong>使用预定义的符号来标记其方向</strong>。</p><p><strong>直线路段的点：</strong>对于位于冠状动脉直线路段上的点，方向生成需要通过计算来确定。</p><ul><li><strong>位移向量 <script type="math/tex">\Delta v_t</script> 的计算</strong>：</li></ul><p>​                <script type="math/tex">Δvt=vt−v0</script></p><ul><li><strong>最小角度法则确定方向类别:</strong>遍历所有可能的球面坐标方向，计算这些方向与位移向量之间的角度，通过计算位移向量 <script type="math/tex">\Delta v_t</script> 和球面坐标系中不同方向的夹角，找到与 <script type="math/tex">\Delta v_t</script> <strong>夹角最小的方向</strong>，并将该方向的索引作为该点的方向类别。</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059280.png" alt="image-20241021205742932" style="zoom:67%;"></p><p><strong>测试阶段的方向引导追踪：</strong>根据预测的半径和方向信息，对初步的分割结果进行细化，以更好地重建冠状动脉的柱状结构。</p><p>Ori-Net有三个输出：P、D、G</p><ul><li><p>P:粗分割结果、D:方向预测结果、G：半径预测结果</p></li><li><p>细化分割结果为粗分割结果P和细化重建的结果<script type="math/tex">~\tilde{Y}~</script>的平均：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059028.png" alt="image-20241022194605266" style="zoom: 50%;"></p></li></ul><p><strong>细化重建的结果的生成：</strong></p><ul><li><strong>方向引导的迭代追踪：</strong>从起点开始，沿着预测的方向和半径逐步找到下一个点，直到达到终点</li><li><strong>平滑处理：</strong>由于半径是离散预测的，这可能导致重建的冠状动脉表面不够光滑，因此，Ori-Net使用高斯核函数来对每个球进行平滑处理，确保最终生成的血管结构光滑、无断裂。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Ori-Net-Orientation-guided-Neural-Network-for-Automated-Coronary-Arteries-Segmentation&quot;&gt;&lt;a href=&quot;#Ori-Net-Orientation-guided-Neural-</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>ASSNet:Adaptive Semantic Segmentation Network for Microtumors and Multi-Organ Segmentation</title>
    <link href="https://wangak.cc/posts/425a95d.html"/>
    <id>https://wangak.cc/posts/425a95d.html</id>
    <published>2024-10-11T16:00:00.000Z</published>
    <updated>2024-10-12T07:51:38.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ASSNet-Adaptive-Semantic-Segmentation-Network-for-Microtumors-and-Multi-Organ-Segmentation"><a href="#ASSNet-Adaptive-Semantic-Segmentation-Network-for-Microtumors-and-Multi-Organ-Segmentation" class="headerlink" title="ASSNet: Adaptive Semantic Segmentation Network for Microtumors and Multi-Organ Segmentation"></a>ASSNet: Adaptive Semantic Segmentation Network for Microtumors and Multi-Organ Segmentation</h2><p><strong>论文：</strong></p><p><strong>《ASSNet: Adaptive Semantic Segmentation Network for Microtumors and Multi-Organ Segmentation》（arXiv 2024）</strong></p><p><strong>主要贡献：</strong></p><ul><li>设计了一种结合ResUnet和Swin-transformer优点的混合模型ASSNet，该模型具有窗口注意力、空间注意力、U型架构和残差连接，以实现高效分割。</li><li>提出了一种自适应特征融合(AFF)解码器，该解码器能够最大化利用多尺度特征，同时捕捉远程依赖并细化目标边界。</li></ul><p>网络整体结构：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202410121507439.png" alt="image-20241008195242686" style="zoom:50%;"></p><p><strong>编码器：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202410121507617.png" alt="image-20241012125942275" style="zoom: 50%;"></p><ul><li>通过在不同分辨率上应用窗口注意力，编码器能够捕捉到图像中的多尺度信息</li><li>引入了一个增强的多层感知器，以在特征提取过程中显式地建模长距离依赖关系</li><li>EFFN结合深度卷积和像素卷积来增强局部特征的提取能力</li></ul><p><strong>Adaptive Feature Fusion (AFF) Decoder:</strong></p><p>该解码器包含三个关键组件:长距离依赖(LRD)块、多尺度特征融合(MFF)块和自适应语义中心(ASC)块。</p><p>Adaptive Feature Fusion (AFF) Decoder是为了解决多尺度特征融合和长距离依赖建模问题而设计的。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202410121507151.png" alt="image-20241012130531795" style="zoom: 50%;"></p><ul><li><p><strong>长距离依赖块(LRD)：</strong>通过一系列的卷积操作建模远距离像素间的关联。</p></li><li><p><strong>多尺度特征融合块(MFF):</strong>接收来自编码器不同分辨率层次的特征图,通过跳跃连接（skip connections）将这些多尺度特征与当前解码层的特征图进行融合。然后通过膨胀卷积扩张卷积处理这些融合的特征，提取出每个尺度下的关键信息。</p></li><li><p><strong>自适应语义中心块(ASC):</strong>类似于传统边缘检测方法,作者使用一种自适应平均池化（Adaptive Average Pooling）操作，结合全连接层对通道特征进行增强。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ASSNet-Adaptive-Semantic-Segmentation-Network-for-Microtumors-and-Multi-Organ-Segmentation&quot;&gt;&lt;a href=&quot;#ASSNet-Adaptive-Semantic-Segme</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>RotCAtt-TransUNet++:Novel Deep Neural Network for Sophisticated Cardiac Segmentation</title>
    <link href="https://wangak.cc/posts/2d5c3529.html"/>
    <id>https://wangak.cc/posts/2d5c3529.html</id>
    <published>2024-09-27T16:00:00.000Z</published>
    <updated>2024-10-12T07:51:21.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RotCAtt-TransUNet-Novel-Deep-Neural-Network-for-Sophisticated-Cardiac-Segmentation"><a href="#RotCAtt-TransUNet-Novel-Deep-Neural-Network-for-Sophisticated-Cardiac-Segmentation" class="headerlink" title="RotCAtt-TransUNet++: Novel Deep Neural Network for Sophisticated Cardiac Segmentation"></a>RotCAtt-TransUNet++: Novel Deep Neural Network for Sophisticated Cardiac Segmentation</h2><p><strong>论文：《RotCAtt-TransUNet++: Novel Deep Neural Network for Sophisticated Cardiac Segmentation》（arXiv 2024）</strong></p><ul><li><p>提出了一种新颖的旋转注意力机制（Rotatory Attention），用于捕捉体数据中相邻切片的信息。</p></li><li><p>编码器部分引入了UNet++的嵌套跳跃连接和密集的多尺度下采样，确保了在不同尺度上保留关键特征</p></li><li>设计了一个通道交叉注意力机制，通过引导Transformer特征的通道和信息过滤，解决了编码器与解码器特征间语义模糊的问题。</li></ul><p>Transformer层有助于捕获片内交互，而旋转注意机制处理片间连接。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202409281659093.png" alt="image-20240927152207198" style="zoom: 50%;"></p><ul><li><p>在跳跃连接处对不同深度和不同分辨率的特征图进行了融合</p></li><li><p>对前三个特征映射X1、X2、X3以不同的patch大小进行线性嵌入（<script type="math/tex">Z_i</script>),然后，通过transformer块捕捉patch之间的交互，并通过旋转注意力机制聚合相邻切片的信息</p></li></ul><h4 id="Linear-Embedding-与-Positional-Embedding"><a href="#Linear-Embedding-与-Positional-Embedding" class="headerlink" title="Linear Embedding 与 Positional Embedding"></a><strong>Linear Embedding 与 Positional Embedding</strong></h4><p>对于不同分辨率的特征图采用不同大小的patch（这样做可以保持特征图的代表性，不同分辨率的特征图包含不同尺度的信息），较小的patch有助于提取图像的局部细节特征，而较大的patch则有助于提取全局或上下文特征，然后对使用卷积操作映射到一个统一的维度。</p><h4 id="Rotatory-Attention-Block"><a href="#Rotatory-Attention-Block" class="headerlink" title="Rotatory Attention Block"></a><strong>Rotatory Attention Block</strong></h4><p>作者使用旋转注意力机制来提取切片间的特征</p><p><img src="https://typoraimg.wangak.cc/2023/img/202409281659406.png" alt="image-20240927155203358" style="zoom: 50%;"></p><p>该机制来源于自然语言处理中的左-中-右分离神经网络，用于捕捉句子中相邻单词之间的上下文关系。（相邻的元素对理解的中心有重要贡献）</p><p><strong>输入：</strong>旋转注意力机制将批量大小视为多个连续切片的集合，并选择性地处理三个连续的切片—左切片（前一个切片）、目标切片（当前切片）和右切片（下一个切片）。     </p><p><strong>Left:</strong></p><ul><li>对左切片使用<script type="math/tex">W_k</script>和<script type="math/tex">W_v</script>来得到<script type="math/tex">K_l</script>和<script type="math/tex">V_l</script>​</li><li>使用对目标切片的平均池化的结果<script type="math/tex">r^t</script>作为查询，通过与<script type="math/tex">K_l</script>和<script type="math/tex">V_l</script>进行注意力的计算，得到左上下文融合后的特征</li></ul><p><strong>Right:</strong>同Left</p><p><strong>目标上下文交互：</strong>通过<strong>单注意力（SA）</strong>,将左上下文和右上下文整合到目标切片之中</p><p>最后，通过通道维度拼接和取平均的操作，得到最后的输出特征。</p><h4 id="Channel-wise-Attention-Gate-for-Feature-Fusion"><a href="#Channel-wise-Attention-Gate-for-Feature-Fusion" class="headerlink" title="Channel-wise Attention Gate for Feature Fusion"></a><strong>Channel-wise Attention Gate for Feature Fusion</strong></h4><ul><li><p>对输入特征图进行全局平均池化，生成一个描述各通道重要性的向量，通过线性层对该向量进行变换，生成一个注意力掩码。</p></li><li><p>将生成的注意力掩码与解码器的特征图进行逐元素相乘，从而得到加权后的特征图。</p></li><li>加权后的特征图与解码器的原始特征图进行连接，以增强解码过程中的信息流动，进一步提升分割精度。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RotCAtt-TransUNet-Novel-Deep-Neural-Network-for-Sophisticated-Cardiac-Segmentation&quot;&gt;&lt;a href=&quot;#RotCAtt-TransUNet-Novel-Deep-Neural-Ne</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>MobileUNETR:A Lightweight End-To-End Hybrid Vision Transformer For Efficient Medical Image Segmentation</title>
    <link href="https://wangak.cc/posts/c34814e1.html"/>
    <id>https://wangak.cc/posts/c34814e1.html</id>
    <published>2024-09-18T16:00:00.000Z</published>
    <updated>2024-09-19T02:12:31.180Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MobileUNETR-A-Lightweight-End-To-End-Hybrid-Vision-Transformer-For-Efficient-Medical-Image-Segmentation"><a href="#MobileUNETR-A-Lightweight-End-To-End-Hybrid-Vision-Transformer-For-Efficient-Medical-Image-Segmentation" class="headerlink" title="MobileUNETR: A Lightweight End-To-End Hybrid Vision Transformer For Efficient Medical Image Segmentation"></a>MobileUNETR: A Lightweight End-To-End Hybrid Vision Transformer For Efficient Medical Image Segmentation</h3><p><strong>论文：《MobileUNETR: A Lightweight End-To-End Hybrid Vision Transformer For Efficient Medical Image Segmentation》（ECCV 2024）</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202409191008537.png" alt="image-20240918195745497"></p><p><strong>Hybrid Encoder Block:</strong>利用深度可分离卷积将特征投影到高维，再利用MobileViT block捕获局部和全局信息</p><p><strong>Hybrid Decoder Block:</strong>首先，使用转置卷积进行上采样；然后，将得到的特征与跳跃连接的特征进行拼接；最后，使用MobileViT block得到改进后的分割结果</p><h4 id="MobileViT-block"><a href="#MobileViT-block" class="headerlink" title="MobileViT block"></a>MobileViT block</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202409191008262.png" alt="image-20240918200915992" style="zoom:67%;"></p><ul><li><strong>Local representations:</strong>先使用n×n卷积进行特征提取，再使用1×1卷积调整通道数，获取局部特征</li><li><strong>global representations:</strong>通过Unfold和Fold操作实现，对相同颜色的小色块会进行Attention，以此来减小Attention计算的复杂度，来获取全局特征</li><li><strong>Fusion:</strong>通过与原始特征图的拼接，来实现融合</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;MobileUNETR-A-Lightweight-End-To-End-Hybrid-Vision-Transformer-For-Efficient-Medical-Image-Segmentation&quot;&gt;&lt;a href=&quot;#MobileUNETR-A-Lig</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Improving Transformers with Dynamically Composable Multi-Head Attention</title>
    <link href="https://wangak.cc/posts/2d10fdc6.html"/>
    <id>https://wangak.cc/posts/2d10fdc6.html</id>
    <published>2024-06-24T16:00:00.000Z</published>
    <updated>2024-09-19T02:11:38.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Improving-Transformers-with-Dynamically-Composable-Multi-Head-Attention"><a href="#Improving-Transformers-with-Dynamically-Composable-Multi-Head-Attention" class="headerlink" title="Improving Transformers with Dynamically Composable Multi-Head Attention"></a>Improving Transformers with Dynamically Composable Multi-Head Attention</h2><p><strong>论文：《Improving Transformers with Dynamically Composable Multi-Head Attention》（ICML 2024）</strong></p><p><strong>多头注意力（MHA)的不足：</strong>对于多头注意力（MHA)，其注意力头是独立工作的，这种独立性限制了每个头能捕捉到的特征和关系的多样性，注意力矩阵存在低秩瓶颈和冗余。</p><p>作者提出了<strong>动态组合多头注意力（DCMHA)</strong>,其解决了MHA的不足，通过动态组合注意力头来提高模型的表达能力。</p><p>动态可组合多头注意力（DCMHA）中，核心是一个 <strong>Compose 函数</strong>，它根据查询 <script type="math/tex">Q_i</script>和键 <script type="math/tex">K_j</script>以及可训练参数 <script type="math/tex">\theta</script>，将它们的注意力向量 <script type="math/tex">A_{:ij}</script>∈<script type="math/tex">{R}^H</script>A:ij∈RH 转换为新的向量 <script type="math/tex">A'_{:ij}</script>​</p><p>注：假设T、S是查询和键序列长度，用<script type="math/tex">A_h</script>​表示第h个头的注意力矩阵</p><p>​    <script type="math/tex">A_{:ij}</script>表示注意力向量，它是查询向量 <script type="math/tex">Q_i</script>和键向量 <script type="math/tex">K_j</script>之间的注意力得分向量</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406251351820.png" alt="image-20240612150016488" style="zoom: 67%;"></p><p>​                                <img src="https://typoraimg.wangak.cc/2023/img/202406251351020.png" alt="image-20240612150213603" style="zoom:67%;">         </p><p>​        为了实现 DCMHA，在 MHA 的计算中插入两个 Compose 函数，其中一个在 softmax 之前应用于注意力分数张量 <script type="math/tex">A_S</script>，另一个在 softmax 之后应用于注意力权重张量 <script type="math/tex">A_W</script>，步骤如下：</p><ul><li>注意力分数 <script type="math/tex">A_S</script> 计算：</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202406251351826.png" alt="image-20240612150526297" style="zoom: 67%;"></p><ul><li>注意力权重 <script type="math/tex">A_W</script> 计算：</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202406251351155.png" alt="image-20240612150547712" style="zoom:67%;"></p><ul><li><p>DCMHA模块最后的输出为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406251351933.png" alt="image-20240612150756075" style="zoom:67%;"></p><p><strong>Compose 函数:</strong></p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202406251351096.png" alt="image-20240612161027897" style="zoom:67%;"></p><p>注意力向量<script type="math/tex">A_{:ij}</script>经过5个分支进行变化，然后相加</p><ul><li><p>第一个分支（基础投影）：<script type="math/tex">A_{:ij}</script>首先由一个权重矩阵<script type="math/tex">W_b</script>进行投影</p></li><li><p>第二个分支（查询的动态投影）：<script type="math/tex">A_{:ij}</script>通过 <script type="math/tex">w_{q1}∈R^{H×R}</script>投影到低维 <script type="math/tex">R</script>,再通过<script type="math/tex">w_{q2}∈R^{R×H}</script>投影回原始维度<script type="math/tex">H</script>,其中动态权重 <script type="math/tex">w_{q1}</script> 和 <script type="math/tex">w_{q2}</script>  由 查询向量<script type="math/tex">Q_i</script> 计算得出。</p></li><li><p>第三个分支（查询的动态门控）：<script type="math/tex">A_{:ij}</script>乘以一个门控权重<script type="math/tex">w_{qg}</script>控制每个头保留或忘记原始分数。</p></li><li><p>第四个分支（键的动态投影）：类似于第二个分支</p></li><li><p>第五个分支（键的动态门控）：类似于第三个分支</p></li></ul><p>最终的 <script type="math/tex">A'_{:ij}</script>为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406251351275.png" alt="image-20240612162302939" style="zoom:50%;"></p><p><em>注：DCMHA的可训练参数<script type="math/tex">\theta</script>为：{<script type="math/tex">W_b</script>、<script type="math/tex">w_{q1}</script>、<script type="math/tex">w_{q2}</script>、<script type="math/tex">w_{qg}</script>、<script type="math/tex">w_{k1}</script>、<script type="math/tex">w_{k2}</script>、<script type="math/tex">w_{kg}</script>}</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Improving-Transformers-with-Dynamically-Composable-Multi-Head-Attention&quot;&gt;&lt;a href=&quot;#Improving-Transformers-with-Dynamically-Composabl</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Frequency Channel Attention Networks</title>
    <link href="https://wangak.cc/posts/eb050326.html"/>
    <id>https://wangak.cc/posts/eb050326.html</id>
    <published>2024-06-12T16:00:00.000Z</published>
    <updated>2024-06-23T04:05:01.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FcaNet-Frequency-Channel-Attention-Networks"><a href="#FcaNet-Frequency-Channel-Attention-Networks" class="headerlink" title="FcaNet: Frequency Channel Attention Networks"></a>FcaNet: Frequency Channel Attention Networks</h2><p>通道注意力机制通常会为每个通道分配一个标量权重，用于加权通道特征图。然而，这种简单的标量表示可能无法充分表达通道之间的复杂关系，因此，设计更有效的通道注意力机制需要考虑如何更好地捕捉和利用通道之间的非线性关系，以充分挖掘通道特征图中的信息。</p><h4 id="DTC（离散余弦变换）"><a href="#DTC（离散余弦变换）" class="headerlink" title="DTC（离散余弦变换）"></a>DTC（离散余弦变换）</h4><p>DCT，即离散余弦变换，常用图像压缩算法，步骤如下：</p><ul><li>首先将图像分割成8x8或16x16的小块；</li><li>DCT变换，对每个小块进行DCT变换；</li><li>舍弃高频系数（AC系数），保留低频信息（DC系数）。高频系数一般保存的是图像的边界、纹理信息，低频信息主要是保存的图像中平坦区域信息。</li><li>图像的低频和高频，高频区域指的是空域图像中突变程度大的区域（比如目标边界区域），通常的纹理丰富区域。</li></ul><p>二维DCT变换就是将二维图像从空间域转换到频率域。形象的说，就是计算出图像由哪些二维余弦波构成，其主要用于数据或图像的压缩，能够将空间域的信号转换到频域上，具有良好的去相关性的性能。二维的DTC公式如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131003312.png" alt="image-20240516105445387" style="zoom:67%;"></p><p>二维的逆DTC公式如下:</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131003180.png" alt="image-20240516105508741" style="zoom:67%;"></p><p>注：逆变换，通过<strong>所有</strong>频率分量的在某点的叠加可以恢复像素值。</p><p>我们称二者的共有项为基函数:</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131003442.png" alt="image-20240516105537223" style="zoom:67%;"></p><h4 id="method"><a href="#method" class="headerlink" title="method"></a>method</h4><p>传统的通道注意方法致力于构建各种通道重要性权重函数，这种权重函数要求每个通道都有一个标量来进行计算，由于计算开销有限，简单有效的全局平均池化（GAP）成为了他们的不二之选。但是一个潜在的问题是GAP是否能够捕获丰富的输入信息，也就是说，仅仅平均值是否足够表示通道注意力中的各个通道。<br><strong>GAP的不足与分析：</strong><br> 1）不同的通道可能拥有相同的平均值，而其代表的语义信息是不相同的；<br> 2）从频率分析的角度，可以证明GAP等价于DCT的最低频率，仅仅使用GAP相当于丢弃了其他许多包含着通道特征的信息；<br> 3）CBAM还表示，仅使用GAP是不够的，因此额外引入了GMP。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131003894.png" alt="image-20240516140310965" style="zoom: 50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131003276.png" alt="image-20240516140405302" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131003179.png" alt="image-20240516140522027" style="zoom: 50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131003247.png" alt="image-20240516140545094" style="zoom:67%;"></p><p><strong>以往的通道注意力（比如下图SE）只考虑了GAP（最低频的分量信息），导致丢失了大量可利用的信息</strong>。</p><h4 id="利用频率信息重构通道注意力"><a href="#利用频率信息重构通道注意力" class="headerlink" title="利用频率信息重构通道注意力"></a>利用频率信息重构通道注意力</h4><p>将通道划分成n等分，之前我们提到“DCT可以被看作图像中每个输入的加权和”，在这里通过两步准则（后面实验会介绍），选择出收益最大的部分频率分量，与对应分组相乘，就得到我们的多光谱通道注意力。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131003328.png" alt="image-20240516141438646" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131004303.png" alt="image-20240516141553753" style="zoom:59%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;FcaNet-Frequency-Channel-Attention-Networks&quot;&gt;&lt;a href=&quot;#FcaNet-Frequency-Channel-Attention-Networks&quot; class=&quot;headerlink&quot; title=&quot;FcaNet</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>SCConv: Spatial and Channel Reconstruction Convolution for Feature Redundancy</title>
    <link href="https://wangak.cc/posts/1c149dcc.html"/>
    <id>https://wangak.cc/posts/1c149dcc.html</id>
    <published>2024-06-12T16:00:00.000Z</published>
    <updated>2024-12-26T08:26:39.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SCConv-Spatial-and-Channel-Reconstruction-Convolution-for-Feature-Redundancy"><a href="#SCConv-Spatial-and-Channel-Reconstruction-Convolution-for-Feature-Redundancy" class="headerlink" title="SCConv: Spatial and Channel Reconstruction Convolution for Feature Redundancy"></a>SCConv: Spatial and Channel Reconstruction Convolution for Feature Redundancy</h2><p><strong>论文：《SCConv: Spatial and Channel Reconstruction Convolution for Feature Redundancy》（cvpr2023）</strong></p><p><strong>SCConv由空间重构单元（SRU)和通道重构单元（CRU)组成。</strong></p><ul><li>SRU采用分离重构的方法来抑制空间冗余</li><li>CRU采用分离变换融合的策略减少通道冗余</li></ul><h4 id="SCConv的结构"><a href="#SCConv的结构" class="headerlink" title="SCConv的结构"></a><strong>SCConv的结构</strong></h4><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012152.png" alt="image-20240529144607573"></p><p>利用SRU运算获得空间细化特征<script type="math/tex">X^w</script>,然后利用CRU运算获得通道细化特征Y,通过SCConv可以减少中间特征映射之间的冗余并增强CNN的特征表示</p><p><strong>空间重构单元（SRU)：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012043.png" alt="image-20240529152914871" style="zoom: 50%;"></p><p>空间重构单元(SRU)利用了分离和重构操作，分离操作的目的是将信息丰富的特征图与空间内容对应的信息较少的特征图分离开来</p><ul><li>利用组归一化（GN)中的因子<script type="math/tex">\gamma</script>来评估不同特征图的信息内容：</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012790.png" alt="image-20240529150814239" style="zoom:67%;"></p><p><em>注：因子<script type="math/tex">\gamma</script>是可训练的参数<script type="math/tex">\gamma\in{R^C}</script>,可利用其测量通道的像素方差，更丰富的空间信息反映了更多空间像素的变化，从而导致更大的<script type="math/tex">\gamma</script></em></p><ul><li>归一化后的权重<script type="math/tex">W_{\gamma}</script>通过下式得到：</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012984.png" alt="image-20240529151546208" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012200.png" alt="image-20240529151624068" style="zoom:67%;"></p><p><em>注:通过Gate门控来得到信息权重<script type="math/tex">W_1</script>和非信息权重<script type="math/tex">W_2</script>（Gate门控通过设置一个阈值，大于阈值置为1得到信息权重，小于置为0得到非信息权重）</em></p><ul><li><p>然后用输入特征X分别乘以信息权重<script type="math/tex">W_1</script>和非信息权重<script type="math/tex">W_2</script>，得到信息量大的<script type="math/tex">X_1^w</script>和信息量小的<script type="math/tex">X_2^w</script></p></li><li><p>最后，使用交叉重构运算将加权后的两个不同的信息特征结合起来</p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012343.png" alt="image-20240529152948213" style="zoom:67%;"></p><p>​    <em>注：∪是concat操作</em></p><p><strong>通道重构单元（CRU)：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012084.png" alt="image-20240529154145674" style="zoom:67%;"></p><p>使用CRU来取代了标准卷积，其通过三个操作符实现（Split、Transform、Fuse)</p><ul><li><p><strong>Split:</strong>将输入的<script type="math/tex">X^w</script>的通道分割为αC和(1-α)C两部分（α是分割比），之后再使用1×1卷积来压缩特征通道，来提高计算效率</p></li><li><p><strong>Transform:</strong></p><ul><li><p>对<script type="math/tex">X_{up}</script>​​使用（GWC、PWC)取代标准卷积来降低计算成本，之后再对输出进行汇总：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012988.png" alt="image-20240529154614185" style="zoom:67%;"></p></li><li><p>对<script type="math/tex">X_{low}</script>使用PWC作为对<script type="math/tex">X_{up}</script>的补充</p></li></ul></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012549.png" alt="image-20240529155523501" style="zoom:67%;"></p><ul><li>Fuse:对<script type="math/tex">Y_1</script>和<script type="math/tex">Y_2</script>进行融合</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012883.png" alt="image-20240529155734692" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012620.png" alt="image-20240529155800507" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131013076.png" alt="image-20240529155813158" style="zoom:67%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SCConv-Spatial-and-Channel-Reconstruction-Convolution-for-Feature-Redundancy&quot;&gt;&lt;a href=&quot;#SCConv-Spatial-and-Channel-Reconstruction-Co</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>BEFUnet:A Hybrid CNN-Transformer Architecture for Precise Medical Image Segmentation</title>
    <link href="https://wangak.cc/posts/7a30900a.html"/>
    <id>https://wangak.cc/posts/7a30900a.html</id>
    <published>2024-05-13T16:00:00.000Z</published>
    <updated>2024-05-28T02:18:35.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BEFUnet-A-Hybrid-CNN-Transformer-Architecture-for-Precise-Medical-Image-Segmentation"><a href="#BEFUnet-A-Hybrid-CNN-Transformer-Architecture-for-Precise-Medical-Image-Segmentation" class="headerlink" title="BEFUnet: A Hybrid CNN-Transformer Architecture for Precise Medical Image Segmentation"></a>BEFUnet: A Hybrid CNN-Transformer Architecture for Precise Medical Image Segmentation</h2><p>论文：《BEFUnet: A Hybrid CNN-Transformer Architecture for Precise Medical Image Segmentation》（arXiv 2024）</p><p>本文提出了一种创新的u型网络BEFUnet，该网络增强了体特征和边缘特征的融合，以实现精确的医学图像分割</p><p><strong>双分支编码器：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141006324.png" alt="image-20240504130415926" style="zoom:67%;"></p><ul><li><p><strong>边缘编码器：</strong>由四个阶段组成，每个阶段包含4个PDC块用于特征检测，并利用最大池化对各阶段之间的特征进行降采样来得到分层特征</p><p>注：PDC块包括一个深度卷积层、一个ReLU层和一个1×1的卷积层</p></li><li><p><strong>主体编码器：</strong>使用Swin-Transfomer对具有全局信息的高级特征进行编码</p></li></ul><p>将提取的边缘和体特征输入到LCAF模块进行融合</p><p><strong>LCAF：</strong>选择性地将边缘图和主体图进行交叉注意力，来融合边缘和主体的特征</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141006843.png" alt="image-20240504131627922" style="zoom:67%;"></p><p><strong>DLF模块：</strong>为确保层级之间的特征一致性，使用交叉注意力机制来跨尺度融合信息</p><p>较浅的层级包含更精确的定位信息，而较深的层级携带更适合解码器的更多语义信息，考虑到节省计算资源，只将最浅层（<script type="math/tex">P^l</script>)和最后一层（<script type="math/tex">P^s</script>)进行融合</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141006502.png" alt="image-20240504133235606" style="zoom:67%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BEFUnet-A-Hybrid-CNN-Transformer-Architecture-for-Precise-Medical-Image-Segmentation&quot;&gt;&lt;a href=&quot;#BEFUnet-A-Hybrid-CNN-Transformer-Arc</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
    <category term="特征融合" scheme="https://wangak.cc/tags/%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88/"/>
    
    <category term="双编码器" scheme="https://wangak.cc/tags/%E5%8F%8C%E7%BC%96%E7%A0%81%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>AGILEFORMER:SPATIALLY AGILE TRANSFORMER UNET FOR MEDICAL IMAGE SEGMENTATION</title>
    <link href="https://wangak.cc/posts/6b854769.html"/>
    <id>https://wangak.cc/posts/6b854769.html</id>
    <published>2024-05-13T16:00:00.000Z</published>
    <updated>2024-05-28T02:18:35.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AGILEFORMER-SPATIALLY-AGILE-TRANSFORMER-UNET-FOR-MEDICAL-IMAGE-SEGMENTATION"><a href="#AGILEFORMER-SPATIALLY-AGILE-TRANSFORMER-UNET-FOR-MEDICAL-IMAGE-SEGMENTATION" class="headerlink" title="AGILEFORMER: SPATIALLY AGILE TRANSFORMER UNET FOR MEDICAL IMAGE SEGMENTATION"></a>AGILEFORMER: SPATIALLY AGILE TRANSFORMER UNET FOR MEDICAL IMAGE SEGMENTATION</h2><p>论文：《AGILEFORMER: SPATIALLY AGILE TRANSFORMER UNET FOR MEDICAL IMAGE SEGMENTATION》（arXiv 2024）</p><ul><li><p>作者使用了一种新的patch embedding取代了vit-unet中标准的patch embedding</p></li><li><p>采用空间动态自注意力来捕获空间变化特征</p></li><li><p>提出了一种新的多尺度可变形位置编码</p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202405141004754.png" alt="image-20240511095459528"></p><h4 id="可变形的patch-embedding"><a href="#可变形的patch-embedding" class="headerlink" title="可变形的patch embedding"></a><strong>可变形的patch embedding</strong></h4><p>通过可变形卷积卷积核的采样位置可以根据输入的特征图进行微小的偏移，从而可以实现更灵活的特征提取。通过引入可变形的采样位置，使得补丁嵌入可以更好地适应不规则的结构，从而提高了特征提取的灵活性和准确性。</p><ul><li><p>第一个patch embedding：使用两个连续的可变形卷积层，这两个连续重叠的可变形patch embedding可以更好地提取局部特征，弥补了自注意力中局部性的不足</p></li><li><p>下采样层：通过3×3卷积完成下采样</p></li></ul><h4 id="空间动态自注意力"><a href="#空间动态自注意力" class="headerlink" title="空间动态自注意力"></a><strong>空间动态自注意力</strong></h4><p><strong>可变形多头自注意力：</strong></p><p>第h个头的计算过程如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141004778.png" alt="image-20240511100930114" style="zoom:67%;"></p><p>注：f是输入的特征图，ϕ是插值函数，用于生成偏移后的特征图<script type="math/tex">\hat{f}</script>,<script type="math/tex">∆p_h</script>是第h个头部生成的偏移量,其通过一个卷积层生成</p><p><strong>邻域多头自注意力：</strong></p><p>与标准自注意力不同，标准自注意力计算特征图f中每个位置p的元素与其他位置元素的相似度，而邻域注意力只利用位置p周围k个最近邻的信息来计算注意力权重，而不是与所有位置的元素计算相似度。减少了标准自注意力的计算复杂度，从二次降至近似于空间维度线性的复杂度。重新引入了局部操作到自注意力中，使得模型具有平移等变性，从而提高了保留局部信息的能力。</p><h4 id="多尺度可变形位置编码"><a href="#多尺度可变形位置编码" class="headerlink" title="多尺度可变形位置编码"></a>多尺度可变形位置编码</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202405141004551.png" alt="image-20240511102232095" style="zoom:67%;"></p><p>通过在跨多个尺度对不规则采样的位置信息进行编码。</p><p>公式如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141004922.png" alt="image-20240511102056849"></p><p><em>注：f是输入特征图，<script type="math/tex">P_θ</script>实现为多尺度可变形深度卷积层，具有不同的核大小（3×3和5×5）</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;AGILEFORMER-SPATIALLY-AGILE-TRANSFORMER-UNET-FOR-MEDICAL-IMAGE-SEGMENTATION&quot;&gt;&lt;a href=&quot;#AGILEFORMER-SPATIALLY-AGILE-TRANSFORMER-UNET-</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
    <category term="特征提取" scheme="https://wangak.cc/tags/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>SegMamba:Long-range Sequential Modeling Mamba For 3D Medical Image Segmentation</title>
    <link href="https://wangak.cc/posts/f4ee98c4.html"/>
    <id>https://wangak.cc/posts/f4ee98c4.html</id>
    <published>2024-05-13T16:00:00.000Z</published>
    <updated>2024-05-28T01:55:18.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SegMamba-Long-range-Sequential-Modeling-Mamba-For-3D-Medical-Image-Segmentation"><a href="#SegMamba-Long-range-Sequential-Modeling-Mamba-For-3D-Medical-Image-Segmentation" class="headerlink" title="SegMamba: Long-range Sequential Modeling Mamba For 3D Medical Image Segmentation"></a>SegMamba: Long-range Sequential Modeling Mamba For 3D Medical Image Segmentation</h2><p>论文：《SegMamba: Long-range Sequential Modeling Mamba For 3D Medical Image Segmentation》（arXiv 2024）</p><p>论文贡献：</p><ul><li>设计了ToM模块，用以增强三维特征的顺序建模</li><li>设计了门控空间卷积模块（GSC)，用以增强每个ToM之前空间维度上的特征表示</li></ul><h4 id="网络结构："><a href="#网络结构：" class="headerlink" title="网络结构："></a><strong>网络结构：</strong></h4><p><img src="https://typoraimg.wangak.cc/2023/img/202405141007030.png" alt="image-20240507091527951"></p><p><strong>1.Stem</strong></p><p>采用深度卷积，内核大小为7×7×7，填充为3×3×3，步幅为2×2×2。</p><p><strong>2.TSMamba块</strong></p><p>计算过程如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141007633.png" alt="image-20240507091715749" style="zoom:67%;"></p><p><em>注：其中GSC和ToM分别表示所提出的门控空间卷积模块和三向Mamba模块</em></p><p><strong>3.门控空间卷积(GSC)</strong></p><p>门控空间卷积(GSC)用于提取mamba层之前的空间关系</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141007183.png" alt="image-20240507092130322" style="zoom:67%;"></p><p>计算过程如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141007271.png" alt="image-20240507092149524" style="zoom:67%;"></p><p><strong>4.三向mamba（ToM)</strong></p><p>从三个方向计算特征依赖关系，将三维输入特征平铺成三个序列，进行相应的特征交互，得到融合后的三维特征</p><p>计算过程如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141007074.png" alt="image-20240507092415793" style="zoom:67%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SegMamba-Long-range-Sequential-Modeling-Mamba-For-3D-Medical-Image-Segmentation&quot;&gt;&lt;a href=&quot;#SegMamba-Long-range-Sequential-Modeling-M</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
    <category term="特征增强" scheme="https://wangak.cc/tags/%E7%89%B9%E5%BE%81%E5%A2%9E%E5%BC%BA/"/>
    
    <category term="mamba类" scheme="https://wangak.cc/tags/mamba%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Medical Image Segmentation via Cascaded Attention Decoding</title>
    <link href="https://wangak.cc/posts/3790531e.html"/>
    <id>https://wangak.cc/posts/3790531e.html</id>
    <published>2024-05-06T16:00:00.000Z</published>
    <updated>2024-05-07T11:47:50.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Medical-Image-Segmentation-via-Cascaded-Attention-Decoding"><a href="#Medical-Image-Segmentation-via-Cascaded-Attention-Decoding" class="headerlink" title="Medical Image Segmentation via Cascaded Attention Decoding"></a>Medical Image Segmentation via Cascaded Attention Decoding</h2><p><strong>论文：《Medical Image Segmentation via Cascaded Attention Decoding》（WACV 2023)</strong></p><p>这篇论文和之前看过的一些文章设计思路也差不多，通过对编码器四个阶段输出的特征进行了融合，不同之处在于这篇论文提出了AG和CAM两个模块进行特征的融合，先使用AG进行特征融合，再使用CAM进行增强</p><p><strong>级联注意解码器:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071929069.png" alt="image-20240426162057053" style="zoom:67%;"></p><p>UpConv:对特征进行上采样</p><p>CAM:用于增强特征映射</p><p>作者使用了四个CAM块聚合编码器四个阶段输出的特征，三个AG模块将先前解码器上采样的特征与跳跃连接的特征结合起来</p><p><strong>AG：用于级联的特征融合</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071929850.png" alt="image-20240427213751108" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071930154.png" alt="image-20240427213938485" style="zoom: 67%;"></p><p><strong>CAM:用于增强特征映射</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071930371.png" alt="image-20240427214031982" style="zoom: 80%;"></p><p>CAM由通道注意力、空间注意力和一个卷积块组成，使用通道注意力、空间注意力可以来抑制背景信息</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071930603.png" alt="image-20240427214223908" style="zoom:67%;"></p><p>注：这里的卷积块是由两个3×3的卷积层组成，每个卷积层后是一个BN和一个ReLU</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071930828.png" alt="image-20240427214438165" style="zoom:67%;"></p><p><strong>多阶段损失和特征聚合：</strong></p><p>作者是通过对分层编码器的四个阶段输出的结果使用加性聚合的方式生成最后的预测图：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071930176.png" alt="image-20240427214745978" style="zoom:67%;"></p><p><em>注1：p1、p2、p3、p4为四个预测头的特征映射，w、x、y、z为各个预测头像的权重。</em></p><p><em>注2：本文中作者将w、x、y、z均设为1</em></p><p>作者通过分别计算每个预测头的损失，来得到最终的损失：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071930911.png" alt="image-20240427215042984" style="zoom:67%;"></p><p><em>注：实验中作者将α, β, γ,  ζ均设为了1</em></p><p><strong>整体的网络结构如下：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071930348.png" alt="image-20240427215222965" style="zoom: 50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Medical-Image-Segmentation-via-Cascaded-Attention-Decoding&quot;&gt;&lt;a href=&quot;#Medical-Image-Segmentation-via-Cascaded-Attention-Decoding&quot; cl</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
    <category term="特征融合" scheme="https://wangak.cc/tags/%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88/"/>
    
    <category term="特征增强" scheme="https://wangak.cc/tags/%E7%89%B9%E5%BE%81%E5%A2%9E%E5%BC%BA/"/>
    
  </entry>
  
</feed>
