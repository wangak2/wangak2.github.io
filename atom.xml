<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>丹青两幻</title>
  
  <subtitle>欢迎~</subtitle>
  <link href="https://wangak.cc/atom.xml" rel="self"/>
  
  <link href="https://wangak.cc/"/>
  <updated>2023-11-06T16:00:00.000Z</updated>
  <id>https://wangak.cc/</id>
  
  <author>
    <name>丹青两幻</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>3D UX-NET</title>
    <link href="https://wangak.cc/posts/eabf9f8.html"/>
    <id>https://wangak.cc/posts/eabf9f8.html</id>
    <published>2023-11-06T16:00:00.000Z</published>
    <updated>2023-11-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3D-UX-NET"><a href="#3D-UX-NET" class="headerlink" title="3D UX-NET"></a>3D UX-NET</h2><p><strong>论文：《3D UX-NET: A LARGE KERNEL VOLUMETRIC CONVNET MODERNIZING HIERARCHICAL TRANSFORMER</strong><br><strong>FOR MEDICAL IMAGE SEGMENTATION》（ICLR 2023）</strong></p><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115336.png" alt="image-20231106201433865"></p><p>采用具备大卷积核的投影层来提取 patch-wise 特征作为编码器的输入</p><p><strong>对Swin transformer的transformer block做了替换：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115856.png" alt="image-20231106202256333" style="zoom:67%;"></p><p>使用大卷积核(7 × 7 × 7)的深度卷积来模仿Swin Transformer的局部自注意力和窗口移动。</p><p>使用2 × 2 × 2、步幅为2的标准卷积块来实现下采样</p><p>在Swin Transformer中MLP隐藏层维度比输入维度宽四倍，引入了具有 1 × 1 × 1 卷积核大小的深度卷积缩放(DCS)，以独立地线性缩放每个通道特征，减少跨通道上下文产生的冗余信息</p><p>DCS：1x1x1的深度卷积+1x1x1的分组卷积</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115037.png" alt="image-20231106205655475" style="zoom:67%;"></p><p>从实验中发现：使用深度卷积缩放(DCS)参数量得到了减小，效果并没有下降</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115199.png" alt="image-20231106204002121"></p><p>编码器的输出特征由残差块作进一步的处理，以稳定提取的特征。（残差块由两个经过实例归一化的后归一化3 × 3 × 3卷积层组成）</p><p>转置卷积层实现上采样，其输出的特征与编码器的输出进行连接后，再次输入到残差块中。</p><h3 id="2-实验结果"><a href="#2-实验结果" class="headerlink" title="2.实验结果"></a>2.实验结果</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115341.png" alt="image-20231106210428239"></p><p>3D UX-Net 在这几个分割任务中均展示出最佳性能，并且 Dice 分数有了一定的提高</p>]]></content>
    
    
    <summary type="html">记录了3D UX-NET的网络结构及实验结果</summary>
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>DconnNet</title>
    <link href="https://wangak.cc/posts/43143b98.html"/>
    <id>https://wangak.cc/posts/43143b98.html</id>
    <published>2023-11-01T16:00:00.000Z</published>
    <updated>2023-11-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DconnNet"><a href="#DconnNet" class="headerlink" title="DconnNet"></a>DconnNet</h2><p>​        将分割问题建模为纯像素分类任务，没有直接利用像素之间的关系和几何特性，网络忽略了像素之间的相互关系，无法充分利用图像中的空间信息，因此，这些模型可能导致低空间一致性（共享相似的空间特征的相邻像素，分割模型或处理方法的输出可能会出现不一致或不协调的情况），具体表现为某些区域存在不规则的断裂或错误的连接，一些结构可能被孤立地分割出来，而不与其他相关结构相连。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;DconnNet&quot;&gt;&lt;a href=&quot;#DconnNet&quot; class=&quot;headerlink&quot; title=&quot;DconnNet&quot;&gt;&lt;/a&gt;DconnNet&lt;/h2&gt;&lt;p&gt;​        将分割问题建模为纯像素分类任务，没有直接利用像素之间的关系和几何特性，网络</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>图像分割常用指标</title>
    <link href="https://wangak.cc/posts/70fa35a7.html"/>
    <id>https://wangak.cc/posts/70fa35a7.html</id>
    <published>2023-11-01T16:00:00.000Z</published>
    <updated>2023-11-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图像分割常用指标"><a href="#图像分割常用指标" class="headerlink" title="图像分割常用指标"></a>图像分割常用指标</h3><h4 id="1-DSC（Dice相似系数）"><a href="#1-DSC（Dice相似系数）" class="headerlink" title="1.DSC（Dice相似系数）"></a>1.DSC（Dice相似系数）</h4><p><strong>DSC：用于衡量区域的重合程度</strong></p><p><strong>计算公式：</strong></p><script type="math/tex; mode=display">DSC = (2 * |A ∩ B|) / (|A| + |B|)</script><p>其中，A为算法生成的分割结果的像素集合，B为参考分割结果的像素集合</p><ul><li><p>DSC值范围在0到1之间，其中0表示完全不相似，1表示完全相似。</p></li><li><p>DSC值越接近1，表示算法生成的分割结果与参考分割结果越相似</p></li></ul><p><em>注：Dice相似系数仅考虑了像素的重叠情况，而没有考虑像素之间的空间关系，在存在模糊边界的分割任务中,Dice系数可能无法准确评估模型的性能。</em></p><h4 id="2-HD-豪斯多夫距离"><a href="#2-HD-豪斯多夫距离" class="headerlink" title="2.HD(豪斯多夫距离)"></a>2.HD(豪斯多夫距离)</h4><p><strong>HD:表示预测分割区域边界与真实区域边界之间的最大距离，其值越小代表预测边界分割误差越小、质量越好。</strong></p><p><strong>计算公式：</strong></p><p><img src="/posts/70fa35a7.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20231102100120629.png" alt="image-20231102100120629" style="zoom:67%;"></p><p><img src="/posts/70fa35a7.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20231102100057838.png" alt="image-20231102100057838" style="zoom:67%;"></p><p><strong>计算步骤：</strong></p><p>​    (1)对点集X中的每一个点x计算其到点集Y中的每一个点y的距离，保留最短距离，然后找出保留的最短距离中的最大距离记为Dxy。</p><p>​    (2)对点集Y中的每一个点y计算其到点集X中的每一个点x的距离，保留最短距离，然后找出保留最短距离中的最大距离记为Dyx。</p><p>​    (3)取Dxy和Dyx最大值作为点集X和Y之间的豪斯多夫距离。</p><p><strong>HD95(95％ 豪斯多夫距离):</strong></p><p>为了排除一些离群点造成的不合理距离，保持整体数值稳定性，一般选择从小到大排名前 95%的距离作为实际豪斯多夫距离，称之为 95% 豪斯多夫距离。</p><p><strong>注：Dice相似系数主要关注分割结果的整体准确性，HD95则更侧重于考虑分割边界的精确性</strong></p><p><strong>注： 豪斯多夫距离目标是捕捉两个集合之间的最大不一致，对于孤立的离群点或噪声非常敏感，不适用于噪声较多的图像。</strong></p><h4 id="3-ASD（平均表面距离）"><a href="#3-ASD（平均表面距离）" class="headerlink" title="3.ASD（平均表面距离）"></a>3.ASD（平均表面距离）</h4><p>平均表面距离：用来测量分割结果中的边界与真实标签中的边界之间的距离。</p><p><strong>计算分割结果中的每个像素与真实标签中的最近像素之间的距离，然后取平均值。</strong></p><p><img src="/posts/70fa35a7.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20231102102746435.png" alt="image-20231102102746435" style="zoom: 50%;"></p><p><strong>ASSD(平均对称表面距离):</strong></p><p>​                                                            <script type="math/tex">\large ASSD(X,Y)={ASD(X,Y)+ASD(Y,X)}/2</script></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;图像分割常用指标&quot;&gt;&lt;a href=&quot;#图像分割常用指标&quot; class=&quot;headerlink&quot; title=&quot;图像分割常用指标&quot;&gt;&lt;/a&gt;图像分割常用指标&lt;/h3&gt;&lt;h4 id=&quot;1-DSC（Dice相似系数）&quot;&gt;&lt;a href=&quot;#1-DSC（Dice相似系数</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>nnFormer</title>
    <link href="https://wangak.cc/posts/9e11ec23.html"/>
    <id>https://wangak.cc/posts/9e11ec23.html</id>
    <published>2023-10-30T16:00:00.000Z</published>
    <updated>2023-10-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nnFormer"><a href="#nnFormer" class="headerlink" title="nnFormer"></a>nnFormer</h2><p><strong>论文：《nnFormer: Volumetric Medical Image Segmentation via a 3D Transformer》（TMI2022）</strong></p><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310252011844.png" alt="image-20231025201100423" style="zoom: 80%;"></p><h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h4><p><strong>nnFormer的输入：</strong>对原始图像中随机裁剪（HxWxD)，数据增强技术，有助于模型更好地学习不同部分的特征。</p><p><strong>The embedding layer:</strong>（将输入数据转换成高维张量）</p><ul><li><strong>使用卷积的好处：</strong>对比transformer使用线性层对patch的向量进行映射，卷积层能够更细致地捕获图像中的像素级信息（减少了训练的参数数量，卷积核在处理特定区域时更加专注）</li><li><strong>在初始阶段使用小卷积核的连续卷积层，相对于大卷积核的好处：</strong>降低计算复杂度,同时保持相同大小的感受野(非线性激活函数多了，语义表达能力增强了)</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202310252109346.png" alt="image-20231025210627610"></p><p><em>注：根据输入的patch大小卷积步长也会有相应的变化</em></p><p><strong>Local Volume-based Multi-head Self-attention (LV-MSA)：</strong>将不同尺度的信息和高分辨率的空间信息相互关联</p><p>不同尺度的特征由下采样层生成，高分辨率的空间信息则由嵌入层编码</p><p>使用的是一种基于局部三维图像块的self-attention计算方式（跟Swin-UNet类似)</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310252129451.png" alt="image-20231025212855680" style="zoom: 80%;"></p><p><strong>SLV-MSA:</strong>是LV-MSA的shifted版本（类似于Swin-UNet，目的是使局部的三维图像块之间产生联系）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310252130572.png" alt="image-20231025213050517" style="zoom: 67%;"></p><p><em>注：$S_H、S_W、S_D$代表每个图像块中的patch的数量</em></p><p>使用LV-MSA减少了计算的复杂度，计算复杂度和图像之间是线性的关系</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310252139215.png" alt="image-20231025213709821" style="zoom: 80%;"></p><p>使用相对位置偏置B来引入位置信息</p><p><strong>The down-sampling layer：</strong></p><p>与Swin-UNet使用patch merging不同，作者选择了使用简单的卷积来实现下采样，卷积下采样可以在不同空间维度上应用不同的步长，以根据问题的要求调整下采样率。（可以根据数据的特点来灵活设置，避免过度下采样，对于三维的图像在某些维度上数据切片数量有限，这时可以将该维度的步长设置为1）</p><h4 id="Bottleneck"><a href="#Bottleneck" class="headerlink" title="Bottleneck"></a>Bottleneck</h4><p>不同于编码器使用局部自注意力机制，Bottleneck中使用全局自注意力。</p><p>计算复杂度：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310271637998.png" alt="image-20231027153408838" style="zoom: 80%;"></p><p>编码器部分减小了h、w、d，这为GV-MSA的应用创造了条件，与LV-MSA相比，GV-MSA能够提供更大的感受野</p><h4 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h4><p><strong>上采样操作</strong>：使用转置卷积</p><p><strong>Skip Attention：</strong>（使不同层之间的信息交流变得更加灵活）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310271636161.png" alt="image-20231027155805206" style="zoom: 67%;"></p><h3 id="2-实验部分"><a href="#2-实验部分" class="headerlink" title="2.实验部分"></a>2.实验部分</h3><h4 id="与基于Transformer的方法学的比较"><a href="#与基于Transformer的方法学的比较" class="headerlink" title="与基于Transformer的方法学的比较"></a>与基于Transformer的方法学的比较</h4><p><strong>脑肿瘤分割</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310271636932.png" alt="image-20231027162254249" style="zoom: 67%;"></p><p>列出了所有模型在脑瘤分割任务上的实验结果,nnFormer在所有类别中取得了最低的HD95和最高的DSC分数。</p><p><strong>多器官分割（Synapse）</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310302100261.png" alt="image-20231029163515666"></p><p>与以前基于Transformer的方法相比，nnFormer在分割胰腺(Pancreas)和胃(Stomach)方面更有优势</p><p><strong>与nnUNet的比较</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310302100944.png" alt="image-20231030203836841"></p><p>nnFormer的HD95似乎更有优势，其可以更好地划分对象边界。</p><p>nnAvg：对nnFormer和nnUNet的预测结果进行平均化，发现整体的性能得到了提高，表明nnFormer和nnUNet是可以互补的。</p><h4 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202310302100685.png" alt="image-20231030205355146"></p><ul><li><p>嵌入层使用小卷积核大小的连续卷积层</p></li><li><p>卷积下采样层替换掉了patch Merging层</p></li><li><p>GV-MSA替换了Bottleneck的LV-MSA</p></li><li><p>Skip Attention代替跳跃连接</p></li><li>SLV-MSA层与LV-MSA层级联，全局自注意力层的数量增加一倍</li></ul>]]></content>
    
    
    <summary type="html">记录了nnFormer的网络结构及实验结果</summary>
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>File类</title>
    <link href="https://wangak.cc/posts/c8b66f0a.html"/>
    <id>https://wangak.cc/posts/c8b66f0a.html</id>
    <published>2023-10-18T12:44:09.000Z</published>
    <updated>2023-10-20T14:33:25.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><h3 id="1-创建File类的对象"><a href="#1-创建File类的对象" class="headerlink" title="1.创建File类的对象"></a>1.创建File类的对象</h3><p><img src="https://typoraimg.wangak.cc/2023/img/1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//创建一个File对象，指向某个具体的文件</span><br><span class="line">      File f1=new File(&quot;./data/test.txt&quot;);</span><br><span class="line">      System.out.println(f1.length());//文件大小</span><br><span class="line"></span><br><span class="line">      File f2=new File(&quot;./data/aaa.txt&quot;);//File对象可以指向空路径</span><br><span class="line">      System.out.println(f2.length());//0</span><br><span class="line">      System.out.println(f2.exists());//false</span><br></pre></td></tr></table></figure><h3 id="2-判断文件类型、获取文件信息"><a href="#2-判断文件类型、获取文件信息" class="headerlink" title="2.判断文件类型、获取文件信息"></a>2.判断文件类型、获取文件信息</h3><p><img src="https://typoraimg.wangak.cc/2023/img/2.png" alt="img" style="zoom: 50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//1.创建一个File对象，指向某个具体的文件</span><br><span class="line">      File f1=new File(&quot;./data/test.txt&quot;);</span><br><span class="line">      //2.判断文件路径是否存在</span><br><span class="line">      System.out.println(f1.exists());</span><br><span class="line">      //3.判断文件对象是否是文件</span><br><span class="line">      System.out.println(f1.isFile());</span><br><span class="line">      //4.判断文件对象是否是文件夹</span><br><span class="line">      System.out.println(f1.isDirectory());</span><br><span class="line">      //5.获取文件的名称</span><br><span class="line">      System.out.println(f1.getName());</span><br><span class="line">      //6.获取文件的大小，返回字节个数</span><br><span class="line">      System.out.println(f1.length());</span><br><span class="line">      //7.获取文件最后的修改时间</span><br><span class="line">      long time = f1.lastModified();</span><br><span class="line">      SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);</span><br><span class="line">      System.out.println(sdf.format(time));//2023/10/18</span><br><span class="line">      //8.获取创建文件对象时使用的路径</span><br><span class="line">      System.out.println(f1.getPath());</span><br><span class="line">      //9.获取文件对象的绝对路径</span><br><span class="line">      System.out.println(f1.getAbsolutePath());</span><br></pre></td></tr></table></figure><h3 id="3-创建、删除文件"><a href="#3-创建、删除文件" class="headerlink" title="3.创建、删除文件"></a>3.创建、删除文件</h3><p><strong>public boolean creatNewFile():</strong>创建一个新文件，创建成功返回true</p><p><strong>public boolean mkdir():</strong>创建文件夹（只能创建一级文件夹）</p><p><strong>public boolean mkdirs():</strong>创建文件夹,可以创建多级文件夹</p><p><strong>public boolean delete():</strong>删除文件或文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//1.创建一个新文件</span><br><span class="line">      File f1=new File(&quot;./data/test2.txt&quot;);</span><br><span class="line">      System.out.println(f1.createNewFile());</span><br><span class="line">      //2.创建文件夹</span><br><span class="line">      File f2=new File(&quot;./data/a&quot;);</span><br><span class="line">      System.out.println(f2.mkdir());</span><br><span class="line">      //3.创建多个文件夹</span><br><span class="line">      File f3=new File(&quot;./data/1/2&quot;);</span><br><span class="line">      System.out.println(f3.mkdirs());</span><br><span class="line">      //4.删除文件或文件夹</span><br><span class="line">      System.out.println(f1.delete());</span><br><span class="line">      System.out.println(f2.delete());</span><br><span class="line">      System.out.println(f3.delete());</span><br><span class="line">      //&quot;./data/1&quot;这个文件夹还存在</span><br></pre></td></tr></table></figure><h3 id="4-遍历文件夹"><a href="#4-遍历文件夹" class="headerlink" title="4.遍历文件夹"></a>4.遍历文件夹</h3><p><img src="https://typoraimg.wangak.cc/2023/img/3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">File f1=new File(&quot;./data&quot;);</span><br><span class="line">      //获取目录下文件的名称</span><br><span class="line">      String[] names=f1.list();</span><br><span class="line">      for(String x:names)&#123;</span><br><span class="line">          System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">      //获取当前目录下的文件对象</span><br><span class="line">      File[] files=f1.listFiles();</span><br><span class="line">      for (File file:files)&#123;</span><br><span class="line">          System.out.println(file.getPath());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;File类&quot;&gt;&lt;a href=&quot;#File类&quot; class=&quot;headerlink&quot; title=&quot;File类&quot;&gt;&lt;/a&gt;File类&lt;/h2&gt;&lt;h3 id=&quot;1-创建File类的对象&quot;&gt;&lt;a href=&quot;#1-创建File类的对象&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>卷积编码位置信息</title>
    <link href="https://wangak.cc/posts/a8dea67.html"/>
    <id>https://wangak.cc/posts/a8dea67.html</id>
    <published>2023-10-13T06:56:14.000Z</published>
    <updated>2023-10-14T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>论文：《HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE?》（ICLR2020）</strong></p><h3 id="论文内容："><a href="#论文内容：" class="headerlink" title="论文内容："></a>论文内容：</h3><h4 id="初步实验："><a href="#初步实验：" class="headerlink" title="初步实验："></a>初步实验：</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412926.png" alt="1"></p><p>对原始图像和裁剪过的图像进行显著性检测。</p><p>显著的区域分析，对于相同的物体，在不同的边缘下，显著性区域始终靠近图像中心。</p><p>推测：<strong>位置信息在 CNN 网络提取的特征图中被隐式编码</strong></p><h4 id="Position-Encoding-Network："><a href="#Position-Encoding-Network：" class="headerlink" title="Position Encoding Network："></a>Position Encoding Network：</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412136.png" alt="2"></p><p><strong>a feed forward convolutional encoder network $f_{enc} $:</strong>使用预训练的VGG或者 ResNet，仅作为前馈网络，其参数不参与训练。为前馈网络的在五个卷积层产生的特征图，使用双线性插值缩放到统一尺寸进行拼接，之后输入到 Position Encoding Module 中。</p><p><strong>position encoding module：</strong>一般卷积网络，其卷积核未使用Padding。</p><p>作者使用该网络判断卷积层产生的特征图中是否包含位置信息。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412155.png" alt="3" style="zoom: 80%;"></p><p>垂直（H)和水平(V)方向的梯度掩码、应用高斯滤波器来设计另一种类型的真值图，高斯分布(G)、水平和垂直条纹（HS、VS)，使用这五种图像表示位置信息，作为Ground Truth，每次训练选择其中一种，<strong>所有样本的标签都是一样的</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412681.png" alt="4" style="zoom:80%;"></p><p>除了使用数据集中的原始图像，作者还分别将<strong>纯黑、纯白、高斯噪声图像作为输入</strong>，这是为了验证在没有语义信息的情况下，特征中是否包含绝对位置信息。</p><p><strong>评价指标：</strong> Spearmen Correlation (<strong>SPC</strong>) and Mean Absoute Error (<strong>MAE</strong>)，前者越高说明输出与目标图像的相关性越高，后者则相反。</p><p><strong>实验结果:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412217.png" alt="5"></p><p>单独使用PosENet得到的分数要低很多，这一结果表明，仅从输入图像中提取位置信息是非常困难的，<strong>PosENet要与编码器网络相结合才能更好地提取出位置信息</strong></p><p>发现基于ResNet的模型比基于VGG16的模型实现了更高的性能。</p><h4 id="探究卷积的参数对提取位置信息的影响"><a href="#探究卷积的参数对提取位置信息的影响" class="headerlink" title="探究卷积的参数对提取位置信息的影响"></a>探究卷积的参数对提取位置信息的影响</h4><p><strong>length of convolutional layers：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412853.png" alt="6" style="zoom: 67%;"></p><p><strong>kernel size:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412339.png" alt="7" style="zoom: 80%;"></p><p>​                                                                <strong>更大的感受野可以更好地解析位置信息</strong></p><p><strong>zero-padding：</strong>作者认为卷积中zero-padding 是 CNN 中位置信息的来源</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412058.png" alt="8" style="zoom:80%;"></p><p>从结果中可以看出，未添加 zero-padding 的 VGG16 的性能比默认设置（padding =  1）低得多。PosENet（padding = 1）实现了比原始（padding = 0）更高的性能，而当 padding 设置为 2  时，位置信息的作用更加明显。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;论文：《HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE?》（ICLR2020）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;论文内容：&quot;&gt;&lt;a href=&quot;#论文内容：</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="深度学习" scheme="https://wangak.cc/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CNN" scheme="https://wangak.cc/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架</title>
    <link href="https://wangak.cc/posts/9753a2e.html"/>
    <id>https://wangak.cc/posts/9753a2e.html</id>
    <published>2023-10-03T08:31:34.000Z</published>
    <updated>2023-10-13T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><h3 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1.泛型"></a>1.泛型</h3><p><strong>泛型：</strong>允许在编写类、接口和方法时使用类型参数，以在运行时确定具体的数据类型，用于增强类型安全性和代码的可重用性</p><h4 id="1-1-泛型类"><a href="#1-1-泛型类" class="headerlink" title="1.1 泛型类"></a>1.1 泛型类</h4><p><strong>泛型类：</strong><code>类名&lt;T,...&gt;</code>,T是类型占位符，表示一种引用类型，如果编写多个用逗号隔开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGeneric</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//1.创建变量</span></span><br><span class="line">    T t;</span><br><span class="line">    <span class="comment">//2.使用泛型作为方法的参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T y)</span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.使用泛型作为方法的返回值</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用泛型类创建对象</span></span><br><span class="line">        MyGeneric&lt;String&gt; myGeneric1=<span class="keyword">new</span> <span class="title class_">MyGeneric</span>&lt;&gt;();</span><br><span class="line">        myGeneric1.t=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        MyGeneric&lt;Integer&gt; myGeneric2=<span class="keyword">new</span> <span class="title class_">MyGeneric</span>&lt;&gt;();</span><br><span class="line">        myGeneric2.t=<span class="number">100</span>;</span><br><span class="line">        myGeneric1.show();</span><br><span class="line">        myGeneric2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p>1.泛型只能是引用类型</p><p>2.不同泛型类型的对象之间不能相互赋值</p><h4 id="1-2-泛型接口"><a href="#1-2-泛型接口" class="headerlink" title="1.2 泛型接口"></a>1.2 泛型接口</h4><p><strong>泛型接口：</strong><code>接口名&lt;T&gt;</code></p><p><strong><em>注：不能使用泛型创建静态常量</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">server</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口实现方式一：class确定泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyImpl1</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&lt;String&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">server</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口实现方式二：class不确定泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyImpl2</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">server</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyImpl1 myImpl1=<span class="keyword">new</span> <span class="title class_">MyImpl1</span>();</span><br><span class="line">        myImpl1.server(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        MyImpl2&lt;Integer&gt; myImpl2a=<span class="keyword">new</span> <span class="title class_">MyImpl2</span>&lt;&gt;();</span><br><span class="line">        myImpl2a.server(<span class="number">100</span>);</span><br><span class="line">        MyImpl2&lt;String&gt; myImpl2b=<span class="keyword">new</span> <span class="title class_">MyImpl2</span>&lt;&gt;();</span><br><span class="line">        myImpl2b.server(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">hello</span><br><span class="line"><span class="number">100</span></span><br><span class="line">world</span><br></pre></td></tr></table></figure><h4 id="1-3-泛型方法"><a href="#1-3-泛型方法" class="headerlink" title="1.3 泛型方法"></a>1.3 泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenernicMod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">show</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;泛型方法:&quot;</span>+t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test4</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GenernicMod genernicMod=<span class="keyword">new</span> <span class="title class_">GenernicMod</span>();</span><br><span class="line">        genernicMod.show(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        genernicMod.show(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">泛型方法:hello</span><br><span class="line">泛型方法:<span class="number">123</span></span><br></pre></td></tr></table></figure><h4 id="1-4-泛型集合"><a href="#1-4-泛型集合" class="headerlink" title="1.4 泛型集合"></a>1.4 泛型集合</h4><p><strong>泛型集合：</strong>参数化类型、类型安全的集合，强制集合元素的类型必须一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;yyy&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; iterator=arrayList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String string=iterator.next();</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Collection体系集合"><a href="#2-Collection体系集合" class="headerlink" title="2.Collection体系集合"></a>2.Collection体系集合</h3><p><strong>集合和数组的区别：</strong></p><p>(1).数组长度固定，集合长度不固定</p><p>(2).数组可以存储基本类型和引用类型，集合只能存储引用类型。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201402167.png" alt="1"></p><ul><li><p><strong>Collection</strong> 接口存储一组不唯一，无序的对象</p></li><li><p><strong>List</strong> 接口存储一组不唯一，有序的对象。</p></li><li><p><strong>Set</strong> 接口存储一组唯一，无序的对象</p></li><li><p><strong>Map</strong> 接口存储一组键值对象，提供key到value的映射</p><p><strong>Collection的使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">       <span class="comment">//1.添加元素</span></span><br><span class="line">        collection.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">        <span class="comment">//*2.删除元素</span></span><br><span class="line"><span class="comment">//        collection.remove(&quot;a&quot;);//一次remove操作只删除一个元素，即使Collection中有相同元素</span></span><br><span class="line"><span class="comment">//        System.out.println(collection);</span></span><br><span class="line">        <span class="comment">//*3.1使用增强for遍历</span></span><br><span class="line"><span class="comment">//        for (Object object:collection) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(object);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//*3.2使用迭代器进行遍历</span></span><br><span class="line">        <span class="comment">//hasNext();判断有没有下一个元素</span></span><br><span class="line">        <span class="comment">//next();获取下一个元素</span></span><br><span class="line">        <span class="comment">//remove();删除当前元素</span></span><br><span class="line">        Iterator it= collection.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String s=(String)it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line"><span class="comment">//            it.remove();//删除当前元素</span></span><br><span class="line">        &#125;<span class="comment">//使用迭代器遍历时禁止使用Collection的其他的一些方法如remove()来改变集合的元素，可以使用迭代器的方法(it.remove())</span></span><br><span class="line"><span class="comment">//        System.out.println(collection);</span></span><br><span class="line">        <span class="comment">//*4.判断元素是否存在</span></span><br><span class="line">        System.out.println(collection.contains(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-1-List子接口"><a href="#2-1-List子接口" class="headerlink" title="2.1 List子接口"></a>2.1 List子接口</h4><p><strong>List：</strong>有序、有下标、元素可以重复</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201402726.png" alt="2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">List_test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//1.添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="number">0</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//2.删除元素</span></span><br><span class="line"><span class="comment">//        list.remove(&quot;c&quot;);//按元素删除</span></span><br><span class="line">        list.remove(<span class="number">0</span>);<span class="comment">//按下标删除</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//3.遍历</span></span><br><span class="line">        <span class="comment">//3.1使用for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.1使用for&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2使用增强for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.2使用增强for&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object object:list)&#123;</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.3使用迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.3使用迭代器&quot;</span>);</span><br><span class="line">        Iterator iterator=list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.4使用列表迭代器，ListIterator可以向前或向后遍历，可以添加、删除、修改元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.4使用列表迭代器向后遍历&quot;</span>);</span><br><span class="line">        ListIterator lit=list.listIterator();</span><br><span class="line">        <span class="keyword">while</span>(lit.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;3.4使用列表迭代器向前遍历&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(lit.hasPrevious())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.previous());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.获取元素的索引位置</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ArrayList存储结构：</strong>数组，查找速度快，增删速度慢，运行效率快，线程不安全</p><p><strong>Vector存储结构：</strong>数组，查找速度快，增删速度慢，运行效率慢，线程安全</p><p><strong>LinkedList存储结构:</strong>双向链表，增删速度快，查询速度慢</p><h4 id="2-2-set子接口"><a href="#2-2-set子接口" class="headerlink" title="2.2 set子接口"></a>2.2 set子接口</h4><h5 id="2-2-1-Set"><a href="#2-2-1-Set" class="headerlink" title="2.2.1 Set"></a>2.2.1 Set</h5><p><strong>Set:无序、无下标、元素不可重复</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set &lt;String&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[a, b, c]</span><br></pre></td></tr></table></figure><h5 id="2-2-2-HashSet"><a href="#2-2-2-HashSet" class="headerlink" title="2.2.2 HashSet"></a>2.2.2 HashSet</h5><p><strong>HashSet存储结构:</strong>哈希表（数组+链表+红黑树）</p><p><strong>存储过程：</strong></p><p>（1）根据hashcode计算保存的位置，如果此位置为空，则直接保存，如果不为空执行第二步。</p><p>（2）再执行equals方法，如果equals方法为true，则认为是重复，否则，形成链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet &lt;Person&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Person person1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;wang&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        Person person2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        set.add(person1);</span><br><span class="line">        set.add(person2);</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[Person@<span class="number">41629346</span>, Person@4eec7777, Person@3b07d329]</span><br></pre></td></tr></table></figure><p><strong>问题：相同name，age的对象于集合中重复添加</strong></p><p><strong>解决方法：重写hashcode、equals方法</strong></p><p><em>注：hashcode、equals方法定义了hashset的重复依据</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写hashCode和equals方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> n1=<span class="built_in">this</span>.name.hashCode();</span><br><span class="line">        <span class="type">int</span> n2=<span class="built_in">this</span>.age;</span><br><span class="line">        <span class="keyword">return</span> n1+n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>==obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Person)</span><br><span class="line">        &#123;</span><br><span class="line">            Person p=(Person) obj;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.name.equals(p.getName())&amp;&amp;<span class="built_in">this</span>.age==p.getAge())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet &lt;Person&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Person person1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;wang&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        Person person2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        set.add(person1);</span><br><span class="line">        set.add(person2);</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">2</span></span><br><span class="line">[Person<span class="meta">@f13</span>, Person@37921a]</span><br></pre></td></tr></table></figure><h5 id="2-2-3-TreeSet"><a href="#2-2-3-TreeSet" class="headerlink" title="2.2.3 TreeSet"></a>2.2.3 TreeSet</h5><p><strong>TreeSet:</strong></p><ul><li>基于排序顺序实现元素不重复</li><li>实现了SortedSet接口，对集合元素自动排序</li><li><strong>元素对象的类型必须实现Comparable接口，指定排序规则</strong></li><li>通过CompareTo方法确定是否为重复元素</li></ul><p><strong>TreeSet存储结构:</strong>红黑树</p><p><strong>TreeSet的使用一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt;&#123;<span class="comment">//TreeSet的元素类型必须实现Comparable接口</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;<span class="comment">//重写Comparable接口的compareTo方法，compareTo方法返回值为0认为是重复元素</span></span><br><span class="line">        <span class="type">int</span> n1=<span class="built_in">this</span>.name.compareTo(o.getName());</span><br><span class="line">        <span class="type">int</span> n2=<span class="built_in">this</span>.age-o.getAge();</span><br><span class="line">        <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        String str=<span class="built_in">this</span>.getName()+<span class="string">&quot;:&quot;</span>+<span class="built_in">this</span>.getAge();</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       TreeSet &lt;Person&gt; persons=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        Person person1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;wang&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        Person person2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        Person person3=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        persons.add(person1);</span><br><span class="line">        persons.add(person2);</span><br><span class="line">        persons.add(person3);</span><br><span class="line">        persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        System.out.println(persons.size());</span><br><span class="line">        System.out.println(persons.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[wang:<span class="number">23</span>, xu:<span class="number">22</span>, xu:<span class="number">24</span>]</span><br></pre></td></tr></table></figure><p><strong>TreeSet的使用二：Comparator实现比较器，无需实现Comparable接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TreeSet &lt;Person&gt; persons=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">               <span class="type">int</span> n1=o1.getName().compareTo(o2.getName());</span><br><span class="line">               <span class="type">int</span> n2=o1.getAge()-o2.getAge();</span><br><span class="line">               <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p><strong>利用TreeSet实现字符串排序：</strong>先按长度排，长度相同比大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;String&gt; treeSet=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">                <span class="type">int</span> n1=o1.length()-o2.length();</span><br><span class="line">                <span class="type">int</span> n2=o1.compareTo(o2);</span><br><span class="line">                <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeSet.add(<span class="string">&quot;peng&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;xu&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;an&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-Map集合体系"><a href="#3-Map集合体系" class="headerlink" title="3.Map集合体系"></a>3.Map集合体系</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201402328.png" alt="3" style="zoom: 80%;"></p><p><strong>Map:</strong>存储一对数据（Key-Value),无序、无下标、键不可重复、值可重复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class demo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;String, String&gt; map=new HashMap&lt;&gt;();</span><br><span class="line">        //1.添加元素</span><br><span class="line">        map.put(&quot;a&quot;,&quot;1&quot;);</span><br><span class="line">        map.put(&quot;b&quot;,&quot;2&quot;);</span><br><span class="line">        map.put(&quot;c&quot;,&quot;3&quot;);</span><br><span class="line">        map.put(&quot;d&quot;,&quot;4&quot;);</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">        //2.删除元素</span><br><span class="line">        map.remove(&quot;b&quot;);</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">        //3.1 使用keySet()遍历</span><br><span class="line">        System.out.println(&quot;使用keySet()遍历&quot;);</span><br><span class="line">//        Set&lt;String&gt; keys=map.keySet();</span><br><span class="line">        for (String key:map.keySet())&#123;</span><br><span class="line">            System.out.println(key+&quot;:&quot;+map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        //3.2 使用entrySet()遍历(效率高于keySet())</span><br><span class="line">        System.out.println(&quot;使用entrySet()遍历&quot;);</span><br><span class="line">//        Set&lt;Map.Entry&lt;String,String&gt; &gt; entrySet=map.entrySet();</span><br><span class="line">        for (Map.Entry&lt;String,String&gt; entry:map.entrySet())&#123;</span><br><span class="line">            System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        //4.判断是否包含</span><br><span class="line">        System.out.println(map.containsKey(&quot;a&quot;));</span><br><span class="line">        System.out.println(map.containsValue(&quot;1&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HashMap的存储结构：哈希表（数组+链表+红黑树）</strong></p><p>注：HashMap使用key的hashcode和equals作为重复的依据</p><p><strong>TreeMap:</strong>实现了SortedMap接口，可以对key自动排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        String str=this.getName()+&quot;:&quot;+this.getAge();</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       TreeMap &lt;Person,String&gt; persons=new TreeMap&lt;&gt;(new Comparator&lt;Person&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public int compare(Person o1, Person o2) &#123;</span><br><span class="line">               int n1=o1.getName().compareTo(o2.getName());</span><br><span class="line">               int n2=o1.getAge()-o2.getAge();</span><br><span class="line">               return n1==0?n2:n1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">        Person person1=new Person(&quot;wang&quot;,23);</span><br><span class="line">        Person person2=new Person(&quot;xu&quot;,22);</span><br><span class="line">        Person person3=new Person(&quot;xu&quot;,24);</span><br><span class="line">        persons.put(person1,&quot;a&quot;);</span><br><span class="line">        persons.put(person2,&quot;b&quot;);</span><br><span class="line">        persons.put(person3,&quot;c&quot;);</span><br><span class="line">        persons.put(new Person(&quot;xu&quot;,22),&quot;d&quot;);</span><br><span class="line">        System.out.println(persons.size());</span><br><span class="line">        System.out.println(persons.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Collections工具类"><a href="#4-Collections工具类" class="headerlink" title="4.Collections工具类"></a>4.Collections工具类</h3><p>Collections工具类：集合工具类，定义了除存取以外的集合常用方法。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201402950.png" alt="4"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;集合框架&quot;&gt;&lt;a href=&quot;#集合框架&quot; class=&quot;headerlink&quot; title=&quot;集合框架&quot;&gt;&lt;/a&gt;集合框架&lt;/h2&gt;&lt;h3 id=&quot;1-泛型&quot;&gt;&lt;a href=&quot;#1-泛型&quot; class=&quot;headerlink&quot; title=&quot;1.泛型&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="java" scheme="https://wangak.cc/categories/java/"/>
    
    
    <category term="java" scheme="https://wangak.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SegFormer</title>
    <link href="https://wangak.cc/posts/9e1703d2.html"/>
    <id>https://wangak.cc/posts/9e1703d2.html</id>
    <published>2023-10-02T07:28:00.000Z</published>
    <updated>2023-10-07T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SegFormer"><a href="#SegFormer" class="headerlink" title="SegFormer"></a>SegFormer</h2><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407750.png" alt="1" style="zoom:75%;"></p><p><strong>编码器:</strong>通过在不同阶段进行下采样，生成多尺度特征。</p><p><strong>Efficient Self-Attention:</strong></p><p><strong>原始的自注意力计算：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407939.png" alt="2" style="zoom: 67%;"></p><p>计算复杂度为O($N^2$),其中N为w*h</p><p><strong>高效的自关注机制:</strong>通过一个压缩比R对K进行处理，改进的计算过程如下.0</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407713.png" alt="3" style="zoom:67%;"></p><p>复杂度从O($N^2$)将至O($N^2 \over R$),降低了计算复杂度</p><p><em>注：论文中的R分别取64, 16, 4, 1</em></p><p>通过将K进行reshape将空间维度N的信息转移到通道维度C上，可以得到$\widehat K$；然后通过线性变换层将通道为降到原始维度C上，得到K’，实现空间下采样。</p><p><strong>Mix-FFN:</strong>为了解决使用位置编码引入位置信息，但由于在测试时的分辨率发生变化时，<strong>会引起精度下降的问题</strong>。</p><p>注：训练时生成的位置编码长度小于预测时的需要时，一种处理方法是使用<strong>插值</strong>将训练时的位置编码扩展到预测时所需的长度。</p><p>位置信息在语义分割中不是必需的</p><p>Mix-FFN：直接使用<strong>3*3卷积</strong>捕获一定程度上的位置信息</p><p>计算过程如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407101.png" alt="4" style="zoom:67%;"></p><p>注：$x_{in}$为自注意力模块的输出</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408906.png" alt="8"></p><p><strong>Overlapped Patch Merging:保持patch周围的局部连续性</strong></p><p>patch尺寸K、步长S、填充尺寸P，在网络中设置参了2套参数：<em>K</em> = 7, <em>S</em> = 4, <em>P</em> = 3 ；<em>K</em> = 3, <em>S</em> = 2, <em>P</em> = 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class OverlapPatchEmbed(nn.Layer):</span><br><span class="line">    def __init__(self,</span><br><span class="line">                 img_size=224,</span><br><span class="line">                 patch_size=7,          # 卷积核大小</span><br><span class="line">                 stride=4,                 # 下采样倍数</span><br><span class="line">                 in_chans=3,            # 输入通道数</span><br><span class="line">                 embed_dim=768):  # 输出通道数</span><br><span class="line">        super().__init__()</span><br><span class="line">        img_size = to_2tuple(img_size)</span><br><span class="line">        patch_size = to_2tuple(patch_size)</span><br><span class="line"></span><br><span class="line">        self.img_size = img_size</span><br><span class="line">        self.patch_size = patch_size</span><br><span class="line">        self.H, self.W = img_size[0] // patch_size[0], img_size[</span><br><span class="line">            1] // patch_size[1]</span><br><span class="line">        self.num_patches = self.H * self.W</span><br><span class="line">        # 定义投影变换所用的卷积</span><br><span class="line">        self.proj = nn.Conv2D(</span><br><span class="line">            in_chans,</span><br><span class="line">            embed_dim,</span><br><span class="line">            kernel_size=patch_size,</span><br><span class="line">            stride=stride,</span><br><span class="line">            padding=(patch_size[0] // 2, patch_size[1] // 2))</span><br><span class="line">        # 定义layer norm层</span><br><span class="line">        self.norm = nn.LayerNorm(embed_dim)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        x = self.proj(x)    # 通过卷积进行特征重投影，实现下采样、通道变换</span><br><span class="line">        x_shape = paddle.shape(x)</span><br><span class="line">        H, W = x_shape[2], x_shape[3]</span><br><span class="line">        x = x.flatten(2).transpose([0, 2, 1])  # 将H*W维度压缩成1个维度</span><br><span class="line">        x = self.norm(x)          # 标准化</span><br><span class="line"></span><br><span class="line">        return x, H, W</span><br></pre></td></tr></table></figure><p><strong>解码器</strong></p><p><strong>Lightweight All-MLP Decoder</strong>：在解码器部分，SegFormer采用了简单的结构，仅由MLP组成</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310212052806.jpg" alt="6" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408838.png" alt="5" style="zoom: 80%;"></p><p><strong>有效感受野分析</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408040.png" alt="7" style="zoom:80%;"></p><p>如图3的放大图所示，MLP头部(蓝框)的ERF与阶段4(红框)不同，除了非局部注意外，局部注意明显更强。</p><p>在上采样阶段，Head的感受野除了具有非局部关注外，还有较强的局部关注。</p><p>作者认为之所以这种简单的Decoder能够很好地工作，关键在于分层的Transformer Encoder比传统的基于CNN的Encoder具有更大的感受野。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408701.png" alt="9" style="zoom:80%;"></p><h3 id="2-实验结果"><a href="#2-实验结果" class="headerlink" title="2.实验结果"></a>2.实验结果</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408211.png" alt="10" style="zoom: 67%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SegFormer&quot;&gt;&lt;a href=&quot;#SegFormer&quot; class=&quot;headerlink&quot; title=&quot;SegFormer&quot;&gt;&lt;/a&gt;SegFormer&lt;/h2&gt;&lt;h3 id=&quot;1-网络结构&quot;&gt;&lt;a href=&quot;#1-网络结构&quot; class=&quot;head</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>MISSFormer</title>
    <link href="https://wangak.cc/posts/d6b0e04e.html"/>
    <id>https://wangak.cc/posts/d6b0e04e.html</id>
    <published>2023-10-02T05:11:58.000Z</published>
    <updated>2023-10-21T07:40:10.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MISSFormer"><a href="#MISSFormer" class="headerlink" title="MISSFormer"></a>MISSFormer</h2><p><strong>论文：《MISSFormer: An Effective Medical Image Segmentation Transformer》（TMI2022）</strong></p><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404731.png" alt="1"></p><p><strong>编码器</strong>由Overlap Patch Embedding、Overlap Patch Merging以及Transformer Block with ReMix-FFN组成。</p><p><strong>EMix-FFN:</strong>在Enhanced Mix块中引入递归跳跃连接，给定输入特征映射xin，应用深度卷积层捕获局部上下文，然后进行递归跳跃连接</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404884.png" alt="2"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404240.png" alt="5" style="zoom: 80%;"></p><p><strong>Enhanced Transformer Context Bridge来捕获不同尺度特征的局部和全局相关性</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404308.png" alt="3" style="zoom: 50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404818.png" alt="4" style="zoom:50%;"></p><p>步骤：</p><p>1.将编码器生成的多尺度的特征的h、w，变成一个序列</p><p>2.将四个输出拼接到一起</p><p>3.对拼接后的结果进行注意力的计算</p><p>4.自注意力输出的结果和输出拼接的结果进行跳跃连接，然后进行层归一化</p><p>5.把归一化的结果再分成四个输出</p><p>6.将这四个输出再进行EMix-FFN</p><p>7.将四个输出的N（h*w)拼接到一起,再与归一化的结果进行跳跃连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class BridgeLayer_4(nn.Module):</span><br><span class="line">    def __init__(self, dims, head, reduction_ratios):</span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">        self.norm1 = nn.LayerNorm(dims)</span><br><span class="line">        self.attn = M_EfficientSelfAtten(dims, head, reduction_ratios)</span><br><span class="line">        self.norm2 = nn.LayerNorm(dims)</span><br><span class="line">        self.mixffn1 = MixFFN_skip(dims,dims*4)</span><br><span class="line">        self.mixffn2 = MixFFN_skip(dims*2,dims*8)</span><br><span class="line">        self.mixffn3 = MixFFN_skip(dims*5,dims*20)</span><br><span class="line">        self.mixffn4 = MixFFN_skip(dims*8,dims*32)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    def forward(self, inputs):</span><br><span class="line">        B = inputs[0].shape[0]</span><br><span class="line">        C = 64</span><br><span class="line">        if (type(inputs) == list):</span><br><span class="line">            # print(&quot;-----1-----&quot;)</span><br><span class="line">            c1, c2, c3, c4 = inputs</span><br><span class="line">            B, C, _, _= c1.shape</span><br><span class="line">            c1f = c1.permute(0, 2, 3, 1).reshape(B, -1, C)  # 3136*64</span><br><span class="line">            c2f = c2.permute(0, 2, 3, 1).reshape(B, -1, C)  # 1568*64</span><br><span class="line">            c3f = c3.permute(0, 2, 3, 1).reshape(B, -1, C)  # 980*64</span><br><span class="line">            c4f = c4.permute(0, 2, 3, 1).reshape(B, -1, C)  # 392*64</span><br><span class="line">            </span><br><span class="line">            # print(c1f.shape, c2f.shape, c3f.shape, c4f.shape)</span><br><span class="line">            inputs = torch.cat([c1f, c2f, c3f, c4f], -2)</span><br><span class="line">        else:</span><br><span class="line">            B,_,C = inputs.shape </span><br><span class="line"></span><br><span class="line">        tx1 = inputs + self.attn(self.norm1(inputs))</span><br><span class="line">        tx = self.norm2(tx1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        tem1 = tx[:,:3136,:].reshape(B, -1, C) </span><br><span class="line">        tem2 = tx[:,3136:4704,:].reshape(B, -1, C*2)</span><br><span class="line">        tem3 = tx[:,4704:5684,:].reshape(B, -1, C*5)</span><br><span class="line">        tem4 = tx[:,5684:6076,:].reshape(B, -1, C*8)</span><br><span class="line"></span><br><span class="line">        m1f = self.mixffn1(tem1, 56, 56).reshape(B, -1, C)</span><br><span class="line">        m2f = self.mixffn2(tem2, 28, 28).reshape(B, -1, C)</span><br><span class="line">        m3f = self.mixffn3(tem3, 14, 14).reshape(B, -1, C)</span><br><span class="line">        m4f = self.mixffn4(tem4, 7, 7).reshape(B, -1, C)</span><br><span class="line"></span><br><span class="line">        t1 = torch.cat([m1f, m2f, m3f, m4f], -2)</span><br><span class="line">        </span><br><span class="line">        tx2 = tx1 + t1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return tx2</span><br></pre></td></tr></table></figure><p><strong>上下文桥循环了四次：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class BridegeBlock_4(nn.Module):   #这是MISSFormer模型图中，上下文桥循环四次的代码</span><br><span class="line">    def __init__(self, dims, head, reduction_ratios):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.bridge_layer1 = BridgeLayer_4(dims, head, reduction_ratios) #定义上下文桥</span><br><span class="line">        self.bridge_layer2 = BridgeLayer_4(dims, head, reduction_ratios) </span><br><span class="line">        self.bridge_layer3 = BridgeLayer_4(dims, head, reduction_ratios) </span><br><span class="line">        self.bridge_layer4 = BridgeLayer_4(dims, head, reduction_ratios) </span><br><span class="line"></span><br><span class="line">    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:</span><br><span class="line">        bridge1 = self.bridge_layer1(x)    #输入数据至第一个上下文桥，得到第一个输出</span><br><span class="line">        bridge2 = self.bridge_layer2(bridge1)#将上一个输出输入至第二个上下文桥</span><br><span class="line">        bridge3 = self.bridge_layer3(bridge2)#将上一个输出输入至第三个上下文桥</span><br><span class="line">        bridge4 = self.bridge_layer4(bridge3)#将上一个输出输入至第四个上下文桥</span><br><span class="line"></span><br><span class="line">        B,_,C = bridge4.shape  #提取B和C大小</span><br><span class="line">        outs = []              #建立空列表，存储输出结果</span><br><span class="line"></span><br><span class="line">        sk1 = bridge4[:,:3136,:].reshape(B, 56, 56, C).permute(0,3,1,2)      #输出转换为二维形式</span><br><span class="line">        sk2 = bridge4[:,3136:4704,:].reshape(B, 28, 28, C*2).permute(0,3,1,2) </span><br><span class="line">        sk3 = bridge4[:,4704:5684,:].reshape(B, 14, 14, C*5).permute(0,3,1,2) </span><br><span class="line">        sk4 = bridge4[:,5684:6076,:].reshape(B, 7, 7, C*8).permute(0,3,1,2) </span><br><span class="line"></span><br><span class="line">        outs.append(sk1)  #将结果存储到列表中</span><br><span class="line">        outs.append(sk2)</span><br><span class="line">        outs.append(sk3)</span><br><span class="line">        outs.append(sk4)</span><br><span class="line"></span><br><span class="line">        return outs</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404365.png" alt="6"></p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404746.png" alt="7"></p>]]></content>
    
    
    <summary type="html">记录了MISSFormer的网络结构及实验结果</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java常用类</title>
    <link href="https://wangak.cc/posts/df13c63f.html"/>
    <id>https://wangak.cc/posts/df13c63f.html</id>
    <published>2023-09-30T08:31:34.000Z</published>
    <updated>2023-10-03T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="1-Object类"><a href="#1-Object类" class="headerlink" title="1.Object类"></a>1.Object类</h3><h4 id="1-1-clone方法"><a href="#1-1-clone方法" class="headerlink" title="1.1 clone方法"></a>1.1 clone方法</h4><p><strong>clone方法：</strong>clone方法执行的是浅拷贝</p><p><em>注：<strong>clone方法</strong>创建了一个新对象，但这个新对象和原始对象的引用变量相同（浅拷贝）。</em></p><p><strong>验证clone方法是浅拷贝的：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 声明静态内部类 Body，实现 Cloneable 接口以支持克隆</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Body</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Head head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Body</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Body</span><span class="params">(Head head)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.head = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">            <span class="comment">// 调用父类的 clone 方法以执行浅拷贝</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明静态内部类 Head，这个类不需要克隆功能</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Head</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Head</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个 Body 对象，并将其关联的 Head 对象初始化</span></span><br><span class="line">        <span class="type">Body</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Body</span>(<span class="keyword">new</span> <span class="title class_">Head</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用克隆方法复制 Body 对象，得到一个新的 Body 对象 body1</span></span><br><span class="line">        <span class="type">Body</span> <span class="variable">body1</span> <span class="operator">=</span> (Body) body.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查两个对象是否相同</span></span><br><span class="line">        System.out.println(<span class="string">&quot;body == body1 : &quot;</span> + (body == body1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查两个对象的 head 属性是否相同（因为是浅拷贝，所以 head 属性相同）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;body.head == body1.head : &quot;</span> + (body.head == body1.head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">body == body1 : <span class="literal">false</span></span><br><span class="line">body.head == body1.head : <span class="literal">true</span><span class="comment">//新对象和原对象共享相同的引用对象,故clone方法执行的是浅拷贝</span></span><br></pre></td></tr></table></figure><h4 id="1-2-toString-方法"><a href="#1-2-toString-方法" class="headerlink" title="1.2 toString()方法"></a>1.2 toString()方法</h4><p>Object 类的 toString 方法返回一个字符串，该字符串由类名、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。</p><p><em>注：通常情况下，<strong>应重写 <code>toString()</code> 方法</strong>，以便返回一个更有意义的、描述对象状态的字符串。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;, age=&quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 toString() 方法输出对象的字符串表示形式</span></span><br><span class="line">        System.out.println(person.toString()); <span class="comment">// 输出：Person&#123;name=&#x27;Alice&#x27;, age=30&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Alice&#x27;</span>, age=<span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-getClass-方法"><a href="#1-3-getClass-方法" class="headerlink" title="1.3 getClass()方法"></a>1.3 getClass()方法</h4><p><strong>getClass()方法：</strong>返回对象的运行时类，所有 Java 类都继承了这个方法，不可重写，要调用的话，一般和getName()联合使用，如getClass().getName()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetClassExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        <span class="comment">// 使用 getClass() 方法获取对象的运行时类</span></span><br><span class="line">        Class&lt;?&gt; cls = vehicle.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出类的名称</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName()); <span class="comment">// 输出：Class name: Car</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Class name: Car</span><br></pre></td></tr></table></figure><h4 id="1-4-equals-方法"><a href="#1-4-equals-方法" class="headerlink" title="1.4 equals()方法"></a>1.4 equals()方法</h4><p> Object中的equals方法是直接判断this和obj本身的值是否相等,如果this和obj指向的是同一块内存对象，则返回true,如果</p><p>this和obj指向的不是同一块内存，则返回false。</p><p><em>注：即便是内容完全相等的两块不同的内存对象，也返回false。</em></p><p>String类已经重写了object中的equals方法（比较内容是否相等）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">// 输出：true，内容相同</span></span><br><span class="line">System.out.println(str1.equals(str3)); <span class="comment">// 输出：true，内容相同</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="1-5-wait-方法"><a href="#1-5-wait-方法" class="headerlink" title="1.5 wait()方法"></a>1.5 wait()方法</h4><p>pass</p><h4 id="1-6-notify-方法"><a href="#1-6-notify-方法" class="headerlink" title="1.6  notify()方法"></a>1.6  notify()方法</h4><p>pass</p><h3 id="2-包装类"><a href="#2-包装类" class="headerlink" title="2.包装类"></a>2.包装类</h3><p>基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用,故Java为每种基本数据类型分别设计了对应的类，称之为<strong>包装类</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201401558.png" alt="1" style="zoom: 67%;"></p><h4 id="自动拆箱和装箱"><a href="#自动拆箱和装箱" class="headerlink" title="自动拆箱和装箱"></a>自动拆箱和装箱</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">500</span>;            <span class="comment">// 创建一个基本数据类型变量 m 并赋值为 500</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> m;        <span class="comment">// 自动装箱：将基本数据类型 m 装箱为 Integer 对象 obj</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obj;            <span class="comment">// 自动拆箱：将 Integer 对象 obj 拆箱为基本数据类型 n</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n = &quot;</span> + n);  <span class="comment">// 输出 n 的值</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="number">500</span>;     <span class="comment">// 创建一个 Integer 对象 obj1 并初始化为 500</span></span><br><span class="line">        System.out.println(<span class="string">&quot;obj 等价于 obj1？&quot;</span> + obj.equals(obj1));  <span class="comment">// 比较 obj 和 obj1 是否相等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">n = <span class="number">500</span></span><br><span class="line">obj 等价于 obj1？<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><em>注：所有的包装类（Integer、Long、Byte、Double、Float、Short）都是<strong>抽象类 Number</strong> 的子类。</em></p><h3 id="3-String类"><a href="#3-String类" class="headerlink" title="3.String类"></a>3.String类</h3><h4 id="3-1-创建字符串对象方式"><a href="#3-1-创建字符串对象方式" class="headerlink" title="3.1 创建字符串对象方式"></a>3.1 创建字符串对象方式</h4><p><strong>String类对象一旦声明则不可以改变，而改变的只是地址，原来的字符串还是存在的，并且产生垃圾。</strong></p><p><strong>直接赋值方式：</strong>创建对象是在方法区的<strong>常量池</strong></p><p><code>String str=&quot;hello&quot;;//直接赋值的方式</code></p><p><strong>构造方法：</strong>通过构造方法创建字符串对象是在<strong>堆内存</strong></p><p><code>String str=new String(&quot;hello&quot;);//实例化的方式</code></p><p><strong>两种实例化方式的比较:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Lance&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Lance&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;Lance&quot;</span>;</span><br><span class="line"><span class="comment">//String类对象==比较，比较的是地址，而不是内容</span></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str1==str3);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3==str2);<span class="comment">//true</span></span><br><span class="line">System.out.println(str1==str4);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//str1和str4引用的是字符串常量池中的同一个对象，因此它们的引用相等</span></span><br></pre></td></tr></table></figure><h4 id="3-2-字符串常量池"><a href="#3-2-字符串常量池" class="headerlink" title="3.2 字符串常量池"></a>3.2 字符串常量池</h4><p>​       在字符串中，如果采用直接赋值的方式（String str=”Lance”）进行对象的实例化，则会将匿名对象“Lance”放入对象池，每当下一次对不同的对象进行直接赋值的时候会直接利用池中原有的匿名对象</p><p><strong>两种实例化方式的区别:</strong></p><p><strong>直接赋值（String str = “hello”）：</strong>只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。</p><p><strong>构造方法（String str= new String(“hello”)）:</strong>连续两次new一个String对象，会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过public String intern();方法进行手工入池。</p><p><em>注：在开发的过程中不会采用构造方法进行字符串的实例化</em></p><h4 id="3-3-空指向异常"><a href="#3-3-空指向异常" class="headerlink" title="3.3 空指向异常"></a>3.3 空指向异常</h4><p><strong>equals</strong>比较的是字符串内容，在开发的过程中，equals()通过接受参数，可以避免空指向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(str.equals(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//此时会出现空指向异常 ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;hello&quot;</span>.equals(str))</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//此时equals会处理null值，可以避免空指向异常 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-StringBuilder-和-StringBuffer"><a href="#4-StringBuilder-和-StringBuffer" class="headerlink" title="4.StringBuilder 和 StringBuffer"></a>4.StringBuilder 和 StringBuffer</h3><p>pass</p><h3 id="5-File类"><a href="#5-File类" class="headerlink" title="5.File类"></a>5.File类</h3><p>pass</p>]]></content>
    
    
    <summary type="html">记录了Java常用类的学习笔记</summary>
    
    
    
    <category term="java" scheme="https://wangak.cc/categories/java/"/>
    
    
    <category term="java" scheme="https://wangak.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础语法</title>
    <link href="https://wangak.cc/posts/ea538f2a.html"/>
    <id>https://wangak.cc/posts/ea538f2a.html</id>
    <published>2023-09-27T07:52:05.000Z</published>
    <updated>2023-09-30T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h2><h3 id="1-浮点型拓展"><a href="#1-浮点型拓展" class="headerlink" title="1.浮点型拓展"></a>1.浮点型拓展</h3><h4 id="1-1浮点类型的舍入误差"><a href="#1-1浮点类型的舍入误差" class="headerlink" title="1.1浮点类型的舍入误差"></a>1.1浮点类型的舍入误差</h4><p>浮点类型<strong>float, double</strong>的数据不适合在<strong>不容许舍入误差</strong>的领域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 定义一个float类型变量f并赋值为0.1</span><br><span class="line">        float f = 0.1f;</span><br><span class="line"></span><br><span class="line">        // 定义一个double类型变量d并赋值为1.0除以10，即0.1</span><br><span class="line">        double d = 1.0 / 10;</span><br><span class="line">        System.out.println(f == d); // 输出：false，由于精度差异，比较结果为false</span><br><span class="line">        float d1 = 2131231231f;</span><br><span class="line"></span><br><span class="line">        // 定义一个float类型变量d2，将d1加1后的结果赋值给d2</span><br><span class="line">        float d2 = d1 + 1;</span><br><span class="line">        System.out.println(&quot;d1=&quot;+d1);</span><br><span class="line">        System.out.println(&quot;d2=&quot;+d2);</span><br><span class="line">        // 检查d1是否等于d2</span><br><span class="line">        if (d1 == d2) &#123;</span><br><span class="line">            // 如果d1等于d2，输出&quot;d1==d2&quot;</span><br><span class="line">            System.out.println(&quot;d1==d2&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果d1不等于d2，输出&quot;d1!=d2&quot;</span><br><span class="line">            System.out.println(&quot;d1!=d2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">false</span><br><span class="line">d1=2.13123123E9</span><br><span class="line">d2=2.13123123E9</span><br><span class="line">d1==d2</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p><em>1.浮点数一般都存在舍入误差，很多数字无法精确表示，其结果只能是接近，但不等于。</em></p><p><strong><em>2.避免比较中使用浮点数</em></strong></p><p><em>3.需要进行不产生舍入误差的精确数字计算，需要使用<strong>BigDecimal</strong>类</em></p><h4 id="1-2-BigDecimal类"><a href="#1-2-BigDecimal类" class="headerlink" title="1.2 BigDecimal类"></a><strong>1.2 BigDecimal类</strong></h4><p><strong>BigDecimal类：</strong>用于高精度数值运算的类，它允许你精确地表示和执行各种数学运算，包括加法、减法、乘法、除法等，而不会丢失精度。</p><p><strong>常用方法：</strong></p><p>1.BigDecimal(String val)：构造方法，将String类型转换成BigDecimal类型数据。</p><p>2.BigDecimal(double val)：构造方法，将double类型转换成BigDecimal类型数据。</p><p>3.BigDecimal(int val)：构造方法，将int类型转换成BigDecimal类型数据。</p><p>4.BigDecimal add(BigDecimal value)：加法，求两个BigDecimal类型数据的和。</p><p>5.BigDecimal subtract(BigDecimal value)：减法，求两个BigDecimal类型数据的差。</p><p>6.BigDecimal multiply(BigDecimal  value)：乘法，求两个BigDecimal类型数据的积。</p><p>7.BigDecimal divide(BigDecimal divisor)：除法，求两个BigDecimal类型数据的商。</p><p>8.BigDecimal remainder(BigDecimal divisor)：求余数，求BigDecimal类型数据除以divisor的余数。</p><p>9.BigDecimal max(BigDecimal value)：最大数，求两个BigDecimal类型数据的最大值。</p><p>10.BigDecimal min(BigDecimal value)：最小数，求两个BigDecimal类型数据的最小值。</p><p>11.BigDecimal abs()：绝对值，求BigDecimal类型数据的绝对值。</p><p>12.BigDecimal negate()：相反数，求BigDecimal类型数据的相反数。</p><p>13.BigDecimal compareTo()：比较两个BigDecimal 对象的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.math.BigDecimal;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal num1 = new BigDecimal(&quot;0.1&quot;);//字符串带双引号被解释为确切的数值,若不加会存在一个微小的舍入误差</span><br><span class="line">        BigDecimal num2 = new BigDecimal(&quot;0.2&quot;);</span><br><span class="line">        BigDecimal num3=num1.multiply(new BigDecimal(&quot;2&quot;));</span><br><span class="line">        BigDecimal sum = num1.add(num2);</span><br><span class="line">        System.out.println(num3.compareTo(num2));</span><br><span class="line">        System.out.println(&quot;sum=&quot;+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">0</span><br><span class="line">sum=0.3</span><br></pre></td></tr></table></figure><h3 id="2-Scanner对象"><a href="#2-Scanner对象" class="headerlink" title="2.Scanner对象"></a>2.Scanner对象</h3><h4 id="2-1-创建-Scanner-对象的基本语法："><a href="#2-1-创建-Scanner-对象的基本语法：" class="headerlink" title="2.1 创建 Scanner 对象的基本语法："></a>2.1 创建 Scanner 对象的基本语法：</h4><p><code>Scanner s = new Scanner(System.in)</code></p><p>通过 Scanner 类的 <strong>next()</strong> 或<strong>nextLine()</strong> 方法获取输入的字符串</p><p>读取前一般需要使用 <strong>hasNext()</strong> 或<strong>hasNextLine()</strong> 判断是否还有输入的数据</p><h4 id="2-2-next-amp-nextLine"><a href="#2-2-next-amp-nextLine" class="headerlink" title="2.2 next &amp; nextLine"></a>2.2 next &amp; nextLine</h4><p>使用<strong>next方式</strong>接收一下输入的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext()) &#123;</span><br><span class="line">            String token = scanner.next();</span><br><span class="line">            System.out.println(&quot;Next Token: &quot; + token);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in: </span><br><span class="line">hello world</span><br><span class="line">out:</span><br><span class="line">Next Token: hello</span><br><span class="line">Next Token: world</span><br></pre></td></tr></table></figure><p>使用<strong>nextLine方式</strong>接收一下输入的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNextLine()) &#123;</span><br><span class="line">            String token = scanner.nextLine();</span><br><span class="line">            System.out.println(&quot;Next Token: &quot; + token);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in:</span><br><span class="line">hello world</span><br><span class="line">out：</span><br><span class="line">Next Token: hello world</span><br></pre></td></tr></table></figure><p><strong>两者区别：</strong></p><p>1.next() 不能得到带有空格的字符串，nextLine()可以获得空白。</p><p>2.nextLine()：以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</p><h4 id="2-3-其他数据类型"><a href="#2-3-其他数据类型" class="headerlink" title="2.3 其他数据类型"></a>2.3 其他数据类型</h4><p>如果要输入int、float等类型的数据，在 Scanner 类中也有支持，使用<strong>hasNextXxx() 方法、 nextXxx() 方法</strong>来读取</p><h3 id="3-可变参数"><a href="#3-可变参数" class="headerlink" title="3.可变参数"></a>3.可变参数</h3><p><strong>可变参数的声明:</strong></p><p><code>typeName... parameterName</code></p><p><strong>注：一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Main&#123;</span><br><span class="line">    public static void printMax(double... num)&#123;</span><br><span class="line">        if(num.length==0)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;wrong!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        double result=0;</span><br><span class="line">        for (int i = 1; i &lt; num.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (num[i] &gt; result)</span><br><span class="line">            &#123; result = num[i]; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num[num.length-1]);</span><br><span class="line">    &#125;;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        printMax(1,2.3,5.0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">5.0</span><br></pre></td></tr></table></figure><h3 id="4-Arrays-类"><a href="#4-Arrays-类" class="headerlink" title="4.Arrays 类"></a>4.Arrays 类</h3><p>数组的工具类<strong>java.util.Arrays</strong></p><p><strong>常用功能：</strong></p><h4 id="4-1-打印数组"><a href="#4-1-打印数组" class="headerlink" title="4.1 打印数组"></a>4.1 打印数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        int []num=new int[10];</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            num[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure><h4 id="4-2-数组排序"><a href="#4-2-数组排序" class="headerlink" title="4.2 数组排序"></a>4.2 数组排序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        int []num= &#123;5,8,9,4,2&#125;;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        System.out.println(Arrays.toString(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[2, 4, 5, 8, 9]</span><br></pre></td></tr></table></figure><h4 id="4-3-二分法查找"><a href="#4-3-二分法查找" class="headerlink" title="4.3 二分法查找"></a>4.3 二分法查找</h4><p><strong>在进行此调用之前对数组进行排序(通 过sort方法等)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        int []num= &#123;5,8,9,4,2&#125;;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        System.out.println(&quot;索引为：&quot;+Arrays.binarySearch(num,4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">索引为：1</span><br></pre></td></tr></table></figure><h4 id="4-4-将数组转换成List集合"><a href="#4-4-将数组转换成List集合" class="headerlink" title="4.4 将数组转换成List集合"></a>4.4 将数组转换成List集合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int []num= &#123;5,2,9,4,2,3,10&#125;;</span><br><span class="line">List&lt;int[]&gt; list= Arrays.asList(num);</span><br></pre></td></tr></table></figure><h3 id="5-内部类"><a href="#5-内部类" class="headerlink" title="5.内部类"></a>5.内部类</h3><h4 id="5-1-成员内部类"><a href="#5-1-成员内部类" class="headerlink" title="5.1 成员内部类"></a>5.1 成员内部类</h4><p><strong>实例化内部类，首先需要实例化外部类，通过外部类去调用内部类</strong></p><p><em>注：成员内部类中不能写静态属性和方法</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ppublic class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1.实例化外部类</span><br><span class="line">        Outer out=new Outer();</span><br><span class="line">        //2.通过外部类调用内部类</span><br><span class="line">        Outer.Inner inObject = out.new Inner();</span><br><span class="line">        inObject.In();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Outer&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    public void out()&#123;</span><br><span class="line">        System.out.println(&quot;外部类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Outer()</span><br><span class="line">    &#123;</span><br><span class="line">        id=10;</span><br><span class="line">    &#125;</span><br><span class="line">    class Inner&#123;</span><br><span class="line">        private int id;</span><br><span class="line">        public void In()&#123;</span><br><span class="line">            System.out.println(&quot;内部类&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Inner()&#123;</span><br><span class="line">            id=1;</span><br><span class="line">            System.out.println(&quot;外部：&quot;+Outer.this.id);//Outer.this.显式调用外部类的变量</span><br><span class="line">            System.out.println(&quot;内部：&quot;+id);//内部类中的变量会暂时将外部类的成员变量给隐藏</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out：</span><br><span class="line">外部：10</span><br><span class="line">内部：1</span><br><span class="line">内部类</span><br></pre></td></tr></table></figure><h4 id="5-2-静态内部类"><a href="#5-2-静态内部类" class="headerlink" title="5.2 静态内部类"></a>5.2 静态内部类</h4><p>静态内部类能够直接被外部类给实例化，不需要使用外部类对象</p><p><strong>静态内部类只能访问自己属性和方法及外部类的静态属性和方法</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private static int outerStaticField = 42;</span><br><span class="line"></span><br><span class="line">    // 静态内部类</span><br><span class="line">    public static class StaticInnerClass &#123;</span><br><span class="line">        private int innerField;</span><br><span class="line"></span><br><span class="line">        public StaticInnerClass(int innerField) &#123;</span><br><span class="line">            this.innerField = innerField;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void printValues() &#123;</span><br><span class="line">            System.out.println(&quot;Outer static field: &quot; + outerStaticField);</span><br><span class="line">            System.out.println(&quot;Inner field: &quot; + innerField);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建静态内部类的实例</span><br><span class="line">        StaticInnerClass innerObj = new StaticInnerClass(10);</span><br><span class="line">        // 调用静态内部类的方法</span><br><span class="line">        innerObj.printValues();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-局部内部类"><a href="#5-3-局部内部类" class="headerlink" title="5.3 局部内部类"></a>5.3 局部内部类</h4><p><strong>局部内部类是在一个方法内部声明的一个类</strong></p><p>在局部内部类中，如果要<strong>访问局部变量</strong>，那么该<strong>局部变量</strong>要用<strong>final修饰</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class LocalInnerClassTest &#123;</span><br><span class="line">    // 外部类的成员变量</span><br><span class="line">    private String name;</span><br><span class="line">    private static int age;</span><br><span class="line">    LocalInnerClassTest(String name,int age)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">        this.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 外部类的实例方法</span><br><span class="line">    public void run() &#123;&#125;</span><br><span class="line">    // 外部类的静态方法</span><br><span class="line">    public static void go() &#123;&#125;</span><br><span class="line">    // 外部类的实例方法，包含局部内部类的定义</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        // 定义一个 final 局部变量</span><br><span class="line">        final String myname = &quot;xxx&quot;;</span><br><span class="line">        // 定义局部内部类 LocalInnerClass</span><br><span class="line">        class LocalInnerClass &#123;</span><br><span class="line">            // 局部内部类的成员变量</span><br><span class="line">            private String name;</span><br><span class="line">            // 局部内部类的方法，接受一个参数 name</span><br><span class="line">            public void test(String name) &#123;</span><br><span class="line">                // 在方法中访问参数 name</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                // 在局部内部类的成员方法中，可以使用 this 关键字访问局部内部类的成员变量</span><br><span class="line">                System.out.println(this.name);</span><br><span class="line">                // 在局部内部类中访问外部方法中的 final 变量 myname</span><br><span class="line">                System.out.println(myname);</span><br><span class="line">                // 在局部内部类中访问外部类的成员变量 name</span><br><span class="line">                System.out.println(LocalInnerClassTest.this.name);</span><br><span class="line">                // 在局部内部类中调用外部类的实例方法 run()</span><br><span class="line">                LocalInnerClassTest.this.run();</span><br><span class="line">                // 在局部内部类中调用外部类的静态方法 go()</span><br><span class="line">                LocalInnerClassTest.go();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 创建局部内部类的实例</span><br><span class="line">        LocalInnerClass lic = new LocalInnerClass();</span><br><span class="line">        // 修改局部内部类的成员变量 name</span><br><span class="line">        lic.name = &quot;tom&quot;;</span><br><span class="line">        // 调用局部内部类的方法 test()，传入参数 &quot;test&quot;</span><br><span class="line">        lic.test(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalInnerClassTest inner=new LocalInnerClassTest(&quot;wang&quot;,22);</span><br><span class="line">        inner.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">test</span><br><span class="line">tom</span><br><span class="line">xxx</span><br><span class="line">wang</span><br></pre></td></tr></table></figure><p><em>注：局部内部类不能通过外部类对象直接实例化，而是在方法中实例化出自己来，然后通过内部类对象调用自己类中的方法。</em></p><h4 id="5-4-匿名内部类"><a href="#5-4-匿名内部类" class="headerlink" title="5.4 匿名内部类"></a>5.4 匿名内部类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个接口</span><br><span class="line">interface Greeting &#123;</span><br><span class="line">    void greet();</span><br><span class="line">&#125;</span><br><span class="line">public class AnonymousInnerClassExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 使用匿名内部类创建实现 Greeting 接口并调用greet方法</span><br><span class="line">        new Greeting() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void greet() &#123;</span><br><span class="line">                System.out.println(&quot;Hello, world!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.greet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java基础语法&quot;&gt;&lt;a href=&quot;#Java基础语法&quot; class=&quot;headerlink&quot; title=&quot;Java基础语法&quot;&gt;&lt;/a&gt;Java基础语法&lt;/h2&gt;&lt;h3 id=&quot;1-浮点型拓展&quot;&gt;&lt;a href=&quot;#1-浮点型拓展&quot; class=&quot;header</summary>
      
    
    
    
    <category term="java" scheme="https://wangak.cc/categories/java/"/>
    
    
    <category term="java" scheme="https://wangak.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>虚拟环境命令</title>
    <link href="https://wangak.cc/posts/37951873.html"/>
    <id>https://wangak.cc/posts/37951873.html</id>
    <published>2023-09-26T11:41:22.000Z</published>
    <updated>2023-09-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.查看虚拟环境</strong><br>conda info —envs<br><strong>2.查看虚拟环境的Python版本</strong><br>python —version<br><strong>3.创建虚拟环境</strong><br>conda create —name 环境名<br><strong>4.激活环境</strong><br>conda activate 环境名<br><strong>5.使用pip下载特定版本的Python包</strong><br>pip install package_name==version_number<br><strong>6.查看虚拟环境中有哪些包</strong><br>conda list -n <env_name><br><strong>7.创建虚拟环境并安装python所需要的版本</strong><br>conda create -n your_env_name python=x.x<br><strong>8.删除虚拟环境</strong><br>conda env remove -n pytorch_env<br><strong>9.pip指定环境安装包</strong><br>pip install —target=/Anaconda/envs/env_name/Lib/site-packages -r requirements.txt</env_name></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;1.查看虚拟环境&lt;/strong&gt;&lt;br&gt;conda info —envs&lt;br&gt;&lt;strong&gt;2.查看虚拟环境的Python版本&lt;/strong&gt;&lt;br&gt;python —version&lt;br&gt;&lt;strong&gt;3.创建虚拟环境&lt;/strong&gt;&lt;br&gt;co</summary>
      
    
    
    
    <category term="运行环境" scheme="https://wangak.cc/categories/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="运行环境" scheme="https://wangak.cc/tags/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>UNeXt</title>
    <link href="https://wangak.cc/posts/260cf31a.html"/>
    <id>https://wangak.cc/posts/260cf31a.html</id>
    <published>2023-09-24T04:53:36.000Z</published>
    <updated>2023-09-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UNeXt"><a href="#UNeXt" class="headerlink" title="UNeXt"></a>UNeXt</h2><h3 id="1-网络设计"><a href="#1-网络设计" class="headerlink" title="1.网络设计"></a>1.网络设计</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411246.png" alt="1" style="zoom: 67%;"></p><p>分成卷积阶段、标记化MLP阶段</p><p>编码器：进行两倍的下采样（2×2的最大池化层）</p><p>解码器：进行两倍的上采样（双线性插值），使用双线性插值而不是转置卷积，因为转置卷积基本上是可学习的上采样，会增加更多可学习参数。</p><p>C为超参数，一般取C1=32、C2=64、C3=128、C4=160、C5=256(C的取值比UNet小，<strong>减少了参数和计算</strong>)</p><p><strong>注：充分考虑了模型维度对参数量和计算量的影响，采用了更少的参数设计</strong></p><p><strong>卷积阶段：</strong>每个卷积块配备了一个卷积层、一个批量归一化层和ReLU激活函数，使用3×3的卷积核大小，步幅为1，填充为1，用于保持特征图的空间分辨率不变，同时允许网络学习提取不同位置的特征信息。</p><p><strong>Tokenized MLP Stage：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411888.png" alt="2" style="zoom:67%;"></p><p>​    <strong>Conv:</strong>kernel_size=3，stride=2，padding=1,同时输出通道数(E)大于输入通道数(E为超参数，token数量)，把特征图大小缩小了一半，增加了通道数</p><p>​    <strong>Shifted MLP：</strong>让模型更加关注 local 的信息</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411232.png" alt="3"></p><p>先使用0填充特征图，填充过后在通道维度做切割，再做平移操作，然后将各个切片合并在一起，最后提取特征图中间部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">xn = x.transpose(1, 2).view(B, C, H, W).contiguous()</span><br><span class="line">xn = F.pad(xn, (self.pad, self.pad, self.pad, self.pad) , &quot;constant&quot;, 0)</span><br><span class="line">xs = torch.chunk(xn, self.shift_size, 1)</span><br><span class="line">x_shift = [torch.roll(x_c, shift, 3) for x_c, shift in zip(xs, range(-self.pad, self.pad+1))]</span><br><span class="line">x_cat = torch.cat(x_shift, 1)</span><br><span class="line">x_cat = torch.narrow(x_cat, 2, self.pad, H)</span><br><span class="line">x_s = torch.narrow(x_cat, 3, self.pad, W)</span><br><span class="line">x_s = x_s.reshape(B,C,H*W).contiguous()</span><br><span class="line">x_shift_c = x_s.transpose(1,2)</span><br><span class="line">x = self.fc2(x_shift_c)</span><br><span class="line">x = self.drop(x)</span><br><span class="line">return x</span><br></pre></td></tr></table></figure><p>  <strong>DWConv：</strong>编码MLP特征的位置信息、减少运算量的作用</p><h3 id="2-实验结果及消融实验"><a href="#2-实验结果及消融实验" class="headerlink" title="2.实验结果及消融实验"></a>2.实验结果及消融实验</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411020.png" alt="4"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411855.png" alt="5"></p>]]></content>
    
    
    <summary type="html">记录了UNeXt的网络结构及实验结果</summary>
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
    <category term="Unet系列" scheme="https://wangak.cc/tags/Unet%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>UCTransNet</title>
    <link href="https://wangak.cc/posts/58f5b62a.html"/>
    <id>https://wangak.cc/posts/58f5b62a.html</id>
    <published>2023-09-22T06:48:54.000Z</published>
    <updated>2023-10-20T04:37:27.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UCTransNet"><a href="#UCTransNet" class="headerlink" title="UCTransNet"></a>UCTransNet</h2><p><strong>解决的问题：</strong>某些跳过连接会对分割性能产生负面影响</p><p><strong>CTrans</strong>代替<strong>U-Net的跳跃连接</strong></p><p><strong>跳跃连接的作用：</strong>减少由于池化操作造成的信息丢失对于分割结果的影响。</p><p>简单的跳跃连接不好：编码器和解码器之间的语义差距，简单的跳跃连接只是在同尺度下进行的，用语义特征较少的浅层特征进行跳跃连接可能会对最终的分割结果产生损害</p><p> <strong>CTrans (Channel Transformer)：</strong>建立编码器和解码器之间的关联，取代原有的跳过连接，解决语义缺口，提高分割性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;UCTransNet&quot;&gt;&lt;a href=&quot;#UCTransNet&quot; class=&quot;headerlink&quot; title=&quot;UCTransNet&quot;&gt;&lt;/a&gt;UCTransNet&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;解决的问题：&lt;/strong&gt;某些跳过连接会对分割性能产生负</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>运算符及类型转换</title>
    <link href="https://wangak.cc/posts/3446eac5.html"/>
    <id>https://wangak.cc/posts/3446eac5.html</id>
    <published>2023-09-19T06:54:09.000Z</published>
    <updated>2023-09-26T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1.运算符"></a>1.运算符</h3><h4 id="1-1-单目运算符重载"><a href="#1-1-单目运算符重载" class="headerlink" title="1.1 单目运算符重载"></a>1.1 单目运算符重载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyNumber&#123;</span><br><span class="line">    private:</span><br><span class="line">        int value;</span><br><span class="line">    public:</span><br><span class="line">        MyNumber(int v):value(v)&#123;&#125;;</span><br><span class="line">        MyNumber&amp; operator++()//重载前置递增运算符++,前置递增运算符返回引用(允许修改原始对象并立即访问修改后的对象)</span><br><span class="line">        &#123;</span><br><span class="line">            value++;</span><br><span class="line">            return *this;</span><br><span class="line">        &#125;</span><br><span class="line">        MyNumber operator++(int)//重载后置递增运算符++，返回原始对象的副本，int 参数只是为了区分前置和后置递增运算符</span><br><span class="line">        &#123;</span><br><span class="line">            MyNumber temp(*this);</span><br><span class="line">            value++;</span><br><span class="line">            return temp;</span><br><span class="line">        &#125;</span><br><span class="line">        void display()</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;value:&quot;&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    MyNumber num(5);</span><br><span class="line">    MyNumber num2=num++;</span><br><span class="line">    num2.display();</span><br><span class="line">    num.display();</span><br><span class="line">    ++num;</span><br><span class="line">    num.display();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">value:5</span><br><span class="line">value:6</span><br><span class="line">value:7</span><br></pre></td></tr></table></figure><p><em>注：如果只想执行递增运算，可使用++ object，也可使用 object ++，但应选择前者，这样避免创建一个未被使用的临时拷贝。</em></p><h4 id="1-2-转换运算符"><a href="#1-2-转换运算符" class="headerlink" title="1.2 转换运算符"></a>1.2 转换运算符</h4><p><strong>转换运算符 const char* ：</strong>对象的内容转换成 cout 能够接受的类型（const char*）</p><p><strong>ostringstream：</strong>属于 <code>&lt;sstream&gt;</code> 头文件，并提供了将各种数据类型（如整数、浮点数、字符串等）转换为字符串的能力</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt; // 用于 ostringstream</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 自定义日期类</span><br><span class="line">class Date &#123;</span><br><span class="line">private:</span><br><span class="line">    int day, month, year;</span><br><span class="line">    string dateInString;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 构造函数，用于初始化日期对象</span><br><span class="line">    Date(int inMonth, int inDay, int inYear) : month(inMonth), day(inDay), year(inYear) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 类型转换运算符，将日期对象转换为 const char* 类型的指针</span><br><span class="line">    operator const char*() &#123;</span><br><span class="line">        ostringstream formattedDate; // 辅助构建字符串</span><br><span class="line">        formattedDate &lt;&lt; month &lt;&lt; &quot; / &quot; &lt;&lt; day &lt;&lt; &quot; / &quot; &lt;&lt; year;</span><br><span class="line">        dateInString = formattedDate.str();</span><br><span class="line">        return dateInString.c_str();//dateInString.c_str(),返回一个 const char* 类型的指针</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建日期对象，表示圣诞节的日期</span><br><span class="line">    Date Holiday(12, 25, 2016);</span><br><span class="line"></span><br><span class="line">    // 直接输出日期对象，由于重载了类型转换运算符，它将自动转换为字符串并输出</span><br><span class="line">    cout &lt;&lt; &quot;Holiday is on: &quot; &lt;&lt; Holiday &lt;&lt; endl;</span><br><span class="line">    // 下面是其他使用示例的注释部分</span><br><span class="line">    // string strHoliday(Holiday); // 可行!</span><br><span class="line">    // strHoliday = Date(11, 11, 2016); // 也是可行的!</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-双目运算符重载"><a href="#1-3-双目运算符重载" class="headerlink" title="1.3 双目运算符重载"></a>1.3 双目运算符重载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Complex &#123;</span><br><span class="line">private:</span><br><span class="line">    double real;</span><br><span class="line">    double imaginary;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Complex(double r, double i) : real(r), imaginary(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 重载加法运算符 +</span><br><span class="line">    Complex operator+(const Complex&amp; other) &#123;</span><br><span class="line">        double newReal = real + other.real;</span><br><span class="line">        double newImaginary = imaginary + other.imaginary;</span><br><span class="line">        return Complex(newReal, newImaginary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打印复数的成员函数</span><br><span class="line">    void display() &#123;</span><br><span class="line">        std::cout &lt;&lt; real &lt;&lt; &quot; + &quot; &lt;&lt; imaginary &lt;&lt; &quot;i&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Complex num1(3.0, 4.0);</span><br><span class="line">    Complex num2(1.0, 2.0);</span><br><span class="line"></span><br><span class="line">    Complex sum = num1 + num2; // 使用重载的 + 运算符</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Sum: &quot;;</span><br><span class="line">    sum.display();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Sum: 4 + 6i</span><br></pre></td></tr></table></figure><h4 id="1-4-重载下标运算符"><a href="#1-4-重载下标运算符" class="headerlink" title="1.4 重载下标运算符"></a>1.4 重载下标运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyArray &#123;</span><br><span class="line">private:</span><br><span class="line">    int arr[10]; // 假设数组大小为 10</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 重载下标运算符 []</span><br><span class="line">    int&amp; operator[](int index) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt;= 10) &#123;</span><br><span class="line">            throw std::out_of_range(&quot;Index out of range&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyArray myArray;</span><br><span class="line"></span><br><span class="line">    // 初始化数组元素</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        myArray[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用下标运算符 [] 访问数组元素并输出</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;myArray[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; myArray[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">myArray[0] = 0</span><br><span class="line">myArray[1] = 1</span><br><span class="line">myArray[2] = 2</span><br><span class="line">myArray[3] = 3</span><br><span class="line">myArray[4] = 4</span><br><span class="line">myArray[5] = 5</span><br><span class="line">myArray[6] = 6</span><br><span class="line">myArray[7] = 7</span><br><span class="line">myArray[8] = 8</span><br><span class="line">myArray[9] = 9</span><br></pre></td></tr></table></figure><h4 id="1-5-函数运算符-operator"><a href="#1-5-函数运算符-operator" class="headerlink" title="1.5 函数运算符 operator()"></a>1.5 函数运算符 operator()</h4><p><strong>operator()</strong>让对象像函数，被称为函数运算符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义一个类 Display</span><br><span class="line">class Display &#123;</span><br><span class="line">public:</span><br><span class="line">    // 重载函数调用运算符 ()，用于输出传入的字符串</span><br><span class="line">    void operator () (string input) const &#123;//const: 这个关键字表示该运算符函数是一个常量成员函数，告诉编译器在函数内部不会修改对象的状态。</span><br><span class="line">        cout &lt;&lt; input &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    // 创建 Display 类的对象 displayFuncObj</span><br><span class="line">    Display displayFuncObj;</span><br><span class="line">    // 使用函数调用运算符 () 调用 displayFuncObj，传入字符串参数</span><br><span class="line">    displayFuncObj(&quot;Display this string! &quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Display this string!</span><br></pre></td></tr></table></figure><h3 id="2-类型转换运算符"><a href="#2-类型转换运算符" class="headerlink" title="2.类型转换运算符"></a>2.类型转换运算符</h3><h4 id="2-1-static-cast"><a href="#2-1-static-cast" class="headerlink" title="2.1 static_cast"></a>2.1 static_cast</h4><p><strong>static_cast:</strong>显式地将一种数据类型转换为另一种数据类型,在执行转换时会进行<strong>编译时</strong>类型检查，以确保类型转换是合法的。</p><p><strong>static_cast</strong>的语法如下：</p><p><code>new_type static_cast&lt;new_type&gt;(expression)</code></p><p>其中：</p><ul><li><code>new_type</code> 表示要进行的目标类型（目标数据类型）。</li><li><code>expression</code> 是要转换的表达式或值。</li></ul><p><strong>主要用途:</strong></p><ul><li><p><strong>基本数据类型之间的转换(主要用途）</strong>：如整数到浮点数，浮点数到整数，以及其他基本数据类型之间的转换。</p></li><li><p>指针类型之间的转换：在执行时<strong>不会进行运行时检查</strong>，因此应该谨慎使用</p></li><li><p>类之间的转换：可以用于父类和子类之间的转换，但它<strong>不执行运行时检查</strong>，因此应谨慎使用。</p></li><li><p>枚举类型的转换：可以用于枚举类型之间的转换。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123; /* ... */ &#125;;</span><br><span class="line">class Child : public Parent &#123; /* ... */ &#125;;</span><br><span class="line"></span><br><span class="line">Parent* parentPtr = new Child();</span><br><span class="line">Child* childPtr = static_cast&lt;Child*&gt;(parentPtr); // 将父类指针转换为子类指针</span><br></pre></td></tr></table></figure><h4 id="2-2-dynamic-cast"><a href="#2-2-dynamic-cast" class="headerlink" title="2.2 dynamic_cast"></a>2.2 dynamic_cast</h4><p><strong>dynamic_cast：</strong>主要用于在继承关系中进行安全的<strong>运行时</strong>类型识别和类型转换。</p><p><strong>dynamic_cast</strong> 的语法如下：</p><p><code>dynamic_cast&lt;new_type&gt;(expression)</code> </p><p>其中：</p><ul><li><code>new_type</code> 表示要进行的目标类型（目标数据类型）。</li><li><code>expression</code> 是要转换的指针或引用。</li></ul><p><strong>dynamic_cast</strong>的主要用途如下：</p><ul><li><strong>用于多态类型的安全类型转换</strong>：<code>dynamic_cast</code> 主要用于处理多态类的情况</li></ul><p><strong>*注：dynamic_cast</strong>会在运行时检查是否可以进行安全的类型转换。如果转换不合法（例如，试图将基类指针转换为未与之相关的派生类指针），则<strong>会返回空指针</strong>（对于指针）或引发 <strong>std::bad_cast</strong>异常（对于引用）。*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void speak() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Animal speaks&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Dog : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void speak() override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Dog barks&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Animal* animal = new Dog();</span><br><span class="line"></span><br><span class="line">    // 使用 dynamic_cast 将基类指针转换为派生类指针</span><br><span class="line">    Dog* dog = dynamic_cast&lt;Dog*&gt;(animal);</span><br><span class="line"></span><br><span class="line">    if (dog) &#123;</span><br><span class="line">        // 转换成功，现在可以安全地调用 Dog 类的函数</span><br><span class="line">        dog-&gt;speak();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 转换失败</span><br><span class="line">        std::cout &lt;&lt; &quot;Failed to cast to Dog&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete animal;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Dog barks</span><br></pre></td></tr></table></figure><h4 id="2-3-const-cast"><a href="#2-3-const-cast" class="headerlink" title="2.3 const_cast"></a>2.3 const_cast</h4><p><strong>const_cast:</strong>用于在一定情况下去除对象的常量性,可以添加或移除对象的 <code>const</code> 限定符，从而改变对象的常量属性。</p><p><strong>const_cast:</strong>的语法如下：</p><p><code>const_cast&lt;new_type&gt;(expression)</code> </p><p>其中：</p><ul><li><code>new_type</code> 表示要进行的目标类型（目标数据类型）。</li><li><code>expression</code> 是要转换的指针、引用或对象。</li></ul><p><strong>注：</strong></p><p><strong>1.const_cast:</strong>主要用于去除对象的 <code>const</code> 限定符，使其变为非常量对象，从而允许对其进行修改。</p><p><strong>2.const_cast:</strong>不会修改对象的实际值，只是修改了对象的类型属性。</p><p><strong>主要用途：</strong>用于解决某些兼容性问题，例如调用老式库函数，这些函数不将参数标记为常量，但实际上不会修改它们。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int value = 42;</span><br><span class="line">    int* nonConstPtr = const_cast&lt;int*&gt;(&amp;value);</span><br><span class="line">    *nonConstPtr = 100; // 合法，修改了原本是常量的对象</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-运算符&quot;&gt;&lt;a href=&quot;#1-运算符&quot; class=&quot;headerlink&quot; title=&quot;1.运算符&quot;&gt;&lt;/a&gt;1.运算符&lt;/h3&gt;&lt;h4 id=&quot;1-1-单目运算符重载&quot;&gt;&lt;a href=&quot;#1-1-单目运算符重载&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Swin-Transformer</title>
    <link href="https://wangak.cc/posts/4b223b72.html"/>
    <id>https://wangak.cc/posts/4b223b72.html</id>
    <published>2023-09-17T05:05:40.000Z</published>
    <updated>2023-09-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Swin-Transformer"><a href="#Swin-Transformer" class="headerlink" title="Swin-Transformer"></a>Swin-Transformer</h2><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201409143.png" alt="1"></p><p><em>注：使用Transformer取代卷积操作是因为卷积操作在每个位置只关注输入图像的局部感受野，即一个固定大小的区域，而难以有效地捕捉全局信息，Transformer架构引入了自注意力机制，允许模型在一定范围内建立像素之间的关联，可以更好地处理全局信息</em>。</p><h3 id="2-W-MSA"><a href="#2-W-MSA" class="headerlink" title="2.W-MSA"></a>2.W-MSA</h3><p>使用窗口多头自注意力，将输入的图片划分成不重叠的窗口，在这样的局部的窗口中计算自注意力，减少计算量，其对于图像的大小具有<strong>线性的复杂度</strong></p><p>$Ω(MSA) = 4hwC^2 + 2(hw)^2C; (1)$<br>$Ω(W-MSA) = 4hwC^2 + 2M^2hwC; (2)$</p><p><strong>注：</strong></p><p>h,w:输入图像的高,宽</p><p>M:一个窗口中含有MxM个patch</p><p>C：超参数（linear embedding将patch的特征维度变成C)</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201409740.png" alt="6"></p><h3 id="3-SW-MSA"><a href="#3-SW-MSA" class="headerlink" title="3.SW-MSA"></a>3.SW-MSA</h3><p>虽然基于窗口计算自注意力能够很好的解决计算量大的问题，但是现在<strong>窗口与窗口之间没有联系</strong>，就达不到全局建模的能力，所以作者就提出了<strong>移动窗口</strong>的方式去解决</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201409940.png" alt="4" style="zoom: 80%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201409148.png" alt="7" style="zoom: 80%;"></p><p><strong>从Layer1移动到Layer1+1后存在的问题：</strong>每个窗口中的patch数量不同，窗口数增大了，会影响计算效率</p><p><strong>解决方法：cyclic shift+MSA-masked</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201410145.png" alt="5" style="zoom: 50%;"></p><p><strong>循环移位：</strong>将A、C先向下拼接，再将B、A向右拼接。通过循环移位将窗口的数目再一次地拼成4个，控制了计算复杂度，但产生了新的问题：同一个窗口中的patch来自于不同的区域，而来自于不同区域的patch之间不应该计算自注意力。</p><p><strong>MSA-masked：</strong>对于一个patch，得到这个patch的attention（Q、K、V），将这个patch的Q与其他patch的K点乘，如果这两个patch来自于不同的区域，那么将点乘的结果减100，那么结果将是一个负数，再经过softmax处理后映射得到的权值接近于0</p><h3 id="4-patch-merging"><a href="#4-patch-merging" class="headerlink" title="4.patch merging"></a>4.patch merging</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201410582.png" alt="8" style="zoom: 67%;"></p><p><strong>patch merging:</strong>进行下采样，用于缩小分辨率，调整通道数进而形成层次化的设计</p><h3 id="5-Relative-position-bias（相对位置偏置）"><a href="#5-Relative-position-bias（相对位置偏置）" class="headerlink" title="5.Relative position bias（相对位置偏置）"></a>5.Relative position bias（相对位置偏置）</h3><p><strong>偏置B:</strong>让attention map进一步有所偏重，在进行Attention计算时考虑到像素间的位置关系。</p><p>偏置B是由将像素与像素间的相对位置进行编码然后通过查找偏置表得到的。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310212045328.png" alt="9" style="zoom: 80%;"></p><h2 id="Swin-Unet"><a href="#Swin-Unet" class="headerlink" title="Swin-Unet"></a>Swin-Unet</h2><p><img src="https://typoraimg.wangak.cc/2023/img/202310201410888.png" alt="11"></p><p><strong>编码器:</strong>工作原理和 Swin-Transformer完全一样的。其中，Patch Merging模块的作用是在每个Swin-Transformer模块开头来降低图片分辨率。</p><p><strong>解码器：</strong>Patch Expanding将相邻维度的特征图重塑为更高分辨率的特征图(2×上采样)，并相应地将特征维数减半。</p><p><strong>Patch Expanding:</strong></p><p>​       在上采样之前，在输入特征上加一个线性层,将特征维数增加到原始维数的2倍,利用重排操作将输入特征的分辨率扩展为输入分辨率的2倍，将特征维数降低为输入维数的1/4。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class PatchExpand(nn.Module): </span><br><span class="line">    def __init__(self, input_resolution, dim, dim_scale=2, norm_layer=nn.LayerNorm):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.input_resolution = input_resolution</span><br><span class="line">        self.dim = dim</span><br><span class="line">        self.expand = nn.Linear(dim, 2*dim, bias=False) if dim_scale==2 else nn.Identity()#如果dim_scale是2则执行nn.Linear()，不是则执行直接映射</span><br><span class="line">        self.norm = norm_layer(dim // dim_scale)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line"></span><br><span class="line">        H, W = self.input_resolution</span><br><span class="line">        x = self.expand(x)</span><br><span class="line">        B, L, C = x.shape</span><br><span class="line">        assert L == H * W, &quot;input feature has wrong size&quot;</span><br><span class="line"></span><br><span class="line">        x = x.view(B, H, W, C)</span><br><span class="line">        x = rearrange(x, &#x27;b h w (p1 p2 c)-&gt; b (h p1) (w p2) c&#x27;, p1=2, p2=2, c=C//4)</span><br><span class="line">        x = x.view(B,-1,C//4)</span><br><span class="line">        x= self.norm(x.clone())</span><br><span class="line"></span><br><span class="line">        return x</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录了Swin-Transformer的网络结构及实验结果</summary>
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
    <category term="Transformer" scheme="https://wangak.cc/tags/Transformer/"/>
    
    <category term="Unet系列" scheme="https://wangak.cc/tags/Unet%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>RNN</title>
    <link href="https://wangak.cc/posts/6fe72dd0.html"/>
    <id>https://wangak.cc/posts/6fe72dd0.html</id>
    <published>2023-09-16T04:12:20.000Z</published>
    <updated>2023-09-16T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-RNN-递归神经网络"><a href="#1-RNN-递归神经网络" class="headerlink" title="1.RNN(递归神经网络)"></a>1.RNN(递归神经网络)</h3><p><strong>RNN:</strong>用于处理<strong>序列</strong>数据和<strong>时间</strong>序列数据。RNN具有循环连接，允许信息在网络内部传递。</p><h4 id="1-1-RNN的结构："><a href="#1-1-RNN的结构：" class="headerlink" title="1.1 RNN的结构："></a>1.1 RNN的结构：</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202310201406368.png" alt="1"></p><p>注：<strong>权重矩阵</strong> W就是<strong>隐藏层</strong>上一次的值作为这一次的输入的权重</p><h4 id="1-2-RNN的优劣"><a href="#1-2-RNN的优劣" class="headerlink" title="1.2  RNN的优劣"></a>1.2  RNN的优劣</h4><p><strong>RNN的主要优点包括：</strong></p><p><strong>1.处理序列数据：</strong>RNN能够有效地处理变长序列数据，因为它的隐藏状态可以捕获先前时间步的信息。</p><p><strong>2.上下文理解：</strong>RNN能够理解上下文信息。</p><p><strong>RNN的缺点：</strong></p><p><strong>1.长期依赖问题：</strong>由于梯度消失或梯度爆炸的问题，传统的RNN在处理长序列时可能会失去对远距离时间步的依赖性。</p><p><strong>2.计算效率：</strong>RNN的计算效率较低，难以处理大规模数据和长序列。</p><h3 id="2-LSTM-长短期记忆"><a href="#2-LSTM-长短期记忆" class="headerlink" title="2.LSTM(长短期记忆)"></a>2.LSTM(长短期记忆)</h3><p><strong>LSTM:</strong>为了解决RNN在长序列训练过程中的梯度消失和梯度爆炸问题。</p><h4 id="2-1-LSTM的结构原理："><a href="#2-1-LSTM的结构原理：" class="headerlink" title="2.1 LSTM的结构原理："></a>2.1 LSTM的结构原理：</h4><p>输入：Z、输入门$Z_i$、输出门 $Z_o$、遗忘门 $Z_f$</p><p>输出：a</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201406702.png" alt="2"></p><p>输入门$Z_i$:决定了哪些新信息要被存储到细胞状态中。它也考虑前一个时间步的隐藏状态和当前时间步的输入，以及一个候选值，用于更新细胞状态。</p><p>遗忘门 $Z_f$:决定了哪些信息要被遗忘或丢弃。输出一个介于0和1之间的值，表示要保留多少以前的信息。</p><p>输出门 $Z_o$:决定哪些将会被当成当前状态的输出。</p><p>细胞状态:在LSTM中负责存储和传递信息，以便于捕获长期依赖关系。</p><h4 id="2-2-LSTM的工作流程"><a href="#2-2-LSTM的工作流程" class="headerlink" title="2.2 LSTM的工作流程"></a>2.2 LSTM的工作流程</h4><p><strong>1.遗忘门的输出（$f_t$)</strong>:</p><script type="math/tex; mode=display">f_t=σ(W_{xf}x_t+W_{hf}h_{t−1}+b_f)</script><p><img src="https://typoraimg.wangak.cc/2023/img/202310201406010.png" alt="3"></p><p><strong>2.候选细胞状态（$\tilde{C}$）及输入门（$i_t$）</strong></p><script type="math/tex; mode=display">\tilde{C}=tanh(W_{xc}x_t+W_{hc}h_{t−1}+b_c)</script><script type="math/tex; mode=display">i_t=σ(W_{xi}x_t+W_{hi}h_{t−1}+b_i)</script><p><img src="https://typoraimg.wangak.cc/2023/img/202310201406785.png" alt="4"></p><p><strong>3.更新状态值($C_t$)</strong></p><script type="math/tex; mode=display">C_t=f_t⋅C_{t−1}+i_t⋅\tilde{C}</script><p><img src="https://typoraimg.wangak.cc/2023/img/202310201406751.png" alt="5"></p><p><strong>4.输出</strong></p><script type="math/tex; mode=display">o_t=σ(W_{xo}x_t+W_{ho}h_{t−1}+b_o)</script><script type="math/tex; mode=display">h_t=o_t⋅tanh(C_t)</script><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407980.png" alt="6"></p><p><strong>注：</strong></p><p>​      <strong>*利用tanh来映射细胞状态信息的原因</strong>：tanh函数其输出在-1-1之间，这与大多数场景下特征分布是0中心的吻合。tanh函数在输入为0附近相比 Sigmoid函数有更大的梯度，通常使模型收敛更快。*</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-RNN-递归神经网络&quot;&gt;&lt;a href=&quot;#1-RNN-递归神经网络&quot; class=&quot;headerlink&quot; title=&quot;1.RNN(递归神经网络)&quot;&gt;&lt;/a&gt;1.RNN(递归神经网络)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;RNN:&lt;/strong&gt;用于处理&lt;st</summary>
      
    
    
    
    <category term="深度学习" scheme="https://wangak.cc/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="RNN" scheme="https://wangak.cc/tags/RNN/"/>
    
    <category term="LSTM" scheme="https://wangak.cc/tags/LSTM/"/>
    
  </entry>
  
  <entry>
    <title>常用损失函数</title>
    <link href="https://wangak.cc/posts/60adb68d.html"/>
    <id>https://wangak.cc/posts/60adb68d.html</id>
    <published>2023-09-09T05:07:22.000Z</published>
    <updated>2023-09-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><h3 id="1-损失函数的概念及使用场景"><a href="#1-损失函数的概念及使用场景" class="headerlink" title="1.损失函数的概念及使用场景"></a>1.损失函数的概念及使用场景</h3><p><strong>损失函数：</strong>用于衡量模型预测结果与真实结果之间的差异或误差。</p><p><strong>损失函数的使用场景：</strong></p><ul><li><p><strong>模型训练：</strong>通过最小化损失函数，可以调整模型的参数，使其能够更好地拟合训练数据，提高模型的性能。</p></li><li><p><strong>模型评估：</strong>通过计算模型在验证集或测试集上的损失值，可以判断模型的泛化能力和预测准确度，较小的损失值通常表示模型更好地适应了新数据。</p></li><li><p><strong>优化算法：</strong>通过计算损失函数对模型参数的梯度，可以确定参数的更新方向和步长，以便优化模型。</p></li><li><p><strong>模型选择和比较：</strong>选择合适的损失函数可以帮助优化模型性能，并对不同模型进行比较和选择。</p></li></ul><h3 id="2-分类任务"><a href="#2-分类任务" class="headerlink" title="2.分类任务"></a>2.分类任务</h3><h4 id="2-1-交叉熵损失函数（Cross-Entropy-Loss）"><a href="#2-1-交叉熵损失函数（Cross-Entropy-Loss）" class="headerlink" title="2.1 交叉熵损失函数（Cross-Entropy Loss）"></a>2.1 交叉熵损失函数（Cross-Entropy Loss）</h4><p><strong>二分类问题：</strong>二元交叉熵损失函数（Binary Cross-Entropy Loss）</p><ul><li><p>计算公式：<script type="math/tex">\large L(y, p) = -[y * log(p) + (1 - y) * log(1 - p)]</script></p><p> <em>注：真实标签为 y（可以是0或1），模型的预测概率为 p（0 ≤ p ≤ 1）</em></p></li></ul><p><strong>多分类问题：</strong>多元交叉熵损失函数（Multiclass Cross-Entropy Loss）</p><p>​        在多元交叉熵损失函数中，假设有 C 个可能的类别，每个类别都有一个与之相关的标签（通常使用 one-hot 编码）。对于每个样本，模型会输出一个长度为 C 的概率分布向量，表示样本属于每个类别的概率。</p><ul><li>计算公式：$\large L(y, p) = -Σ(y_i * log(p_i))$</li></ul><p><em>注：其中，i 表示类别的索引，$y_i$ 表示真实标签的第 i 个元素，$p_i$ 表示模型的输出概率分布的第 i 个元素。</em></p><h4 id="2-2-Focal-Loss（聚焦损失）"><a href="#2-2-Focal-Loss（聚焦损失）" class="headerlink" title="2.2 Focal Loss（聚焦损失）"></a>2.2 Focal Loss（聚焦损失）</h4><p><strong>Focal Loss:</strong>用于处理类别不平衡问题的损失函数,旨在解决当某些类别的样本数量远远多于其他类别时，传统的交叉熵损失函数会受到类别不平衡的影响，导致模型难以有效地学习少数类别。</p><p><strong>focal loss的具体形式：</strong><script type="math/tex">\large-\alpha(1-y_{pred})^{\gamma}y_{true}log(y_{pred})-(1-\alpha)y_{pred}^{\gamma}(1-y_{true})log(1-y_{pred})</script></p><p><strong>注：</strong></p><p><em>1.$\large\gamma$通常设置为2，$\large(1-y_{pred})^{\gamma}$相当于样本的难易度权值,$\large\alpha$为正负样本的比例</em></p><p><em>2.为了防止难易样本的频繁变化，应当选取小的学习率。防止学习率过大，造成w变化较大从而引起 $\large y_{pred}$的巨大变化，造成难易样本的改变。</em></p><h3 id="3-回归任务"><a href="#3-回归任务" class="headerlink" title="3.回归任务"></a>3.回归任务</h3><h4 id="3-1-均方误差损失函数（Mean-Squared-Error-MSE）"><a href="#3-1-均方误差损失函数（Mean-Squared-Error-MSE）" class="headerlink" title="3.1 均方误差损失函数（Mean Squared Error, MSE）"></a>3.1 均方误差损失函数（Mean Squared Error, MSE）</h4><p><strong>计算公式：</strong>$\large MSE = (1/N) * Σ(y_i - ŷ_i)^2$</p><p>注：N 表示样本数量，$y_i$ 表示真实标签，$ŷ_i$ 表示模型的预测值。</p><h4 id="3-2-平均绝对误差损失函数（Mean-Absolute-Error-MAE"><a href="#3-2-平均绝对误差损失函数（Mean-Absolute-Error-MAE" class="headerlink" title="3.2 平均绝对误差损失函数（Mean Absolute Error, MAE)"></a>3.2 平均绝对误差损失函数（Mean Absolute Error, MAE)</h4><p><strong>计算公式：</strong>$\large MAE = (1/N) * Σ|y_i - ŷ_i|$</p><p>注：N 表示样本数量，$y_i$ 表示真实标签，$ŷ_i$ 表示模型的预测值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;损失函数&quot;&gt;&lt;a href=&quot;#损失函数&quot; class=&quot;headerlink&quot; title=&quot;损失函数&quot;&gt;&lt;/a&gt;损失函数&lt;/h2&gt;&lt;h3 id=&quot;1-损失函数的概念及使用场景&quot;&gt;&lt;a href=&quot;#1-损失函数的概念及使用场景&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="深度学习" scheme="https://wangak.cc/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://wangak.cc/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="损失函数" scheme="https://wangak.cc/tags/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>nnUnet</title>
    <link href="https://wangak.cc/posts/544635d8.html"/>
    <id>https://wangak.cc/posts/544635d8.html</id>
    <published>2023-09-08T11:41:22.000Z</published>
    <updated>2023-09-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nnUnet"><a href="#nnUnet" class="headerlink" title="nnUnet"></a>nnUnet</h2><h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1.预处理"></a>1.预处理</h3><h4 id="1-1-Crop"><a href="#1-1-Crop" class="headerlink" title="1.1 Crop"></a>1.1 Crop</h4><p><strong>Crop:</strong>裁剪去除图片的0区域，使用非0区域作为训练数据，对MRI数据能够显著降低其大小。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405330.png" alt="1"></p><h4 id="1-2-Resample"><a href="#1-2-Resample" class="headerlink" title="1.2 Resample"></a>1.2 Resample</h4><p><strong>Resample:</strong>CNN无法理解体素间距的概念，重采样使得数据集体素间距一致（使像素间所对应的真实的物理距离一致）。</p><p><em>注：在医学图像中要关注图像的物理距离，这关系到器官的大小。</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405296.png" alt="2"></p><h3 id="2-训练"><a href="#2-训练" class="headerlink" title="2.训练"></a>2.训练</h3><h4 id="2-1-Patch-Sampling"><a href="#2-1-Patch-Sampling" class="headerlink" title="2.1 Patch-Sampling:"></a>2.1 Patch-Sampling:</h4><p><strong>Patch-Training:</strong>对不同的图像裁剪固定的大小，组成一个batch进行训练（用于解决在统一体素间距后，出现的数据分辨率不一致的问题）。</p><p><strong>Sampling：</strong>为了防止Patch中的数据全部是背景，保证batch中的数据有1/3包含前景。</p><h4 id="2-2-Cross-Validation"><a href="#2-2-Cross-Validation" class="headerlink" title="2.2 Cross-Validation"></a>2.2 Cross-Validation</h4><p><strong>nnUnet</strong>在训练集上使用<strong>五折交叉验证</strong>进行评估</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405943.png" alt="3"></p><h3 id="3-网络设计"><a href="#3-网络设计" class="headerlink" title="3.网络设计"></a>3.网络设计</h3><p>nnUnet与Unet的结构类似，但<strong>nnUnet</strong>会根据数据集<strong>自适应调整网络结构</strong>。</p><h4 id="3-1-Cascade-Unet"><a href="#3-1-Cascade-Unet" class="headerlink" title="3.1 Cascade-Unet"></a>3.1 Cascade-Unet</h4><p><strong>Cascade-Unet:</strong>使用patch-training，不完整的图片导致感受野受限，为了解决该问题，设计出Cascade-Unet。</p><p><strong>Cascade-Unet的两个阶段：</strong></p><p><strong>1.对输入图片下采样，使用下采样的图片得到粗糙的分割结果</strong></p><p><strong>2.将第一阶段的分割结果上采样，然后与原图concat，使用patch训练</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405010.png" alt="4"></p><h4 id="3-2-网络自适应调整"><a href="#3-2-网络自适应调整" class="headerlink" title="3.2 网络自适应调整"></a>3.2 网络自适应调整</h4><p><strong>nnUnet：</strong>先统一体素间距，然后根据数据集计算网络的输入分辨率并确定网络的结构及参数。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405038.png" alt="5"></p><h3 id="4-后处理"><a href="#4-后处理" class="headerlink" title="4.后处理"></a>4.后处理</h3><p><strong>保留最大连通区域</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405154.png" alt="6"></p><p>上图：<strong>蓝色（前景）、黄色（预测的结果）</strong></p><p><strong>出现的问题：</strong>第一次处理使的模型的性能下降，第二次处理使得模型的性能提高。</p><p><strong>解决方法：</strong>在训练过程中，分别对使用后处理和不使用后处理得到两个精度，然后通过对比结果，决定是否使用后处理。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405294.png" alt="7"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;nnUnet&quot;&gt;&lt;a href=&quot;#nnUnet&quot; class=&quot;headerlink&quot; title=&quot;nnUnet&quot;&gt;&lt;/a&gt;nnUnet&lt;/h2&gt;&lt;h3 id=&quot;1-预处理&quot;&gt;&lt;a href=&quot;#1-预处理&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="https://wangak.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像分割" scheme="https://wangak.cc/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
    <category term="Unet系列" scheme="https://wangak.cc/tags/Unet%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>C++基础（2）</title>
    <link href="https://wangak.cc/posts/679d2361.html"/>
    <id>https://wangak.cc/posts/679d2361.html</id>
    <published>2023-09-08T07:52:05.000Z</published>
    <updated>2023-09-09T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-复制函数"><a href="#1-复制函数" class="headerlink" title="1.复制函数"></a>1.复制函数</h3><h4 id="1-1-浅复制"><a href="#1-1-浅复制" class="headerlink" title="1.1 浅复制"></a>1.1 浅复制</h4><p><strong>浅复制：</strong>仅复制对象的成员变量的值，而不复制对象中的指针所指向的内容。</p><p><em>注：如果原始对象中包含指针，浅复制将导致多个对象共享同一内存块，从而可能引发潜在的问题。当原始对象的析构函数被调用时，如果没有适当地管理共享资源，可能会导致重复释放内存或内存泄漏等问题。</em></p><h4 id="1-2-深复制"><a href="#1-2-深复制" class="headerlink" title="1.2 深复制"></a>1.2 深复制</h4><p><strong>深复制：</strong>不仅复制对象的成员变量的值，还要递归地复制对象中的指针所指向的内容，创建一个全新的数据拷贝。</p><p><em>注：新对象与原始对象彼此独立，<strong>不共享内存块</strong>，但需要更多的计算和内存开销。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt; </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std; </span><br><span class="line">class String&#123;</span><br><span class="line">  private:</span><br><span class="line">    char *data;</span><br><span class="line">  public:</span><br><span class="line">    String(const char *str)</span><br><span class="line">    &#123;</span><br><span class="line">      data=new char[strlen(str)]+1;</span><br><span class="line">      strcpy(data,str);</span><br><span class="line">    &#125;</span><br><span class="line">    // String(const String &amp;other)//浅复制</span><br><span class="line">    // &#123;</span><br><span class="line">    //   data=other.data;</span><br><span class="line">    // &#125;</span><br><span class="line">    String(const String &amp;other)//深复制</span><br><span class="line">    &#123;</span><br><span class="line">      data=new char[strlen(other.data)+1];</span><br><span class="line">      strcpy(data,other.data);</span><br><span class="line">    &#125;</span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">      delete []data;</span><br><span class="line">    &#125;</span><br><span class="line">    void printData()</span><br><span class="line">    &#123;</span><br><span class="line">      cout&lt;&lt;data&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  String Str0(&quot;Hello&quot;);</span><br><span class="line">  String Str1(Str0);</span><br><span class="line">  Str1.printData();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-复制构造函数-拷贝"><a href="#1-3-复制构造函数-拷贝" class="headerlink" title="1.3 复制构造函数(拷贝)"></a>1.3 复制构造函数(拷贝)</h4><p><strong>构造函数委托:</strong>允许一个构造函数调用同一类的另一个构造函数来完成对象的初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyString</span><br><span class="line">&#123;</span><br><span class="line">  private:</span><br><span class="line">    char * _data;</span><br><span class="line">  public:</span><br><span class="line">    MyString(const char* s=&quot;&quot;)</span><br><span class="line">    :_data(nullptr)//初始化_data成员变量为nullptr</span><br><span class="line">    &#123;</span><br><span class="line">      if(s)&#123;</span><br><span class="line">        size_t n=strlen(s)+1;</span><br><span class="line">        _data=new char[n];</span><br><span class="line">        memcpy(_data,s,n);</span><br><span class="line">      &#125;</span><br><span class="line">      cout&lt;&lt;&quot;create&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">  ~MyString()</span><br><span class="line">  &#123;</span><br><span class="line">    cout&lt;&lt;&quot;delete&quot;&lt;&lt;endl;</span><br><span class="line">    delete[] _data;</span><br><span class="line">  &#125;</span><br><span class="line">  MyString(const MyString &amp;other)//复制构造函数(使用构造函数委托来重用构造函数)</span><br><span class="line">  :MyString(other._data)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;copy constructor&quot;&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  MyString str(&quot;hello&quot;);</span><br><span class="line">  MyString str2(str);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">create</span><br><span class="line">create</span><br><span class="line">copy constructor</span><br><span class="line">delete</span><br><span class="line">delete</span><br></pre></td></tr></table></figure><h4 id="1-4-移动构造函数（移动）"><a href="#1-4-移动构造函数（移动）" class="headerlink" title="1.4 移动构造函数（移动）"></a>1.4 移动构造函数（移动）</h4><p><strong>移动构造函数:</strong>一个对象的资源从一个对象转移到另一个对象，而无需进行深层次的复制操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyString</span><br><span class="line">&#123;</span><br><span class="line">  private:</span><br><span class="line">    char * _data;</span><br><span class="line">  public:</span><br><span class="line">    MyString(const char* s=&quot;&quot;)</span><br><span class="line">    :_data(nullptr)//初始化_data成员变量为nullptr</span><br><span class="line">    &#123;</span><br><span class="line">      if(s)&#123;</span><br><span class="line">        size_t n=strlen(s)+1;</span><br><span class="line">        _data=new char[n];</span><br><span class="line">        memcpy(_data,s,n);</span><br><span class="line">      &#125;</span><br><span class="line">      cout&lt;&lt;&quot;create&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">  ~MyString()</span><br><span class="line">  &#123;</span><br><span class="line">    cout&lt;&lt;&quot;delete&quot;&lt;&lt;endl;</span><br><span class="line">    delete[] _data;</span><br><span class="line">  &#125;</span><br><span class="line">  MyString(MyString&amp;&amp; other)//移动构造函数</span><br><span class="line">  &#123;</span><br><span class="line">    this-&gt;_data=other._data;</span><br><span class="line">    other._data=nullptr;</span><br><span class="line">    cout&lt;&lt;&quot;move constructor&quot;&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  MyString str(&quot;hello&quot;);</span><br><span class="line">  MyString str2(move(str));</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">create</span><br><span class="line">move constructor</span><br><span class="line">delete</span><br><span class="line">delete</span><br></pre></td></tr></table></figure><h3 id="2-单例类"><a href="#2-单例类" class="headerlink" title="2.单例类"></a>2.单例类</h3><p><strong>单例类：</strong>使用私有构造函数、私有赋值运算符和静态实例成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class President &#123;</span><br><span class="line">private:</span><br><span class="line">    President() &#123;&#125;; // 私有的默认构造函数，防止直接创建对象</span><br><span class="line">    President(const President&amp;); // 私有的复制构造函数，阻止复制对象</span><br><span class="line">    const President&amp; operator=(const President&amp;); // 私有的赋值运算符重载，阻止赋值操作</span><br><span class="line"></span><br><span class="line">    string name; // 存储总统名字的私有成员变量</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static President&amp; GetInstance() // 获取唯一的总统实例的静态成员函数</span><br><span class="line">    &#123;</span><br><span class="line">        // 使用静态局部变量确保只有一个实例会被创建</span><br><span class="line">        static President onlyInstance;</span><br><span class="line">        return onlyInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string GetName() // 获取总统名字的公有成员函数</span><br><span class="line">    &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void SetName(string InputName) // 设置总统名字的公有成员函数</span><br><span class="line">    &#123;</span><br><span class="line">        name = InputName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    President&amp; onlyPresident = President::GetInstance(); // 获取唯一的总统实例并引用它</span><br><span class="line">    onlyPresident.SetName(&quot;Abraham Lincoln&quot;); // 设置总统的名字为 &quot;Abraham Lincoln&quot;</span><br><span class="line">    // 下面的注释代码演示了禁止创建多个总统实例的情况</span><br><span class="line">    // President second; // 不能访问构造函数</span><br><span class="line">    // President* third = new President(); // 不能访问构造函数</span><br><span class="line">    // President fourth = onlyPresident; // 不能访问复制构造函数</span><br><span class="line">    // onlyPresident = President::GetInstance(); // 不能访问赋值运算符重载</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;The name of the President is: &quot;;</span><br><span class="line">    cout &lt;&lt; President::GetInstance().GetName() &lt;&lt; endl; // 获取并输出总统的名字</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-关键字-explicit"><a href="#3-关键字-explicit" class="headerlink" title="3.关键字 explicit"></a>3.关键字 explicit</h3><p><strong>关键字 explicit：</strong>避免隐式转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义一个名为 Human 的类</span><br><span class="line">class Human &#123;</span><br><span class="line">private:</span><br><span class="line">    int age; // 私有成员变量，表示人的年龄</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 显式构造函数，阻止隐式类型转换</span><br><span class="line">    explicit Human(int humansAge) : age(humansAge) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 函数，接受一个 Human 类型的参数</span><br><span class="line">void DoSomething(Human person) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Human sent did something&quot; &lt;&lt; endl;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个 Human 对象 kid，设置年龄为 10</span><br><span class="line">    Human kid(10);</span><br><span class="line"></span><br><span class="line">    // 创建另一个 Human 对象 anotherKid，设置年龄为 11</span><br><span class="line">    Human anotherKid = Human(11);</span><br><span class="line"></span><br><span class="line">    // 调用函数，将 kid 对象作为参数传递给它</span><br><span class="line">    DoSomething(kid); // 这是有效的，因为参数的类型是明确的</span><br><span class="line"></span><br><span class="line">    // 下面两行是注释掉的代码，因为它们尝试执行隐式类型转换，会导致编译错误</span><br><span class="line">    // Human anotherKid2 = 11;</span><br><span class="line">    // DoSomething(10);</span><br><span class="line"></span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p><strong>隐式转换：</strong>将提供的整数作为参数发送给这个构造函数，从而创建一个Human 对象。</p><h3 id="4-友元"><a href="#4-友元" class="headerlink" title="4.友元"></a>4.友元</h3><p>使用关键字 <strong>friend</strong>声明友元类或友元函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义一个名为 Human 的类</span><br><span class="line">class Human &#123;</span><br><span class="line">private:</span><br><span class="line">    // 允许 Utility 类成员访问私有成员</span><br><span class="line">    friend class Utility;</span><br><span class="line"></span><br><span class="line">    string name; // 私有成员变量，表示人的姓名</span><br><span class="line">    int age;    // 私有成员变量，表示人的年龄</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 构造函数，接受人的姓名和年龄</span><br><span class="line">    Human(string humansName, int humansAge) &#123;</span><br><span class="line">        name = humansName;</span><br><span class="line">        age = humansAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义一个名为 Utility 的类</span><br><span class="line">class Utility &#123;</span><br><span class="line">public:</span><br><span class="line">    // 静态成员函数，用于显示人的年龄</span><br><span class="line">    static void DisplayAge(const Human&amp; person) &#123;</span><br><span class="line">        cout &lt;&lt; person.age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个 Human 对象 firstMan，初始化姓名为 &quot;Adam&quot; 年龄为 25</span><br><span class="line">    Human firstMan(&quot;Adam&quot;, 25);</span><br><span class="line"></span><br><span class="line">    // 使用友元类 Utility 来访问 private 成员 age</span><br><span class="line">    cout &lt;&lt; &quot;Accessing private member age via friend class: &quot;;</span><br><span class="line">    Utility::DisplayAge(firstMan);</span><br><span class="line"></span><br><span class="line">    return 0; // 程序正常退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-继承"><a href="#5-继承" class="headerlink" title="5.继承"></a>5.继承</h3><p><strong>调用基类中被覆盖的方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class base&#123;</span><br><span class="line">    private:</span><br><span class="line">    public:</span><br><span class="line">        void print()</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;base\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class son:public base&#123;</span><br><span class="line">    private:</span><br><span class="line">    public:</span><br><span class="line">        void print()</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;son\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    son a;</span><br><span class="line">    a.print();</span><br><span class="line">    a.base::print();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">son</span><br><span class="line">base</span><br></pre></td></tr></table></figure><h3 id="6-抽象基类和纯虚函数"><a href="#6-抽象基类和纯虚函数" class="headerlink" title="6.抽象基类和纯虚函数"></a>6.抽象基类和纯虚函数</h3><p><strong>抽象基类：</strong>计用来作为其他派生类的基础，但不能被实例化为对象</p><p><em>注：抽象基类至少包含一个纯虚函数，这些纯虚函数在派生类中必须被实现。</em></p><p><strong>纯虚函数：</strong>在抽象基类中声明的虚函数，但没有提供实际的函数体实现。</p><p><em>注：纯虚函数的声明使用 <code>virtual</code> 关键字，并在函数声明后加上 <code>= 0</code></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    // 纯虚函数，必须在派生类中实现</span><br><span class="line">    virtual double Area() const = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 派生类 Circle</span><br><span class="line">class Circle : public Shape &#123;</span><br><span class="line">private:</span><br><span class="line">    double radius;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Circle(double r) : radius(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 实现了抽象基类中的纯虚函数</span><br><span class="line">    double Area() &#123;</span><br><span class="line">        return 3.14 * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-虚继承"><a href="#7-虚继承" class="headerlink" title="7.虚继承"></a>7.虚继承</h3><p><strong>虚继承：</strong>解决了多继承中可能出现的菱形继承问题以及由此引发的二义性问题。</p><p><strong>菱形继承问题</strong>：菱形继承问题发生在一个派生类从两个不同的基类继承，而这两个基类都继承自同一个共同的基类。派生类会继承两份相同的数据，导致二义性和内存浪费。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class CommonBase &#123;</span><br><span class="line">public:</span><br><span class="line">    int data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Base1 : virtual public CommonBase &#123;</span><br><span class="line">public:</span><br><span class="line">    void setData(int d) &#123;</span><br><span class="line">        data = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Base2 : virtual public CommonBase &#123;</span><br><span class="line">public:</span><br><span class="line">    int getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base1, public Base2 &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    obj.setData(42);</span><br><span class="line">    int result = obj.getData();</span><br><span class="line">    cout &lt;&lt; &quot;Data: &quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-限定符-override"><a href="#8-限定符-override" class="headerlink" title="8.限定符 override"></a>8.限定符 override</h3><p><strong>限定符 override：</strong>用于显式指示派生类中的成员函数是对基类中的虚函数进行重写（覆盖）的，主要作用是提高代码的可读性和可维护性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void MyFunction() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base::MyFunction()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    // 使用 override 明确表示覆盖了基类的虚函数</span><br><span class="line">    void MyFunction() override &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derived::MyFunction()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    Base* ptr = &amp;obj;//一个派生类对象的地址赋给一个基类指针，可以使用该指针来访问基类中定义的成员函数和数据成员。</span><br><span class="line">    ptr-&gt;MyFunction(); // 输出 Derived::MyFunction()</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-final关键字"><a href="#9-final关键字" class="headerlink" title="9.final关键字"></a>9.final关键字</h3><p><strong>修饰类：</strong>表示该类不能被其他类继承。</p><p>示例：<code>class MyFinalClass final &#123; /* 类定义 */ &#125;;</code></p><p><strong>修饰成员函数</strong>：表示该成员函数不能在派生类中被重写。</p><p>示例：<code>virtual void MyFunction() final;</code></p><p><strong>修饰变量</strong>：数值一旦在初始化之后便不能更改。</p><p>示例：<code>final int j = 5;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-复制函数&quot;&gt;&lt;a href=&quot;#1-复制函数&quot; class=&quot;headerlink&quot; title=&quot;1.复制函数&quot;&gt;&lt;/a&gt;1.复制函数&lt;/h3&gt;&lt;h4 id=&quot;1-1-浅复制&quot;&gt;&lt;a href=&quot;#1-1-浅复制&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="C++" scheme="https://wangak.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://wangak.cc/tags/C/"/>
    
  </entry>
  
</feed>
