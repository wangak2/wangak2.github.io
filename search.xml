<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>神经网络</title>
      <link href="/2023/07/16/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/07/16/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><h3 id="1-激活函数"><a href="#1-激活函数" class="headerlink" title="1. 激活函数"></a>1. 激活函数</h3><p>激活函数：作用在于决定如何来激活输入信号的总和。</p><p>如，感知机的数学形式：<img src="/2023/07/16/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/img2.png" alt="img2"></p><p>其亦可表达为：</p><p><img src="/2023/07/16/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/img3.png" alt="img3"></p><p><img src="/2023/07/16/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/img4.png" alt="img4"></p><p>h(x)函数会将输入信号的总和转换为输出信号，即为激活函数。</p><h4 id="1-1-阶跃函数"><a href="#1-1-阶跃函数" class="headerlink" title="1.1 阶跃函数"></a>1.1 阶跃函数</h4><p><strong>激活函数：</strong>以阈值为界，一旦输入超过阈值，就切换输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#当输入超过0时，输出1，否则输出0的阶跃函数</span><br><span class="line">def step_function(x):</span><br><span class="line">  y = x &gt; 0</span><br><span class="line">  return y.astype(np.int)</span><br><span class="line">  #用astype()方法转换NumPy数组的类型</span><br></pre></td></tr></table></figure><p><strong>阶跃函数的图形</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pylab as plt</span><br><span class="line">def step_function(x):</span><br><span class="line"> return np.array(x &gt; 0, dtype=np.int)</span><br><span class="line">x = np.arange(-5.0, 5.0, 0.1)</span><br><span class="line">y = step_function(x)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.ylim(-0.1, 1.1) # 指定y轴的范围</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2023/07/16/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/img5.png" alt="img5" style="zoom:50%;"></p><h4 id="1-2-sigmoid函数"><a href="#1-2-sigmoid函数" class="headerlink" title="1.2 sigmoid函数"></a>1.2 sigmoid函数</h4><p><strong>sigmoid函数:</strong> $h(x)={1 \over 1+e^{-x} }$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def sigmoid(x):</span><br><span class="line"> return 1 / (1 + np.exp(-x))</span><br></pre></td></tr></table></figure><p><strong>sigmoid函数的图形</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(-5.0, 5.0, 0.1)</span><br><span class="line">y = sigmoid(x)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.ylim(-0.1, 1.1) # 指定y轴的范围</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>​                                                                <img src="/2023/07/16/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/img6.png" alt="img6" style="zoom: 50%;">.</p><p><em>注：神经网络的激活函数必须使用非线性函数。使用线性函数时，加深神经网络的层数就没有意义了，因为不管如何加深层数，总是存在与之等效的“无隐藏层的神经网络”。</em></p><h4 id="1-3-tanh函数"><a href="#1-3-tanh函数" class="headerlink" title="1.3 tanh函数"></a>1.3 tanh函数</h4><p><strong>tanh函数：</strong>$\LARGE {e^{x}-e^{-x}\over e^{x}+e^{-x} }$</p><p><img src="/2023/07/16/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/神经网络\img11.png" alt="img11" style="zoom: 50%;"></p><h4 id="1-4-ReLU函数"><a href="#1-4-ReLU函数" class="headerlink" title="1.4 ReLU函数"></a>1.4 ReLU函数</h4><p><strong>ReLU函数</strong>：<img src="/2023/07/16/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/img7.png" alt="img7"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def relu(x):</span><br><span class="line"> return np.maximum(0, x)</span><br></pre></td></tr></table></figure><p><strong>ReLU函数的图形</strong></p><p><img src="/2023/07/16/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/img8.png" alt="img8" style="zoom: 67%;"></p><p><strong>Leaky ReLU函数:</strong>max(0.1x,x)</p><h3 id="2-恒等函数和-softmax函数"><a href="#2-恒等函数和-softmax函数" class="headerlink" title="2 恒等函数和 softmax函数"></a>2 恒等函数和 softmax函数</h3><p><strong>恒等函数：</strong>将输入按原样输出，对于输入的信息，不加以任何改动地直接输出。</p><p><strong>softmax函数：</strong><script type="math/tex">y_k={e^{a_k} \over \sum\limits_{i=1}^ne^{a_i}}</script></p><p>为了防止溢出，可对softmax函数进行如下改进：</p><p><img src="/2023/07/16/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/img10.png" alt="img10"></p><p><em>注：其中，$C^{，}$通常使用输入信号中的最大值，来防止溢出。</em></p><p><img src="/2023/07/16/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/img9.png" alt="img9"></p><p><em>注：1.softmax函数的输出通过箭头与所有的输入信号相连，输出层的各个神经元都受到所有输入信号的影响。</em></p><p>​        <em>2.softmax函数将输出的给类别的得分转换成了概率</em></p><h3 id="3-交叉熵损失"><a href="#3-交叉熵损失" class="headerlink" title="3. 交叉熵损失"></a>3. 交叉熵损失</h3><p><strong>交叉熵损失：</strong>用于比较分类器预测分布与真实分布的距离。</p><p><strong>熵：</strong>H(p)=$-\sum p(x)log(p(x))$</p><p><strong>交叉熵：</strong>H(p,q)=$-\sum p(x)log(q(x))$</p><p><strong>相对熵(KL散度)：</strong>KL(p||q)=$-\sum p(x)log({q(x)\over p(x)})$</p><p><strong>三者之间的关系：</strong>H(p,q)=KL(p||q)+H(p)</p><p>p(x):真实分布概率        q(x):分类器预测分布概率</p><p>注：<strong>1.相对熵(KL散度)用于度量两个分布间的不相似性。</strong></p><p>​        <strong>2.真实分布为one-hot形式时，H(p)=0,用H(p,q)代替KL(p||q),且交叉熵损失可化简为L=$-log(q_j)$,其中j为真实的类别。</strong></p><h3 id="3-参数优化"><a href="#3-参数优化" class="headerlink" title="3. 参数优化"></a>3. 参数优化</h3><p>参数优化：利用损失函数的输出值作为反馈信号来调整分类器的参数。</p><h4 id="3-1-梯度下降算法"><a href="#3-1-梯度下降算法" class="headerlink" title="3.1 梯度下降算法"></a>3.1 梯度下降算法</h4><p>原理：对于最小化优化问题，只需要将参数沿着梯度相反的方向前进一个步长，就可以实现目标函数的下降。</p><p>方向：负梯度方向</p><p>移动：步长(学习率)</p><p><strong>随机梯度下降算法：</strong>每次随机选择一个样本，计算损失并更新梯度。</p><p>缺点：单个样本的训练易受噪声的影响，不是每次迭代都向着整体最优化的方向。</p><p><strong>小批量随机梯度下降：</strong>每次选择m个样本，计算损失并更新梯度。</p><h4 id="3-2-梯度消失与梯度爆炸"><a href="#3-2-梯度消失与梯度爆炸" class="headerlink" title="3.2 梯度消失与梯度爆炸"></a>3.2 梯度消失与梯度爆炸</h4><p><strong>梯度消失：</strong>由于链式法则的乘法性质导致梯度趋向于0。</p><p>注：tanh,sigmoid局部梯度特性不利于网络梯度流的反向传播，尽量选择RelU或Leaky RelU。</p><p><strong>梯度爆炸：</strong>断崖处梯度乘以学习率后是一个非常大得值，从而“飞”出了合理区域，最终导致算法不收敛;</p><p>注：通过限制步长的大小(梯度裁剪)可以避免梯度爆炸。</p><h4 id="3-3-梯度下降算法的问题及改进"><a href="#3-3-梯度下降算法的问题及改进" class="headerlink" title="3.3 梯度下降算法的问题及改进"></a>3.3 梯度下降算法的问题及改进</h4><p><strong>梯度下降算法的问题：</strong>在一个方向上变化迅速而在另一个方向上的变化缓慢，并且通过增大步长不能提高算法的收敛速度。</p><p><strong>动量法：</strong>利用累加历史梯度信息更新梯度。</p><p>步骤：</p><p>1.采样</p><p>2.计算梯度：g</p><p>3.速度更新：v=uv+g(u:动量系数，u=0时为梯度下降算法)</p><p>4.更新权值：w=w-\varepsilonv($\varepsilon$:学习率）</p><p><em>注：梯度下降算法在局部最小点与鞍点处的梯度为0，无法通过，而动量法由于动量的存在可以通过，可以找到更优的解）</em></p><p><strong>自适应梯度算法(AdaGrad)：</strong>减小震荡方向的步长，增大平坦方向的步长。</p><p>步骤：</p><p>1.采样</p><p>2.计算梯度：g</p><p>3.累计平方梯度：r=r+g*g (r : 累计变量)</p><p>4.更新权值：w=w-${\large \varepsilon \over \sqrt{r}+\delta}*g$($\delta$:小常数，通常取$10^{-5}$,用于防止除0出错）</p><p><em>注：AdaGrad的一个限制是，随着累计变量的不断增大，导致每个参数的步长(学习率)非常小，这可能会大大减慢搜索进度，并且可能意味着无法找到最优值。</em></p><p><strong>RMSProp：</strong>累计平方梯度：r=$\rho$r+(1-$\rho$)g*g ($\rho$:衰减系数，通常取0.999)</p><p><strong>ADAM:</strong>同时使用动量与自适应梯度的思想</p><p>步骤：</p><p>1.采样</p><p>2.计算梯度：g</p><p>3.累计梯度：v=uv+(1-u)*g(u:动量系数,通常取0.9)</p><p>4.累计平方梯度：r=$\rho$r+(1-$\rho$)g*g </p><p>5.修正偏差：$\large \tilde{v}={v\over 1-u^t}$  ,$\large \tilde{r}={r\over 1-\rho^t}$ (t:迭代系数，该步骤极大缓解了算法初期的冷启动的问题)</p><p>6.更新权值：w=w-${\large \varepsilon \over \sqrt{\tilde{r}}+\delta}*\tilde{v}$</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> 激活函数 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 交叉熵 </tag>
            
            <tag> 参数优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib</title>
      <link href="/2023/07/15/matplotlib/"/>
      <url>/2023/07/15/matplotlib/</url>
      
        <content type="html"><![CDATA[<h3 id="1-plot-函数"><a href="#1-plot-函数" class="headerlink" title="1.plot()函数"></a>1.plot()函数</h3><p><strong>plot()函数会根据列表中的数据尝试绘制出有意义的图形</strong></p><p>参数：<img src="/2023/07/15/matplotlib/img1.png" alt="img1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(-6,6,0.1)</span><br><span class="line">#起点：-6，终点：6，步长：0.1</span><br><span class="line">y1 = np.sin(x)</span><br><span class="line">y2 = np.cos(x)</span><br><span class="line">plt.plot(x,y1)</span><br><span class="line">plt.plot(x,y2)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/matplotlib/img2.png" alt="img2"></p><p><strong>plt的title()方法：</strong>添加图标标题</p><p><strong>xlabel()、ylabel()方法：</strong>为每条轴设置标题、大小等参数</p><p><strong>tick_params()方法：</strong>指定刻度标记的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(-6,6,0.1)#起点：-6，终点：6，步长：0.1</span><br><span class="line">y1 = np.sin(x)</span><br><span class="line">y2 = np.cos(x)</span><br><span class="line">plt.plot(x,y1)</span><br><span class="line">plt.plot(x,y2)</span><br><span class="line">plt.title(&quot;Figure 1&quot;,fontsize = 18,color = &quot;red&quot;)</span><br><span class="line">plt.xlabel(&quot;x value&quot;,fontsize = 14)</span><br><span class="line">plt.ylabel(&quot;y value&quot;,fontsize = 14)</span><br><span class="line">plt.tick_params(axis=&quot;both&quot;,labelsize=10)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/matplotlib/img3.png" alt="img3"></p><h3 id="2-图像的显示和读取"><a href="#2-图像的显示和读取" class="headerlink" title="2.图像的显示和读取"></a>2.图像的显示和读取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = plt.imread(&#x27;lena.png&#x27;)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2023/07/15/matplotlib/img4.png" alt="img4"></p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感知机</title>
      <link href="/2023/07/12/%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
      <url>/2023/07/12/%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h2><h3 id="感知机的概念"><a href="#感知机的概念" class="headerlink" title="感知机的概念"></a>感知机的概念</h3><p>​        感知机是一种线性分类模型，属于判别模型，其使用一个线性方程所对应的超平面，将特征空间分成两部分。</p><p>​        感知机接收多个输入信号，输出一个信号。</p><p><strong>例：有两个输入的感知机：</strong></p><p>x1、x2是输入信号，y是输出信号，w1、w2是权重。图中的○称为“神经元”或者“节点”。输入信号被送往神经元时，会被分别乘以固定的权重（w1x1、w2x2）。神经元会计算传送过来的信号的总和，只有当这个总和超过了某个界限值时，才会输出1。这也称为“神经元被激活”。这里将这个界限值称为阈值，用符号θ表示。</p><p><img src="/2023/07/12/%E6%84%9F%E7%9F%A5%E6%9C%BA/img1.png" alt="img1"></p><p>用数学公式表示为：</p><p><img src="/2023/07/12/%E6%84%9F%E7%9F%A5%E6%9C%BA/img2.png" alt="img2"></p><p><em>注：感知机的多个输入信号都有各自固有的权重，权重越大，对应该权重的信号的重要性就越高</em></p><p><strong>单层感知机的局限性：</strong>单层感知机的局限性就在于它只能表示由一条直线分割的空间。（单层感知机无法分离非线性空间）</p><p><strong>多层感知机：</strong>多层感知机可以表示非线性空间<img src="/2023/07/12/%E6%84%9F%E7%9F%A5%E6%9C%BA/img3.png" alt="img3"></p><h3 id="感知机的损失函数"><a href="#感知机的损失函数" class="headerlink" title="感知机的损失函数"></a>感知机的损失函数</h3><p>感知机的损失函数：误分类点到超平面的距离，即$-{1 \over {||w||}}\sum \limits_{x_i\in M} y_i(w*x_i+b)$,其中M为误分类点的集合</p><p><em>注：对于误分类点，$y_i(wx_i+b)$&lt;0</em></p><h3 id="感知机学习算法的原始形式"><a href="#感知机学习算法的原始形式" class="headerlink" title="感知机学习算法的原始形式"></a>感知机学习算法的原始形式</h3><p>感知机学习算法是误分类驱动的，采用随机梯度下降法，不断地极小化目标函数。</p><p><img src="/2023/07/12/%E6%84%9F%E7%9F%A5%E6%9C%BA/学习步骤.png" alt="感知机算法学习步骤"></p><p><em>注：当一个实例点被误分类时，调整w,b，使分离超平面向误分类点的一侧移动，以减少误分类点距离超平面的距离。</em></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 感知机 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则化</title>
      <link href="/2023/07/12/%E6%AD%A3%E5%88%99%E5%8C%96-1/"/>
      <url>/2023/07/12/%E6%AD%A3%E5%88%99%E5%8C%96-1/</url>
      
        <content type="html"><![CDATA[<h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><h4 id="1-基本公式"><a href="#1-基本公式" class="headerlink" title="1.基本公式"></a>1.基本公式</h4><p><strong>经验风险最小化：</strong>$min{1\over N}\sum\limits_{i=1}^NL(y_i,f(x_i))$<br><strong>正则化项：</strong>$\lambda J(f)$</p><p><strong>L1正则化项：</strong>$||w_1||=|w1|+|w2|+…..+|w_n|$<br><strong>L2正则化项：</strong>$||w_2||=\sqrt [2]{w_1^2+w_2^2+…..+w_n^2}$</p><p><strong>结构风险最小化：</strong>$min{1\over N}\sum_{i=1}^{N}L(y_i,f(x_i)+\lambda J(f)$</p><p>注：其中λ 是正则化参数，用来控制正则化项在整体损失函数中的重要程度。较大的 λ 值会增加对模型复杂度的惩罚，从而更强调正则化的效果。</p><h4 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h4><p><strong>过拟合：</strong>模型过于复杂或过度拟合了训练数据的细节和噪声，导致对新数据的泛化能力不佳。</p><p><strong>欠拟合：</strong>无法在训练数据上达到较好的拟合效果，也不能很好地泛化到新数据。</p><p><strong>正则化：</strong>在经验风险的基础上增添了一个正则化项，用来控制模型的复杂度，可以防止过拟合。通过正则化可以选择出经验风险和模型复杂度同时较小的模型。</p><h4 id="3-常见问题："><a href="#3-常见问题：" class="headerlink" title="3.常见问题："></a>3.常见问题：</h4><h5 id="3-1为什么正则化可以防止过拟合？"><a href="#3-1为什么正则化可以防止过拟合？" class="headerlink" title="3.1为什么正则化可以防止过拟合？"></a>3.1为什么正则化可以防止过拟合？</h5><p>答：正则化等价于对模型的复杂度添加约束条件，其具有相同的解空间。</p><h5 id="3-2为什么L1正则化具有稀疏性？"><a href="#3-2为什么L1正则化具有稀疏性？" class="headerlink" title="3.2为什么L1正则化具有稀疏性？"></a>3.2为什么L1正则化具有稀疏性？</h5><p>答：在最小化损失函数时，L1正则化项会与损失函数一起构成优化问题。从解空间形状的角度分析，，另外，L1正则化在参数空间中形成了一个尖锐的角，使得优化算法更有可能选择参数为零的解（即L1正则化图像与损失函数的等值线的交点更可能位于坐标轴上）。</p><p><img src="/2023/07/12/%E6%AD%A3%E5%88%99%E5%8C%96-1/image-20230710170542545.png" alt="image-20230710170542545"></p><p>从贝叶斯的观点，所有的正则化都是来自于对参数分布的先验，Laplace先验会导出L1正则化，Gauss先验会导出L2正则化，而Laplace分布取零值的概率较大，所以参数取零值的概率较大，因而L1正则化具有稀疏性。</p><h5 id="3-3推导L1先验分布是Laplace分布"><a href="#3-3推导L1先验分布是Laplace分布" class="headerlink" title="3.3推导L1先验分布是Laplace分布"></a>3.3推导L1先验分布是Laplace分布</h5><p>后验概率：$P(\theta|D)={P(D|\theta)*P(\theta)} \over P(D) $</p><p>要使后验概率最大，即使$P(D|\theta)*P(\theta)$最大</p><p>取log加负号后求其最小值：</p><script type="math/tex; mode=display">-log(P(D|\theta))-log(P(\theta))</script><p>其等价于求$-\sum\limits_{i=1}^NlogP(x_i|\theta)-log(P(\theta))$的最小值</p><p>假设$P(\theta)$满足拉普拉斯分布：</p><script type="math/tex; mode=display">P(\theta)={1 \over {2\lambda}}e^{-|\theta|\over \lambda}</script><p>代入$P(\theta)$后，即求$-\sum\limits_{i=1}^NlogP(x_i|\theta)-log({1 \over {2\lambda}})+{1 \over \lambda}|\theta|$</p><p>其相当于L1正则</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 正则化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy基础</title>
      <link href="/2023/07/02/numpy%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/07/02/numpy%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h3><h4 id="1-np-random-randn函数"><a href="#1-np-random-randn函数" class="headerlink" title="1.np.random.randn函数"></a>1.np.random.randn函数</h4><p>numpy中rand与randn的区别:</p><p>(1).rand是随机生成值在0-1之间的函数。</p><p>(2).randn是随机生成均值为0，方差为1的正态分布上的数值。</p><p><strong>np.random.randn函数不同个数参数的输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">in: x = np.random.randn(3)</span><br><span class="line">    print(x)#输出1行3列的一维数组</span><br><span class="line">out:array([0.87154087, 0.78316833, 0.97669061])</span><br><span class="line"></span><br><span class="line">in: x = np.random.randn(4,3)</span><br><span class="line">    print(x)#输出4行3列的二维数组</span><br><span class="line">out:[[ 0.81536654 -0.06119516  0.23273782]</span><br><span class="line">     [-1.3096832   0.11305955 -0.43735283]</span><br><span class="line">     [-1.68680386 -0.08597495 -1.20287298]</span><br><span class="line">     [-0.30945828 -0.50162275  0.41018841]]</span><br><span class="line">     </span><br><span class="line">in: x = np.random.randn(4,3,2)</span><br><span class="line">    print(x)#输出4个小矩阵，每个小矩阵都是3行2列</span><br><span class="line">out:[[[-0.24571791 -0.51039714]</span><br><span class="line">      [ 0.88810165 -0.94045245]</span><br><span class="line">      [-0.37231775  1.33880112]]</span><br><span class="line"></span><br><span class="line">     [[ 0.09029384 -0.76451493]</span><br><span class="line">      [ 1.25793366  1.04770133]</span><br><span class="line">      [ 0.92711157  1.07891784]]</span><br><span class="line"></span><br><span class="line">     [[ 1.10773856 -0.0084584 ]</span><br><span class="line">      [-0.31300087 -0.80121054]</span><br><span class="line">      [ 0.15738774 -1.12602141]]</span><br><span class="line"></span><br><span class="line">     [[ 0.54273696  1.2454806 ]</span><br><span class="line">      [-0.80644804 -1.00282505]</span><br><span class="line">      [ 0.70669598 -0.45169629]]]</span><br><span class="line">   </span><br><span class="line">#其他情况以此类推</span><br></pre></td></tr></table></figure><h4 id="2-ndarray的创建"><a href="#2-ndarray的创建" class="headerlink" title="2.ndarray的创建"></a>2.ndarray的创建</h4><p>ndarray是一个通用的同构数据多维容器，其中的所有元素必须是相同类型的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">in :data1 = [6, 7.5, 8, 0, 1]</span><br><span class="line">    arr1 = np.array(data1)</span><br><span class="line">    print(arr1)</span><br><span class="line">out:array([6. , 7.5, 8. , 0. , 1. ])#np.array会尝试为新建的这个数组推断出一个较为合适的数据类型。</span><br><span class="line"></span><br><span class="line">in :data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]</span><br><span class="line">    arr2 = np.array(data2)</span><br><span class="line">    print(arr2)</span><br><span class="line">out:[[1 2 3 4]</span><br><span class="line">     [5 6 7 8]]</span><br><span class="line">in :arr1 = np.array([1, 2, 3], dtype=np.float64)#指定创建的array的元素类型</span><br><span class="line">    print(arr1)</span><br><span class="line">out:[1. 2. 3.]</span><br><span class="line"></span><br><span class="line">in :arr2.ndim  #维度大小</span><br><span class="line">out:2</span><br><span class="line"></span><br><span class="line">in :arr2.shape #数组大小</span><br><span class="line">out:(2, 4)</span><br><span class="line"></span><br><span class="line">in :arr2.dtype #元素类型</span><br><span class="line">out:dtype(&#x27;int32&#x27;) </span><br></pre></td></tr></table></figure><p>zeros和ones分别可以创建指定长度或形状的全0或全1数组。</p><p>empty可以创建一个没有任何具体值的数组，通常它返回的都是一些未初始化的垃圾值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in : np.zeros(10)</span><br><span class="line">out: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])</span><br></pre></td></tr></table></figure><p>通过ndarray的astype方法可以明确地将一个数组从一个dtype转换成另一个dtype：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in :arr = np.array([1, 2, 3, 4, 5])</span><br><span class="line">    float_arr = arr.astype(np.float64)</span><br><span class="line">    float_arr.dtype</span><br><span class="line">out:dtype(&#x27;float64&#x27;)</span><br></pre></td></tr></table></figure><h4 id="3-numpy数组的运算"><a href="#3-numpy数组的运算" class="headerlink" title="3.numpy数组的运算"></a>3.numpy数组的运算</h4><p>大小相等的数组之间的任何算术运算及数组与标量的算术运算都会将运算应用到元素级。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In :arr = np.array([[1., 2., 3.], [4., 5., 6.]])</span><br><span class="line">    arr</span><br><span class="line">Out: </span><br><span class="line">array([[ 1.,  2.,  3.],</span><br><span class="line">       [ 4.,  5.,  6.]])</span><br><span class="line"></span><br><span class="line">In : arr * arr</span><br><span class="line">Out: </span><br><span class="line">array([[  1.,   4.,   9.],</span><br><span class="line">       [ 16.,  25.,  36.]])</span><br></pre></td></tr></table></figure><p><strong>矩阵的乘法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in: A = np.array([[1,2], [3,4]])</span><br><span class="line">    B = np.array([[5,6], [7,8]])</span><br><span class="line">    np.dot(A, B)#进行矩阵A与矩阵B的乘法运算</span><br><span class="line">out:</span><br><span class="line">array([[19, 22],</span><br><span class="line">       [43, 50]])</span><br></pre></td></tr></table></figure><h4 id="4-ndarray的切片"><a href="#4-ndarray的切片" class="headerlink" title="4.ndarray的切片"></a>4.ndarray的切片</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">in :arr2d</span><br><span class="line">out:</span><br><span class="line">array([[1, 2, 3],</span><br><span class="line">       [4, 5, 6],</span><br><span class="line">       [7, 8, 9]])</span><br><span class="line">in :arr2d[:2, 1:]</span><br><span class="line">out:</span><br><span class="line">array([[2, 3],</span><br><span class="line">       [5, 6]])</span><br></pre></td></tr></table></figure><h4 id="5-广播"><a href="#5-广播" class="headerlink" title="5.广播"></a>5.广播</h4><p>NumPy中，形状不同的数组之间也可以进行运算。</p><p><img src="/2023/07/02/numpy%E5%9F%BA%E7%A1%80/img1.png" alt="img1"></p><p><img src="/2023/07/02/numpy%E5%9F%BA%E7%A1%80/img2.png" alt="img2"></p><h4 id="6-np-arange-用法"><a href="#6-np-arange-用法" class="headerlink" title="6.np.arange()用法"></a>6.np.arange()用法</h4><p><strong>一个参数时：</strong></p><h5 id="（1）参数值为终点"><a href="#（1）参数值为终点" class="headerlink" title="（1）参数值为终点"></a>（1）参数值为终点</h5><h5 id="（2）起点取默认值0"><a href="#（2）起点取默认值0" class="headerlink" title="（2）起点取默认值0"></a>（2）起点取默认值0</h5><h5 id="（3）步长取默认值1"><a href="#（3）步长取默认值1" class="headerlink" title="（3）步长取默认值1"></a>（3）步长取默认值1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in ：</span><br><span class="line">import numpy </span><br><span class="line">print(numpy.arange(6)) #从0到5,不包括6</span><br><span class="line">out:</span><br><span class="line">[0 1 2 3 4 5]</span><br></pre></td></tr></table></figure><p><strong>两个参数时：</strong></p><h5 id="（1）第一个参数为起点"><a href="#（1）第一个参数为起点" class="headerlink" title="（1）第一个参数为起点"></a>（1）第一个参数为起点</h5><h5 id="（2）第二个参数为终点（不包括）"><a href="#（2）第二个参数为终点（不包括）" class="headerlink" title="（2）第二个参数为终点（不包括）"></a>（2）第二个参数为终点（不包括）</h5><h5 id="（3）步长取默认值1-1"><a href="#（3）步长取默认值1-1" class="headerlink" title="（3）步长取默认值1"></a>（3）步长取默认值1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in: print(numpy.arange(6, 10)) #[6,9)</span><br><span class="line">out:[6 7 8 9]</span><br></pre></td></tr></table></figure><p><strong>三个参数时：</strong></p><h5 id="（1）第一个参数为起点-1"><a href="#（1）第一个参数为起点-1" class="headerlink" title="（1）第一个参数为起点"></a>（1）第一个参数为起点</h5><h5 id="（2）第二个参数为终点（不包括）-1"><a href="#（2）第二个参数为终点（不包括）-1" class="headerlink" title="（2）第二个参数为终点（不包括）"></a>（2）第二个参数为终点（不包括）</h5><h5 id="（3）第三个参数为步长"><a href="#（3）第三个参数为步长" class="headerlink" title="（3）第三个参数为步长"></a>（3）第三个参数为步长</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in: print(np.arange(6,20,1.5))  #步长支持小数</span><br><span class="line">out:</span><br><span class="line">[ 6.   7.5  9.  10.5 12.  13.5 15.  16.5 18.  19.5]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> numpy </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础（2）</title>
      <link href="/2023/07/01/python%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/"/>
      <url>/2023/07/01/python%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h3><h4 id="1-enumerate函数"><a href="#1-enumerate函数" class="headerlink" title="1.enumerate函数"></a>1.enumerate函数</h4><p>用于返回<code>(i, value)</code>元组序列，可以跟踪当前项的序号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (i,value) in enumerate(tup):</span><br><span class="line">    print(str(i)+&quot;:&quot;+value)</span><br></pre></td></tr></table></figure><h4 id="2-sorted函数"><a href="#2-sorted函数" class="headerlink" title="2.sorted函数"></a>2.sorted函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In : sorted([7, 1, 2, 6, 0, 3, 2])</span><br><span class="line">Out: [0, 1, 2, 2, 3, 6, 7]</span><br><span class="line"></span><br><span class="line">In : sorted(&#x27;horse race&#x27;)#对字符串进行排序</span><br><span class="line">Out: [&#x27; &#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;e&#x27;, &#x27;h&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;r&#x27;, &#x27;s&#x27;]</span><br></pre></td></tr></table></figure><p>sorted()函数与sort()函数不同，会返回一个排序列表，而不改变原有序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">in :tup1=[2,6,8,1]</span><br><span class="line">    tup1.sort()</span><br><span class="line">    print(tup1)</span><br><span class="line">out:[1, 2, 6, 8]</span><br><span class="line"></span><br><span class="line">in :tup1=[2,6,8,1]</span><br><span class="line">    tup2=sorted(tup1)</span><br><span class="line">    print(tup2)</span><br><span class="line">    print(tup1)</span><br><span class="line">out:[1, 2, 6, 8]</span><br><span class="line">    [2, 6, 8, 1]</span><br></pre></td></tr></table></figure><p><strong>sort（）可以接受两个参数sort（key,reverse）</strong></p><p>key接受的函数返回值，表示此元素的权值，sort将按照权值大小进行排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in: x=[8,9,0,7,4,5,1,2,3,6]</span><br><span class="line">    def size(a):</span><br><span class="line">        x=10-int(a)</span><br><span class="line">        return x</span><br><span class="line">    x.sort(key=size)</span><br><span class="line">    print(x)</span><br><span class="line">out:[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br></pre></td></tr></table></figure><p>reverse接受的是一个bool类型的值 (Ture or False),表示是否颠倒排列顺序,一般默认的是False</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in :x=[8,9,0,7,4,5,1,2,3,6]</span><br><span class="line">    x.sort(reverse=True)</span><br><span class="line">    print(x)</span><br><span class="line">out:[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br></pre></td></tr></table></figure><p><strong>sort根据关键字排序</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in :l = [[1,2,3],[2,2,1],[2,1,3]]</span><br><span class="line">    l.sort(key = lambda x: (x[0],-x[1]))</span><br><span class="line">    print(l)</span><br><span class="line">out:[[1, 2, 3], [2, 2, 1], [2, 1, 3]]</span><br></pre></td></tr></table></figure><p><u>注：其中key表示按第几个关键字排序，lambda x:后()中的元素表示了关键字的优先级（由高至低），x[0]表示按第一个关键词的升序排列，-x[1]表示按第二个关键词的降序排列</u></p><h4 id="3-zip函数"><a href="#3-zip函数" class="headerlink" title="3.zip函数"></a>3.zip函数</h4><p><code>zip</code>可以将多个列表、元组或其它序列成对组合成一个元组列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In :tup1=1,2,3</span><br><span class="line">    tup2=&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;</span><br><span class="line">    ziped=zip(tup1,tup2)</span><br><span class="line">    list(ziped)</span><br><span class="line">out:[(1, &#x27;a&#x27;), (2, &#x27;b&#x27;), (3, &#x27;c&#x27;)]</span><br></pre></td></tr></table></figure><p>处理任意多的序列，元素的个数取决于最短的序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In :tup1=1,2,3</span><br><span class="line">    tup2=&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;</span><br><span class="line">    tup3=False,True</span><br><span class="line">    ziped=zip(tup1,tup2,tup3)</span><br><span class="line">    list(ziped)</span><br><span class="line">out:[(1, &#x27;a&#x27;, False), (2, &#x27;b&#x27;, True)]</span><br></pre></td></tr></table></figure><p><strong>（1）zip函数的常见用法：同时迭代多个序列</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in :tup1=1,2,3</span><br><span class="line">    tup2=&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;</span><br><span class="line">    for i,(value1,value2) in enumerate(zip(tup1,tup2)):</span><br><span class="line">         print(&#x27;&#123;0&#125;:&#123;1&#125;,&#123;2&#125;&#x27;.format(i,value1,value2))</span><br><span class="line">out:0:1,a</span><br><span class="line">    1:2,b</span><br><span class="line">    2:3,c</span><br></pre></td></tr></table></figure><p><strong>（2）zip函数的常见用法:解压序列</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in :pitchers = [(&#x27;Nolan&#x27;, &#x27;Ryan&#x27;), (&#x27;Roger&#x27;, &#x27;Clemens&#x27;),(&#x27;Schilling&#x27;, &#x27;Curt&#x27;)]</span><br><span class="line">    first_names, last_names = zip(*pitchers)</span><br><span class="line">    print(first_names)</span><br><span class="line">    print(last_names)</span><br><span class="line">out:(&#x27;Nolan&#x27;, &#x27;Roger&#x27;, &#x27;Schilling&#x27;)</span><br><span class="line">    (&#x27;Ryan&#x27;, &#x27;Clemens&#x27;, &#x27;Curt&#x27;)</span><br></pre></td></tr></table></figure><h4 id="4-reversed函数"><a href="#4-reversed函数" class="headerlink" title="4.reversed函数"></a>4.reversed函数</h4><p>用于从后向前迭代序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in :tup = tuple(&#x27;string&#x27;)</span><br><span class="line">    for (i,value) in enumerate(reversed(tup)):#从后向前迭代元组</span><br><span class="line">        print(str(i)+&quot;:&quot;+value,end=&#x27; &#x27;)</span><br><span class="line">out:0:g 1:n 2:i 3:r 4:t 5:s </span><br></pre></td></tr></table></figure><h4 id="5-匿名（lambda）函数"><a href="#5-匿名（lambda）函数" class="headerlink" title="5.匿名（lambda）函数"></a>5.匿名（lambda）函数</h4><p>由单条语句组成，该语句的结果就是返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">in :def apply_to_list(some_list, f):</span><br><span class="line">        return [f(x) for x in some_list]</span><br><span class="line"></span><br><span class="line">    ints = [4, 0, 1, 5, 6]</span><br><span class="line">    apply_to_list(ints, lambda x: x * 2)#&#x27;:&#x27;前为参数,&#x27;:&#x27;后为运算表达式</span><br><span class="line">out:[8, 0, 2, 10, 12]</span><br><span class="line"></span><br><span class="line">in :strings = [&#x27;foo&#x27;, &#x27;card&#x27;, &#x27;bar&#x27;, &#x27;aaaa&#x27;, &#x27;abab&#x27;]</span><br><span class="line">    strings.sort(key=lambda x: len(set(list(x))))#根据不同字母的数量，对strings排序</span><br><span class="line">    print(strings)</span><br><span class="line">out:[&#x27;aaaa&#x27;, &#x27;foo&#x27;, &#x27;abab&#x27;, &#x27;bar&#x27;, &#x27;card&#x27;]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础（1）</title>
      <link href="/2023/06/26/python%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/"/>
      <url>/2023/06/26/python%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h3><h4 id="1-字符串输入：使用input-函数"><a href="#1-字符串输入：使用input-函数" class="headerlink" title="1.字符串输入：使用input()函数"></a>1.字符串输入：使用input()函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x=input()</span><br><span class="line">y=input()</span><br><span class="line">print(x+y)</span><br><span class="line">#输入：5 4</span><br><span class="line"> 输出：54(&quot;+&quot;对于字符串进行拼接)</span><br><span class="line"></span><br><span class="line">name=input(&quot;请输入姓名：&quot;)#input()中添加文本对所要输入的信息进行提示</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure><h4 id="2-列表（list"><a href="#2-列表（list" class="headerlink" title="2.列表（list)"></a>2.列表（list)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span><br><span class="line">print(List)</span><br><span class="line">print(len(List))#获取列表的长度</span><br><span class="line">print(List[-1])#获取列表表尾的元素</span><br><span class="line">print(List[-2])#获取列表倒数第二个元素</span><br><span class="line"></span><br><span class="line">#列表的插入</span><br><span class="line">List.append(&#x27;D&#x27;)#列表尾部插入</span><br><span class="line">List.insert(2,&#x27;F&#x27;)#列表指定位置插入</span><br><span class="line">List.pop()#列表尾部元素删除</span><br><span class="line">List.pop(2)#删除列表指定索引处的元素</span><br><span class="line">print(List)</span><br><span class="line">List.remove(&#x27;A&#x27;)#一次remove()只删除一个，若有多个，要多次使用remove()函数</span><br><span class="line">print(List)</span><br></pre></td></tr></table></figure><h4 id="3-元组-tuple"><a href="#3-元组-tuple" class="headerlink" title="3.元组(tuple)"></a>3.元组(tuple)</h4><p>tuple一旦初始化就不能修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tuple=(2,3,4)#定义元组并初始化</span><br><span class="line">print(tuple)</span><br><span class="line">tuple2=(2,)#定义单元组</span><br><span class="line">tuple3=(2)#由于出现歧义，tuple3为2这个数</span><br><span class="line">print(tuple2,tuple3)</span><br></pre></td></tr></table></figure><h4 id="4-for-…-in…-循环：可以用于遍历元组或列表"><a href="#4-for-…-in…-循环：可以用于遍历元组或列表" class="headerlink" title="4.for ….in….循环：可以用于遍历元组或列表"></a>4.for ….in….循环：可以用于遍历元组或列表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span><br><span class="line">for i in List:#遍历列表</span><br><span class="line">    print(i)</span><br><span class="line">print(list(range(5)))#range(5)生成一个从0开始小于5的整数序列</span><br><span class="line">                     #list()将这个整数序列转换成列表</span><br><span class="line">sum=0</span><br><span class="line">for i in range(101):#计算从0加到100的值</span><br><span class="line">    sum+=i</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><h4 id="5-字典-dict"><a href="#5-字典-dict" class="headerlink" title="5.字典(dict)"></a>5.字典(dict)</h4><p>使用键-值（key-value）存储，具有极快的查找速度</p><h5 id="字典的创建"><a href="#字典的创建" class="headerlink" title="字典的创建"></a>字典的创建</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dict=&#123;&#x27;A&#x27;:1,&#x27;B&#x27;:2,&#x27;C&#x27;:3&#125;#创建字典</span><br><span class="line">Dict[&#x27;A&#x27;]=4#修改key对应的值</span><br><span class="line">print(&#x27;D&#x27; in Dict)#判断字典key是否存在</span><br><span class="line">Dict.pop(&#x27;A&#x27;)#按key删除 或可用：del Dict[&#x27;A&#x27;]</span><br><span class="line">print(Dict)#注：字典中的key是不可变的对象</span><br><span class="line">Dict[&#x27;D&#x27;]=4#向字典中添加键值对</span><br></pre></td></tr></table></figure><h5 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for key,val in Dict.items():#以键值对的形式遍历字典</span><br><span class="line">    print(key,val)</span><br><span class="line">for key in Dict.keys():#遍历字典的键，其中.keys()可省略</span><br><span class="line">    print(key)</span><br><span class="line">for val in Dict.values():#遍历字典中的值</span><br><span class="line">    print(val)</span><br><span class="line">for key in sorted(Dict.keys()):#在遍历前对字典的键的列表排序</span><br><span class="line">    print(key)</span><br><span class="line">for val in set(Dict.values()):#在遍历前对字典的值的列表去重</span><br><span class="line">    print(val)</span><br></pre></td></tr></table></figure><h4 id="6-集合-set"><a href="#6-集合-set" class="headerlink" title="6.集合(set)"></a>6.集合(set)</h4><p>重复的元素在set中会被自动过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s=set([1,2,2,3,3])#创建一个set，使用list作为输入集合</span><br><span class="line">print(s)#输出&#123;1, 2, 3&#125;，相同的元素被过滤</span><br><span class="line">s.add(4)#向集合中添加元素</span><br><span class="line">s.remove(1)</span><br><span class="line">print(s)#输出&#123;2，3，4&#125;</span><br><span class="line">s2=set([1,2,3])</span><br><span class="line">print(s&amp;s2)#集合取交集</span><br><span class="line">print(s|s2)#集合取并集</span><br></pre></td></tr></table></figure><h4 id="7-字符串（str"><a href="#7-字符串（str" class="headerlink" title="7.字符串（str)"></a>7.字符串（str)</h4><p>str是不可变对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=&#x27;abc&#x27;</span><br><span class="line">print(a.replace(&#x27;a&#x27;,&#x27;A&#x27;))#输出Abc</span><br><span class="line">print(a)#输出abc,不可变对象本身永远是不可变的</span><br></pre></td></tr></table></figure><h4 id="8-函数的默认参数"><a href="#8-函数的默认参数" class="headerlink" title="8.函数的默认参数"></a>8.函数的默认参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def enroll(name, gender, age=6, city=&#x27;Beijing&#x27;):#把年龄和城市设为默认参数</span><br><span class="line">    print(&#x27;name:&#x27;, name)</span><br><span class="line">    print(&#x27;gender:&#x27;, gender)</span><br><span class="line">    print(&#x27;age:&#x27;, age)</span><br><span class="line">    print(&#x27;city:&#x27;, city)</span><br><span class="line"></span><br><span class="line">#只有与默认参数不符的学生才需要提供额外的信息</span><br><span class="line">enroll(&#x27;Bob&#x27;, &#x27;M&#x27;, 7)</span><br><span class="line">enroll(&#x27;Adam&#x27;, &#x27;M&#x27;, city=&#x27;Tianjin&#x27;)#不按顺序提供部分默认参数时，需要把参数名写上</span><br></pre></td></tr></table></figure><h4 id="9-函数的可变参数"><a href="#9-函数的可变参数" class="headerlink" title="9.函数的可变参数"></a>9.函数的可变参数</h4><p>可变参数就是函数传入的参数个数是可变的</p><p><u>注：可变参数通过创建一个元组将传入的参数封装到元组中，即使函数只收到一个值也是如此。</u></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def calc(*numbers):#计算：a*a+b*b+c*c+……</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers:#numbers是元组</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum</span><br><span class="line"></span><br><span class="line">print(calc(1, 2))</span><br><span class="line">nums = [1, 2, 3]</span><br><span class="line">print(calc(*nums))#在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去</span><br></pre></td></tr></table></figure><h4 id="10-函数upper-、title-、lower"><a href="#10-函数upper-、title-、lower" class="headerlink" title="10.函数upper()、title()、lower()"></a>10.函数upper()、title()、lower()</h4><p>upper():全字母大写</p><p>title():首字母大写</p><p>lower():全字母小写</p><p><u>注：以上方法是非永久性改变，不会改变变量的值</u></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cars=[&#x27;audi&#x27;,&#x27;bmw&#x27;,&#x27;subaru&#x27;,&#x27;toyota&#x27;]</span><br><span class="line">for car in cars:</span><br><span class="line">    if car==&#x27;bmw&#x27;:</span><br><span class="line">        print(car.upper())#car为bmw时以大写输出</span><br><span class="line">    else:</span><br><span class="line">        print(car.title())</span><br></pre></td></tr></table></figure><h4 id="11-函数的列表参数"><a href="#11-函数的列表参数" class="headerlink" title="11.函数的列表参数"></a>11.函数的列表参数</h4><p>列表作为参数传给函数，函数可以对列表做出永久性修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def fun(List):</span><br><span class="line">    i=0</span><br><span class="line">    for x in List:</span><br><span class="line">        List[i]=x.lower()</span><br><span class="line">        i+=1</span><br><span class="line">List=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span><br><span class="line">fun(List)</span><br><span class="line">print(List)#输出[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure><p>传入列表的副本，原始列表不做修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def fun(List):</span><br><span class="line">    i=0</span><br><span class="line">    for x in List:</span><br><span class="line">        List[i]=x.lower()</span><br><span class="line">        i+=1</span><br><span class="line">List=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span><br><span class="line">fun(List[:])#切片表示法创建副本</span><br><span class="line">print(List)#输出[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br></pre></td></tr></table></figure><h4 id="12-列表生成式"><a href="#12-列表生成式" class="headerlink" title="12.列表生成式"></a>12.列表生成式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print([x * x for x in range(1, 11) if x % 2 == 0]) #筛选出仅偶数的平方</span><br><span class="line"></span><br><span class="line">print([m + n for m in &#x27;ABC&#x27; for n in &#x27;XYZ&#x27;])#使用两层循环，可以生成全排列</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">print([d for d in os.listdir(&#x27;.&#x27;)])#列出当前目录下的所有文件和目录名</span><br><span class="line"></span><br><span class="line">print([x if x % 2 == 0 else -x for x in range(1, 5)])#生成表达式的if……else……，输出[-1, 2, -3, 4]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
