<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>八股 8.28</title>
      <link href="/posts/c53b1f76.html"/>
      <url>/posts/c53b1f76.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-什么是-Cyber-RT？"><a href="#1-什么是-Cyber-RT？" class="headerlink" title="1.什么是 Cyber RT？"></a>1.什么是 Cyber RT？</h4><ul><li><strong>组件机制（Component对算法模块进行封装）</strong></li><li><p><strong>通信机制（Node节点，Reader/Writer)</strong></p></li><li><p><strong>插件（cyber_recorder/cyber_monitor)</strong></p></li></ul><h4 id="2-MQTT协议"><a href="#2-MQTT协议" class="headerlink" title="2.MQTT协议"></a>2.MQTT协议</h4><ul><li><strong>应用层协议</strong><ul><li><strong>相比与HTTP协议</strong>：<ul><li><strong>轻量级与低开销，适合资源受限的设备，如传感器</strong>（报文头部较小，包含报文类型+服务质量QoS）</li><li><strong>通信模式不同：</strong> MQTT（<strong>长连接</strong>）是<strong>发布/订阅</strong>；HTTP是<strong>请求/响应</strong></li></ul></li><li><strong>发布/订阅模型（Pub/Sub）</strong><ul><li><strong>发布者（Publisher）</strong>：向某主题（Topic）发送消息。</li><li><strong>订阅者（Subscriber）</strong>：订阅某主题，接收相关消息。</li><li><strong>代理（Broker）</strong>：中间人，负责接收、过滤和转发消息。</li></ul></li><li><strong>支持不同服务质量（QoS）等级</strong><ul><li><strong>QoS 0</strong>：消息最多发送一次，发布者发送后不关心是否成功送达。（消息可能丢失）</li><li><strong>QoS 1</strong>：保证消息至少送达一次，但可能重复（可能重复）。</li><li><strong>QoS 2</strong>：确保消息 <strong>不丢失、不重复</strong>，传递“正好一次”（确保不重复也不丢失）。</li></ul></li></ul></li></ul><h4 id="3-发布-订阅与请求-响应的区别"><a href="#3-发布-订阅与请求-响应的区别" class="headerlink" title="3.发布/订阅与请求/响应的区别"></a>3.发布/订阅与请求/响应的区别</h4><ul><li><p><strong>请求/响应： 客户端主动发起请求，服务器接收并返回响应。</strong></p><ul><li><strong>同步性</strong>：请求发出后等待结果，典型例子是 HTTP。</li><li><strong>一对一通信</strong>：请求方和响应方直接通信。</li><li><strong>短连接/无状态</strong>：HTTP <strong>通常</strong>是一次性事务</li></ul></li><li><p><strong>发布/订阅： </strong>消息生产者（Publisher）发布消息到某个“主题”（Topic），消息消费者（Subscriber）只要订阅了该主题，就能收到消息。</p><ul><li><strong>异步性</strong>：发布者不关心谁在接收，订阅者也不直接请求。</li><li><strong>一对多通信</strong>：一个消息可被多个订阅者接收。</li><li><strong>解耦</strong>：发布者与订阅者不直接耦合，通过 <strong>消息中间件/Broker</strong> 转发。</li></ul></li></ul><h4 id="4-MQTT的broker对消息的转发"><a href="#4-MQTT的broker对消息的转发" class="headerlink" title="4.MQTT的broker对消息的转发"></a>4.MQTT的broker对消息的转发</h4><ul><li><strong>存储消息：</strong><ul><li><strong>QoS &gt; 0：</strong> Broker 会临时缓存消息<strong>直到确认完成</strong></li><li><strong>QoS 0：</strong> <strong>立即转发</strong>给匹配的订阅者，不做确认，也不缓存</li></ul></li></ul><p>​    <em>注：若订阅者 QoS &lt; 发布者 QoS，则以 <strong>订阅者 QoS 为准</strong>。</em></p><ul><li><strong>主题匹配：</strong> Broker 维护一个 <strong>订阅表</strong>，记录哪些客户端订阅了哪些主题。</li></ul><h4 id="5-介绍一下cyber-Reader"><a href="#5-介绍一下cyber-Reader" class="headerlink" title="5.介绍一下cyber::Reader"></a>5.介绍一下cyber::Reader</h4><ul><li><p><strong>订阅消息通道： </strong>每个消息在 Cyber RT 中通过 <strong>Channel</strong>传递，Reader 就是某个模块用来<strong>“订阅”消息</strong>的对象。</p></li><li><p><strong>解码消息内容：</strong>底层消息通常用 <strong>Protobuf</strong> 定义格式。Reader 能自动解析收到的二进制流，转成对应的 Protobuf 对象。</p></li><li><p><strong>触发回调：</strong> 当有新消息到来时，Reader 会执行用户注册的回调函数。</p><p><em>注：Reader也提供主动轮询来获取消息的方法。</em></p></li></ul><h4 id="6-时间线为什么要用protobuf定义？"><a href="#6-时间线为什么要用protobuf定义？" class="headerlink" title="6.时间线为什么要用protobuf定义？"></a>6.时间线为什么要用protobuf定义？</h4><ul><li>相比与Json,<strong>解析速度</strong>更快，相比于文本，<strong>不用手写解析器</strong></li><li>可以实现<strong>二进制与文本的无缝切换</strong></li><li>相比于json更加安全，会进行<strong>数据类型检查</strong></li><li><strong>Cyber RT 的消息机制就是基于 Protobuf 的</strong>，统一格式能直接借用已有工具链（Writer/Reader、日志工具等）</li></ul><h4 id="7-RTPS协议"><a href="#7-RTPS协议" class="headerlink" title="7.RTPS协议"></a>7.RTPS协议</h4><p><strong>Cyber RT</strong>借助 RTPS 作为底层消息传输机制来实现<strong>跨进程、跨机器的分布式通信。</strong></p><p><strong>工作流程：</strong></p><ul><li><p><strong>节点启动</strong>：Cyber RT 节点 → 创建 <strong>RTPS Participant</strong>。</p></li><li><p><strong>自动发现</strong>：通过多播广播 → <strong>发现同一 Domain 的其他 Participant</strong>。</p></li><li><p><strong>Endpoint 注册</strong>：Writer 和 Reader 通告自己 → <strong>建立 Topic 映射</strong>。</p></li><li><p><strong>数据传输</strong>：Writer 发送 DATA → Reader 接收 → <strong>可根据 QoS 确保可靠性。</strong></p></li><li><p><strong>心跳与重传</strong>：Writer 周期发送 HEARTBEAT → Reader 若发现丢包，回复 ACKNACK → Writer 重传。</p></li></ul><p><strong>RTPS协议和MQTT协议的区别：RTPS 更适合本地局域网内的实时分布式通信，而 MQTT 更适合跨互联网的轻量级物联网应用。</strong></p><p><img src="/posts/c53b1f76.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20250827235934872.png" alt="image-20250827235934872" style="zoom:67%;"></p><p><strong><em>注：RTPS协议可以通过缓存来实现可靠性：</em></strong></p><ul><li><p><em>Writer 侧缓存 = 便于重传（数据丢包时能重新发）。</em></p></li><li><p><em>Reader 侧缓存 = 防止上层应用消费不及时时丢失数据。</em></p></li></ul><h4 id="8-视频压缩"><a href="#8-视频压缩" class="headerlink" title="8.视频压缩"></a>8.视频压缩</h4><p><strong>压缩的原始数据采用YUV格式：</strong></p><ul><li><p><strong>Y</strong> ：<strong>亮度</strong>（人眼对亮度比颜色更敏感，所以 Y 分量保留较高分辨率）</p></li><li><p><strong>UV：</strong> <strong>色度</strong>（人眼对颜色细节不如亮度敏感，所以 U、V 分量可以降低分辨率（采样），常见的有 <strong>4:2:0、4:2:2、4:4:4</strong>。）</p><p><img src="/posts/c53b1f76.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20250828002736224.png" alt="image-20250828002736224" style="zoom: 67%;"></p></li></ul><p><strong>视频压缩原理：</strong></p><ul><li><strong>空间冗余：</strong>相邻像素之间存在相关性</li><li><strong>时间冗余：</strong>前后帧图像之间存在相关性</li><li><strong>视觉冗余：</strong>人眼对于某些细节不敏感（有损压缩）</li><li><strong>编码冗余：</strong>哈夫曼编码（出现次数多的像素，用少的位数来编码）</li></ul><p><strong>解码顺序：</strong>I、P、B</p><p><strong>显示顺序：</strong>I、B、P</p><p><em>注：B帧位于I帧和P帧之间会延迟编码</em></p><p><strong>GOP:</strong> 两个 I 帧之间的帧数。</p><p><strong>GOP 间隔大（I帧少）的影响</strong></p><ul><li><p><strong>压缩率更高</strong></p><ul><li>I帧体积大，占用码率多。</li><li>减少 I 帧 → 更多 P/B 帧 → 平均码率下降 → 更高压缩比。</li></ul></li><li><p><strong>随机访问不方便</strong></p><ul><li>视频播放器需要从 I 帧开始解码。</li><li>GOP 太长 → 跳转到任意时间点时，必须先找到最近 I 帧 → 延迟增加。</li></ul></li><li><p><strong>误差累积</strong></p><ul><li>P/B 帧是基于前帧预测的。</li><li>GOP 太长 → 预测链条长 → 误差容易累积 → 视频容易出现马赛克或画质下降。</li><li>特别在网络传输丢包时，长 GOP 更容易造成严重图像损坏。</li></ul></li><li><p><strong>GOP 太长 → P/B 帧依赖链长 → 解码延迟大</strong>。</p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202508282323910.png" alt="image-20250828005020163" style="zoom:67%;"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股 8.26</title>
      <link href="/posts/22833271.html"/>
      <url>/posts/22833271.html</url>
      
        <content type="html"><![CDATA[<h2 id="八股-8-26"><a href="#八股-8-26" class="headerlink" title="八股 8.26"></a>八股 8.26</h2><h4 id="1-网络时延"><a href="#1-网络时延" class="headerlink" title="1.网络时延"></a>1.网络时延</h4><ul><li><p><strong>发送时延：</strong>数据包放置到输出链路上所需的时间</p><ul><li>发送时延 = 数据包长度 / 链路带宽</li></ul></li><li><p><strong>传输时延：</strong> 信号在物理媒介上传播所需的时间，比如光纤或电缆</p><ul><li>传输时延 = 两节点间的距离 / 信号传播速度</li></ul></li><li><p><strong>处理时延：</strong>取决于设备的性能和需要进行的处理复杂度。</p></li></ul><h4 id="2-为什么发送多个小的数据包比一次性发送一个大的数据包开销要大？"><a href="#2-为什么发送多个小的数据包比一次性发送一个大的数据包开销要大？" class="headerlink" title="2.为什么发送多个小的数据包比一次性发送一个大的数据包开销要大？"></a>2.为什么发送多个小的数据包比一次性发送一个大的数据包开销要大？</h4><ul><li><strong>头部开销</strong>：每个数据包都需要包含一定的头部信息，用于路由和传输控制等目的。无论数据包的大小如何，这些头部信息都是必需的。</li><li><p><strong>处理时延</strong>：每个数据包到达路由器或交换机时都需要进行处理，包括检查包头信息、决定转发路径等操作。更多的数据包意味着需要处理更多的头部信息，这<strong>增加了设备的处理负担和总体处理时延</strong>。</p></li><li><p><strong>发送时延</strong>：虽然单个小数据包的发送时延较短，但由于存在多次<strong>排队等待</strong>的情况（每次发送一个小数据包都可能需要在输出队列中等待），总的发送时延可能会比发送一个大数据包要长。</p></li></ul><h4 id="3-用户态和内核态"><a href="#3-用户态和内核态" class="headerlink" title="3.用户态和内核态"></a>3.用户态和内核态</h4><p><strong>用户态：</strong>大多数应用程序都在用户态下运行，例如浏览器、文本编辑器等。在用户态下，程序只能访问受限的内存空间，并且<strong>不能直接访问硬件资源。</strong></p><p><strong>内核态：</strong></p><ul><li><strong>管理系统资源</strong>：内核态允许操作系统核心代码管理硬件资源（如CPU、内存、I/O设备等）、文件系统以及进程调度等关键功能。</li><li><strong>提供服务给用户程序</strong>：虽然用户程序在用户态运行，但它们需要通过系统调用进入内核态来请求操作系统提供的服务，比如读写文件、网络通信等。</li><li><strong>处理异常和中断</strong>：当发生硬件中断或者软件异常时，处理器会切换到内核态来处理这些情况。</li></ul><h4 id="4-线程间的通信方式"><a href="#4-线程间的通信方式" class="headerlink" title="4.线程间的通信方式"></a>4.线程间的通信方式</h4><ul><li><p><strong>共享内存 + 同步机制(最基本的方式）</strong></p><ul><li><strong>互斥锁（<code>std::mutex</code>)</strong></li><li><strong>读写锁(<code>std::shared_muetx</code>)</strong></li><li><strong>条件变量(<code>std::condition_variable</code>)</strong></li><li><strong>原子操作(<code>&lt;atomic&gt;</code>)</strong></li></ul></li><li><p><strong>使用<code>queue</code>实现消息传递：</strong><code>std::queue</code>结合互斥锁或条件变量来实现<strong>生产者-消费者模式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#incldue<span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeQueue</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    queue&lt;T&gt; q;</span><br><span class="line">    mutex mtx;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"><span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t);</span><br><span class="line">            cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function">T <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock,[<span class="keyword">this</span>]()&#123;<span class="keyword">return</span> !q.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">           T value=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Future/Promise 模式</strong></p></li><li><strong>事件通知机制：</strong><ul><li><code>condition_variable</code></li><li><code>std::notify_all()</code>/<code>std::notify_one()</code>:唤醒一个或所有等待该条件变量的线程</li></ul></li></ul><h4 id="5-函数指针和指针函数"><a href="#5-函数指针和指针函数" class="headerlink" title="5.函数指针和指针函数"></a>5.函数指针和指针函数</h4><p><strong>指针函数：</strong>返回值是指针的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">10</span>; <span class="comment">// 使用static确保num在函数调用之间保持其值</span></span><br><span class="line">    <span class="keyword">return</span> &amp;num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数指针：</strong>指向函数的指针变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="built_in">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">funcPtr = add;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">funcPtr</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//通过funcPtr调用函数add</span></span><br></pre></td></tr></table></figure><h4 id="6-Qt信号与槽的实现机制"><a href="#6-Qt信号与槽的实现机制" class="headerlink" title="6.Qt信号与槽的实现机制"></a>6.Qt信号与槽的实现机制</h4><p>QT信号与槽的实现机制，是以<strong>观察者模式</strong>实现的。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Signal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> SlotType = std::function&lt;<span class="built_in">void</span>(Args...)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(SlotType slot)</span> </span>&#123;</span><br><span class="line">        connections.<span class="built_in">push_back</span>(slot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">emit</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; conn : connections) &#123;</span><br><span class="line">            <span class="built_in">conn</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;SlotType&gt; connections;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Update called with: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Signal&lt;<span class="type">int</span>, <span class="type">int</span>&gt; signal; <span class="comment">// 支持两个int参数的信号</span></span><br><span class="line">    Observer observer;</span><br><span class="line"></span><br><span class="line">    signal.<span class="built_in">connect</span>([&amp;observer](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        observer.<span class="built_in">update</span>(a, b); <span class="comment">// 自动推导T=int</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    signal.<span class="built_in">emit</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-一个函数如何使其在main函数执行前执行"><a href="#7-一个函数如何使其在main函数执行前执行" class="headerlink" title="7.一个函数如何使其在main函数执行前执行"></a>7.一个函数如何使其在main函数执行前执行</h4><ul><li><p><strong>使用全局对象的构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Initializer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Initializer</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Initializer constructor called before main()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 在这里执行你想做的初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局对象，在 main() 前构造</span></span><br><span class="line">Initializer init;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main() is running&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用函数局部静态变量</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> initialized = []()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Initialization code here (before main)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态变量在 main 之前初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> dummy = (<span class="built_in">initFunction</span>(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main() is running&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-子类和父类的构造函数与析构函数的执行顺序"><a href="#8-子类和父类的构造函数与析构函数的执行顺序" class="headerlink" title="8.子类和父类的构造函数与析构函数的执行顺序"></a>8.子类和父类的构造函数与析构函数的执行顺序</h4><p><strong>构造函数：</strong>先父类，再子类</p><p><strong>析构函数：</strong>先子类，再父类</p><h4 id="9-vector在clear后的内存变化"><a href="#9-vector在clear后的内存变化" class="headerlink" title="9.vector在clear后的内存变化"></a>9.vector在clear后的内存变化</h4><ul><li><p><strong><code>vector.clear()</code>：</strong>移除 <code>vector</code> 中的所有元素</p><ul><li><code>size()</code> 变为 0</li><li><strong>不会释放底层内存（capacity() 不变）</strong></li></ul></li><li><p><strong>如何真正释放内存？</strong></p><ul><li><p><strong>交换空 vector：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt;(vec).swap(vec);</span><br><span class="line">// 或者更明确地写成：</span><br><span class="line">vec = std::vector&lt;int&gt;();</span><br></pre></td></tr></table></figure></li><li><p><strong><code>shrink_to_fit()</code>：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vec.<span class="built_in">clear</span>();</span><br><span class="line">vec.<span class="built_in">shrink_to_fit</span>();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="10-fork的原理"><a href="#10-fork的原理" class="headerlink" title="10.fork的原理"></a>10.fork的原理</h4><ul><li><strong>复制进程</strong>：当程序执行到 <code>fork()</code> 调用时，操作系统会<strong>复制</strong>调用 <code>fork()</code> 的<strong>当前进程的所有信息</strong>来创建一个新的进程。</li><li><strong>返回值</strong>：<code>fork()</code> 在父进程中返回子进程的进程ID（PID），在子进程中返回 0。</li><li><strong>共享与独立</strong>：<ul><li>父进程和子进程拥有独立的地址空间，这意味着它们各自的<strong>数据段、堆和栈是分开的。</strong></li><li><strong>文件描述符默认情况下是在父子进程间共享的</strong>，即如果父进程打开了一些文件，在没有特殊处理的情况下，子进程也会有这些文件的访问权限，可以读写相同的文件位置。</li></ul></li></ul><h4 id="11-bss段和data段存放的是什么？"><a href="#11-bss段和data段存放的是什么？" class="headerlink" title="11.bss段和data段存放的是什么？"></a>11.bss段和data段存放的是什么？</h4><ul><li><strong>BSS:</strong> 存放程序中未初始化的全局变量和静态变量</li><li><strong>代码段: </strong>存储程序的实际机器码，即编译后的二进制指令。这个段通常被多个进程共享，以节省内存。</li><li><strong>初始化数据段: </strong>包含全局变量和静态变量，这些变量在程序开始执行之前已经被赋予了初始值。</li></ul><h4 id="12-unique-ptr如何转移所有权？"><a href="#12-unique-ptr如何转移所有权？" class="headerlink" title="12.unique_ptr如何转移所有权？"></a>12.<code>unique_ptr</code>如何转移所有权？</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr1=std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt; (<span class="number">10</span>);</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2=std::<span class="built_in">move</span>(ptr1);<span class="comment">//转移所有权，ptr1现在为空</span></span><br></pre></td></tr></table></figure><h4 id="13-什么是虚拟内存？为什么需要虚拟内存？"><a href="#13-什么是虚拟内存？为什么需要虚拟内存？" class="headerlink" title="13.什么是虚拟内存？为什么需要虚拟内存？"></a>13.什么是虚拟内存？为什么需要虚拟内存？</h4><p><strong>虚拟内存：</strong>虚拟内存在每一个<strong>进程创建加载</strong>的过程中，会分配一个连续虚拟地址空间，它不是真实存在的，而是通过<strong>映射</strong>与实际地址空间对应，这样就可以使每个进程看起来都有自己<strong>独立的连续地址空间</strong>，并允许程序访问比物理内存 RAM 更大的地址空间，每个程序都可以认为它拥有<strong>足够</strong>的内存来运行。</p><p><strong>使用虚拟内存的主要原因： </strong> <strong>隔离性+可扩展</strong></p><ul><li><strong>内存扩展：</strong> 物理内存（RAM）是有限的，但虚拟内存可以通过<strong>使用硬盘空间模拟额外内存</strong>来“扩展”内存容量。</li><li><p><strong>内存隔离：</strong> 每个进程都有自己的虚拟地址空间，因此一个进程无法直接访问另一个进程的内存。</p><ul><li>安全性（防止恶意或错误访问其他程序的数据）</li><li>系统稳定性（一个程序崩溃不会直接影响其他程序）</li></ul></li><li><p><strong>物理内存管理：</strong></p><ul><li>程序不需要一次性全部加载到内存中</li><li>操作系统只加载当前需要的部分（称为“页”）</li><li>不常用的页面可以被交换到磁盘上（即“换出”），腾出空间给其他更需要的程序使用</li></ul></li><li><p><strong>页面交换：</strong> 当物理内存不足时，操作系统可以将一部分数据从物理内存写入到硬盘的虚拟内存中，这个过程被称为<strong>页面交换</strong>。当需要时，数据可以再次从虚拟内存中加载到物理内存中。这样可以保证系统可以继续运行，尽管物理内存有限。</p><p><em>注：虽然这会导致性能下降（硬盘比内存慢得多），但它能防止程序因内存不足而崩溃。</em></p></li><li><p><strong>内存映射文件：</strong> 虚拟内存还可以用于将文件映射到内存中，这使得文件的读取和写入可以像访问内存一样高效。</p><ul><li>操作系统可以把磁盘上的文件“映射”到虚拟内存中</li><li>程序可以直接像访问内存一样读写文件内容，而不必调用传统的文件I/O函数</li><li>这种方式效率更高，常用于大文件处理、共享库等场景</li></ul></li></ul><h4 id="14-多线程顺序执行控制问题"><a href="#14-多线程顺序执行控制问题" class="headerlink" title="14.多线程顺序执行控制问题"></a>14.多线程顺序执行控制问题</h4><p><strong>问题描述：</strong>有三个线程分别调用 <code>first()</code>、<code>second()</code> 和 <code>third()</code> 方法，要求不管这三个线程的启动顺序如何，<strong>它们的执行顺序必须是：<code>first() -&gt; second() -&gt; third()</code></strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    mutex mtx;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    <span class="type">int</span> turn;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>() :<span class="built_in">turn</span>(<span class="number">1</span>) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> turn == <span class="number">1</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl;</span><br><span class="line">        ++turn;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> turn == <span class="number">2</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl;</span><br><span class="line">        ++turn;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> turn == <span class="number">3</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;third&quot;</span> &lt;&lt; endl;</span><br><span class="line">        ++turn;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入 nums，表示线程启动顺序</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;  <span class="comment">// 示例输入</span></span><br><span class="line"></span><br><span class="line">    vector&lt;thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (num) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            threads.<span class="built_in">emplace_back</span>([&amp;solution]() &#123;</span><br><span class="line">                solution.<span class="built_in">first</span>();</span><br><span class="line">                &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            threads.<span class="built_in">emplace_back</span>([&amp;solution]() &#123;</span><br><span class="line">                solution.<span class="built_in">second</span>();</span><br><span class="line">                &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            threads.<span class="built_in">emplace_back</span>([&amp;solution]() &#123;</span><br><span class="line">                solution.<span class="built_in">third</span>();</span><br><span class="line">                &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Invalid method number: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经2</title>
      <link href="/posts/562448a5.html"/>
      <url>/posts/562448a5.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-ps命令的常见用法"><a href="#1-ps命令的常见用法" class="headerlink" title="1.ps命令的常见用法"></a>1.ps命令的常见用法</h4><ul><li><p><code>ps aux</code></p><p><img src="https://typoraimg.wangak.cc/2023/img/202505151026587.png" alt="image-20250428212923424" style="zoom:50%;"></p></li><li><p><code>ps -eo</code>: 自定义输出格式</p><p><img src="https://typoraimg.wangak.cc/2023/img/202505151026547.png" alt="image-20250428213239620" style="zoom: 67%;"></p></li><li><p><strong>使用<code>ps</code>命令查看某个进程的详细信息：</strong></p><ul><li><p><strong>使用PID:</strong> <code>ps -p &lt;PID&gt; -o pid,ppid,cmd,%cpu,%mem</code></p></li><li><p><strong>通过进程名查找:</strong> <code>ps aux | grep &lt;进程名&gt;</code></p><p><img src="https://typoraimg.wangak.cc/2023/img/202505151026392.png" alt="image-20250428213615139"></p></li></ul></li><li><p><strong>杀死一个进程：</strong></p><ul><li><code>kill -9 + &lt;Pid&gt;</code>: 强制杀死一个进程</li><li><code>pkill &lt;进程名&gt;</code></li></ul></li></ul><h4 id="2-CPU负载高，怎么排查？"><a href="#2-CPU负载高，怎么排查？" class="headerlink" title="2.CPU负载高，怎么排查？"></a>2.CPU负载高，怎么排查？</h4><ul><li>排查高负载是否是<strong>高 CPU 利用率</strong>引起的：<ul><li><strong><code>top</code>或<code>ps aux</code>:</strong>  找到高CPU利用率的进程的Pid。</li><li><strong>检查：</strong>检查该进程是否处于死循环、是否存在计算密集型任务等。</li></ul></li><li><p><strong>如果是低 CPU 利用率，而出现高负载：</strong> 可能是由于IO等待所造成的</p><ul><li>通过top命令查看<strong><code>%wa</code></strong>: <code>%wa</code>表示CPU因为IO操作而空闲的时间占比</li></ul></li><li><p><strong>频繁的上下文切换（进程/线程过多）：</strong> 内核态的时间长，用户态时间短</p><ul><li>通过top命令查看<strong><code>%sys</code></strong>(内核态 CPU 时间，应该会升高)，<strong><code>%user</code></strong>（用户态 CPU 时间，降低）</li></ul><p><em>注：上下文切换：当 CPU 从一个进程（或线程）切换到另一个进程时，需要保存当前任务的上下文（寄存器、内存页表等）并加载新任务的上下文</em></p></li></ul><h4 id="3-对于IO等待造成高负载的问题，应该如何改善？"><a href="#3-对于IO等待造成高负载的问题，应该如何改善？" class="headerlink" title="3.对于IO等待造成高负载的问题，应该如何改善？"></a>3.对于IO等待造成高负载的问题，应该如何改善？</h4><ul><li><strong>减少不必要的I/O操作</strong></li><li><strong>异步I/O</strong>：如果可能，采用异步I/O操作代替同步I/O，让程序在等待I/O完成的同时能够继续执行其他任务。</li><li><strong>批量处理I/O请求</strong>：尽量合并多个小的I/O请求为一个大的请求，这样可以减少I/O调用的开销。<ul><li>对于磁盘I/O来说，磁头移动到特定位置并开始读取数据的过程称为<strong>“寻道”</strong>。这个过程相对较慢。如果以小块的形式请求数据，会导致<strong>更多的寻道操作</strong>，从而降低整体效率。</li><li>在网络通信中，每个单独的数据包都会增加一定的延迟（如传输延迟、排队延迟等）。将多个小的数据包组合成一个大的数据包发送，不仅可以减少总的网络延迟，还能更有效地利用带宽。</li></ul></li><li><strong>使用缓存</strong>：对于频繁访问的数据，可以使用缓存机制来减少直接从磁盘或数据库读取数据的需求。</li><li><strong>更快的存储设备</strong>：考虑使用SSD代替HDD，因为SSD提供更快的数据读写速度。</li></ul><h4 id="4-什么样的场景会造成CPU的利用率高？怎么解决？"><a href="#4-什么样的场景会造成CPU的利用率高？怎么解决？" class="headerlink" title="4.什么样的场景会造成CPU的利用率高？怎么解决？"></a>4.什么样的场景会造成CPU的利用率高？怎么解决？</h4><p><strong>常见高 CPU 利用率场景</strong></p><ul><li><strong>计算密集型任务</strong>： <code>%user</code> 高（用户态 CPU 占用高）-》<strong>多线程/多进程</strong></li><li><strong>死循环、未优化的递归操作</strong>  -》进行算法优化</li><li><strong>中断风暴：</strong> <code>%soft</code> 高（如恶意攻击 SYN Flood） -》 <strong>中断延迟处理机制(调整中断优先级，确保关键中断能够得到及时处理,将非紧急的、耗时的处理任务转移到低优先级的任务或线程中处理)</strong><ul><li><strong>频繁的任务切换</strong></li><li><strong>抢占正常进程执行</strong>：中断具有较高的优先级，它们可以打断正在运行的进程。如果中断频繁发生，正常的用户进程和服务将得不到足够的CPU时间，从而影响系统性能</li></ul></li></ul><h4 id="5-软中断的作用？软中断的类型？"><a href="#5-软中断的作用？软中断的类型？" class="headerlink" title="5.软中断的作用？软中断的类型？"></a>5.软中断的作用？软中断的类型？</h4><p>​    与硬中断不同，软中断<strong>不会直接打断</strong>正在运行的代码，而是在<strong>内核</strong>控制下，在适当的时候被调度执行。软中断主要用于提高系统的响应速度和效率，并且允许<strong>延迟处理某些任务</strong>，从而避免长时间阻塞在中断处理程序中。</p><p>​    <strong>它介于硬件中断（快速但不可并行）和线程（灵活但调度延迟高）之间。</strong></p><p><strong>类型：</strong></p><ul><li><strong>net_tx</strong> 和 <strong>net_rx</strong>：分别表示网络传输（发送）和接收过程中的软中断数量。在网络数据包的发送和接收过程中，为了保证高效的数据处理，会使用软中断来完成部分工作。</li><li><strong>block</strong>：与块设备I/O相关的软中断数量。当有磁盘读写请求时，可能会产生这类软中断。</li><li><p><strong>timer</strong>：定时器相关的软中断数量。</p></li><li><p><strong>hi</strong>：表示由硬中断触发的软中断处理次数。硬中断发生后，可能会触发相应的软中断进行后续处理。</p></li><li><strong>hrtimer</strong>：高精度定时器相关的软中断数量。</li></ul><p><strong>软中断性能指标的作用：</strong></p><p><strong>诊断性能瓶颈</strong>：通过监控这些软中断的数量或消耗的时间，可以帮助识别系统中的性能瓶颈所在。例如，如果发现大量的<code>net_rx</code>软中断，可能意味着网络接收端存在压力，可能是由于网络流量过大或网卡处理能力不足等原因造成的。-》1.<strong>绑定中断到多核</strong>，避免所有 <code>NET_RX</code> 中断集中在单个CPU。2.<strong>限流</strong></p><h4 id="6-netstat的常见用法"><a href="#6-netstat的常见用法" class="headerlink" title="6.netstat的常见用法"></a>6.netstat的常见用法</h4><ul><li><strong>查看所有活动连接：</strong> <code>netstat -a</code></li><li><strong>仅显示TCP连接:</strong> <code>netstat -at</code></li><li><strong>仅显示UDP连接:</strong> <code>netstat -au</code></li><li><strong>查看特定PID的所有TCP连接： </strong><code>netstat -anp | grep &lt;PID&gt; | grep &#39;tcp&#39;</code></li></ul><h4 id="7-TCP三次握手发送方发送SYN，一直收不到ACK-会怎么样？"><a href="#7-TCP三次握手发送方发送SYN，一直收不到ACK-会怎么样？" class="headerlink" title="7.TCP三次握手发送方发送SYN，一直收不到ACK,会怎么样？"></a>7.TCP三次握手发送方发送SYN，一直收不到ACK,会怎么样？</h4><ul><li><p><strong>SYN重传</strong></p><ul><li><strong>首次发送SYN</strong>：客户端发送<code>SYN</code>报文，进入<code>SYN_SENT</code>状态。</li><li><strong>重传规则</strong>：<ul><li><strong>初始超时时间（RTO）</strong>：通常为<code>1秒</code></li><li><strong>指数退避</strong>：每次重传的超时时间翻倍（如1s, 2s, 4s, 8s…）。（防止过多的重传请求导致网络拥塞）</li><li><strong>重传次数</strong>：默认通常为<code>6次</code></li></ul></li></ul></li><li><p><strong>最终放弃连接</strong></p><ul><li>达到最大重传次数后，客户端内核会：<ul><li>关闭连接</li><li>通知应用程序</li></ul></li></ul></li></ul><h4 id="8-Linux能建立的最大的TCP连接数"><a href="#8-Linux能建立的最大的TCP连接数" class="headerlink" title="8.Linux能建立的最大的TCP连接数"></a>8.Linux能建立的最大的TCP连接数</h4><p><strong>理论最大连接数</strong>: </p><ul><li><p>受 <strong>源端口号范围</strong> 限制</p></li><li><p><strong>全局文件描述符限制</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/fs/file-max  <span class="comment"># 内核最大文件句柄数（默认约10%内存）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>由内存决定： </strong>每个 TCP 连接占用约 <strong>3~10KB 内存</strong></p></li></ul><h4 id="9-网络编程中read函数的返回值"><a href="#9-网络编程中read函数的返回值" class="headerlink" title="9.网络编程中read函数的返回值"></a>9.网络编程中read函数的返回值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>返回值:</strong></p><ul><li><strong>正数</strong>：如果返回值是正数，那么它表示实际从套接字读取到的字节数。</li><li><strong>0</strong>：如果返回值为 0，这意味着连接已经被对端正常关闭</li><li><strong>-1</strong>：如果返回值为 -1，则表示发生了错误。具体的错误信息可以通过全局变量 <strong><code>errno</code></strong> 获得。<ul><li><code>EAGAIN</code> ：在非阻塞模式下，当前没有数据可读。</li></ul></li></ul><h4 id="10-CPU处理指令的步骤"><a href="#10-CPU处理指令的步骤" class="headerlink" title="10.CPU处理指令的步骤"></a>10.CPU处理指令的步骤</h4><ul><li><p><strong>取指:</strong></p><ul><li><strong>程序计数器（PC）</strong> 提供下一条要执行指令的地址。</li><li>CPU通过地址总线访问内存，根据PC提供的地址读取指令，并将其加载到<strong>指令寄存器（IR）</strong>中。</li></ul></li><li><p><strong>译码:</strong></p><ul><li>在此阶段，CPU<strong>分析指令</strong>的内容，<strong>确定其类型（例如加法、减法、乘法等）</strong>，以及所需的操作数位置。</li></ul></li><li><p><strong>执行</strong>：</p><ul><li><strong>ALU（算术逻辑单元）</strong>进行数学运算、逻辑比较，或者更新寄存器的内容</li></ul></li><li><p><strong>写回：</strong></p><ul><li>计算得到的结果会被写回到指定的目标寄存器或内存位置。</li></ul></li><li><p><strong>更新PC：</strong></p><ul><li>更新程序计数器（PC）以指向下一个待执行的指令。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/posts/9520183a.html"/>
      <url>/posts/9520183a.html</url>
      
        <content type="html"><![CDATA[<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h4 id="1-Innodb为什么使用自增id作为主键？"><a href="#1-Innodb为什么使用自增id作为主键？" class="headerlink" title="1.Innodb为什么使用自增id作为主键？"></a>1.Innodb为什么使用自增id作为主键？</h4><p><strong>自增 ID 作为主键的优点：</strong></p><p><strong>InnoDB 的数据是以 B+树 结构存储的，数据被组织成一个个页</strong></p><ul><li><strong>不需要频繁调整现有数据的位置：</strong>每次插入新记录时，记录会按照 <strong>顺序</strong> 添加到当前索引节点的后续位置。</li><li><strong>减少页分裂和碎片化的问题：</strong><ul><li><strong>使用自增id作主键：</strong>当一页写满时，新的记录会自动开辟一个新的页来存储，而不会影响现有的页结构。</li><li><strong>非自增主键：</strong> <strong>插入</strong>的主键是<strong>随机的</strong>，插入点可能会落在现有的任意页中，从而可能导致任意的页发生分裂，也容易出现碎片化的问题。</li></ul></li></ul><h4 id="2-MyISAM和InnoDB两种存储引擎在实现-B-树索引方式上的区别"><a href="#2-MyISAM和InnoDB两种存储引擎在实现-B-树索引方式上的区别" class="headerlink" title="2.MyISAM和InnoDB两种存储引擎在实现 B+ 树索引方式上的区别"></a>2.MyISAM和InnoDB两种存储引擎在实现 B+ 树索引方式上的区别</h4><p><strong>MyISAM：</strong></p><ul><li><p>MyISAM使用<strong>非聚簇索引</strong>，索引文件和数据文件是分离的。B+ 树的叶节点存放的是指向<strong>实际数据记录的地址</strong>，而不是数据本身。</p></li><li><p><strong>检索过程</strong>：</p><ul><li>通过 B+ 树搜索算法找到指定 key 的位置。如果该 key 存在，则取出其 data 域中的值，这个值是指向实际数据记录的地址。</li><li>根据这个地址去读取相应的数据记录。</li></ul></li></ul><p><strong>InnoDB：</strong></p><ul><li>InnoDB使用<strong>聚簇索引</strong>，索引文件和数据文件是一起存储的。</li></ul><p><strong><em>注：在MyISAM存储引擎中，主键索引树和二级索引树没有区别，存储的都是数据的地址（不涉及回表）。</em></strong></p><h4 id="3-非聚簇索引和聚簇索引的优缺点"><a href="#3-非聚簇索引和聚簇索引的优缺点" class="headerlink" title="3.非聚簇索引和聚簇索引的优缺点"></a>3.非聚簇索引和聚簇索引的优缺点</h4><p><strong>非聚簇索引：</strong></p><ul><li><strong>优点：</strong><ul><li>一个表中可以建立多个非聚簇索引，且数据的物理存储顺序不受索引的影响，<strong>灵活性</strong>更好</li></ul></li><li><strong>缺点：</strong><ul><li>增加了一次<strong>额外的磁盘I/O</strong> (使用从索引中获得的地址来访问实际的数据页）</li></ul></li></ul><p><strong>聚簇索引：</strong></p><ul><li><p><strong>优点：</strong></p><ul><li><strong>减少了磁盘I/O</strong>操作次数，因为一次索引查找即可定位到所需的数据行。</li><li><strong>范围查询</strong>非常高效，数据行在物理上相邻存放。</li></ul></li><li><p><strong>缺点：</strong></p><ul><li>存在<strong>回表</strong>的问题。</li></ul></li></ul><h4 id="4-Drop、Delete与Truncate的区别"><a href="#4-Drop、Delete与Truncate的区别" class="headerlink" title="4.Drop、Delete与Truncate的区别"></a>4.Drop、Delete与Truncate的区别</h4><ul><li><strong>Drop: </strong>直接删掉表，操作不能回滚</li><li><strong>Delete:</strong> 删除表中数据，可以加where字句，可以通过<code>rollback</code>来撤销删除</li><li><strong>Truncate: </strong>删除表中的所有数据，再插入数据时，自增长id从1开始计数</li></ul><h4 id="5-数据库隔离级别"><a href="#5-数据库隔离级别" class="headerlink" title="5.数据库隔离级别"></a>5.数据库隔离级别</h4><ul><li><strong>未提交读：</strong>存在脏读</li><li><strong>提交读：</strong> 不存在脏读，存在不可重复读</li><li><strong>可重复读：</strong> 不存在不可重复读，存在部分幻读</li><li><strong>串行化：</strong> 不存在幻读</li></ul><h4 id="6-为什么数据库索引通常使用B-树？"><a href="#6-为什么数据库索引通常使用B-树？" class="headerlink" title="6.为什么数据库索引通常使用B+ 树？"></a>6.为什么数据库索引通常使用B+ 树？</h4><ul><li><strong>磁盘I/O次数少：</strong>B+树的非叶子节点只存储关键字，节点中能存储的关键字个数就更多，树的高度就会更小，使用的磁盘I/O次数就会更少。</li><li><strong>查询时间更稳定：</strong>B树每个节点既存储关键字也存储数据，因此离根节点越近的数据查询就越来。而B+树所有数据都存储在叶子节点上，所以找对应数据的时间比较平均。</li><li><strong>更适合范围查询：</strong>B+树的所有叶子节点连成了有序链表，适合整表查询或范围查询。</li></ul><p><strong>注：B+树的范围查询</strong>（如 <code>WHERE id BETWEEN 10 AND 100</code>）<strong>：</strong></p><ul><li><strong>只需找到起始键（10），然后沿着链表遍历即可</strong></li><li><strong>时间复杂度 = O(log N)（查找） + O(M)（遍历）</strong></li></ul><h4 id="7-乐观锁和悲观锁的原理和应用场景？"><a href="#7-乐观锁和悲观锁的原理和应用场景？" class="headerlink" title="7.乐观锁和悲观锁的原理和应用场景？"></a>7.乐观锁和悲观锁的原理和应用场景？</h4><p><strong>悲观锁：</strong></p><ul><li><strong>定义：</strong>操作数据之前先加锁，确保其他事务无法修改数据。</li><li><strong>实现方式： </strong>使用 <code>SELECT ... FOR UPDATE</code> 语句来实现。这条语句会在查询数据时对涉及的数据行加上行级锁，阻止其他事务对该数据进行修改。</li><li><p><strong>应用场景</strong></p><ul><li><strong>高并发写操作</strong>：当多个事务<strong>频繁更新同一份数据</strong>时，适合使用悲观锁，可以避免冲突和数据不一致。</li><li><strong>敏感数据操作</strong>：例如银行账户余额、库存管理等场景，<strong>数据一致性要求非常高</strong>。</li><li><strong>短事务</strong>：由于悲观锁会阻塞其他事务的访问，因此<strong>适合事务处理时间较短</strong>的场景。</li></ul></li><li><p><strong>优缺点</strong></p><ul><li><strong>优点</strong>：保证强一致性，避免并发冲突。</li><li><strong>缺点</strong>：性能较低，容易导致死锁或事务阻塞。</li></ul></li></ul><p><strong>乐观锁：</strong></p><ul><li><p><strong>定义：</strong> 在操作数据时不加锁，仅在最后更新数据时检查数据是否被其他事务修改过。</p></li><li><p><strong>实现方式</strong>：</p><ul><li><strong>版本号</strong>机制：在表中增加一个 <code>version</code> 字段，每次更新数据时都会检查版本号是否匹配。如果版本号不匹配，则说明数据已经被其他事务修改。</li><li><strong>时间戳</strong>机制：类似版本号机制，但使用时间戳字段记录最后一次更新的时间。</li><li><strong>CAS</strong>机制：通过比较<strong>旧值和新值</strong>来判断是否需要更新。</li></ul></li><li><p><strong>应用场景</strong></p><ul><li><strong>低并发写操作</strong>：当数据<strong>更新频率较低</strong>时，适合使用乐观锁，因为它不会阻塞其他事务。</li><li><strong>读多写少的场景</strong>：例如商品详情页展示、用户信息查询等场景，数据<strong>以读为主</strong>，写操作较少。</li></ul></li><li><p><strong>优缺点</strong></p><ul><li><strong>优点</strong>：性能较高，不会阻塞其他事务。</li><li><strong>缺点</strong>：在高并发写操作场景下，可能导致大量更新失败</li></ul></li></ul><h4 id="8-数据库引擎InnoDB与MyISAM的区别"><a href="#8-数据库引擎InnoDB与MyISAM的区别" class="headerlink" title="8.数据库引擎InnoDB与MyISAM的区别"></a>8.数据库引擎InnoDB与MyISAM的区别</h4><p><strong>InnoDB：</strong></p><ul><li><strong>事务支持</strong>：InnoDB是MySQL默认的事务型存储引擎，支持ACID属性（原子性、一致性、隔离性、持久性），适用于需要高数据一致性的应用。它实现了四个标准的隔离级别，默认为可重复读(REPEATABLE READ)。</li><li><strong>并发控制</strong>：在可重复读隔离级别下，通过多版本并发控制(<strong>MVCC</strong>)来防止部分幻读问题，从而提升并发处理能力。</li><li><strong>索引结构</strong>：主索引是聚簇索引，意味着数据直接存储在索引节点</li><li><strong>支持行级锁</strong></li></ul><p><strong>MyISAM：</strong></p><ul><li><strong>MyISAM不支持事务，也不支持行级锁，只能对整张表加锁</strong></li><li><strong>索引是非聚簇索引</strong></li></ul><h4 id="9-介绍一下InnoDB的自适应哈希的作用"><a href="#9-介绍一下InnoDB的自适应哈希的作用" class="headerlink" title="9.介绍一下InnoDB的自适应哈希的作用"></a>9.介绍一下InnoDB的自适应哈希的作用</h4><p><strong>加速查询</strong>：自适应哈希索引的主要目的是加快对数据页的访问速度。当查询可以通过哈希索引直接定位到所需的数据行时，可以大大减少搜索时间，尤其对于频繁访问的数据页。</p><h4 id="10-关系型数据库的范式的作用和局限性"><a href="#10-关系型数据库的范式的作用和局限性" class="headerlink" title="10.关系型数据库的范式的作用和局限性"></a>10.关系型数据库的范式的作用和局限性</h4><p><strong>数据库范式的好处：</strong></p><ul><li><strong>减少数据冗余</strong>：这是应用数据库范式<strong>最主要的目的</strong>。通过<strong>消除重复的数据存储</strong>，可以<strong>节省存储空间</strong>，并且减少了因多处<strong>修改/删除</strong>同一数据而引发的<strong>不一致性</strong>问题。</li></ul><p><strong>数据库范式的局限性：</strong> </p><ul><li><strong>表连接使得SQL效率降低：</strong> 高度规范化的数据库往往需要<strong>更多的表</strong>来存储数据，增加了<strong>表连接的复杂度</strong>，从而会导致SQL效率的降低。</li></ul><h4 id="11-介绍一下常见的范式"><a href="#11-介绍一下常见的范式" class="headerlink" title="11.介绍一下常见的范式"></a>11.介绍一下常见的范式</h4><ul><li><p><strong>第一范式（1NF）</strong>： </p><ul><li>每个<strong>列保持原子特性</strong>，即表中的每一列都应该是单一值而不是集合或者列表。</li><li>不满足第一范式不能称作关系型数据库</li></ul></li><li><p><strong>第二范式（2NF）</strong>： </p><ul><li>非主键字段必须<strong>完全依赖于整个主键</strong>，而不是主键的一部分。</li><li>消除了<strong>部分依赖</strong>关系。</li></ul></li><li><p><strong>第三范式（3NF）</strong>：</p><ul><li>所有列都<strong>直接依赖于主键</strong>，不存在传递依赖。<strong>非主键字段间不能存在依赖关系。</strong></li><li>消除了<strong>传递依赖</strong>关系。</li></ul></li><li><p><strong>BCNF范式</strong> ：</p><ul><li><strong>每个表中只有一个候选键（在一个数据库中每行的值都不相同，则可称为候选键）</strong></li></ul></li></ul><h4 id="12-索引的优点和缺点？"><a href="#12-索引的优点和缺点？" class="headerlink" title="12.索引的优点和缺点？"></a>12.索引的优点和缺点？</h4><p><strong>优点</strong>：提高查询效率</p><p><strong>缺点</strong>：索引并非越多越好，过多的索引会<strong>增加CPU使用率</strong>，并且由于<strong>数据更新</strong>时需要<strong>同步更新索引</strong>，这会导致<strong>额外的磁盘I/O</strong>操作，从而加重CPU负荷</p><h4 id="13-MySql中有哪些日志文件？各有什么作用？"><a href="#13-MySql中有哪些日志文件？各有什么作用？" class="headerlink" title="13.MySql中有哪些日志文件？各有什么作用？"></a>13.MySql中有哪些日志文件？各有什么作用？</h4><ul><li><strong>错误日志</strong></li><li><strong>查询日志：</strong> 客户端连接以及执行的SQL语句</li><li><strong>慢查询日志： </strong>执行时间超过指定阈值（由<code>long_query_time</code>参数定义）的查询</li><li><strong>二进制日志: </strong>包含了对数据库进行更改的所有操作(用于主从复制或数据恢复)</li><li><strong>Redo Log：</strong>（对缓冲池中的数据进行任何修改之前，这些修改首先会被记录到Redo Log中）用于崩溃恢复，当数据库意外关闭时，它能确保已提交但未写入磁盘的数据能够被正确地恢复。</li><li><strong>Undo Log:</strong> 支持事务回滚</li></ul><h4 id="14-SQL的优化方式"><a href="#14-SQL的优化方式" class="headerlink" title="14.SQL的优化方式"></a>14.SQL的优化方式</h4><ul><li><p><strong>避免使用<code>select *</code>:</strong></p><ul><li><code>select *</code>可能会产生大量的回表查询，且会浪费CPU、内存资源，增加网络消耗。</li></ul></li><li><p><strong>连接查询时，以小表作为主表</strong>。</p></li><li><p><strong>为<code>group by</code>的字段添加索引</strong>，B+树会对索引进行排序，可以使分组的性能提升。</p></li><li><p>数据插入应用<strong>批量插入取代循环逐条插入</strong></p></li><li><p><strong>使用<code>limit</code></strong></p></li><li><p><strong><code>limit</code>偏移大如何优化：</strong></p><ul><li><p>使用自增索引定位偏移量</p></li><li><p>使用子查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from table limit 10000,10; </span><br><span class="line">select * from table where (id&gt;=10000) limit 10; </span><br><span class="line">select * from table where id in (select id from table where (user=xxx) limit 10000,10); </span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>用<code>union all</code>代替<code>union</code>:</strong></p><ul><li><p>union all: 不去重</p></li><li><p>union：去重</p></li></ul></li></ul><h4 id="15-数据库瓶颈"><a href="#15-数据库瓶颈" class="headerlink" title="15.数据库瓶颈"></a>15.数据库瓶颈</h4><p>数据库瓶颈：</p><ul><li><p>IO瓶颈：</p><ul><li>磁盘IO</li><li>网络IO</li></ul></li><li><p>CPU瓶颈</p><ul><li>单表数据量过大：水平分表</li><li>SQL问题：建立索引等。</li></ul></li></ul><h4 id="16-数据库分库分表"><a href="#16-数据库分库分表" class="headerlink" title="16.数据库分库分表"></a>16.数据库分库分表</h4><ul><li><p><strong>水平分库：</strong>按照某个字段的哈希或范围规则，将<strong>同一个表的数据</strong>分散到不同的数据库实例中。</p><ul><li><p><strong>特点：</strong></p><ul><li>每个库的结构完全一样</li><li>数据不同，没有交集</li><li>所有库的并集构成完整数据</li></ul></li><li><p><strong>优点</strong>：</p><ul><li>解决单库数据量过大问题</li><li>提高系统整体吞吐量</li><li><strong>分散单库的I/O压力</strong></li></ul></li></ul></li><li><p><strong>水平分表:</strong> 在<strong>同一个数据库内</strong>，将同一个表的数据按某种规则拆分到多个结构相同的表中。</p><ul><li><p><strong>特点</strong>：</p><ul><li>每张表的结构完全相同</li><li>数据不同，没有交集</li><li>所有表的并集是完整数据</li></ul></li><li><p><strong>优点</strong>：</p><ul><li><strong>解决单表数据量过大问题</strong></li><li>提高查询效率</li><li>减少索引大小</li></ul></li></ul></li><li><p><strong>垂直分库:</strong> 按照<strong>业务功能</strong>将不同的表拆分到不同的数据库实例中。</p><ul><li><p><strong>特点</strong>：</p><ul><li>每个库的<strong>表结构不同</strong></li><li>表之间通常没有关联或关联很少</li><li>各库的表集合互不重叠</li></ul></li><li><p><strong>优点</strong>：</p><ul><li>业务解耦，专库专用</li><li>降低单库压力</li><li><strong>便于针对不同业务进行优化</strong></li></ul></li></ul></li><li><p><strong>垂直分表:</strong> 将一个表按字段拆分成多个表，通常<strong>将热点数据和非热点数据分离</strong>。</p><ul><li><strong>特点</strong>：<ul><li>每张表包含原表的部分字段</li><li>通常有一个主表和多个扩展表</li><li>通过主键关联</li></ul></li><li><strong>优点</strong>：<ul><li>减少单表的宽度</li><li><strong>提高热点数据的查询效率(数据库只需加载必要的字段)</strong></li><li>减少I/O操作</li></ul></li></ul></li></ul><p>17.性能分析</p><p><img src="/posts/9520183a.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20250707150354328.png" alt="image-20250707150354328"></p><p><img src="/posts/9520183a.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20250707150251960.png" alt="image-20250707150251960"></p><p><img src="/posts/9520183a.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20250707150319251.png" alt="image-20250707150319251"></p><p><img src="/posts/9520183a.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20250707150633819.png" alt="image-20250707150633819"></p><p><img src="/posts/9520183a.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20250707151522388.png" alt="image-20250707151522388"></p><p><code>show profiles</code>: 查看所有sql语句的执行时间</p><p><img src="/posts/9520183a.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20250707151930753.png" alt="image-20250707151930753"></p><p><img src="/posts/9520183a.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20250707154305111.png" alt="image-20250707154305111"></p><p><img src="/posts/9520183a.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20250707154454914.png" alt="image-20250707154454914"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 八股 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经1</title>
      <link href="/posts/cf2d191f.html"/>
      <url>/posts/cf2d191f.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-单例模式的应用场景？"><a href="#1-单例模式的应用场景？" class="headerlink" title="1.单例模式的应用场景？"></a>1.单例模式的应用场景？</h4><ul><li><strong>日志记录器</strong>：整个应用程序只需要一个日志记录，可以防止被重复创建。</li><li><strong>文件配置初始化类</strong></li></ul><h4 id="2-HTTP协议常见状态码"><a href="#2-HTTP协议常见状态码" class="headerlink" title="2.HTTP协议常见状态码"></a>2.HTTP协议常见状态码</h4><ul><li><p><strong>1xx (信息)：</strong>临时响应 - 已收到请求，正在继续处理。</p></li><li><p><strong>2xx (成功)：</strong>服务器已成功接收并接受请求。</p></li><li><p><strong>3xx (重定向)：</strong>需要采取进一步操作才能完成请求。</p></li><li><p><strong>4xx (客户端错误)：</strong>请求包含错误，无法实现。</p></li><li><p><strong>5xx (服务器错误)：</strong>服务器无法完成请求。</p></li></ul><ul><li><strong>200（成功）</strong> - 服务器成功返回网页</li><li>201（已创建） - 请求成功并且服务器创建了新的资源。</li><li>304（未修改） - 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</li><li><strong>400（错误请求）</strong> - 服务器不理解请求的语法。</li><li><strong>404（未找到）</strong> - 请求的网页不存在</li><li><strong>500（服务器内部错误）</strong> - 服务器遇到错误，无法完成请求。</li><li><strong>503（服务不可用）</strong>- 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</li></ul><h4 id="3-前向声明的作用？"><a href="#3-前向声明的作用？" class="headerlink" title="3.前向声明的作用？"></a>3.前向声明的作用？</h4><p><strong>前向声明主要用于.h文件中，仅告诉编译器某个类的存在，而没有提供类的具体实现</strong>。</p><p><strong>作用：</strong></p><ul><li><p><strong>减少编译依赖，加快编译速度：</strong>当一个头文件中包含另一个类的完整定义时，任何对该头文件的修改都会导致所有依赖该头文件的源文件重新编译。</p></li><li><p><strong>解决循环依赖问题：</strong>不使用前向声明，两个类的头文件中可能出现相互引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;B.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    B* b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    A* a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-TCP-IP五层模型各自常用的物理设备？"><a href="#4-TCP-IP五层模型各自常用的物理设备？" class="headerlink" title="4.TCP/IP五层模型各自常用的物理设备？"></a>4.TCP/IP五层模型各自常用的物理设备？</h4><ul><li><strong>应用层：</strong> 应用层直接面向用户的应用程序，为用户提供各种网络服务。不涉及特定的物理设备。</li><li><strong>传输层：</strong> 提供端到端的通信服务。不涉及特定的物理设备。</li><li><p><strong>网络层：</strong> 网络层负责路由选择及数据包的转发，确保数据可以从源端到达目的端。</p><ul><li><strong>路由器：</strong>根据IP地址进行数据包的转发，从而实现在不同网络之间的通信。</li></ul></li><li><p><strong>数据链路层：</strong> 处理节点间的可靠数据传输，包括错误检测与纠正。</p><ul><li><strong>交换机：</strong>通过MAC地址来转发数据帧</li><li><strong>网桥：</strong> 用于连接两个或更多的局域网段。</li></ul></li><li><p><strong>物理层：</strong> 负责在物理介质上传输原始比特流。</p><ul><li><strong>网线、光纤、中继器、集线器</strong></li></ul></li></ul><h4 id="5-进程间通讯方式，各自的优缺点？"><a href="#5-进程间通讯方式，各自的优缺点？" class="headerlink" title="5.进程间通讯方式，各自的优缺点？"></a>5.进程间通讯方式，各自的优缺点？</h4><ul><li><p><strong>管道</strong></p><ul><li>简单易用，但对于非亲缘关系的进程不适用，且性能受限于I/O操作。</li></ul></li><li><p><strong>消息队列： </strong>为进程提供了<strong>异步通信</strong>的方式，消息可以被发送到队列中，并由<strong>另一个进程按顺序</strong>读取。</p><ul><li>适用于那些需要保证消息传递顺序及可靠性的应用场景。</li></ul></li><li><p><strong>共享内存：</strong> 允许多个进程访问同一块物理内存空间，从而实现高效的数据交换。</p><ul><li><strong>优点：</strong>速度快，适合需要频繁或大量数据传输的情况</li><li><strong>缺点：</strong>需要处理同步问题，避免竞态条件。</li></ul></li><li><p><strong>套接字：</strong>支持本地和网络上的进程间通信。</p></li><li><p><strong>信号：</strong> 用于通知进程发生了特定事件，比如异常终止等，本身不是用来传输复杂数据的。</p></li></ul><h4 id="6-介绍一下匿名管道和命名管道"><a href="#6-介绍一下匿名管道和命名管道" class="headerlink" title="6.介绍一下匿名管道和命名管道"></a>6.介绍一下匿名管道和命名管道</h4><p><strong>匿名管道：</strong></p><ul><li>用于具有亲缘关系的进程之间通信，如<strong>父子进程</strong>。</li><li><strong>仅存在于内存</strong>中，并没有实体文件与之对应。</li><li>匿名管道是<strong>单向的</strong>，意味着数据只能在一个方向上流动。</li></ul><p><strong>命名管道（FIFO)：</strong></p><ul><li><p><strong>使用一个特殊路径来标识，任何知道该路径的进程</strong>都可以打开并使用这个管道进行通信，不论这些进程是否具有亲缘关系。</p></li><li><p>保证了数据按照<strong>先进先出</strong>的原则被读取。</p></li><li><p>命名管道是一个<strong>实际存在的对象</strong>，可以在文件系统中看到它。</p></li><li>相较于匿名管道，<strong>配置和管理更加复杂。</strong></li></ul><h4 id="7-哪些函数不能定义为虚函数"><a href="#7-哪些函数不能定义为虚函数" class="headerlink" title="7.哪些函数不能定义为虚函数"></a>7.哪些函数不能定义为虚函数</h4><ul><li><strong>构造函数</strong></li><li><strong>静态成员函数</strong></li><li><strong>友元函数</strong></li><li><strong>inline内联函数：</strong>inline内联函数是在<strong>编译时被展开</strong>，<strong>虚函数</strong>实在运行时才能<strong>动态绑定</strong>函数。</li></ul><h4 id="8-为什么模板类通常放在头文件中？"><a href="#8-为什么模板类通常放在头文件中？" class="headerlink" title="8.为什么模板类通常放在头文件中？"></a>8.为什么模板类通常放在头文件中？</h4><p><strong>模板实例化</strong>是指编译器基于模板定义和提供的具体类型参数生成具体的类或函数版本的过程。</p><p><strong>普通类的代码在编译阶段生成，模板类的代码在实例化（编译阶段）的阶段生成。</strong></p><p><strong>模板实例化时，编译器需要看到模板的定义，以便生成相应的代码。所以模板类一般在头文件中要有具体的定义。</strong></p><p><strong>分离编译的条件：</strong></p><ul><li><p><strong>模板实现</strong>放在<strong>.cpp</strong>文件中，同时在该文件中给出<strong>所有可能的模板实例化</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyTemplate.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyTemplate.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyTemplate&lt;T&gt;::<span class="built_in">MyTemplate</span>() : <span class="built_in">value</span>(<span class="built_in">T</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> MyTemplate&lt;T&gt;::<span class="built_in">print</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyTemplate</span>&lt;<span class="type">int</span>&gt;;     <span class="comment">// 实例化 MyTemplate&lt;int&gt;</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyTemplate</span>&lt;<span class="type">double</span>&gt;;  <span class="comment">// 实例化 MyTemplate&lt;double&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="9-静态库和动态库的区别"><a href="#9-静态库和动态库的区别" class="headerlink" title="9.静态库和动态库的区别"></a>9.静态库和动态库的区别</h4><p><strong>静态库：</strong></p><ul><li><p><strong>扩展名</strong>：</p><ul><li>在Unix/Linux系统上，以<code>.a</code>为扩展名</li><li>在Windows系统上，以<code>.lib</code>为扩展名。</li></ul></li><li><p><strong>链接时机</strong>：在<strong>编译阶段</strong>，静态库中的代码会被完整地复制到最终生成的可执行文件中</p></li><li><p><strong>优点</strong>：</p><ul><li>编译后的可执行文件<strong>包含了所有需要的库代码</strong>，因此<strong>无需担心依赖</strong>问题。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>由于每个使用该静态库的<strong>应用程序都会包含一份库代码</strong>，这会导致生成的可执行文件体积增大。</li><li>如果静态库更新了，所有依赖它的应用程序都需要重新编译链接。</li></ul></li></ul><p><strong>动态库：</strong></p><ul><li><p><strong>扩展名</strong>：</p><ul><li>在Unix/Linux系统上，以<code>.so</code>作为扩展名。</li><li>在Windows系统上，以<code>.dll</code>作为扩展名。</li></ul></li><li><p><strong>链接时机</strong>：动态库只在程序启动时或者<strong>运行过程</strong>中按需加载。</p></li><li><p><strong>优点</strong>：</p><ul><li><strong>多个程序可以共享同一个动态库实例</strong>，节省内存和磁盘空间。</li><li><strong>方便更新：</strong>库文件更新后，只要接口不变，已有的应用程序无需重新编译即可使用新版本的库。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>程序<strong>运行时需要确保相应的动态库存在，并且版本兼容</strong>，否则可能导致程序无法启动或出现错误。</li><li>相对于静态库，可能会有稍微<strong>复杂</strong>的依赖管理和部署要求。</li></ul></li></ul><h4 id="10-线程池有什么缺点"><a href="#10-线程池有什么缺点" class="headerlink" title="10.线程池有什么缺点"></a>10.线程池有什么缺点</h4><p><strong>线程池中的线程数量配置：</strong></p><ul><li>如果任务量<strong>超过了线程池的最大容量</strong>，额外的任务可能需要等待空闲线程，这可能会导致响应时间增加。</li><li>设置的<strong>线程数过多</strong>，可能会导致系统资源（如内存、CPU）过度消耗，<strong>影响整个系统的性能</strong></li></ul><h4 id="11-RAII"><a href="#11-RAII" class="headerlink" title="11.RAII"></a>11.RAII</h4><p><strong>使用局部对象来管理对象资源。</strong>局部对象是存储在栈上的对象，生命周期由操作系统来管理，不需要人工介入。对象获取即初始化，当不再需要使用即自动释放资源</p><h4 id="12-线程安全"><a href="#12-线程安全" class="headerlink" title="12.线程安全"></a>12.线程安全</h4><ul><li><p><strong>数据竞争</strong>： 互斥锁</p></li><li><p><strong>原子操作：</strong> 原子操作是不可分割的操作，不会被其他线程中断。</p></li><li><p><strong>死锁：</strong> </p><ul><li><p><strong>按顺序加锁</strong>：确保所有线程以相同的顺序获取锁。</p></li><li><p><strong>使用超时机制</strong>：尝试加锁时设置超时时间。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络八股</title>
      <link href="/posts/aa7d05b8.html"/>
      <url>/posts/aa7d05b8.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-什么是负载均衡？如何实现负载均衡？"><a href="#1-什么是负载均衡？如何实现负载均衡？" class="headerlink" title="1.什么是负载均衡？如何实现负载均衡？"></a>1.什么是负载均衡？如何实现负载均衡？</h4><p><strong>负载均衡：</strong>将<strong>工作负载</strong>（如<strong>用户请求</strong>、数据流量等）合理地分配到<strong>多个服务器</strong>，以优化资源利用率、<strong>提高系统性能</strong>、增强系统的可靠性和可用性，<strong>避免单个服务器过载</strong>。</p><ul><li><strong>（硬件/软件）负载均衡器：</strong>根据负载情况/预定的规则，来将请求转发到后端服务器。</li><li><strong>DNS负载均衡：</strong>同<strong>一个域名可以解析为多个 IP 地址</strong>，<strong>DNS 服务器</strong>会根据一定的<strong>策略</strong>（如轮询）<strong>返回不同的 IP</strong><ul><li><strong>分配策略：</strong><ul><li><strong>轮询：</strong> 按顺序依次分配请求到服务器。01</li><li><strong>加权轮询：</strong> 根据服务器的性能设置权重，性能高的服务器分配更多请求。</li><li><strong>最少连接（适合长连接场景）：</strong> 将请求分配给当前连接数最少的服务器。</li><li><strong>哈希算法（适合需要会话保持的场景）：</strong> 根据请求的某些特征（如 IP 地址、会话 ID）进行哈希计算，确保相同特征的请求总是分配到同一台服务器。</li></ul></li></ul></li></ul><h4 id="2-介绍一下ping命令的原理"><a href="#2-介绍一下ping命令的原理" class="headerlink" title="2.介绍一下ping命令的原理"></a>2.介绍一下ping命令的原理</h4><p>ping是用于测试<strong>网络中主机间是否可达</strong>的工具。其基于<strong>ICMP协议</strong>（<strong>网络层</strong>，与I<strong>P协议配合使用</strong>，为IP协议提供了<strong>错误报告和控制机制</strong>）</p><p><strong>ICMP协议：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202504220926465.png" alt="image-20250420142751949" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202504220927151.png" alt="image-20250420142832876" style="zoom:67%;"></p><p><strong>ping命令的过程：</strong></p><ul><li><p><strong>命令发起：</strong> 输入 <code>ping</code> 命令</p></li><li><p><strong>域名解析(DNS)</strong></p></li><li><p><strong>构造 ICMP 请求报文:</strong> <code>ping</code> 命令会构造一个 <strong>ICMP Echo Request</strong> 报文</p><ul><li><p><strong>类型字段：值为 <code>8</code></strong>，表示这是一个 “Echo Request” 报文。</p></li><li><p>标识符和序列号：用于区分不同的请求和响应。</p></li></ul></li><li><p><strong>发送 ICMP 请求: </strong>构造好的 <strong>ICMP 请求报文被封装到 IP 数据包</strong>中，并通过网络发送到目标主机。</p></li><li><p><strong>目标主机接收并响应: </strong>当目标主机接收到 ICMP Echo Request 报文后，会检查报文的有效性。生成一个 <strong>ICMP Echo Reply</strong> 报文作为响应。</p><ul><li><strong>类型字段：值为 <code>0</code></strong>，表示这是一个 “Echo Reply” 报文。</li><li>原始请求中的标识符和序列号会被复制到响应中。</li></ul></li><li><p><strong>计算往返时间</strong></p></li><li><strong>重复发送多个请求，统计结果</strong></li></ul><p><strong>Request Timed Out的原因：</strong></p><ul><li><strong>防火墙限制</strong>：某些服务器可能会配置防火墙规则，禁止 ICMP 流量，导致 <code>ping</code> 无法成功。</li><li><strong>目标不可达</strong>：如果<strong>目标主机不在线</strong>、防火墙阻止了 ICMP 流量，或者网络路径中断，<code>ping</code> 将无法收到回应，显示超时</li></ul><h4 id="3-网络层协议和传输层协议的区别"><a href="#3-网络层协议和传输层协议的区别" class="headerlink" title="3.网络层协议和传输层协议的区别"></a>3.网络层协议和传输层协议的区别</h4><p><strong>传输层协议：</strong>提供端口号，实现的是不同主机上<strong>进程间的通信</strong>。端口号主要用于区分同一台主机上的不同进程。</p><p><strong>网络层协议：</strong>提供IP地址，实现的是不同<strong>主机间的通信</strong>。</p><h4 id="4-HTTPS的原理？"><a href="#4-HTTPS的原理？" class="headerlink" title="4.HTTPS的原理？"></a>4.HTTPS的原理？</h4><ul><li><p><strong>客户端请求：</strong>尝试访问一个 HTTPS 网址时，客户端（浏览器）会发起一个到服务器 <strong>443</strong> 端口（HTTPS 的默认端口）的<strong>连接请求</strong>。</p></li><li><p><strong>服务器响应：</strong> 服务器会向客户端发送其数字证书，证书包含了<strong>公钥</strong>、<strong>服务器信息</strong>（如域名）、<strong>有效期</strong>以及证书颁发者的信息等。</p></li><li><p><strong>客户端解析证书并对其进行验证：</strong></p><ul><li>如果证书<strong>不是可信机构</strong>颁布，或者证书中的域名与实际域名不一致，或者证书<strong>已经过期</strong>，就会向访问者显示一个<strong>警告</strong>，由其选择<strong>是否还要继续通信</strong>。</li><li>如果证书<strong>没有问题</strong>，客户端就会从服务器证书中<strong>取出服务器的公钥</strong>。然后客户端还会生成一个<strong>随机码 KEY</strong>，并使用<strong>公钥将其加密</strong>。</li></ul></li><li><p><strong>客户端发送对称密钥：</strong>客户端把<strong>加密后的随机码 KEY</strong> 发送给服务器，作为后面对称加密的密钥。</p></li><li><p><strong>服务器解密：</strong>服务器在收到随机码 KEY 之后会使用私钥B将其解密。</p></li><li><p><strong>使用对称密钥进行通信：</strong>服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。</p></li></ul><h4 id="5-二层转发的工作原理"><a href="#5-二层转发的工作原理" class="headerlink" title="5.二层转发的工作原理"></a>5.二层转发的工作原理</h4><p><strong>二层转发：</strong>数据链路层进行的数据包转发过程。</p><ul><li><p><strong>学习（维护一个MAC地址表）</strong>：当交换机接收到一个数据帧时，它会检查源MAC地址，并记录下这个地址与接收此帧的端口之间的对应关系。</p></li><li><p><strong>转发/过滤</strong>：一旦建立了MAC地址表，每当交换机收到一个目标为特定MAC地址的数据帧时，它就会查找其MAC地址表，找到对应的出端口并将帧直接转发到那个端口。如果目标MAC地址不在表中，或者帧的目标是一个广播地址，则交换机会将该帧<strong>泛洪</strong>（flooding）至除接收端口外的<strong>所有其他端口</strong>，以确保能够到达目标设备。</p></li><li><strong>老化</strong>：为了适应网络拓扑的变化，交换机会定期更新MAC地址表中的条目。如果一段时间内没有收到来自某个MAC地址的数据帧，交换机会删除相应的条目，以便释放空间给新的条目。</li></ul><h4 id="6-IPv4地址划分"><a href="#6-IPv4地址划分" class="headerlink" title="6.IPv4地址划分"></a>6.IPv4地址划分</h4><p><strong>分类地址：</strong></p><ul><li><strong>A类</strong>：第一个字节表示网络部分，后面三个字节表示主机部分。范围：0.0.0.0 - 127.255.255.255。默认子网掩码：/8或255.0.0.0。</li><li><strong>B类</strong>：前两个字节表示网络部分，后两个字节表示主机部分。范围：128.0.0.0 - 191.255.255.255。默认子网掩码：/16或255.255.0.0。</li><li><strong>C类</strong>：前三字节表示网络部分，最后一个字节表示主机部分。范围：192.0.0.0 - 223.255.255.255。默认子网掩码：/24或255.255.255.0。</li><li><strong>D类</strong>：用于多播（即一对多的通信）。范围：224.0.0.0 - 239.255.255.255。</li><li><strong>E类</strong>：保留用于实验和研究。范围：240.0.0.0 - 255.255.255.255。</li></ul><p><strong>子网掩码的作用</strong>：子网掩码中值为1的部分对应的IP地址位属于网络号，值为0的部分对应的IP地址位属于主机号。</p><h4 id="7-网络层多跳是什么？"><a href="#7-网络层多跳是什么？" class="headerlink" title="7.网络层多跳是什么？"></a>7.网络层多跳是什么？</h4><p><strong>网络层的“多跳”：</strong>是指数据包从源节点到达目的节点的过程中，需要<strong>经过多个中间节点（路由器）进行转发</strong>的过程。每经过一个中间节点即视为一跳，因此当数据包从源地址到目标地址需通过若干个这样的中间节点时，就称为多跳传输。</p><p><strong>IP 地址的分层结构</strong>：路由器根据<strong>目标 IP 地址的网络部分逐步靠近目标</strong>，而不是直接送达。</p><h4 id="8-HTTP2的头部压缩HPACK的工作原理"><a href="#8-HTTP2的头部压缩HPACK的工作原理" class="headerlink" title="8.HTTP2的头部压缩HPACK的工作原理"></a>8.HTTP2的头部压缩HPACK的工作原理</h4><p><strong>静态表：</strong>HPACK 预定义了一个静态表，其中包含了一些<strong>常见的 HTTP 头部字段</strong>及其值（如 <code>:method: GET</code>、<code>:status: 200</code> 等）。如果请求或响应中使用了这些字段，可以直接用静态表中的索引代替，从而减少传输的数据量。</p><p><strong>动态表</strong>：动态表是由客户端和服务器在通信过程中<strong>动态维护的一个共享表</strong>。当一个新的头部字段首次出现时，它会被添加到动态表中，并分配一个唯一的索引值。后续的请求或响应可以使用这个索引来引用该字段，避免重复传输完整字段。</p><p><strong>差量编码</strong>：如果某个头部字段的值发生了变化（例如 Cookie 的内容略有不同），HPACK 只传输发生变化的部分，而不是重新发送整个字段。这种方式进一步减少了数据量。</p><p><strong>霍夫曼编码</strong>：对于未被静态表或动态表覆盖的头部字段，HPACK 使用霍夫曼编码对字段名和字段值进行压缩。霍夫曼编码是一种基于频率的无损压缩算法，能够显著减少字符串的长度。</p><p><strong>在 HTTP/2 中，HPACK 压缩算法会显著减少重复的 <code>Cookie</code> 数据传输：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一次请求：</span><br><span class="line">GET /page1 HTTP/2</span><br><span class="line">:method: GET</span><br><span class="line">:path: /page1</span><br><span class="line">:authority: example.com</span><br><span class="line">cookie: sessionId=abc123; userId=456; theme=dark</span><br><span class="line">第二次请求：</span><br><span class="line">GET /page2 HTTP/2</span><br><span class="line">:method: GET</span><br><span class="line">:path: /page2</span><br><span class="line">:authority: example.com</span><br><span class="line">cookie: 62; theme=light</span><br></pre></td></tr></table></figure><h4 id="9-常见TCP的连接状态有哪些？"><a href="#9-常见TCP的连接状态有哪些？" class="headerlink" title="9.常见TCP的连接状态有哪些？"></a>9.常见TCP的连接状态有哪些？</h4><p><strong>LISTEN：</strong> 服务器端处于等待客户端发起连接请求的状态。</p><p><strong>SYN_SENT：</strong> 客户端socket执行CONNECT连接，发送SYN包，进入此状态。</p><p><strong>SYN_RECV：</strong>服务端收到SYN包并发送服务端SYN包，进入此状态。</p><p><strong>ESTABLISH：</strong>表示连接建立。客户端发送了最后⼀个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</p><p><strong>FIN_WAIT_1：</strong> 主动关闭方（通常是客户端或服务器中的一方）已经发送了FIN（结束）报文段，等待对方的ACK确认或者同时带有ACK的FIN报文。</p><p><strong>FIN_WAIT_2：</strong> 主动关闭方收到了对方的ACK确认，但还在等待对方发送FIN报文来完成关闭过程。</p><p><strong>CLOSE_WAIT</strong>：被动关闭方已经接收到对方的FIN报文，并发送了ACK确认，正在等待应用程序调用close()函数来发出自己的FIN。</p><p><strong>TIME_WAIT：</strong> 主动关闭方在收到对方的FIN报文并发送了ACK确认后进入此状态，主要是为了确保对方有足够的时间收到ACK报文。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式面试</title>
      <link href="/posts/3d262387.html"/>
      <url>/posts/3d262387.html</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式面试"><a href="#设计模式面试" class="headerlink" title="设计模式面试"></a>设计模式面试</h3><h4 id="1-什么是设计模式？为什么要使用设计模式？"><a href="#1-什么是设计模式？为什么要使用设计模式？" class="headerlink" title="1.什么是设计模式？为什么要使用设计模式？"></a>1.什么是设计模式？为什么要使用设计模式？</h4><p>设计模式是一种解决问题的方案。</p><p><strong>为什么要使用设计模式？</strong></p><ul><li><strong>提高代码复用性</strong>：经过验证的解决方案可以直接应用于类似问题</li><li><strong>提高可维护性</strong>：使代码更易于理解和修改</li><li><strong>提高扩展性</strong>：使系统更容易应对变化和增长</li></ul><h4 id="2-设计模式有哪些原则？"><a href="#2-设计模式有哪些原则？" class="headerlink" title="2.设计模式有哪些原则？"></a>2.设计模式有哪些原则？</h4><p><strong>单一职责原则(SRP)</strong>：一个类只应该有一个引起它变化的原因。<strong>一个类只负责一项职责。</strong></p><p><strong>开闭原则（OCP）</strong>：软件中的对象（类、模块、函数等）应该<strong>对扩展开放，对修改关闭。</strong>通过扩展来实现变化，而不是修改现有代码。</p><p><strong>依赖倒置原则（DIP）</strong>：为了保证低耦合</p><ul><li>高层模块不应该依赖低层模块，二者都应该依赖抽象</li><li><strong>抽象不应该依赖细节，细节应该依赖抽象</strong></li></ul><h4 id="3-工厂模式和策略模式的区别？"><a href="#3-工厂模式和策略模式的区别？" class="headerlink" title="3.工厂模式和策略模式的区别？"></a>3.工厂模式和策略模式的区别？</h4><ul><li><p><strong>目的不同：</strong></p><ul><li><strong>工厂模式</strong>的目的是<strong>创建对象</strong>，将对象的创建过程封装起来，使客户端的代码<strong>不需要依赖于</strong>具体类的<strong>实例化逻辑和使用逻辑。</strong></li><li><strong>策略模式</strong>的目的是对于<strong>行为的封装和替换</strong>，使得客户端可以在运行时<strong>动态选择不同的算法。</strong></li></ul></li><li><p><strong>结构不同：</strong></p><ul><li><strong>工厂模式：</strong>抽象产品类+具体产品类</li><li><strong>策略模式</strong>：抽象策略类+具体策略类+上下文类（持有一个 <strong>抽象策略 的引用</strong>，并允许在<strong>运行时动态设置不同的策略</strong>）</li></ul></li></ul><h4 id="4-什么是单例模式的懒汉模式？为什么线程不安全？怎么解决？"><a href="#4-什么是单例模式的懒汉模式？为什么线程不安全？怎么解决？" class="headerlink" title="4.什么是单例模式的懒汉模式？为什么线程不安全？怎么解决？"></a>4.什么是单例模式的懒汉模式？为什么线程不安全？怎么解决？</h4><p><strong>单例模式的懒汉模式：延迟初始化</strong>，即直到第一次使用该实例时才进行实例化。</p><p><strong>为什么线程不安全？</strong></p><p>​    如果两个线程同时调用 <code>getInstance()</code> 方法，获取实例，可能会创建多个实例，从而违反单例模式的原则。</p><p><strong>如何使其线程安全？</strong></p><ul><li><p><strong>使用互斥锁（Mutex）</strong>：可以在 <code>getInstance</code> 方法内部使用互斥锁来保证同一时刻只有一个线程能够执行实例化代码块。但是，这种方法每次获取实例都需要加锁和解锁，影响性能。</p></li><li><p><strong>双重检查锁定（Double-Checked Locking）</strong>：为了减少不必要的同步开销，可以采用双重检查锁定的方法。首先检查是否已经实例化，如果没有，则进行加锁后再检查一次并实例化。</p></li><li><p><strong>使用局部静态变量（C++11及以上标准）</strong>：C++11引入了对局部静态变量的支持，保证了其线程安全性，因此可以通过定义一个局部静态变量来实现懒汉模式下的线程安全单例。<strong>（局部静态变量只有第一次进入作用域时才初始化，且初始化具有原子性）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;  <span class="comment">// 构造函数私有化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance; <span class="comment">// 局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;            <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止赋值操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 八股 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++八股8</title>
      <link href="/posts/44c987f8.html"/>
      <url>/posts/44c987f8.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-类对象的大小由哪些因素决定？"><a href="#1-类对象的大小由哪些因素决定？" class="headerlink" title="1.类对象的大小由哪些因素决定？"></a>1.类对象的大小由哪些因素决定？</h4><ul><li><p><strong>空类或无数据成员类的默认大小</strong>：如果一个类不包含任何数据成员（包括继承来的数据成员），根据C++标准，即使是空类也会被分配<strong>至少1个字节</strong>的空间。这是为了确保每个<strong>对象都有唯一的地址。</strong></p></li><li><p><strong>虚函数的影响（虚函数指针）</strong>：当一个类包含虚函数时，编译器会为该类添加一个指向虚函数表（vtable）的指针，称为vptr。这个指针是每个对象的一部分，因此它增加了对象的大小。指针的大小取决于系统架构（例如，在32位系统上是4字节，在64位系统上是8字节）。</p></li><li><p><strong>虚继承的影响</strong>：当使用虚继承来解决多重继承下的菱形继承问题时，每个对象需要额外的指针来维护到虚基类子对象的引用，这被称为<strong>虚基表指针</strong>（vbptr）。这样的设计避免了基类部分的重复，但同时也增加了每个对象的大小。</p></li><li><p><strong>内存对齐</strong>：类对象的大小计算遵循结构体内存对齐的原则。这意味着编译器会在数据成员之间或者末尾插入填充字节，以满足特定硬件平台上的对齐要求。这种对齐可以提高访问速度，但同时可能增加对象的实际大小。</p></li></ul><p><em>注：<strong>静态数据成员和成员函数不影响</strong>：无论是静态还是非静态成员函数，它们都不会影响类对象的大小。这是因为<strong>成员函数实际上是存储在代码段</strong>中的，所有对象<strong>共享同一份函数代码副本</strong>。同样，静态数据成员属于整个类，而非单个对象，因此它们也不会增加对象的大小。</em></p><h4 id="2-虚基表指针是什么？有什么作用？"><a href="#2-虚基表指针是什么？有什么作用？" class="headerlink" title="2.虚基表指针是什么？有什么作用？"></a>2.虚基表指针是什么？有什么作用？</h4><p><strong>虚基表指针：</strong>编译器会为每个<strong>包含虚基类的类</strong>插入一个虚基表指针<strong>（vbptr）</strong>，该指针<strong>指向一个虚基表（vbtable）</strong>。这个表包含了访问虚基类子对象所需的信息。</p><p><strong>虚基表结构</strong>：</p><ul><li>虚基类子对象相对于当前对象的偏移量</li><li>当前对象相对于虚基表指针的偏移量</li></ul><p><strong>虚基表指针的作用：</strong></p><p>虚基表指针的主要作用是<strong>在虚继承情况下，正确找到共享的虚基类子对象（虚基类子对象相对于当前对象的偏移量）</strong>。</p><h4 id="3-什么是内存对齐？内存对齐有什么作用？"><a href="#3-什么是内存对齐？内存对齐有什么作用？" class="headerlink" title="3.什么是内存对齐？内存对齐有什么作用？"></a>3.什么是内存对齐？内存对齐有什么作用？</h4><p><strong>内存对齐：</strong>要求数据的存储地址必须是某个特定值的整数倍。</p><p><em>eg:</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Example1</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;      <span class="comment">// 1字节（地址0）</span></span><br><span class="line">    <span class="type">int</span> b;       <span class="comment">// 4字节（必须对齐到4，地址4）</span></span><br><span class="line">    <span class="type">double</span> c;    <span class="comment">// 8字节（必须对齐到8，地址8）</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 大小：1 + 3（填充） + 4 + 8 = 16字节</span></span><br></pre></td></tr></table></figure><p><strong>为什么要内存对齐？</strong></p><p>加快<strong>硬件访问效率</strong>，现代CPU通常以<strong>固定大小的块（如4字节、8字节）读取内存</strong>。如果数据未对齐，CPU可能需要多次访问内存才能读取完整数据。</p><h4 id="4-std-move的作用和使用场景？"><a href="#4-std-move的作用和使用场景？" class="headerlink" title="4.std::move的作用和使用场景？"></a>4.std::move的作用和使用场景？</h4><p><code>std::move</code>: 将一个对象转换为<strong>右值引用</strong>，从而启用移动语义。</p><p><strong>使用场景：</strong>如果类实现了<strong>移动构造函数</strong>或<strong>移动赋值运算符</strong>，可以结合 <code>std::move</code> 使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="built_in">int</span>(value)) &#123;&#125;</span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span> data;         <span class="comment">// 释放当前资源</span></span><br><span class="line">            data = other.data;   <span class="comment">// 窃取资源</span></span><br><span class="line">            other.data = <span class="literal">nullptr</span>;<span class="comment">// 将原对象置空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data; <span class="comment">// 释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    MyClass obj2 = std::<span class="built_in">move</span>(obj1); <span class="comment">// 使用 std::move 调用移动构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (obj1.data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;obj1&#x27;s resource has been moved!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj2&#x27;s data: &quot;</span> &lt;&lt; *(obj2.data) &lt;&lt; std::endl; <span class="comment">// 输出 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-std-forward的作用和使用场景？"><a href="#5-std-forward的作用和使用场景？" class="headerlink" title="5.std::forward的作用和使用场景？"></a>5.std::forward的作用和使用场景？</h4><p><strong><code>std::forward</code>:</strong> 主要作用是实现<strong>完美转发</strong>，即将函数模板的参数原封不动地转发给另一个函数，同时保留其值类别（lvalue 或 rvalue）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Lvalue reference&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Rvalue reference&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg)); <span class="comment">// 根据 arg 的值类别转发</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(x);       <span class="comment">// 左值，调用 process(int&amp;)</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">42</span>);      <span class="comment">// 右值，调用 process(int&amp;&amp;)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：<code>T&amp;&amp;</code>是万能引用，既能接收左值又能接收右值。</em></p><h4 id="6-构造函数和析构函数能抛出异常吗？"><a href="#6-构造函数和析构函数能抛出异常吗？" class="headerlink" title="6.构造函数和析构函数能抛出异常吗？"></a>6.构造函数和析构函数能抛出异常吗？</h4><p><strong>构造函数可以抛出异常，但可能会造成内存泄露。</strong></p><ul><li>如果构造函数抛出异常，对象被视为未完全构造，析构函数不会被调用，可能导致资源泄漏。使用智能指针（如 <code>std::unique_ptr</code>）可以有效避免资源泄漏问题。</li></ul><p><strong>析构函数不能、也不应该抛出异常。</strong></p><ul><li>如果析构函数抛出异常，则异常点之后的程序不会被执行，如果析构函数在<strong>异常点之后执行了某些必要的动作比如释放某些资源</strong>，则这些动作不会被执行，会造成诸如<strong>资源泄露</strong>的问题。</li><li>通常<strong>异常发生时</strong>，C++机制会<strong>调用已经构造对象的析构函数</strong>来释放资源，此时如<strong>析构函数本身也抛出异常</strong>，则前一个异常尚未处理，又有新的异常，会造成<strong>程序崩溃</strong>的问题。</li></ul><h4 id="7-左值和右值的区别？"><a href="#7-左值和右值的区别？" class="headerlink" title="7.左值和右值的区别？"></a>7.左值和右值的区别？</h4><p>左值有明确的内存地址、能够被引用和修改。</p><p>右值是指临时的、没有明确的内存地址的对象。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202504171506915.png" alt="image-20250417150545277" style="zoom:67%;"></p><h4 id="8-类中默认构造函数有几个？"><a href="#8-类中默认构造函数有几个？" class="headerlink" title="8.类中默认构造函数有几个？"></a>8.类中默认构造函数有几个？</h4><p><strong>八个：</strong></p><ul><li><strong>默认构造函数</strong></li><li><strong>默认拷贝构造函数</strong></li><li><strong>默认析构函数</strong></li><li><strong>默认拷贝赋值运算符</strong></li><li><strong>默认移动构造函数</strong></li><li><strong>默认移动赋值运算符</strong></li><li><strong>默认取址运算符</strong></li><li><strong>默认取址运算符 <code>const</code> 版本</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试模板</title>
      <link href="/posts/1977b211.html"/>
      <url>/posts/1977b211.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1.自我介绍"></a>1.自我介绍</h4><p>尊敬的面试官，您好。我是东北大学在读硕士研究生XXX。我的技术栈是C++,熟悉windows和linux的C++开发，熟悉网络编程开发和常见的网络协议。</p><p>在实践过程中，我实现过一个高性能RPC框架，让我对分布式系统通信和RPC远程过程调用有了进一步的认识，另外，我也做Linux性能监控项目，基于grpc实现了对服务器上的性能数据采集，并进行监控的过程。</p><p>在校期间，我曾多次获得过校奖学金，参加过蓝桥杯和程序设计天梯赛，并均获得了国家三等奖，这些经历使我具有扎实的算法基础和工程实践能力，所以我认为贵公司的开发岗位要求和我的技术能力是非常契合的。</p><p>最后，非常感谢您给我这次面试机会，谢谢。</p><h4 id="2-1-介绍一下你的项目（分布式Linux性能监控）"><a href="#2-1-介绍一下你的项目（分布式Linux性能监控）" class="headerlink" title="2.1 介绍一下你的项目（分布式Linux性能监控）"></a>2.1 介绍一下你的项目（分布式Linux性能监控）</h4><p>在校期间我做过<strong>分布式Linux性能监控</strong>的项目，首先，我利用了Docker容器化的技术，通过Dockerfile来构建环境，例如安装CMake、gRpc、Protobuf等依赖，以此来<strong>简化多服务器的部署</strong>。</p><p>通过基于gRpc的框架来构建服务端和客户端，服务端位于目标监控的服务器上，客户端调用<strong>monitor模块</strong>和<strong>display模块</strong>实现对服务端的监控，通过这样的设计保证了模块之间的<strong>低耦合</strong>。</p><p>对于<strong>monitor模块</strong>主要作用是用来获取服务器端的CPU、内存、网络、软中断等性能指标。Display模块就利用了monitor模块所获取到的性能指标来使用Qt构建ui界面。</p><p>最后，使用<code>stress</code>工具模拟高负载情况，验证了系统的稳定性。</p><p>遇到的困难：</p><ul><li>protobuf如何使用cmake进行编译</li></ul><h4 id="2-2-介绍一下你的项目（RPC）"><a href="#2-2-介绍一下你的项目（RPC）" class="headerlink" title="2.2 介绍一下你的项目（RPC）"></a>2.2 介绍一下你的项目（RPC）</h4><p>这个项目是基于C++实现的RPC网络通信框架，实现了同一台机器不同进程间或者不同机器间的服务调用。</p><p>首先，本项目是使用protobuf进行序列化和反序列化，并使用了Zookeeper作为服务注册中心，动态地存储服务的ip和端口。</p><p>其次，对于网络层采用Muduo库的Reactor模型，来将网络IO和业务逻辑相解耦，提升系统的并发处理能力。</p><p>最后，通过CMake构建编译环境。</p><h3 id="1-Docker相关"><a href="#1-Docker相关" class="headerlink" title="1.Docker相关"></a>1.Docker相关</h3><h4 id="1-1-docker和VM的区别"><a href="#1-1-docker和VM的区别" class="headerlink" title="1.1 docker和VM的区别"></a>1.1 docker和VM的区别</h4><p>Docker 和虚拟机是两种不同的<strong>虚拟化技术</strong>，它们的核心目标都是为了<strong>实现资源隔离</strong>和环境一致性。</p><ul><li><p><strong>性能开销：</strong></p><ul><li>每个<strong>虚拟机</strong>都需要运行一个<strong>完整的操作系统</strong>，所以<strong>资源消耗较大</strong>，启动时间较长，占用更多的磁盘空间和内存。</li><li>容器<strong>共享宿主机的内核</strong>，因此几乎没有额外的虚拟化开销，启动<strong>速度更快</strong>（通常在毫秒级别），并且占用的磁盘空间和内存也更少。</li></ul></li><li><p><strong>隔离性：</strong></p><ul><li><strong>虚拟机</strong>提供了<strong>更强的隔离性</strong>，因为每个虚拟机都运行在一个完全独立的操作系统中，彼此之间互不影响。这种隔离性使得虚拟机更适合需要<strong>高度安全性</strong>和稳定性的场景。</li><li><strong>容器</strong>之间的<strong>隔离性相对较弱</strong>，因为它们共享宿主机的内核。如果某个容器被攻破，可能会对宿主机或其他容器造成影响。不过，通过命名空间和控制组等技术，Docker 已经能够提供一定程度的安全隔离。<strong>Docker容器适合需要进行快速部署的场景。</strong></li></ul></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504131447602.png" alt="image-20250410141629895" style="zoom:50%;"></p><h4 id="1-2-使用docker创建镜像的流程是什么？相关的命令有哪些？"><a href="#1-2-使用docker创建镜像的流程是什么？相关的命令有哪些？" class="headerlink" title="1.2 使用docker创建镜像的流程是什么？相关的命令有哪些？"></a>1.2 使用docker创建镜像的流程是什么？相关的命令有哪些？</h4><ul><li><p><strong>编写 Dockerfile（.dockerfile文件）</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>  ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get clean &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get autoclean</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> apt/sources.list /etc/apt/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update  &amp;&amp; apt-get upgrade -y  &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y \</span></span><br><span class="line"><span class="language-bash">    htop \</span></span><br><span class="line"><span class="language-bash">    apt-utils \</span></span><br><span class="line"><span class="language-bash">    curl \</span></span><br><span class="line"><span class="language-bash">    git \</span></span><br><span class="line"><span class="language-bash">    openssh-server \</span></span><br><span class="line"><span class="language-bash">    build-essential \</span></span><br><span class="line"><span class="language-bash">    qtbase5-dev \</span></span><br><span class="line"><span class="language-bash">    qtchooser \</span></span><br><span class="line"><span class="language-bash">    qt5-qmake \</span></span><br><span class="line"><span class="language-bash">    qtbase5-dev-tools \</span></span><br><span class="line"><span class="language-bash">    libboost-all-dev \</span></span><br><span class="line"><span class="language-bash">    net-tools \</span></span><br><span class="line"><span class="language-bash">    vim \</span></span><br><span class="line"><span class="language-bash">    stress </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y libc-ares-dev  libssl-dev gcc g++ make </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y  \</span></span><br><span class="line"><span class="language-bash">    libx11-xcb1 \</span></span><br><span class="line"><span class="language-bash">    libfreetype6 \</span></span><br><span class="line"><span class="language-bash">    libdbus-1-3 \</span></span><br><span class="line"><span class="language-bash">    libfontconfig1 \</span></span><br><span class="line"><span class="language-bash">    libxkbcommon0   \</span></span><br><span class="line"><span class="language-bash">    libxkbcommon-x11-0</span></span><br><span class="line"> <span class="comment"># 复制当前目录下的文件到容器中</span></span><br><span class="line"> <span class="keyword">COPY</span><span class="language-bash"> install/cmake /tmp/install/cmake</span></span><br><span class="line"> <span class="comment"># 安装 cmake 依赖</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="language-bash"> /tmp/install/cmake/install_cmake.sh</span></span><br><span class="line"> <span class="keyword">COPY</span><span class="language-bash"> install/protobuf /tmp/install/protobuf</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="language-bash"> /tmp/install/protobuf/install_protobuf.sh</span></span><br><span class="line"> <span class="keyword">COPY</span><span class="language-bash"> install/abseil /tmp/install/abseil</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="language-bash"> /tmp/install/abseil/install_abseil.sh</span></span><br><span class="line"> <span class="keyword">COPY</span><span class="language-bash"> install/grpc /tmp/install/grpc</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="language-bash"> /tmp/install/grpc/install_grpc.sh</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="language-bash"> apt-get install -y python3-pip</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="language-bash"> pip3 install cuteci -i https://mirrors.aliyun.com/pypi/simple</span></span><br><span class="line"> <span class="keyword">COPY</span><span class="language-bash"> install/qt /tmp/install/qt</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="language-bash"> /tmp/install/qt/install_qt.sh</span></span><br></pre></td></tr></table></figure></li><li><p><strong>构建镜像：</strong>使用 <code>docker build</code> 命令根据 <code>Dockerfile</code> 构建镜像。</p></li><li><p><strong>测试镜像：</strong><code>docker images</code>查看本地已经存在的镜像列表</p></li><li><p><strong>运行容器:</strong><code>docker run</code>运行镜像并启动容器。</p></li><li><p><strong>查看运行中的容器:</strong> <code>docker ps</code></p></li><li><p><strong>进入容器的交互式终端</strong>：<code>docker exec -it &lt;容器ID或名称&gt; /bin/bash</code></p></li></ul><h4 id="1-3-docker的namespace是什么？有什么作用？"><a href="#1-3-docker的namespace是什么？有什么作用？" class="headerlink" title="1.3 docker的namespace是什么？有什么作用？"></a>1.3 docker的namespace是什么？有什么作用？</h4><p>namespace是<strong>实现隔离的机制</strong>，每个容器运行在一个独立的命名空间之中</p><p><strong>每个进程都有自己所属的 namespace，可以在 <code>/proc/&lt;pid&gt;/ns/</code> 目录下查看。</strong></p><p><strong>Docker 使用的主要几种 namespace：</strong></p><ul><li><strong>PID Namespace</strong>：用于隔离<strong>进程ID编号空间</strong>。这意味着在不同的 PID namespace 中可以存在相同的 PID，而且一个 namespace 中的进程对于另一个 namespace 来说是不可见的。</li><li><strong>Network Namespace</strong>：提供<strong>独立的网络协议栈</strong>（例如网络设备、IP地址、路由表等）。每个 Network namespace 都有自己的网络配置和状态。</li><li><strong>Mount Namespace</strong>：允许修改<strong>文件系统的挂载点列表</strong>，使不同容器可以看到完全不同的文件系统结构。</li><li><strong>UTS Namespace</strong>：允许<strong>单个系统上存在不同的主机名和域名</strong>，这有助于创建更真实的测试环境。</li><li><strong>IPC Namespace</strong>：用于隔离System V IPC 和 POSIX消息队列，这样即使在同一系统上，不同容器也可以安全地使用这些通信机制而不会相互干扰。</li><li><strong>User Namespace</strong>：提供了用户ID和组ID的隔离，使得同一用户的ID在不同的namespace中可以对应不同的权限。</li></ul><p>​    通过使用这些 namespace，Docker  能够<strong>为每个容器创建一个独立的执行环境</strong>，这个环境看起来就像是一个单独的操作系统实例。这种隔离性是容器技术的核心特点之一，使得<strong>多个容器可以在同一台机器上共存而互不干扰</strong>。同时，由于它们共享同一个内核，所以比传统的虚拟机更加高效且<strong>占用资源更少</strong>。</p><h4 id="1-4-docker的cgroups是什么？有什么作用？"><a href="#1-4-docker的cgroups是什么？有什么作用？" class="headerlink" title="1.4 docker的cgroups是什么？有什么作用？"></a>1.4 docker的cgroups是什么？有什么作用？</h4><p>​    cgroups是一种用于限制和隔离一个或一组进程对系统资源使用的机制，将<strong>一组进程组织在一个控制组中</strong>，为这个控制组分配特定的<strong>资源限制</strong>与优先级，包括 CPU资源、内存、网络等。确保容器在共享主机上合理利用系统资源，避免资源竞争和过度使用。 </p><p>​    <strong>容器利用 Linux 的namespace技术来实现这种隔离，并结合 cgroups 来管理资源的使用，保证容器之间不会互相干扰。</strong></p><h4 id="1-5-什么是镜像？为什么要使用镜像？"><a href="#1-5-什么是镜像？为什么要使用镜像？" class="headerlink" title="1.5 什么是镜像？为什么要使用镜像？"></a>1.5 什么是镜像？为什么要使用镜像？</h4><p><strong>镜像：包含程序运行环境的软件包</strong></p><p><strong>使用 Docker镜像 的主要原因：</strong></p><ul><li><strong>环境一致性：</strong> 确保在任何地方运行结果一致。</li><li><strong>快速部署：</strong> 镜像可以 <strong>一键运行</strong>，秒级启动容器</li><li><strong>资源隔离：</strong> 每个容器基于镜像独立运行，资源相互隔离。</li></ul><h4 id="1-6-docker分层原理与内部结构"><a href="#1-6-docker分层原理与内部结构" class="headerlink" title="1.6 docker分层原理与内部结构"></a>1.6 docker分层原理与内部结构</h4><p><strong>Docker采用分层存储结构：</strong></p><ul><li><strong>基础镜像层</strong>：通常是一个最小化的操作系统环境，例如 <code>alpine</code> 或 <code>ubuntu</code>。它是其他所有层的基础。</li><li><p><strong>中间层</strong>：基于基础镜像层之上，每执行一条指令（比如 <code>RUN</code> 命令），都会创建一个新的层。这<strong>包括安装软件包、复制文件等操作。</strong></p></li><li><p><strong>可写层（容器层）</strong>：当使用 <strong><code>docker run</code></strong> 命令启动一个容器时，在镜像的最顶层会添加一个可写的容器层。所有对容器的更改（如文件的增删改）都只会发生在这一层，而不会影响到下面的只读层。<strong>容器删除后，可写层也随之消失(除非数据被持久化)。</strong></p></li></ul><p><strong>分层的工作方式：</strong></p><ul><li><p><strong>镜像构建时的分层：只读层(镜像层)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:<span class="number">20.04</span>          # 基础层(第<span class="number">1</span>层)</span><br><span class="line">RUN apt-get update         # 第<span class="number">2</span>层</span><br><span class="line">RUN apt-get install -y nginx  # 第<span class="number">3</span>层</span><br><span class="line">COPY index.html /var/www/html/  # 第<span class="number">4</span>层</span><br><span class="line">CMD [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]  # 第<span class="number">5</span>层</span><br></pre></td></tr></table></figure></li><li><p><strong>容器运行时的分层: 可写层(容器层)</strong> 通过<code>docker run</code>创建</p></li></ul><p><strong>分层的好处：</strong></p><ul><li><strong>高效的存储</strong>：由于各层之间共享(<strong>只读层共享，可写层独立</strong>），如果两个镜像共用了某些层，那么这些层只需要存储一次，从而<strong>节省了磁盘空间。</strong></li><li><strong>快速部署</strong>：在构建新镜像时，只有变动的部分需要重新生成新的层，其余未变的部分可以直接复用，大大加快了镜像的构建速度。</li></ul><h3 id="2-Protobuf"><a href="#2-Protobuf" class="headerlink" title="2.Protobuf"></a>2.Protobuf</h3><p><strong>Protobuf: 轻量级的数据序列化协议</strong></p><h4 id="2-1-为什么数据的传输和通信需要序列化？"><a href="#2-1-为什么数据的传输和通信需要序列化？" class="headerlink" title="2.1 为什么数据的传输和通信需要序列化？"></a>2.1 为什么数据的传输和通信需要序列化？</h4><ul><li><p><strong>跨平台兼容性</strong>：<strong>不同的系统、编程语言或者运行环境可能对数据结构有不同的表示方法。</strong>通过序列化，可以将这些差异抽象掉，使得数据可以在不同平台间进行有效传输。</p></li><li><p><strong>优化传输大小</strong>：有效的序列化格式能够减少数据传输的体积，从而提高传输效率并节省带宽。</p><p><em>注：<strong>Protobuf 使用字段编号（如 <code>1</code>、<code>2</code>）来代替字段名</strong>，这样可以大大减少字段标识的占用空间。</em></p></li></ul><h4 id="2-2-为什么使用protobuf？"><a href="#2-2-为什么使用protobuf？" class="headerlink" title="2.2 为什么使用protobuf？"></a>2.2 为什么使用protobuf？</h4><ul><li><p><strong>性能</strong>：Protobuf 使用二进制格式进行数据编码，这使得它更加紧凑，占用更少的空间，同时也加快了序列化和反序列化的速度。</p><p><em>注：字段编号（如 <code>1</code>、<code>2</code>）来代替字段名，另外，二进制格式相比于文本格式去掉了空白字符。</em></p></li><li><p><strong>支持跨平台</strong>：Protobuf 支持<strong>多种编程语言</strong>，如 C++, Java, Python 等，并且支持跨平台使用。</p></li></ul><h3 id="3-CMake"><a href="#3-CMake" class="headerlink" title="3.CMake"></a>3.CMake</h3><h4 id="3-1-使用cmake进行编译的步骤？"><a href="#3-1-使用cmake进行编译的步骤？" class="headerlink" title="3.1 使用cmake进行编译的步骤？"></a>3.1 使用cmake进行编译的步骤？</h4><ul><li><p><strong>编写<code>CMakeLists.txt</code> 文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.10</span><span class="number">.2</span>)</span><br><span class="line"><span class="built_in">project</span>(test_monitor LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_subdirectory</span>(rpc_manager)</span><br><span class="line"><span class="built_in">add_subdirectory</span>(test_monitor)</span><br><span class="line"><span class="built_in">add_subdirectory</span>(proto)</span><br><span class="line"><span class="built_in">add_subdirectory</span>(display_monitor)</span><br></pre></td></tr></table></figure></li><li><p><strong>创建构建目录：</strong>创建一个单独的构建目录build,避免污染源代码目录。</p></li><li><p><strong>进入构建目录，执行<code>cmake ..</code>,生成 <code>Makefile</code></strong></p></li><li><p><strong>执行构建:</strong> 使用<code>make</code>命令执行构建</p></li></ul><h4 id="3-2-cmake的常用API"><a href="#3-2-cmake的常用API" class="headerlink" title="3.2 cmake的常用API?"></a>3.2 cmake的常用API?</h4><ul><li><strong>项目配置: </strong> <code>cmake_minimum_required(VERSION &lt;version&gt;)</code></li><li><strong>设置变量:</strong> <code>set(&lt;variable&gt; &lt;value&gt;)</code></li><li><strong>定义一个可执行目标:</strong> <code>add_executable(&lt;target_name&gt; &lt;source_files&gt;)</code></li><li><strong>定义一个库目标:</strong> <code>add_library(&lt;target_name&gt; [STATIC | SHARED | MODULE] &lt;source_files&gt;)</code></li><li><strong>链接库:</strong> <code>target_link_libraries(&lt;target&gt; &lt;libraries&gt;)</code></li><li><strong>指定头文件路径:</strong> <code>target_include_directories(&lt;target&gt; [PRIVATE | PUBLIC | INTERFACE] &lt;directories&gt;)</code></li><li><strong>将子目录添加到构建系统:</strong> <code>add_subdirectory</code></li></ul><p>3.3 动态库和静态库的区别？</p><ul><li><p><strong>静态库：</strong></p><ul><li><strong>编译时集成</strong>：静态库在编译阶段与应用程序代码一起被编译并链接到可执行文件中。这意味着每个使用该静态库的应用程序都会包含一份库代码的副本。</li><li><strong>大小和性能</strong>：由于静态库的代码被直接嵌入到最终的可执行文件中，这可能导致生成的可执行文件较大。</li></ul></li><li><p><strong>动态库：</strong></p><ul><li>动态库在程序运行时才被加载到内存，并与程序进行链接。<strong>多个程序可以共享同一个动态库实例</strong>，从而节省内存和磁盘空间。</li></ul></li><li><p>静态库适合于<strong>确保程序独立运行</strong>，减少对外部依赖的情况；动态库则有助于资源共享、减小程序体积，并简化库的升级流程。</p></li></ul><h3 id="4-gRPC"><a href="#4-gRPC" class="headerlink" title="4.gRPC"></a>4.gRPC</h3><h4 id="4-1-介绍一下gRPC"><a href="#4-1-介绍一下gRPC" class="headerlink" title="4.1 介绍一下gRPC"></a>4.1 介绍一下gRPC</h4><p>​    gRPC是一种高性能的远程过程调用框架，主要用于分布式场景中的服务与服务间的数据交互，其采用HTTP2（支持io多路复用）作为传输协议，使用protobuf作为序列化协议，并且支持多种开发语言。</p><h4 id="4-2-对比一下HTTP1-0、HTTP1-1、HTTP2-0、HTTP3-0"><a href="#4-2-对比一下HTTP1-0、HTTP1-1、HTTP2-0、HTTP3-0" class="headerlink" title="4.2 对比一下HTTP1.0、HTTP1.1、HTTP2.0、HTTP3.0"></a>4.2 对比一下HTTP1.0、HTTP1.1、HTTP2.0、HTTP3.0</h4><p><strong>HTTP/1.0:</strong></p><ul><li><strong>连接方式（短连接）</strong>：每个<strong>请求都需要建立一个新的TCP连接</strong>，完成之后立即关闭，这导致了较大的延迟。</li><li><strong>基于文本的协议：</strong>传输文本格式的数据 </li><li><strong>单工：</strong>无法实现服务端的推送</li></ul><p><strong>HTTP1.1：</strong></p><ul><li><strong>有限的长连接：</strong> 由keep-alived决定保持的时间，允许在一个TCP连接上发送多个请求和响应。</li><li><strong>基于文本的协议：</strong>传输文本格式的数据 </li><li><strong>无法实现双工通信</strong></li><li><strong>存在队头阻塞的问题（不支持多路复用）：</strong>下一个请求必须在前一个请求响应到达之后才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。（一个连接上不能同时发出多个请求）</li></ul><p><strong>HTTP2.0：</strong></p><ul><li><strong>长连接</strong></li><li><strong>多路复用</strong>：解决了HTTP/1.x中的队头阻塞问题，通过一条TCP连接可以同时进行多个请求和响应的传输。</li><li><strong>二进制协议</strong>：传输二进制数据效率高</li><li><strong>可以实现双工通信</strong></li><li><strong>仍存在可能因丢包重传阻塞所有流（TCP 层队头阻塞）</strong></li></ul><p><strong>HTTP/3.0：</strong></p><ul><li><strong>底层协议变更</strong>：最大的变化是从基于TCP变为基于UDP的QUIC协议，旨在减少连接建立时间并提高安全性。</li><li><strong>快速握手</strong>：利用TLS 1.3实现了更快的安全握手过程，使得连接建立速度显著加快。</li></ul><h3 id="5-性能相关"><a href="#5-性能相关" class="headerlink" title="5.性能相关"></a>5.性能相关</h3><h4 id="5-1-性能数据是怎么得到的？"><a href="#5-1-性能数据是怎么得到的？" class="headerlink" title="5.1 性能数据是怎么得到的？"></a>5.1 性能数据是怎么得到的？</h4><p>通过读取<code>/proc</code>文件系统下的相关文件得到。</p><h4 id="5-2-什么是中断？什么是软中断？"><a href="#5-2-什么是中断？什么是软中断？" class="headerlink" title="5.2 什么是中断？什么是软中断？"></a>5.2 什么是中断？什么是软中断？</h4><p><code>/proc/softirqs</code></p><p><strong>中断：</strong>是一种<strong>异步</strong>的事件处理机制，可以提高系统的并发处理能力。</p><p><strong>软中断（异常）：</strong></p><p>为了解决中断处理程序<strong>执行过长</strong>和<strong>中断丢失</strong>的问题，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部（软中断）。</p><ul><li>上半部用来快速处理中断，它在<strong>中断禁止模式</strong>下运行，主要处理跟<strong>硬件</strong>紧密相关的或时间敏感的工作。</li><li>下半部用来延迟处理上半部未完成的工作，通常以<strong>内核线程</strong>的方式运行。</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504131447451.png" alt="image-20250412094031429" style="zoom:50%;"></p><h4 id="5-3-统计了内存相关的哪些信息？"><a href="#5-3-统计了内存相关的哪些信息？" class="headerlink" title="5.3 统计了内存相关的哪些信息？"></a>5.3 统计了内存相关的哪些信息？</h4><p>/proc/meminfo 当前内存使用的统计信息，常由free命令使用</p><p><strong>基础内存统计：</strong></p><ul><li><strong><code>total</code>：</strong> 系统的总物理内存大小</li><li><strong><code>free</code>： </strong>当前未被使用的物理内存大小。</li><li><strong><code>avail</code>： </strong> 可用于启动新应用程序而无需交换的内存大小。它包括了空闲内存 (<code>free</code>) 和可回收的缓存（如文件缓存和部分 slab 缓存）。</li></ul><p><strong>缓存与缓冲区：</strong></p><ul><li><p><strong><code>buffers</code>： </strong>块设备 I/O 操作的缓冲区内存大小。</p></li><li><p><strong><code>cached</code>： </strong>表示文件系统缓存占用的内存大小。</p><p>……</p></li></ul><p><strong>活跃与非活跃内存</strong></p><ul><li><p><strong><code>active</code>: </strong>最近被频繁访问的内存页面大小。这些页面不太可能被回收。</p></li><li><p><strong><code>in_active</code>: </strong>最近较少被访问的内存页面大小。这些页面可能被回收以释放内存。</p><p>……</p></li></ul><p><strong>脏页与写回</strong></p><ul><li><strong><code>dirty</code>: </strong>尚未写入磁盘的脏页（修改过的页面）的内存大小。这些页面需要尽快写回磁盘以确保数据一致性。</li><li><strong><code>writeback</code>: </strong>表示正在写回磁盘的页面的内存大小。这些页面已经被标记为“正在写入”，但尚未完成。</li></ul><p><strong>匿名内存</strong></p><ul><li><p><strong><code>anon_pages</code>: </strong>表示匿名内存的总大小。匿名内存是指没有文件支持的内存区域，如堆、栈和通过 <code>mmap</code> 创建的匿名映射。</p><p>……</p></li></ul><p><strong>可回收内存</strong></p><ul><li><p><strong><code>kReclaimable</code>: </strong>表示内核中可回收的内存大小。这部分内存由内核管理，但可以被回收以供其他用途。</p><p>……</p></li></ul><h3 id="6-Muduo库"><a href="#6-Muduo库" class="headerlink" title="6.Muduo库"></a>6.Muduo库</h3><h4 id="6-1-介绍一下Muduo库的Reactor模型"><a href="#6-1-介绍一下Muduo库的Reactor模型" class="headerlink" title="6.1 介绍一下Muduo库的Reactor模型"></a>6.1 介绍一下Muduo库的Reactor模型</h4><p>​    Reactor模型其核心思想是<strong>“事件驱动”</strong>，即通过一个事件循环（<strong>EventLoop</strong>）监听多种事件，然后通过一个<strong>事件分发器</strong>分发给对应的<strong>事件处理器（回调函数）</strong>进行处理。</p><p>然而，在高并发的场景下，单线程的EventLoop可能无法满足性能需求。这是通常采用主Reactor线程和子Reactor线程的分离设计。</p><ul><li><strong>主Reactor线程：</strong>运行一个 EventLoop，负责监听服务器端口并接受新连接，并把连接分配给子Reactor线程。</li><li><strong>子Reactor线程：</strong>每个线程都运行一个独立的 EventLoop，负责处理具体的 TCP 连接，后续的所有 IO 操作（如读写）都在对应的子线程中完成。</li></ul><h4 id="6-2-同步和异步的区别"><a href="#6-2-同步和异步的区别" class="headerlink" title="6.2 同步和异步的区别"></a>6.2 同步和异步的区别</h4><p><strong>同步</strong>：指<strong>任务依次执行</strong>，一个任务完成之后下一个任务才开始</p><p><strong>异步</strong>：指<strong>任务可以不按顺序执行</strong>，发起一个任务后无需等待其完成即可继续执行其他任务，通过回调、通知或轮询等方式获取任务结果。</p><h4 id="6-3-什么是事件驱动？Reactor模型是怎么实现事件驱动的？"><a href="#6-3-什么是事件驱动？Reactor模型是怎么实现事件驱动的？" class="headerlink" title="6.3 什么是事件驱动？Reactor模型是怎么实现事件驱动的？"></a>6.3 什么是事件驱动？Reactor模型是怎么实现事件驱动的？</h4><p><strong>事件驱动的核心思想是：</strong></p><ul><li><p><strong>异步非阻塞</strong>：程序<strong>不会主动轮询</strong>或等待某个事件的发生，而是通过<strong>注册回调函数</strong>的方式，由底层框架在事件发生时<strong>通知应用程序</strong>。</p></li><li><p><strong>事件循环（Event Loop）</strong>：一个持续运行的循环，用于<strong>监听事件并调用相应的回调函数。</strong></p></li></ul><p><strong>Reactor 模型的事件驱动流程</strong></p><ul><li><p><strong>注册事件：</strong>将感兴趣的事件（如可读、可写、连接关闭等）注册到 Reactor 中。</p><ul><li><code>setConnectionCallback</code> 注册了连接事件的回调函数 <code>OnConnection</code></li><li><code>setMessageCallback</code> 注册了消息事件的回调函数 <code>OnMessage</code></li></ul></li><li><p><strong>监听事件</strong>：<code>loop.loop()</code> 启动事件循环，通过 <code>epoll</code> 监听服务器端口上的连接请求和已连接套接字上的读写事件。</p></li><li><p><strong>分发事件：</strong></p><ul><li>当有新连接到达时，Muduo 调用 <code>OnConnection</code> 处理连接事件。</li><li>当有数据到达时，Muduo 调用 <code>OnMessage</code> 处理消息事件。</li></ul></li><li><p><strong>执行回调：</strong> <code>OnConnection</code> 和 <code>OnMessage</code> 执行具体的业务逻辑，例如打印日志、回显消息等。</p></li></ul><h3 id="7-Zookeeper"><a href="#7-Zookeeper" class="headerlink" title="7.Zookeeper"></a>7.Zookeeper</h3><h4 id="7-1-什么是Zookeeper？为什么使用Zookeeper？"><a href="#7-1-什么是Zookeeper？为什么使用Zookeeper？" class="headerlink" title="7.1 什么是Zookeeper？为什么使用Zookeeper？"></a>7.1 什么是Zookeeper？为什么使用Zookeeper？</h4><p>Zookeeper是一个<strong>分布式协调工具</strong>，而在本项目中主要用到了它的服务注册与发现的功能。</p><p><strong>具体的设计：</strong></p><ul><li>对于服务的提供者，以自己提供的服务名和方法作为Znode的路径，而将ip和端口作为Znode节点的数据，注册到zookeeper上。</li><li>对于服务的调用者，根据所请求的服务名和方法名就可以查找到对应服务器的ip和端口。</li></ul><p><strong>好处：</strong></p><ul><li>服务的调用者<strong>无需手动配置</strong>服务器的地址，只需提供服务名和方法名即可。</li><li>Zookeeper提供了<strong>Watcher机制</strong>可以<strong>实时感知</strong>服务的上线和下线。</li></ul><h4 id="7-2-ZooKeeper-的-Watcher-机制是如何实现的？"><a href="#7-2-ZooKeeper-的-Watcher-机制是如何实现的？" class="headerlink" title="7.2 ZooKeeper 的 Watcher 机制是如何实现的？"></a>7.2 ZooKeeper 的 Watcher 机制是如何实现的？</h4><p>​    Zookeeper 的观察者（Watcher）机制是一种事件通知机制，允许<strong>客户端在 ZNode 上设置观察者</strong>，以便在 ZNode 的数据或状态发生变化时接收通知。但在本项目中只使用了一个全局的<strong><code>global_watcher</code></strong>来监听<strong>客户端与服务器之间的连接状态变化</strong></p><h4 id="7-3-ZooKeeper客户端和服务器是长连接吗？"><a href="#7-3-ZooKeeper客户端和服务器是长连接吗？" class="headerlink" title="7.3 ZooKeeper客户端和服务器是长连接吗？"></a>7.3 ZooKeeper客户端和服务器是长连接吗？</h4><p>​    <strong>可以保持长连接</strong>，线程会定期向 ZooKeeper 服务器发送心跳包（Ping 消息），以确保连接的有效性。通过设置一个超时时间，如果客户端未收到服务器的响应（包括心跳响应），ZooKeeper 客户端会认为会话已过期，连接会被关闭。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL面试</title>
      <link href="/posts/ea5b5bc.html"/>
      <url>/posts/ea5b5bc.html</url>
      
        <content type="html"><![CDATA[<h2 id="STL面试"><a href="#STL面试" class="headerlink" title="STL面试"></a>STL面试</h2><h4 id="1-vector迭代器失效的问题？"><a href="#1-vector迭代器失效的问题？" class="headerlink" title="1.vector迭代器失效的问题？"></a>1.vector迭代器失效的问题？</h4><p>vector中的插入/删除会改变元素的位置或数量，从而导致迭代器失效。对vector进行连续插入或者删除操作（insert/erase)，一定要更新迭代器。</p><h4 id="2-array和vector的区别？"><a href="#2-array和vector的区别？" class="headerlink" title="2.array和vector的区别？"></a>2.array和vector的区别？</h4><ul><li><p><strong>大小是否可变：</strong></p><ul><li><strong><code>std::array</code></strong>在<strong>编译时确定大小</strong>，运行时无法更改。</li><li><strong><code>std::vector</code></strong>可在运行时动态调整大小</li></ul></li><li><p><strong>底层实现：</strong></p><ul><li><strong><code>std::array</code>：</strong> 基于普通数组（连续存储）实现，直接存储在栈上（除非它是某个堆对象的一部分）。</li><li><strong><code>std::vector</code>：</strong> 基于动态数组实现，数据存储在堆上。（在使用vector这个结构的时候，如果vector在函数内部直接定义，则对象存储在栈上，数据存储在堆上；而通过new动态创建时，指针在栈上，对象和数据都在堆上。</li></ul></li><li><p><strong>性能：</strong> <strong><code>vector</code></strong>插入或删除元素时可能需要重新分配内存和复制数据，导致性能下降。</p><p>注：如果提前预留足够的容量（通过 <code>reserve()</code> 方法），可以减少动态分配的次数。</p></li><li><p><strong>容器大小：</strong></p><ul><li><strong><code>std::array</code>：</strong> 返回的是编译时固定的大小</li><li><strong><code>std::vector</code></strong>：返回当前存储的元素数量</li></ul></li><li><p><strong>迭代器失效</strong>：<code>array</code>迭代器永远不会失效，除非整个容器被销毁。</p></li></ul><h4 id="3-描述一下vetcor动态内存的基本原理"><a href="#3-描述一下vetcor动态内存的基本原理" class="headerlink" title="3.描述一下vetcor动态内存的基本原理"></a>3.描述一下vetcor动态内存的基本原理</h4><p><strong>内存分配策略：</strong></p><ul><li><strong>分配更大的内存块</strong>：通过<strong>增长因子</strong>将容量翻倍（例如，从 4 → 8 → 16 → 32…）</li><li><strong>复制原有数据</strong>： 将原有数据从旧内存块复制到新内存块</li><li><strong>释放旧内存</strong>： 在完成数据迁移后，旧的内存块会被释放</li><li><strong>更新内部状态</strong>： 更新 <code>capacity</code> 和指向新内存块的指针。</li></ul><h4 id="4-介绍一下deque的底层结构"><a href="#4-介绍一下deque的底层结构" class="headerlink" title="4.介绍一下deque的底层结构"></a>4.介绍一下deque的底层结构</h4><p><code>std::deque</code>结合了数组和链表的特性</p><p><strong>底层实现：分块存储</strong></p><ul><li><strong>主数组（Map 或索引数组）:</strong> 指针数组，存储指向各个小块（chunk）的指针。</li><li><strong>小块（Chunk）:</strong> 固定大小的连续内存区域，用于存储 <code>std::deque</code> 的实际数据。</li><li><strong>头部和尾部标记:</strong> <code>std::deque</code> 内部维护两个标记，分别指向当前数据的起始位置和结束位置。</li></ul><p><strong><em>注：deque支持随机访问</em></strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202504102134400.png" alt="image-20250407170801444" style="zoom:50%;"></p><h4 id="5-list的底层结构是什么？"><a href="#5-list的底层结构是什么？" class="headerlink" title="5.list的底层结构是什么？"></a>5.list的底层结构是什么？</h4><p>双向循环链表</p><h4 id="6-容器适配器有哪些？底层结构是什么？"><a href="#6-容器适配器有哪些？底层结构是什么？" class="headerlink" title="6.容器适配器有哪些？底层结构是什么？"></a>6.容器适配器有哪些？底层结构是什么？</h4><ul><li><strong><code>stack</code>： </strong>底层默认使用 <code>std::deque</code></li><li><strong><code>queue</code>:</strong>  底层默认使用 <code>std::deque</code></li><li><strong><code>priority_queue:</code></strong> 底层默认使用<code>std::vector</code>。队列中的元素根据优先级排序，默认是大根堆。入队时进行排序，出队时排出优先级最高的元素，并对剩下的元素重新排序</li></ul><p><em>容器适配器没有自己的数据结构，它的方法全部由底层依赖的容器进行实现</em></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针面试题</title>
      <link href="/posts/1be7b917.html"/>
      <url>/posts/1be7b917.html</url>
      
        <content type="html"><![CDATA[<h3 id="智能指针面试题"><a href="#智能指针面试题" class="headerlink" title="智能指针面试题"></a>智能指针面试题</h3><h4 id="1-介绍一下shared-ptr的底层实现"><a href="#1-介绍一下shared-ptr的底层实现" class="headerlink" title="1.介绍一下shared_ptr的底层实现"></a>1.介绍一下shared_ptr的底层实现</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504081029173.png" alt="image-20250408093323071" style="zoom:67%;"></p><p><code>std::shared_ptr</code>的底层结构分为两部分：</p><ul><li><p><strong>控制块（Control Block）</strong>：一个动态分配的小型数据结构，用于存储引用计数和其他元信息。</p><ul><li><strong>强引用计数（Strong Reference Count）</strong>：记录有多少个 <code>shared_ptr</code> 引用了该对象。</li><li><strong>弱引用计数（Weak Reference Count）</strong>：记录有多少个 <code>std::weak_ptr</code> 引用了该对象（用于支持 <code>std::weak_ptr</code>）。</li><li><strong>删除器（Deleter）</strong>：可选的自定义函数，用于释放对象时执行特定操作。</li><li><strong>分配器（Allocator）</strong>：可选的自定义分配器，用于管理内存分配和释放。</li></ul></li><li><p><strong>原始指针（Raw Pointer）</strong>：保存一个指向实际对象的原始指针</p></li></ul><h4 id="2-介绍一下shared-ptr的引用计数的操作"><a href="#2-介绍一下shared-ptr的引用计数的操作" class="headerlink" title="2.介绍一下shared_ptr的引用计数的操作"></a>2.介绍一下shared_ptr的引用计数的操作</h4><p><strong>增加引用计数</strong>：当一个 <code>shared_ptr</code> 被拷贝（通过拷贝构造函数或赋值操作符）时，控制块中的强引用计数加 1。</p><p><strong>减少引用计数</strong>：当一个 <code>shared_ptr</code> 被销毁或重置时，控制块中的强引用计数减 1。</p><ul><li><strong>强引用计数变为 0：</strong><ul><li>调用删除器（如果有）来释放原始指针指向的对象。</li><li>如果<strong>弱引用计数也为 0</strong>，则释放控制块本身。</li></ul></li></ul><h4 id="3-weak-ptr能直接访问对象吗"><a href="#3-weak-ptr能直接访问对象吗" class="headerlink" title="3.weak_ptr能直接访问对象吗"></a>3.weak_ptr能直接访问对象吗</h4><p><code>std::weak_ptr</code> 本身<strong>不能直接访问对象</strong>，<code>std::weak_ptr</code> 可以通过检查控制块的状态来<strong>判断对象是否仍然有效</strong>。</p><p><strong>间接访问：</strong></p><ul><li><p><strong>检查对象是否仍然有效：</strong> 调用 <code>std::weak_ptr::lock()</code> 方法，尝试将 <code>std::weak_ptr</code> 提升为一个 <code>std::shared_ptr</code></p><ul><li>强引用计数为 0（即对象已经被销毁），<code>lock()</code> 返回一个空的 <code>std::shared_ptr</code></li><li>强引用计数大于 0（即对象仍然有效），<code>lock()</code> 返回一个新的 <code>std::shared_ptr</code>，并增加强引用计数。</li></ul></li><li><p><strong>提升为 <code>std::shared_ptr</code>：</strong> 如果 <code>std::weak_ptr::lock()</code> 成功返回一个有效的 <code>std::shared_ptr</code>，则可以通过这个 <code>std::shared_ptr</code> 访问对象。</p></li></ul><h4 id="4-shared-ptr和unique-ptr的区别"><a href="#4-shared-ptr和unique-ptr的区别" class="headerlink" title="4.shared_ptr和unique_ptr的区别"></a>4.shared_ptr和unique_ptr的区别</h4><ul><li><p><strong>所有权：</strong></p><ul><li><strong><code>std::unique_ptr</code></strong>：实现了独占所有权语义。</li><li><strong><code>std::shared_ptr</code></strong>：实现了共享所有权语义。</li></ul></li><li><p><strong>性能与内存开销：</strong></p><ul><li><strong><code>std::unique_ptr</code></strong>：性能较高，因为它不需要额外的内存开销来存储引用计数或其他元数据。</li><li><strong><code>std::shared_ptr</code></strong>：性能较低，因为每次增加或减少引用计数都需要原子操作。还需要额外的控制块来存储引用计数和其他信息。</li></ul></li><li><p><strong>移动语义 vs 复制语义：</strong></p><ul><li><strong><code>std::unique_ptr</code></strong>：支持移动语义，但不支持复制语义。</li><li><strong><code>std::shared_ptr</code></strong>：支持复制和赋值操作。</li></ul></li></ul><h4 id="5-shared-ptr的循环引用问题是什么？如何解决？"><a href="#5-shared-ptr的循环引用问题是什么？如何解决？" class="headerlink" title="5.shared_ptr的循环引用问题是什么？如何解决？"></a>5.shared_ptr的循环引用问题是什么？如何解决？</h4><p><strong>循环引用:</strong> <code>std::shared_ptr</code> 的循环引用问题是指两个或多个对象通过 <code>std::shared_ptr</code> <strong>相互持有对方</strong>，导致它们的强引用计数永远不会降为 0，从而无法释放内存。</p><p><strong>解决方案：用 <code>std::weak_ptr</code> 替代部分 <code>std::shared_ptr</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr; <span class="comment">// A 持有 B 的 shared_ptr</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A is destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;A&gt; a_ptr; <span class="comment">// 使用 weak_ptr 持有 A，此处如果是shared_ptr就变成了循环引用</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B is destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    <span class="keyword">auto</span> b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">    a-&gt;b_ptr = b; <span class="comment">// A 持有 B</span></span><br><span class="line">    b-&gt;a_ptr = a; <span class="comment">// B 使用 weak_ptr 持有 A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时 a 的强引用计数为 1，b 的强引用计数为 2</span></span><br><span class="line">&#125; <span class="comment">// 离开作用域后，a 和 b 的局部变量被销毁，引用计数降为 0，对象被正确释放</span></span><br></pre></td></tr></table></figure><h4 id="6-shared-ptr是否线程安全？"><a href="#6-shared-ptr是否线程安全？" class="headerlink" title="6.shared_ptr是否线程安全？"></a>6.shared_ptr是否线程安全？</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504081029981.png" alt="image-20250408100616337" style="zoom:50%;"></p><h4 id="7-shared-ptr的构造方法有哪几种，为什么尽量使用make-shared"><a href="#7-shared-ptr的构造方法有哪几种，为什么尽量使用make-shared" class="headerlink" title="7.shared_ptr的构造方法有哪几种，为什么尽量使用make_shared?"></a>7.shared_ptr的构造方法有哪几种，为什么尽量使用make_shared?</h4><p><strong>构造方法：</strong></p><ul><li><p><strong>默认构造函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr; <span class="comment">// 空 shared_ptr</span></span><br></pre></td></tr></table></figure></li><li><p><strong>从原始指针构造</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* rawPtr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(rawPtr)</span></span>; <span class="comment">// 用裸指针初始化 shared_ptr</span></span><br></pre></td></tr></table></figure><p><em>注：这种方式需要手动分配内存（如 <code>new</code>），容易导致资源泄漏或双重释放。</em></p></li><li><p><strong>使用 <code>std::make_shared</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用删除器：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>), [](<span class="type">int</span>* p) &#123; <span class="keyword">delete</span> p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>为什么尽量使用make_shared:</strong></p><ul><li><p><strong>减少内存分配次数</strong>：裸指针需要两次内存分配,而 <code>std::make_shared</code> 将对象和控制块合并到一次内存分配中，减少了内存分配的开销。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用裸指针构造 shared_ptr</span></span><br><span class="line"><span class="type">int</span>* rawPtr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>); <span class="comment">// 分配对象</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(rawPtr)</span></span>; <span class="comment">// 分配控制块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 make_shared</span></span><br><span class="line"><span class="keyword">auto</span> ptr2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 合并对象和控制块的一次分配</span></span><br></pre></td></tr></table></figure></li><li><p><strong>异常安全性:</strong> 在分配对象后、构造 <code>std::shared_ptr</code> 前抛出异常，则会导致内存泄漏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用裸指针可能引发异常安全性问题</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span>* rawPtr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>); <span class="comment">// 分配对象</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error&quot;</span>); <span class="comment">// 抛出异常，rawPtr 未被管理</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(rawPtr)</span></span>; <span class="comment">// 这行代码不会被执行</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 内存泄漏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 make_shared 是安全的</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 单步完成分配和管理</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error&quot;</span>); <span class="comment">// 异常安全，ptr 会正确释放资源</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 资源被正确释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504081029670.png" alt="image-20250408101900500" style="zoom:50%;"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Muduo库</title>
      <link href="/posts/70fda4f8.html"/>
      <url>/posts/70fda4f8.html</url>
      
        <content type="html"><![CDATA[<h4 id="非阻塞IO-IO复用"><a href="#非阻塞IO-IO复用" class="headerlink" title="非阻塞IO+IO复用"></a>非阻塞IO+IO复用</h4><p><strong>Event Loop：</strong> <strong>一个不断监听事件的发生，并调用相应回调函数的机制。</strong>处理<strong>异步</strong>I/O操作的编程模式，通过一个无限循环监听和分发事件。</p><p>注：在Event Loop中，应用首先注册感兴趣的事件处理器（如网络连接、文件I/O等），然后进入一个循环，等待这些事件的发生，并在事件发生时调用相应的处理器来响应事件。</p><p><strong>Non-Blocking 几乎总是和 I/O 多路复用一起使用：</strong></p><ul><li>单用Non-Blocking需要<strong>轮询</strong>检测I/O状态，会浪费CPU资源。</li><li><strong>I/O多路复用不能与阻塞I/O共存：</strong>I/O 多路复用判断某个 socket 可能处于某种状态（如“可读”或“可写”），但这并不保证后续的阻塞 I/O 操作一定能够成功完成。<ul><li>对于“可读”状态，可能只是表示内核缓冲区中有一些数据，但实际的数据量可能不足以满足 <code>read()</code> 请求（比如请求读取 100 字节，但缓冲区只有 50 字节）。</li><li>对于“可写”状态，可能只是表示内核缓冲区有空间，但如果你尝试写入大量数据，可能会超出缓冲区容量，导致 <code>write()</code> 阻塞。</li></ul></li></ul><p><strong><em>注：阻塞 I/O 会导致线程被挂起，从而无法处理其他 socket 上的事件。</em></strong></p><h4 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h4><p><strong>Reactor模型：</strong>是一个<strong>异步</strong>I/O模型，它不会阻塞程序的执行等待某个I/O操作完成，而是通过<strong>事件驱动</strong>的方式来处理I/O操作。Reactor设计模式是用于处理服务请求的事件处理模式，由一个或多个输入同时传递给服务处理程序，服务处理程序然后对传入的请求进行<strong>解复用</strong>，并将它们<strong>同步分派</strong>给关联的请求处理程序。</p><p><strong>Reactor模式的核心概念：事件分发和处理分离</strong></p><ul><li><strong>事件驱动</strong>：在Reactor模型中，所有输入（如客户端连接请求、数据到达等）都被视为事件。这些事件由Reactor负责监听和分发。</li><li><strong>解复用</strong>：当多个输入同时到达服务端时，Reactor会将这些输入进行解复用（demultiplexing），即<strong>根据事件类型将它们分类</strong>。例如，连接请求和数据接收是两种不同的事件类型，会被分配给不同的处理器处理。</li><li><strong>同步分派</strong>：一旦事件被解复用后，Reactor会同步地将这些事件分派给对应的事件处理器（EventHandler）。这里的“同步”意味着<strong>Reactor以同步方式分派事件。</strong></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504071032961.png" alt="image-20250407100736409" style="zoom: 50%;"></p><p><strong>一个Reactor模型的网络服务器交互流程：</strong></p><ul><li><strong>注册感兴趣的事件和回调函数：</strong> 将感兴趣的事件及预置的回调函数Handler注册到Reactor反应堆上</li><li><p><strong>启动Reactor反应堆：</strong> 一旦所有的事件都注册完毕，Reactor 就开始监听这些事件的发生。</p></li><li><p><strong>启动事件分发器：</strong>持续等待直到有事件发生，一旦事件分发器检测到某个事件已经准备好，就会通知 Reactor。</p></li><li><strong>处理事件并响应:</strong>  Reactor会通过map表找到Event事件对应的事件处理器来读取用户请求</li></ul><p><strong>Main Reactor 和 Sub Reactors：</strong>为了提高系统的可扩展性（连接和读写请求相分离）和性能（负载均衡）</p><ul><li><p>当有新的客户端连接请求到达时，Main Reactor 调用 <code>accept()</code> 接受连接，<strong>并获取客户端的 socket 文件描述符</strong>，将其分配给某个 Sub Reactor。</p><p><em>注：这里一般是Main Reactor 直接调用<code>accept()</code> ，而不用事件处理器。因为接受新连接的逻辑简单且高效</em></p></li><li><p>Sub Reactors 的任务是<strong>监听已经建立的连接</strong>（即客户端的 socket），并处理（调用对应的事件处理器）这些连接上的 I/O 事件，比如数据到达、可写等。</p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504071033850.png" alt="image-20250407101911108" style="zoom:67%;"></p><h4 id="ET模式与LT模式"><a href="#ET模式与LT模式" class="headerlink" title="ET模式与LT模式"></a>ET模式与LT模式</h4><p><strong>LT模式：</strong> 当 <code>epoll_wait</code> 检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用 <code>epoll_wait</code>时，还会再次向应用程序通告此事件，直到该事件被处理。</p><p><strong>ET模式：</strong>当<code>epoll_wait</code>检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的<code>epoll_wait</code>调用将不再向应用程序通知这一事件。所以 ET 模式在很大程度上<strong>降低了同一个<code>epoll</code>事件被重复触发的次数</strong>，因此一半了来说效率比 LT 模式高。</p><p><strong>实际上muduo库采用的为LT模式，主要好处如下：</strong></p><ul><li><strong>不会丢失数据或者消息：</strong> 应用没有读取完数据，内核是会不断上报的。</li><li><strong>低延迟处理：</strong> 每次读数据只需要一次系统调用；照顾了多个连接的<strong>公平性</strong>，不会因为某个连接上的数据量过大而影响其他连接处理消息。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux项目相关</title>
      <link href="/posts/a61c879f.html"/>
      <url>/posts/a61c879f.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-平均负载？"><a href="#1-平均负载？" class="headerlink" title="1.平均负载？"></a><strong>1.平均负载？</strong></h4><p><strong>平均负载：</strong> 单位时间内活跃的进程数</p><p><strong>eg:</strong></p><p><strong>平均负载为 2 时，意味着什么呢？</strong></p><ul><li>系统有2个CPU：所有的CPU都刚好被完全占用。</li><li>系统有4个CPU： CPU有50%的空闲。</li><li>系统有1个CPU：一半的进程竞争不到CPU，会有进程切换</li></ul><h4 id="2-记录了1分钟、5分钟、15分钟的平均负载，到底怎么参考？"><a href="#2-记录了1分钟、5分钟、15分钟的平均负载，到底怎么参考？" class="headerlink" title="2.记录了1分钟、5分钟、15分钟的平均负载，到底怎么参考？"></a>2.记录了1分钟、5分钟、15分钟的平均负载，到底怎么参考？</h4><p><strong>负载平衡：</strong>1 分钟、5 分钟、15 分钟的三个值基本相同</p><p><strong>1 分钟的值远小于 15 分钟的值：</strong> 在14分钟的时间里系统的负载情况是有一点问题的</p><p><strong>1 分钟的值远大于 15 分钟的值：</strong> 这种增加有可能只是临时性的，需要持续观察</p><p><strong>1 分钟的平均负载接近或超过了 CPU 的个数：</strong> 系统正在发生过载的问题，就需要分析具体的问题，并进行优化了</p><p>当平均负载高于 CPU 数量 70% 的时候，你就应该分析排查负载高的问题了。</p><h4 id="3-平均负载与-CPU-使用率的区别"><a href="#3-平均负载与-CPU-使用率的区别" class="headerlink" title="3.平均负载与 CPU 使用率的区别"></a>3.平均负载与 CPU 使用率的区别</h4><p><strong>平均负载：</strong> 代表的是活跃进程数，指单位时间内，处于可运行状态和不可中断状态的进程数。</p><p><strong>CPU 使用率：</strong> 单位时间内 CPU 繁忙情况的统计。</p><p><strong>平均负载和CPU使用率未必是一致的：</strong></p><ul><li><strong>CPU 密集型进程</strong>，使用大量 CPU 会导致平均负载升高，此时这两者是一致的</li><li><strong>I/O 密集型进程</strong>，等待 I/O 也会导致平均负载升高，但 CPU 使用 率不一定很高</li></ul><h4 id="4-什么是中断？"><a href="#4-什么是中断？" class="headerlink" title="4.什么是中断？"></a>4.什么是中断？</h4><p><strong>中断其实是一种异步的事件处理机制，可以提高系统的并发处理能力</strong>，中断处理程序会打断其他进程的运行。</p><p><strong><em>注：中断处理程序在响应中断时，还会临时关闭别的中断（中断屏蔽）。这就会导致上一次中断处理完成之前，其他中断都不能响应，也就是说中断有可能会丢失。（中断队列的容量限制）</em></strong></p><h4 id="5-什么是软中断？"><a href="#5-什么是软中断？" class="headerlink" title="5.什么是软中断？"></a>5.什么是软中断？</h4><p>为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部：</p><ul><li>上半部用来快速处理中断，它<strong>在中断禁止模式下运行</strong>，主要处理跟硬件紧密相关的或时间敏感的工作。</li><li>下半部用来延迟处理上半部未完成的工作，通常以<strong>内核线程</strong>的方式运行</li></ul><p>从上半部到下半部的切换是通过<strong>软中断信号</strong>实现的</p><ul><li><p>上半部直接处理<strong>硬件请求</strong>，也就是我们常说的<strong>硬中断</strong>，特点是快速执行；</p></li><li><p>下半部则是由<strong>内核触发</strong>，也就是我们常说的软中断，特点是延迟执行。</p></li></ul><p><em>注1：软中断不只包括了硬件设备中断处理程序的下半部，一些内核自定义的事件也属于软中断</em></p><p><em>注2：同一种中断在不同 CPU 上的累积次数应该差不多。</em></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP协议</title>
      <link href="/posts/51aeee82.html"/>
      <url>/posts/51aeee82.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-什么是TCP网络分层？"><a href="#1-什么是TCP网络分层？" class="headerlink" title="1.什么是TCP网络分层？"></a>1.什么是TCP网络分层？</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504012024749.png" alt="image-20250328205930579" style="zoom:67%;"></p><p>客户端：发送HTTP数据包</p><ul><li>应用层：根据HTTP协议组装数据包</li><li>传输层：增加TCP头部（包含端口号、序列号等）</li><li>网络层：增加IP头部（包含源IP地址等）</li><li>网络接口层：增加以太网头部（包含MAC地址等）</li></ul><p>服务端：接收HTTP数据包</p><ul><li>应用层：HTTP报文解析</li><li>传输层：TCP报文解析</li><li>网络层：IP报文解析，传送数据包、确定路由</li><li>网络接口层：根据MAC地址判断包是不是发给自己的</li></ul><h4 id="2-TCP协议的三次握手为什么不能是两次？为什么不能是四次？"><a href="#2-TCP协议的三次握手为什么不能是两次？为什么不能是四次？" class="headerlink" title="2.TCP协议的三次握手为什么不能是两次？为什么不能是四次？"></a>2.TCP协议的三次握手为什么不能是两次？为什么不能是四次？</h4><p><strong>三次握手：</strong></p><ul><li>客户端向服务端发送连接请求：客户端发送请求报文将 SYN = 1 同步序列号和初始化序列号 seq = x 发送给服务端，发送完之后客户端处于 <code>SYN_Send</code> 状态 (确认客户端的发送能力、服务端的接收能力)</li><li>服务端向客户端确认：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，此时服务器处于<code>SYN_RCVD</code> 的状态(确认服务端的发送能力、客户端的接收能力)</li><li>客户端收到 SYN 报文之后，会发送⼀个 ACK 报文，当然，也是⼀样把服务器的 ISN + 1 作为ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <code>ESTABLISHED</code> 状态。服务器收到 ACK 报文之后，也处于 <code>ESTABLISHED</code>状态，此时，双方已建立起了连接 (客户端向服务端建立连接)</li></ul><h4 id="3-TCP为什么是四次挥手？"><a href="#3-TCP为什么是四次挥手？" class="headerlink" title="3.TCP为什么是四次挥手？"></a>3.TCP为什么是四次挥手？</h4><p><strong>四次挥手：</strong></p><ul><li>第一次挥手：客户端请求断开(客户端发送FIN)</li><li>第二次挥手：服务端许可客户端断开连接（服务端回ACK，缓冲区写入<code>EOF</code>文件结束符，read读到<code>EOF</code>会返回0，进入<code>close_wait</code>状态）</li><li>第三次挥手：服务器请求断开(服务端发送FIN)</li><li>第四次挥手：客户端许可服务端断开连接(发送ACK)</li></ul><p><em>注：使用close（读写端都关闭）没有四次挥手，只有使用shutdown（关闭写端）时才有四次挥手</em></p><p><strong>为什么不能是三次？</strong></p><p>​    因为TCP的连接是全双工的，每个方向上的关闭都需要单独进行确认，否则一方关闭，另一方还在继续发送数据，会导致数据的丢失。</p><p><strong>为什么第二次挥手和第三次挥手不能合成一次？</strong></p><p>​    因为服务器上可能还有尚未处理完的数据，只有等数据都处理完毕之后，才能发出断开连接的请求</p><p><strong>如果发生数据包丢失，会发生什么？</strong></p><p>​    FIN包会重传，如果超出了所设置的最大重传次数，会直接断开。而ACK不会重传，ACK丢失会导致发送FIN包的一端不断重传，直至断开。</p><h4 id="4-四次挥手为什么要有time-wait的状态？"><a href="#4-四次挥手为什么要有time-wait的状态？" class="headerlink" title="4.四次挥手为什么要有time_wait的状态？"></a>4.四次挥手为什么要有time_wait的状态？</h4><ul><li><p><strong>防止旧数据包干扰新连接：</strong>如果一个 TCP 连接关闭后立即重新使用相同的源 IP、源端口、目标 IP 和目标端口（即相同的四元组）建立新的连接，那么之前滞留在网络中的旧数据包可能会被错误地认为是新连接的数据包。</p><ul><li><code>TIME_WAIT</code> 状态的作用是等待足够长的时间（通常是 2 倍的 MSL，Maximum Segment Lifetime），以确保所有可能的旧数据包都从网络中消失。</li><li>MSL 是指一个数据包在网络中能够存活的最长时间，通常设置为 30 秒到 2 分钟。因此，<code>TIME_WAIT</code> 的持续时间一般为 2MSL（大约 1~4 分钟）。</li></ul></li><li><p><strong>确保对方收到最后的 ACK</strong></p><ul><li>在 TCP 四次挥手中，主动关闭连接的一方（通常是客户端）会发送最后一个 ACK 来确认对方的 FIN 包。然而，这个 ACK 可能会在网络中丢失。如果对方没有收到这个 ACK，它会重传 FIN 包。</li></ul></li></ul><h4 id="5-为什么TIME-WAIT是-2MSL？"><a href="#5-为什么TIME-WAIT是-2MSL？" class="headerlink" title="5.为什么TIME_WAIT是 2MSL？"></a>5.<strong>为什么TIME_WAIT是 2MSL？</strong></h4><ul><li><strong>第一个 MSL</strong>：用于确保最后一个 ACK 能够到达对方。如果对方没有收到 ACK，它会重传 FIN 包。</li><li><strong>第二个 MSL</strong>：用于确保对方重传的 FIN 包能够到达本方，并得到处理。</li></ul><h4 id="6-为什么SYN-FIN不包含数据却需要消耗一个序列号？"><a href="#6-为什么SYN-FIN不包含数据却需要消耗一个序列号？" class="headerlink" title="6.为什么SYN/FIN不包含数据却需要消耗一个序列号？"></a>6.为什么SYN/FIN不包含数据却需要消耗一个序列号？</h4><p><strong>在TCP协议中，SYN（同步）和FIN（结束）标志位的报文虽然不包含应用层数据，但它们仍然需要消耗一个序列号。</strong></p><p>这是因为:</p><p><strong>凡是需要对端的确认，一定消耗TCP报文的序列号：</strong>TCP通过序列号和确认号来检测丢包并触发重传。如果无法区分重复的SYN或FIN报文。例如，如果网络中存在延迟的SYN报文，接收方可能会错误地认为这是一个新的连接请求。</p><h4 id="7-什么是半连接队列？什么是SYN-Flood攻击？"><a href="#7-什么是半连接队列？什么是SYN-Flood攻击？" class="headerlink" title="7.什么是半连接队列？什么是SYN Flood攻击？"></a>7.什么是半连接队列？什么是SYN Flood攻击？</h4><p><strong>半连接队列：</strong>客户端<strong>伪造IP发送SYN包</strong>，而服务端回复的ACK+SYN去到了一个未知的IP地址，这会造成大量的连接无法正常建立，这样的连接会处于半连接状态，而服务器会在半连接队列中记录这样的尚未完成的连接请求。</p><p><strong>SYN Flood（洪泛攻击）：</strong> 服务器的半连接队列大小是有限的，如果半连接队列满，会无法处理正常的请求。</p><h4 id="8-说说TCP快速打开-TCP-Fast-Open-TFO-原理"><a href="#8-说说TCP快速打开-TCP-Fast-Open-TFO-原理" class="headerlink" title="8.说说TCP快速打开(TCP Fast Open, TFO)原理"></a>8.说说TCP快速打开(TCP Fast Open, TFO)原理</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504012024295.png" alt="image-20250329141017329" style="zoom:50%;"></p><p><strong>TCP快速打开（TCP Fast Open, TFO）</strong>是一种旨在减少TCP连接建立时间，从而加速网络数据传输的机制。</p><p><strong>传统的TCP的缺陷：</strong>三次握手在每次建立连接时都需要完整地进行，这会引入一定的延迟，特别是在处理小数据量的请求时这种延迟尤为明显。</p><p><strong>TFO的工作流程：</strong></p><p><strong>阶段一：首次连接（无TFO，获取Cookie）</strong></p><ul><li><strong>客户端发送SYN并请求Cookie</strong>：普通SYN包，无数据，首选项表明支持TFO。</li><li><strong>服务端生成Cookie并发送至客户端</strong>：服务端生成一个加密的Cookie（基于客户端IP、密钥等），通过<code>SYN-ACK</code>的TFO选项返回。</li><li><strong>客户端存储Cookie</strong>：客户端保存该Cookie，用于后续连接。</li></ul><p><strong>阶段二：后续连接（启用TFO，加速握手）</strong></p><ul><li><p><strong>客户端发送SYN + 数据 + Cookie</strong>：</p></li><li><p>在SYN包中直接携带应用数据（如HTTP请求）和之前存储的Cookie。</p></li><li><p><strong>服务端验证Cookie</strong>：</p><ul><li>若Cookie有效，服务端立即处理数据并返回<code>SYN-ACK</code>（同时携带响应数据）。</li><li>若无效，则回退到普通三次握手，丢弃SYN中的数据。</li></ul></li><li><p><strong>客户端确认</strong>：发送<code>ACK</code>（若服务端已返回响应数据，此ACK可能已无实际数据，仅为确认连接的可靠性，否则退化为三次握手）</p></li></ul><p><strong>TFO性能收益:</strong></p><ul><li><strong>延迟降低</strong>：短连接场景可减少1 RTT，平均延迟下降20%~30%。</li></ul><h4 id="9-TCP时间戳的作用？"><a href="#9-TCP时间戳的作用？" class="headerlink" title="9.TCP时间戳的作用？"></a>9.TCP时间戳的作用？</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504012024595.png" alt="image-20250329143009627" style="zoom: 50%;"></p><p><strong>核心作用: </strong></p><ul><li><strong>计算往返时间</strong></li><li><strong>防止序列号回绕: </strong>时间戳作为序列号的扩展，即使序列号回绕，接收方通过比较时间戳（严格递增）可区分新旧数据包，<strong>丢弃过期的重复包</strong>。</li></ul><h4 id="10-TCP的超时重传时间是如何计算的"><a href="#10-TCP的超时重传时间是如何计算的" class="headerlink" title="10.TCP的超时重传时间是如何计算的?"></a>10.TCP的超时重传时间是如何计算的?</h4><p>TCP具有超时重传机制，即间隔一段时间没有等到数据包的回复，就会重传这个数据包。这个重传间隔就是<strong>超时重传时间（RTO)。</strong></p><p><strong>经典方法：（平滑RTT来计算RTO）适用于RTT波动较小的情况</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503291516533.png" alt="image-20250329144101644" style="zoom:67%;"></p><p><em>注：SampleRTT是新采样的RTT的值。</em></p><h4 id="11-说一说TCP的流量控制"><a href="#11-说一说TCP的流量控制" class="headerlink" title="11.说一说TCP的流量控制"></a>11.说一说TCP的流量控制</h4><p><strong>TCP发送数据的过程：</strong>发送方将数据放到发送缓冲区，再由发送缓冲区发送给接收方的接收缓冲区。</p><p><strong>流量控制的目标：</strong>根据接收缓冲区的大小控制发送端的发送。如果接收缓冲区满了，发送方就不能再继续发送。</p><p><strong>流量控制的基本原理：</strong></p><ul><li><strong>窗口字段</strong>：每个TCP报文段头部都包含一个16位的窗口字段（在某些情况下，如使用窗口缩放选项时可以大于16位），该字段指示了其剩余未使用的接收缓冲区大小。</li></ul><p><em>注：随着接收方处理数据并释放缓冲区空间，它可以向发送方发送具有更新后的窗口大小的新报文段，告知发送方现在可接受更多数据。</em></p><h4 id="12-如何理解TCP的keep-alive原理？"><a href="#12-如何理解TCP的keep-alive原理？" class="headerlink" title="12.如何理解TCP的keep-alive原理？"></a>12.如何理解TCP的keep-alive原理？</h4><p>​    TCP  Keep-Alive机制用于<strong>检测长时间处于空闲状态的TCP连接是否仍然有效</strong>。在网络通信中，可能会出现由于网络故障或对端主机崩溃等原因导致的连接中断，而两端的应用程序并未意识到这种情况的发生。Keep-Alive机制通过在<strong>设定的时间间隔内没有数据传输时发送探测包来检查连接的状态</strong>，从而帮助应用程序及时发现并处理这些“死”连接。</p><h4 id="13-A、B两个主机之间建立了一个TCP连接，A主机发给B主机两个TCP报文，大小分别是500和300，第一个报文的序列号是200，那么B主机接收两个报文后，返回的确认号是多少"><a href="#13-A、B两个主机之间建立了一个TCP连接，A主机发给B主机两个TCP报文，大小分别是500和300，第一个报文的序列号是200，那么B主机接收两个报文后，返回的确认号是多少" class="headerlink" title="13.A、B两个主机之间建立了一个TCP连接，A主机发给B主机两个TCP报文，大小分别是500和300，第一个报文的序列号是200，那么B主机接收两个报文后，返回的确认号是多少?"></a>13.A、B两个主机之间建立了一个TCP连接，A主机发给B主机两个TCP报文，大小分别是500和300，第一个报文的序列号是200，那么B主机接收两个报文后，返回的确认号是多少?</h4><p><strong>TCP序列号与确认号规则：</strong></p><ul><li><strong>序列号（SEQ）</strong>：标识发送方数据字节流的起始位置。</li><li><strong>确认号（ACK）</strong>：表示接收方<strong>期望收到的下一个字节的序列号</strong>（即已成功接收所有之前的数据）。</li><li><strong>数据长度</strong>：TCP报文中实际携带的应用数据长度（不包含TCP头部）。</li></ul><p>所以确认号为500+300+200=1000</p><h4 id="14-收到IP数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议（UDP或TCP"><a href="#14-收到IP数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议（UDP或TCP" class="headerlink" title="14.收到IP数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议（UDP或TCP)?"></a>14.收到IP数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议（UDP或TCP)?</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202504012024757.png" alt="image-20250329150436272" style="zoom:50%;"></p><p><strong>IP头中有协议字段来区分IP协议的上层协议</strong></p><h4 id="15-TCP和UDP的区别？"><a href="#15-TCP和UDP的区别？" class="headerlink" title="15.TCP和UDP的区别？"></a>15.TCP和UDP的区别？</h4><p><strong>连接类型：</strong></p><ul><li><strong>TCP</strong>：面向连接的协议。在数据传输前需要通过三次握手建立连接，确保双方准备好进行通信。</li><li><strong>UDP</strong>：无连接的协议。发送数据之前不需要建立连接，直接将数据报发送到目标地址。</li></ul><p><strong>可靠性：</strong></p><ul><li><strong>TCP</strong>：提供可靠的数据传输服务。它保证数据包按顺序到达且不会丢失或损坏。如果出现问题，TCP会自动重传丢失的数据包，并确保数据完整性。</li><li><strong>UDP</strong>：不保证数据包的到达顺序、重复性或可靠性。数据可能丢失、重复或者乱序到达，但它的开销更小，速度更快。</li></ul><p><strong>流量控制与拥塞控制</strong>：</p><ul><li><strong>TCP</strong>：内置了流量控制和拥塞控制机制，能够根据网络状况调整发送速率，避免网络过载。</li><li><strong>UDP</strong>：没有内置的流量控制或拥塞控制功能，依赖于应用层来管理这些问题。</li></ul><p><strong>应用场景：</strong></p><ul><li><strong>TCP</strong>：适用于对数据准确性和顺序有严格要求的应用，如文件传输（FTP）、电子邮件（SMTP）、网页浏览（HTTP/HTTPS）等。</li><li><strong>UDP</strong>：适合对实时性要求高但对少量丢包不太敏感的应用，如视频会议、在线游戏、语音通话（VoIP）、直播流媒体等。</li></ul><h4 id="16-设计一个系统，使得发送方能够向接收方发送-1GB-数据，但不知道接收方的-IP-地址。"><a href="#16-设计一个系统，使得发送方能够向接收方发送-1GB-数据，但不知道接收方的-IP-地址。" class="headerlink" title="16.设计一个系统，使得发送方能够向接收方发送 1GB 数据，但不知道接收方的 IP 地址。"></a>16.设计一个系统，使得发送方能够向接收方发送 1GB 数据，但不知道接收方的 IP 地址。</h4><ul><li><strong>发送方发送 UDP 广播寻找接收方</strong></li><li><strong>接收方回复 IP</strong></li><li><strong>建立 TCP 连接并传输</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 发送 UDP 广播寻找接收方</span><br><span class="line"><span class="built_in">broadcast</span>(<span class="string">&quot;DATA_SEND_REQUEST&quot;</span>, port=<span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> 接收方回复 IP</span><br><span class="line">receiver_ip = <span class="built_in">wait_for_response</span>()</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span> 建立 TCP 连接并传输</span><br><span class="line">with <span class="built_in">TCPConnection</span>(receiver_ip, port=<span class="number">54321</span>) as conn:</span><br><span class="line">    conn.<span class="built_in">send_file</span>(<span class="string">&quot;1GB_data.bin&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="17-什么是网络拥塞？说一说TCP协议的拥塞控制？"><a href="#17-什么是网络拥塞？说一说TCP协议的拥塞控制？" class="headerlink" title="17.什么是网络拥塞？说一说TCP协议的拥塞控制？"></a>17.什么是网络拥塞？说一说TCP协议的拥塞控制？</h4><p><strong>网络拥塞：</strong>当网络中的流量过大时，可能会导致路由器或<strong>链路过载</strong>，进而引发<strong>丢包</strong>、延迟增加等问题。</p><p><strong>TCP 的拥塞控制机制：</strong></p><ul><li><p><strong>慢启动：</strong></p><ul><li><strong>目的</strong>：逐步探测网络的可用带宽。</li><li><strong>工作原理</strong>：<ul><li>初始阶段，发送方将拥塞窗口（<code>cwnd</code>）设置为一个较小的值</li><li>每收到一个确认（ACK），<code>cwnd</code> 值加倍（即指数增长）</li><li>当 <code>cwnd</code> 达到慢启动阈值（<code>ssthresh</code>）时，进入拥塞避免阶段</li></ul></li><li><strong>缺点</strong>：可能导致初期传输效率较低</li></ul></li><li><p><strong>拥塞避免：</strong></p><ul><li><strong>目的</strong>：平稳地增加发送速率，避免网络过载。</li><li><strong>工作原理</strong>：<ul><li><code>cwnd</code> 不再指数增长，而是线性增长（每次增加 1 个 MSS）</li><li>如果由于网络拥塞发生丢包，<code>ssthresh</code> 被设置为当前 <code>cwnd</code> 的一半，并重新进入慢启动阶段。</li></ul></li></ul></li><li><p><strong>快速重传：</strong></p><ul><li><p><strong>目的</strong>：快速恢复因丢包导致的传输中断。</p></li><li><p><strong>工作原理</strong>：当发送方收到 3 个重复的 ACK 时，认为某个数据包丢失。发送方立即重传丢失的数据包，而不必等待超时。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202504101621506.png" alt="image-20250410161758659" style="zoom:50%;"></p></li></ul></li><li><p><strong>快速恢复：</strong></p><ul><li><strong>目的</strong>：在快速重传后快速恢复正常的传输速率。</li><li><strong>工作原理</strong>：<ul><li>当检测到丢包并触发快速重传后，<code>ssthresh</code> 被设置为当前 <code>cwnd</code> 的一半。</li><li><code>cwnd</code> 被设置为 <code>ssthresh</code>，然后继续线性增长（拥塞避免）。</li></ul></li></ul></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504101625741.png" alt="image-20250410161817347" style="zoom:50%;"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用</title>
      <link href="/posts/b21cb050.html"/>
      <url>/posts/b21cb050.html</url>
      
        <content type="html"><![CDATA[<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p><strong>IO多路复用：</strong>由内核检测多个文件描述符的状态，来解决传统的阻塞式的IO，可以提高CPU的利用率。另外，相比于多线程模型，每个连接都要一个独立的线程，所需的系统开销过大，而IO多路复用只有在连接准备好进行读写操作时，才进行处理。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line">    <span class="type">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set *exceptfds, <span class="keyword">struct</span> timeval * timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>nfds：</strong>委托内核检测的这三个集合中<strong>最大的文件描述符 + 1</strong></li><li><strong>readfds：</strong>需要检测<strong>读</strong>缓冲区的文件描述符的集合</li><li><strong>writefds：</strong>需要检测<strong>写</strong>缓冲区的文件描述符的集合</li><li><strong>exceptfds：</strong> 需要检测<strong>异常</strong>缓冲区的文件描述符的集合</li><li><strong>timeout：</strong>超时时长</li></ul><p><strong>常用操作函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将文件描述符fd从set集合中删除 == 将fd对应的标志位设置为0        </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"><span class="comment">// 判断文件描述符fd是否在set集合中 == 读一下fd对应的标志位到底是0还是1</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"><span class="comment">// 将文件描述符fd添加到set集合中 == 将fd对应的标志位设置为1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"><span class="comment">// 将set集合中, 所有文件文件描述符对应的标志位设置为0, 集合中没有添加任何文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>select的局限性：</strong></p><ul><li><strong>频繁的数据复制：</strong>因为用户态和内核态之间存在严格的隔离，调用 <code>select</code> 函数会进行数据的拷贝（将文件描述符集合拷贝到内核空间，再将修改后的集合复制回用户空间），这种频繁的数据复制操作会带来额外的系统开销</li><li><strong>线性扫描：</strong>待检测文件描述符集合采取的是线性扫描的方式进行检查。</li><li><strong>默认最大文件描述符数限制</strong>：<code>select</code> 可以检测的最大文件描述符数量通常是有限制的，默认情况下这个值是 1024（由宏 <code>FD_SETSIZE</code> 定义）。</li></ul><h4 id="通信代码"><a href="#通信代码" class="headerlink" title="通信代码"></a>通信代码</h4><ul><li><p><strong>服务器端代码如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的fd</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    <span class="built_in">listen</span>(lfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的fd的状态检测委托给内核检测</span></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line">    <span class="comment">// 初始化检测的读集合</span></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    fd_set rdtemp;</span><br><span class="line">    <span class="comment">// 清零</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;rdset);</span><br><span class="line">    <span class="comment">// 将监听的lfd设置到检测的读集合中</span></span><br><span class="line">    <span class="built_in">FD_SET</span>(lfd, &amp;rdset);</span><br><span class="line">    <span class="comment">// 通过select委托内核检测读集合中的文件描述符状态, 检测read缓冲区有没有数据</span></span><br><span class="line">    <span class="comment">// 如果有数据, select解除阻塞返回</span></span><br><span class="line">    <span class="comment">// 应该让内核持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 默认阻塞</span></span><br><span class="line">        <span class="comment">// rdset 中是委托内核检测的所有的文件描述符</span></span><br><span class="line">        rdtemp = rdset;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">select</span>(maxfd+<span class="number">1</span>, &amp;rdtemp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// rdset中的数据被内核改写了, 只保留了发生变化的文件描述的标志位上的1, 没变化的改为0</span></span><br><span class="line">        <span class="comment">// 只要rdset中的fd对应的标志位为1 -&gt; 缓冲区有数据了</span></span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="comment">// 有没有新连接</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(lfd, &amp;rdtemp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 接受连接请求, 这个调用不阻塞</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliaddr;</span><br><span class="line">            <span class="type">int</span> cliLen = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">            <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;cliLen);</span><br><span class="line"><span class="comment">//accept会返回用于通信的文件描述符</span></span><br><span class="line">            <span class="comment">// 得到了有效的文件描述符</span></span><br><span class="line">            <span class="comment">// 通信的文件描述符添加到读集合</span></span><br><span class="line">            <span class="comment">// 在下一轮select检测的时候, 就能得到缓冲区的状态</span></span><br><span class="line">            <span class="built_in">FD_SET</span>(cfd, &amp;rdset);</span><br><span class="line">            <span class="comment">// 重置最大的文件描述符</span></span><br><span class="line">            maxfd = cfd &gt; maxfd ? cfd : maxfd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有新连接, 通信</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;maxfd+<span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">// 判断从监听的文件描述符之后到maxfd这个范围内的文件描述符是否读缓冲区有数据</span></span><br><span class="line">            <span class="keyword">if</span>(i != lfd &amp;&amp; <span class="built_in">FD_ISSET</span>(i, &amp;rdtemp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="comment">// 一次只能接收10个字节, 客户端一次发送100个字节</span></span><br><span class="line">                <span class="comment">// 一次是接收不完的, 文件描述符对应的读缓冲区中还有数据</span></span><br><span class="line">                <span class="comment">// 下一轮select检测的时候, 内核还会标记这个文件描述符缓冲区有数据 -&gt; 再读一次</span></span><br><span class="line">                <span class="comment">// 循环会一直持续, 知道缓冲区数据被读完位置</span></span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">read</span>(i, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端关闭了连接...\n&quot;</span>);</span><br><span class="line">                    <span class="comment">// 将检测的文件描述符从读集合中删除</span></span><br><span class="line">                    <span class="built_in">FD_CLR</span>(i, &amp;rdset);</span><br><span class="line">                    <span class="built_in">close</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 收到了数据</span></span><br><span class="line">                    <span class="comment">// 发送数据</span></span><br><span class="line">                    <span class="built_in">write</span>(i, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 异常</span></span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>客户端代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;     <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);   <span class="comment">// 服务器监听的端口, 字节序应该是网络字节序</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        <span class="comment">// sprintf(recvBuf, &quot;data: %d\n&quot;, i++);</span></span><br><span class="line">        <span class="built_in">fgets</span>(recvBuf, <span class="built_in">sizeof</span>(recvBuf), stdin);</span><br><span class="line">        <span class="built_in">write</span>(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果客户端没有发送数据, 默认阻塞</span></span><br><span class="line">        <span class="built_in">read</span>(fd, recvBuf, <span class="built_in">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>, recvBuf);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">close</span>(fd); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>对于待检测集合<code>select</code>和<code>poll</code>是基于线性方式处理的，epoll是基于红黑树来管理待检测集合的。</p><p>epoll实例就是一棵树，每个节点是<code>epoll_event</code>的结构体，结构体里有<strong><code>events</code></strong> 字段描述文件描述符的事件类型，还有<code>data</code>字段是一个联合体类型，通常存储对应的文件描述符</p><h4 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h4><p><strong>操作函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建epoll实例，通过一棵红黑树管理待检测集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">// 管理红黑树上的文件描述符(添加、修改、删除)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">// 检测epoll树中是否有就绪的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>struct epoll_event:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合体, 多个变量共用同一块内存        </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line"> <span class="type">void</span>        *ptr;</span><br><span class="line"><span class="type">int</span>          fd;<span class="comment">// 通常情况下使用这个成员, 和epoll_ctl的第三个参数相同即可</span></span><br><span class="line"><span class="type">uint32_t</span>     u32;</span><br><span class="line"><span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line"><span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="comment">//通常使用data.fd，将其设置为当前event的文件描述符</span></span><br><span class="line"><span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="通信代码（服务端）"><a href="#通信代码（服务端）" class="headerlink" title="通信代码（服务端）"></a>通信代码（服务端）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">// 本地多有的ＩＰ</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="comment">// 所有的文件描述符对应读写缓冲区状态都是委托内核进行检测的epoll</span></span><br><span class="line">    <span class="comment">// 创建一个epoll模型</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往epoll实例中添加需要检测的节点, 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.events = EPOLLIN;    <span class="comment">// 检测lfd读读缓冲区是否有数据</span></span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> evs[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">sizeof</span>(evs) / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="comment">// 持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用一次, 检测一次</span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">epoll_wait</span>(epfd, evs, size, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出当前的文件描述符</span></span><br><span class="line">            <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">            <span class="comment">// 判断这个文件描述符是不是用于监听的</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建立新的连接</span></span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">                ev.events = EPOLLIN;    <span class="comment">// 读缓冲区是否有数据</span></span><br><span class="line">                ev.data.fd = cfd;</span><br><span class="line">                ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl-accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理通信的文件描述符</span></span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">recv</span>(curfd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端已经断开了连接\n&quot;</span>);</span><br><span class="line">                    <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">close</span>(curfd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">                    <span class="built_in">send</span>(curfd, buf, len, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="epoll的工作模式"><a href="#epoll的工作模式" class="headerlink" title="epoll的工作模式"></a>epoll的工作模式</h4><p><strong>水平触发模式（LT）</strong></p><ul><li><strong>持续性通知</strong>：只要文件描述符处于就绪状态（例如，有数据可以读取），就会持续通知应用。这意味着即使你不处理完所有可用的数据，下一次调用<code>epoll_wait</code>时，如果该文件描述符仍然准备好进行操作，它将继续被包含在返回的事件列表中。</li><li><strong>易于使用</strong>：因为其持续通知特性，编程相对简单，不容易错过事件。</li><li><strong>效率</strong>：由于可能会多次通知同一个就绪状态，这在高并发场景下可能导致一定的性能损耗。</li></ul><p><strong>边沿触发模式（ET）</strong></p><ul><li><strong>一次性通知</strong>：<strong>仅当文件描述符的状态发生变化（例如，从不可读变为可读）时发出通知。</strong>这意味着如果你没有完全读取或写入所有数据，在下一次调用<code>epoll_wait</code>时可能不会再收到关于这个文件描述符的通知，除非它的状态再次改变。</li><li><strong>高效性</strong>：减少重复通知的数量，提高效率，特别适用于高负载的网络服务器等场景。</li><li><strong>复杂性增加</strong>：需要更细致地管理I/O操作，通常要求使用非阻塞I/O，并且需要确保每次触发时尽可能多地处理数据，以避免丢失事件。</li></ul><p><strong>ET模式的设置:</strong> 水平触发模式（LT）是默认的模式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">ev.events = EPOLLIN | EPOLLET;<span class="comment">// 设置边沿模式</span></span><br></pre></td></tr></table></figure><p><strong>边沿触发模式需要设置为阻塞</strong></p><p>边沿触发模式需要一次性操作缓冲区的全部数据，所以需要使用循环的结构操作数据，那么要将文件描述符设置为非阻塞，过程使用<code>fcntl()</code>进行处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置完成之后, 读写都变成了非阻塞模式</span></span><br><span class="line"><span class="type">int</span> flag = <span class="built_in">fcntl</span>(cfd, F_GETFL);</span><br><span class="line">flag |= O_NONBLOCK;                                                        </span><br><span class="line"><span class="built_in">fcntl</span>(cfd, F_SETFL, flag);</span><br></pre></td></tr></table></figure><p><em>注：当缓冲区数据被读完了，调用的read()/recv()函数还会继续从缓冲区中读数据，此时函数调用就失败了，返回-1，对应的全局变量 <code>errno</code> 值为<code>EAGAIN</code>或者 <code>EWOULDBLOCK</code></em></p><p><strong>边沿触发模式的通信代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">// 本地多有的ＩＰ</span></span><br><span class="line">    <span class="comment">// 127.0.0.1</span></span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr.s_addr);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">64</span>);<span class="comment">//将 Socket 设置为监听状态</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="comment">// 所有的文件描述符对应读写缓冲区状态都是委托内核进行检测的epoll</span></span><br><span class="line">    <span class="comment">// 创建一个epoll模型</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往epoll实例中添加需要检测的节点, 现在只有监听的文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.events = EPOLLIN;    <span class="comment">// 检测lfd读读缓冲区是否有数据</span></span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> evs[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">sizeof</span>(evs) / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="comment">// 持续检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用一次, 检测一次</span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">epoll_wait</span>(epfd, evs, size, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;==== num: %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出当前的文件描述符</span></span><br><span class="line">            <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">            <span class="comment">// 判断这个文件描述符是不是用于监听的</span></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建立新的连接</span></span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">// 将文件描述符设置为非阻塞</span></span><br><span class="line">                <span class="comment">// 得到文件描述符的属性</span></span><br><span class="line">                <span class="type">int</span> flag = <span class="built_in">fcntl</span>(cfd, F_GETFL);</span><br><span class="line">                flag |= O_NONBLOCK;</span><br><span class="line">                <span class="built_in">fcntl</span>(cfd, F_SETFL, flag);</span><br><span class="line">                <span class="comment">// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了</span></span><br><span class="line">                <span class="comment">// 通信的文件描述符检测读缓冲区数据的时候设置为边沿模式</span></span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;    <span class="comment">// 读缓冲区是否有数据</span></span><br><span class="line">                ev.data.fd = cfd;</span><br><span class="line">                ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl-accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理通信的文件描述符</span></span><br><span class="line">                <span class="comment">// 接收数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                <span class="comment">// 循环读数据</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> len = <span class="built_in">recv</span>(curfd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 非阻塞模式下和阻塞模式是一样的 =&gt; 判断对方是否断开连接</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">                        <span class="comment">// 将这个文件描述符从epoll模型中删除</span></span><br><span class="line">                        <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="built_in">close</span>(curfd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 通信</span></span><br><span class="line">                        <span class="comment">// 接收的数据打印到终端</span></span><br><span class="line">                        <span class="built_in">write</span>(STDOUT_FILENO, buf, len);</span><br><span class="line">                        <span class="comment">// 发送数据</span></span><br><span class="line">                        <span class="built_in">send</span>(curfd, buf, len, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// len == -1</span></span><br><span class="line">                        <span class="keyword">if</span>(errno == EAGAIN)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;数据读完了...\n&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h3><p>1.为什么epoll的边沿模式要使用<code>fcntl</code>将文件描述符设置为非阻塞？</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++八股7</title>
      <link href="/posts/d4769a69.html"/>
      <url>/posts/d4769a69.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-什么是STL？"><a href="#1-什么是STL？" class="headerlink" title="1. 什么是STL？"></a>1. 什么是STL？</h4><p>STL，即标准模板库</p><p><strong>STL</strong>从广义上讲主要包括三大部分：<strong>算法、容器和迭代器。</strong></p><h4 id="2-什么是RAII？"><a href="#2-什么是RAII？" class="headerlink" title="2. 什么是RAII？"></a>2. 什么是RAII？</h4><p>RAII 的全称是 <strong>Resource Acquisition Is Initialization</strong>（资源获取即初始化），这是一种 C++ 中的<strong>编程范式</strong>，用于管理资源（如内存、文件句柄、网络连接等）的生命周期。</p><p><strong>资源的分配与对象的构造绑定</strong>：在对象创建时（调用构造函数）申请或分配资源。</p><p><strong>资源的释放与对象的析构绑定</strong>：在对象销毁时（调用析构函数）自动释放资源。</p><p>智能指针（<code>std::shared_ptr</code>和<code>std::unique_ptr</code>）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记<code>delete</code>造成的内存泄漏。</p><h4 id="3-it-和-it-的区别以及哪个更好"><a href="#3-it-和-it-的区别以及哪个更好" class="headerlink" title="3.++it 和 it++ 的区别以及哪个更好?"></a>3.<code>++it</code> 和 <code>it++</code> 的区别以及哪个更好?</h4><p><strong>前置递增 (<code>++it</code>)</strong>：不需要额外创建临时对象，因此效率更高。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;  <span class="comment">// 将当前对象加 1</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后置递增 (<code>it++</code>)</strong>：后置递增首先会创建一个临时对象来保存当前值，然后调用前置递增操作修改当前对象的值，最后返回临时对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="type">int</span> temp = *<span class="keyword">this</span>; <span class="comment">// 创建一个临时对象保存当前值</span></span><br><span class="line">    ++*<span class="keyword">this</span>;          <span class="comment">// 调用前置递增操作，将当前对象加 1</span></span><br><span class="line">    <span class="keyword">return</span> temp;      <span class="comment">// 返回临时对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202504131432347.png" alt="image-20250326142820411" style="zoom:50%;"></p><h4 id="4-简述哈希表的基本原理？什么是哈希冲突？有哪些解决方法？"><a href="#4-简述哈希表的基本原理？什么是哈希冲突？有哪些解决方法？" class="headerlink" title="4. 简述哈希表的基本原理？什么是哈希冲突？有哪些解决方法？"></a>4. 简述哈希表的基本原理？什么是哈希冲突？有哪些解决方法？</h4><p><strong>哈希表的基本原理：</strong>通过一个哈希函数将键（Key）映射到一个固定范围的索引位置（桶，Bucket）</p><ul><li><p><strong>哈希函数计算</strong>：将键（Key）通过哈希函数转换为一个整数值（哈希值）。</p></li><li><p><strong>映射到桶</strong>：根据哈希值确定数据在哈希表中的存储位置（桶）。</p></li><li><p><strong>插入或查找</strong>：将数据存入对应的桶中，或者从桶中查找数据。</p></li></ul><p><strong>哈希冲突：</strong> 不同的键通过哈希函数映射到同一个哈希值。</p><p><strong>解决哈希冲突的方法：</strong></p><ul><li><p><strong>链地址法： </strong>每个桶维护一个链表（或其他数据结构），当发生冲突时，将冲突的键值对存储在链表中。</p></li><li><p><strong>开放地址法：</strong></p><p><strong>常见的探测方法有：</strong></p><ul><li><strong>线性探测（Linear Probing）</strong>：依次检查当前桶的下一个桶。</li><li><strong>二次探测（Quadratic Probing）</strong>：以平方递增的方式检查桶。</li><li><strong>双重哈希（Double Hashing）</strong>：使用第二个哈希函数计算步长。</li></ul></li><li><p><strong>再哈希法</strong></p><ul><li><strong>使用多个哈希函数</strong>，当第一个哈希函数发生冲突时，尝试使用第二个哈希函数重新计算位置。</li><li>优点：减少冲突的概率。</li><li>缺点：增加了计算复杂度。</li></ul></li></ul><p><strong>STL中的hashtable使用的是链地址法解决hash冲突问题</strong></p><h4 id="5-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素-STL-中vector删除其中的元素，迭代器如何变化？"><a href="#5-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素-STL-中vector删除其中的元素，迭代器如何变化？" class="headerlink" title="5.vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素?STL 中vector删除其中的元素，迭代器如何变化？"></a>5.vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素?STL 中vector删除其中的元素，迭代器如何变化？</h4><p><strong><code>vector</code></strong>：</p><ul><li>基于动态数组实现，内存是连续的。</li><li>支持高效的随机访问（时间复杂度为 O(1)），因为可以通过索引直接定位到任意元素。</li><li>插入和删除操作效率较低（时间复杂度为 O(n)），因为在中间或头部插入/删除时需要移动大量数据。</li><li>动态扩容：当容量不足时，会重新分配更大的内存块，并将原有数据拷贝到新内存中。</li></ul><p><strong><code>list</code></strong>：</p><ul><li>基于双向链表实现，内存是非连续的。</li><li>不支持随机访问（时间复杂度为 O(n)），需要通过遍历链表才能访问指定位置的元素。</li><li>插入和删除操作效率高（时间复杂度为 O(1)），只需要修改相关节点的指针即可。</li><li>每个节点包含三个部分：元素值、指向前一个节点的指针（prev）和指向后一个节点的指针（next）。</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202504131432772.png" alt="image-20250326150309901" style="zoom: 50%;"></p><p><strong>如何找到 <code>vector</code> 或 <code>list</code> 的倒数第二个元素：</strong></p><ul><li><p>由于 <code>vector</code> 支持随机访问，可以通过下标直接访问倒数第二个元素</p></li><li><p>由于 <code>list</code> 不支持随机访问，无法通过下标直接访问元素。但可以使用反向迭代器来访问倒数第二个元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (lst.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = lst.<span class="built_in">rbegin</span>(); <span class="comment">// 反向迭代器，指向最后一个元素</span></span><br><span class="line">        ++it;                   <span class="comment">// 移动到倒数第二个元素</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The second last element is: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;List has fewer than 2 elements.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>vector中的迭代器在使用后就失效了，而list的迭代器在使用之后还可以继续使用。</strong></p><p><strong><code>vector</code> 的迭代器失效</strong>：</p><ul><li><p><code>vector</code> 是基于连续内存的动态数组实现的。当发生插入或删除操作时，可能会导致内存重新分配（例如扩容），或者需要移动元素以保持连续性。这种情况下，原有的迭代器可能指向无效的内存地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>() + <span class="number">2</span>; <span class="comment">// 指向第三个元素（值为 3）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before insertion: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">10</span>); <span class="comment">// 在第二个位置插入元素 10</span></span><br><span class="line">    <span class="comment">// 尝试访问迭代器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After insertion: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl; <span class="comment">// 可能导致未定义行为</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>list</code> 的迭代器失效</strong>：</p><ul><li><p><code>list</code> 是基于双向链表实现的，每个节点独立存储，并通过指针连接。插入和删除操作只会影响相邻节点的指针，而不会影响其他节点的地址。因此，<code>list</code> 的迭代器在插入或删除后通常仍然有效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">next</span>(lst.<span class="built_in">begin</span>(), <span class="number">2</span>); <span class="comment">// 指向第三个元素（值为 3）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before insertion: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    lst.<span class="built_in">insert</span>(std::<span class="built_in">next</span>(lst.<span class="built_in">begin</span>(), <span class="number">1</span>), <span class="number">10</span>); <span class="comment">// 在第二个位置插入元素 10</span></span><br><span class="line">    <span class="comment">// 继续访问迭代器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After insertion: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl; <span class="comment">// 安全且正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：<code>std::next</code>: 基于给定的迭代器，向前或向后移动指定的步数，返回一个新的迭代器。</em></p></li></ul><h4 id="6-reserve-和-resize-的区别"><a href="#6-reserve-和-resize-的区别" class="headerlink" title="6. reserve 和 resize 的区别"></a>6. <code>reserve</code> 和 <code>resize</code> 的区别</h4><p><strong><code>reserve(n)</code></strong>： 只分配内存，不影响元素数量。</p><ul><li>只改变 <code>capacity()</code>，即预分配的总空间大小。</li><li>不会改变 <code>size()</code>，也不会初始化新分配的内存。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">10</span>); <span class="comment">// 预分配 10 个元素的空间</span></span><br><span class="line">std::cout &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>(); <span class="comment">// 输出：0 10</span></span><br></pre></td></tr></table></figure><p><code>resize</code>:  改变元素数量，并可能分配更多内存。</p><ul><li>改变 <code>size()</code>，即实际存储的元素数量</li><li>如果 <code>n &gt; size()</code>，会初始化新增的元素（对于基本类型，默认初始化为 0）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">10</span>); <span class="comment">// 调整大小为 10</span></span><br><span class="line">std::cout &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>(); <span class="comment">// 输出：10 10</span></span><br></pre></td></tr></table></figure><h4 id="7-容器内部删除一个元素"><a href="#7-容器内部删除一个元素" class="headerlink" title="7. 容器内部删除一个元素"></a>7. 容器内部删除一个元素</h4><p><strong>顺序容器(</strong><code>vector</code>、<code>deque</code><strong>):</strong></p><ul><li><p><code>erase(it)</code> 不仅会使被删除元素的迭代器失效，还会使被删除元素之后的所有迭代器失效。</p></li><li><p><strong>不能使用 <code>erase(it++)</code></strong></p></li><li><p><strong>正确的删除方式</strong>：<code>erase</code> 的返回值是下一个有效的迭代器，可以直接赋值给当前迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = c.<span class="built_in">begin</span>(); it != c.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (需要删除(*it)) &#123;</span><br><span class="line">        it = c.<span class="built_in">erase</span>(it); <span class="comment">// erase 返回下一个有效迭代器</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it; <span class="comment">// 如果不删除，则正常递增迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>关联容器（<code>map</code>、<code>set</code>、<code>multimap</code>、<code>multiset</code>）</strong></p><ul><li>可以安全地使用 <code>erase(it++)</code></li></ul><h4 id="8-map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？-为什么使用红黑树？"><a href="#8-map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？-为什么使用红黑树？" class="headerlink" title="8.map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？"></a>8.map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？</h4><p><strong><code>map</code> 和 <code>set</code> 的底层实现:</strong></p><ul><li><code>map</code> 和 <code>set</code> 是 C++ STL 中的关联容器，它们的底层实现通常基于<strong>红黑树</strong>。红黑树是一种自平衡二叉搜索树，它能够在插入、删除和查找操作中保持对数时间复杂度 <script type="math/tex">O(log⁡n)</script>。</li></ul><p><strong>红黑树的核心特性</strong>：</p><ul><li>每个节点要么是红色，要么是黑色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL 节点）是黑色。</li><li>如果一个节点是红色，那么它的两个子节点必须是黑色（即没有连续的红色节点）。</li><li>从任意节点到其每个叶子的所有路径都包含相同数量的黑色节点。</li></ul><p><strong><code>map</code> 和 <code>set</code> 的区别</strong>：</p><ul><li><p><strong><code>set</code></strong>：</p><ul><li>底层红黑树的节点数据类型为 <strong><code>key</code></strong>（即存储的值本身）。</li><li>插入和查找时，直接根据 <code>key</code> 进行操作。</li></ul></li><li><p><strong><code>map</code></strong>：</p><ul><li>底层红黑树的节点数据类型为 <strong><code>key + value</code></strong>（即键值对）。</li><li>插入和查找时，根据 <code>key</code> 进行操作，但节点中还存储了与 <code>key</code> 对应的 <code>value</code>。</li></ul></li></ul><p><strong>为什么使用红黑树？</strong></p><ul><li><p><strong>自动排序</strong>：红黑树作为一种二叉搜索树，能够自然地按照 <code>key</code> 的顺序组织数据。</p></li><li><p><strong>时间复杂度低</strong>：红黑树的操作（如插入、删除、查找）的时间复杂度为 <script type="math/tex">O(log⁡n)</script>，这比线性时间复杂度 <script type="math/tex">O(n)</script>​高效得多。</p><p><em>注：相比于 AVL 树，在插入和删除时的调整开销较小。</em></p></li></ul><h4 id="9-关于this指针你知道什么？"><a href="#9-关于this指针你知道什么？" class="headerlink" title="9.关于this指针你知道什么？"></a>9.关于this指针你知道什么？</h4><ul><li><p><code>this</code> 是一个常量指针（<code>const pointer</code>），指向当前对象的首地址。</p></li><li><p>它是一个隐含参数，编译器会自动将其<strong>作为非静态成员函数的第一个参数传递给函数。</strong></p><p><strong><code>this</code> 指针的作用：</strong></p></li><li><p><strong>访问类的成员</strong></p></li><li><strong>返回当前对象</strong>： 可以直接使用 <code>return *this;</code></li></ul><p><strong><code>this</code> 指针是什么时候创建的？</strong></p><ul><li><code>this</code> 指针在调用成员函数时由编译器生成，并在成员函数执行结束后销毁。</li></ul><h4 id="10-a-10-b-30-如何不使用新的变量交换两个数"><a href="#10-a-10-b-30-如何不使用新的变量交换两个数" class="headerlink" title="10.a=10,b=30,如何不使用新的变量交换两个数"></a>10.a=10,b=30,如何不使用新的变量交换两个数</h4><p><strong>使用异或：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 交换逻辑</span></span><br><span class="line">    a = a ^ b; <span class="comment">// a = 10 ^ 30</span></span><br><span class="line">    b = a ^ b; <span class="comment">// b = (10 ^ 30) ^ 30 = 10</span></span><br><span class="line">    a = a ^ b; <span class="comment">// a = (10 ^ 30) ^ 10 = 30</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-双端队列（deque-是否支持随机访问？"><a href="#11-双端队列（deque-是否支持随机访问？" class="headerlink" title="11.双端队列（deque)是否支持随机访问？"></a>11.双端队列（deque)是否支持随机访问？</h4><p><strong><code>std::deque</code>（双端队列）</strong>是 C++ STL 中的一个容器，支持在两端高效地插入和删除元素。它的底层实现基于<strong>分段连续存储结构</strong>，每个段是一个固定大小的连续内存块，这些<strong>段通过指针链接起来</strong>。这种设计使得 <code>std::deque</code> 能够在两端进行高效的插入操作。</p><p><strong><code>std::deque</code></strong>支持随机访问，可以通过下标直接访问任意位置的元素。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202504131432727.png" alt="image-20250326193256814" style="zoom: 50%;"></p><p>12.举三个智能指针的应用场景</p><ul><li><p><strong><code>std::shared_ptr</code> 在多线程编程中保证线程安全的引用计数</strong></p><p>在多线程环境中，多个线程可能需要共享同一个对象（例如数据库连接池、配置文件对象等），并且需要确保对象在所有线程都使用完毕后才被释放。<code>std::shared_ptr</code> 的引用计数是线程安全的，因此可以用来实现这种共享。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseConnection</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">const</span> std::string&amp; sql)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Executing query: &quot;</span> &lt;&lt; sql &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadTask</span><span class="params">(std::shared_ptr&lt;DatabaseConnection&gt; conn, <span class="type">const</span> std::string&amp; queryStr)</span> </span>&#123;</span><br><span class="line">    conn-&gt;<span class="built_in">query</span>(queryStr); <span class="comment">// 使用共享的数据库连接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> dbConn = std::<span class="built_in">make_shared</span>&lt;DatabaseConnection&gt;(); <span class="comment">// 创建一个共享的数据库连接</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadTask, dbConn, <span class="string">&quot;SELECT * FROM users&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(threadTask, dbConn, <span class="string">&quot;SELECT * FROM products&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>(); <span class="comment">// 等待线程1完成</span></span><br><span class="line">    t2.<span class="built_in">join</span>(); <span class="comment">// 等待线程2完成</span></span><br><span class="line">    <span class="comment">// 当所有线程都完成后，dbConn 自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::unique_ptr</code> 在工厂模式中返回独占所有权的对象</strong></p><p><code>std::unique_ptr</code> 明确表示对象的所有权不可共享。</p></li><li><p><strong><code>std::weak_ptr</code>：检测对象是否已被销毁</strong></p><p>使用 <code>std::weak_ptr</code> 来检测对象是否仍然有效（即是否已经被销毁）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Event triggered!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;EventListener&gt; listener = std::<span class="built_in">make_shared</span>&lt;EventListener&gt;();</span><br><span class="line">    std::weak_ptr&lt;EventListener&gt; weakListener = listener; <span class="comment">// 创建弱引用</span></span><br><span class="line">    <span class="comment">// 模拟事件触发</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> strongListener = weakListener.<span class="built_in">lock</span>()) &#123; <span class="comment">// 尝试提升为 shared_ptr</span></span><br><span class="line">        strongListener-&gt;<span class="built_in">onEvent</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Listener has been destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 销毁 listener</span></span><br><span class="line">    listener.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="comment">// 再次尝试触发事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> strongListener = weakListener.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">        strongListener-&gt;<span class="built_in">onEvent</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Listener has been destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：<code>weakListener.lock()</code> 是 C++ 中 <code>std::weak_ptr</code> 提供的一个成员函数，用于尝试将弱引用（<code>std::weak_ptr</code>）提升为强引用（<code>std::shared_ptr</code>）。它的主要作用是检查底层对象是否仍然存在，并在对象有效时返回一个 <code>std::shared_ptr</code>。对象不存在返回空指针。</em></p></li></ul><h4 id="12-举例说明万能引用和完美转发的作用"><a href="#12-举例说明万能引用和完美转发的作用" class="headerlink" title="12.举例说明万能引用和完美转发的作用"></a>12.举例说明万能引用和完美转发的作用</h4><p><strong>万能引用</strong>： 指的是那些<strong>可以绑定到左值引用或右值引用的引用类型</strong></p><p>当一个模板函数的参数类型为 <code>T&amp;&amp;</code> 并且 <code>T</code> 是通过模板参数推导出来的，则该参数是一个万能引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayType</span><span class="params">(T&amp;&amp; val)</span> </span>&#123; <span class="comment">// 这里 T&amp;&amp; 是一个万能引用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">displayType</span>(x);        <span class="comment">// 左值传递给万能引用</span></span><br><span class="line">    <span class="built_in">displayType</span>(<span class="number">20</span>);       <span class="comment">// 右值传递给万能引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>完美转发:</strong></p><p><strong>完美转发:</strong> 允许函数模板将参数按其原始形式（包括值类别：左值或右值）转发给另一个函数。这意味着如果传入的是一个右值，那么它将以右值的形式被转发；如果是左值，则以左值的形式被转发。</p><ul><li><p><strong>完美转发</strong>借助于万能引用和 <code>std::forward</code>，能够让函数模板准确地将参数按照它们的原始类型和值类别转发给其他函数，保持了参数的特性和优化机会</p></li><li><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;utility&gt; // std::forward 所在头文件// 一个简单的函数，用于接收左值或右值void process(int&amp; x) &#123;    std::cout &lt;&lt; &quot;Lvalue reference: &quot; &lt;&lt; x &lt;&lt; std::endl;&#125;void process(int&amp;&amp; x) &#123;    std::cout &lt;&lt; &quot;Rvalue reference: &quot; &lt;&lt; x &lt;&lt; std::endl;&#125;// 模板函数，使用 std::forward 实现完美转发template&lt;typename T&gt;void wrapper(T&amp;&amp; arg) &#123;    process(std::forward&lt;T&gt;(arg)); // 使用 std::forward 转发参数&#125;int main() &#123;    int x = 42;    wrapper(x);       // 传入左值    wrapper(42);      // 传入右值    return 0;&#125;</code></pre></li></ul><h4 id="13-extern-“C”的作用"><a href="#13-extern-“C”的作用" class="headerlink" title="13.extern “C”的作用"></a>13.extern “C”的作用</h4><p><strong>extern “C”：</strong> 用于告诉编译器按照C语言的方式编译和链接函数或变量，来解决兼容性的问题。</p><p><strong>为什么需要extern “C”？</strong></p><p><strong>C++:</strong> 支持函数重载，在编译时会修改函数名，加入参数类型信息。</p><p><strong>C:</strong> 不支持重载，编译后函数名不会改变。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>套接字通信</title>
      <link href="/posts/d3b8d1d4.html"/>
      <url>/posts/d3b8d1d4.html</url>
      
        <content type="html"><![CDATA[<h2 id="套接字通信"><a href="#套接字通信" class="headerlink" title="套接字通信"></a>套接字通信</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><h4 id="1-1-局域网和广域网"><a href="#1-1-局域网和广域网" class="headerlink" title="1.1 局域网和广域网"></a>1.1 局域网和广域网</h4><p><strong>局域网：</strong>局域网将<strong>一定区域内</strong>的各种计算机、外部设备和数据库连接起来形成计算机通信的<strong>私有网络</strong>。、</p><ul><li>局域网的主要特点是传输速度快、延迟低、成本较低且安全性高。</li></ul><p><strong>广域网：</strong>又称广域网、外网、公网。是<strong>连接不同地区局域网</strong>或城域网计算机通信的远程<strong>公共网络</strong>。</p><ul><li>广域网相对于局域网来说，传输速度较慢，延迟较高。</li></ul><h4 id="1-2-IP和端口"><a href="#1-2-IP和端口" class="headerlink" title="1.2 IP和端口"></a>1.2 IP和端口</h4><p><strong>IP:</strong> 是分配给网络上每个<strong>设备的唯一标识符</strong>，用于在网络中进行通信。</p><ul><li><p><strong>IPv4</strong></p><ul><li>IPv4使用32位整数来表示一个IP地址，这相当于<strong>4个字节</strong>。通常，这个32位的地址被分为四部分，每部分8位（1字节），并<strong>以点分十进制格式表示。</strong></li><li>最小的IPv4地址是 <code>0.0.0.0</code>，而最大的是 <code>255.255.255.255</code></li><li>鉴于IPv4采用32位地址，理论上总共可以提供 <script type="math/tex">2^{32}</script>​个不同的地址</li></ul></li><li><p><strong>IPv6</strong></p><ul><li>IPv6使用128位整数来表示一个IP地址，等同于<strong>16个字节</strong>。</li><li>Pv6地址<strong>写作8组，每组4个十六进制数字</strong>，各组之间<strong>用冒号分隔</strong>，例如 <code>2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b</code>。</li><li>由于IPv6采用128位地址长度，所以它可以提供的地址总数为 <script type="math/tex">2^{128}</script></li></ul></li></ul><p><strong>端口: 用于定位主机上的特定进程。</strong></p><ul><li><p>端口号是一个16位的无符号整数（<code>unsigned short</code>），<strong>其取值范围是0到65535（<script type="math/tex">2^{16}−1</script>​）</strong></p></li><li><p><strong>只有那些涉及网络通信的进程才需要绑定端口。</strong>如果一个进程不需要与网络上的其他设备进行通信，那么它就不必绑定端口。</p></li><li><p><strong>一个端口可以被重复使用吗？</strong></p><p>在任何给定时间，<strong>一个具体的端口只能由一个进程独占使用</strong>。这意味着在同一时刻，多个进程不能同时监听同一个端口以接收数据。然而，一旦某个进程完成了对特定端口的使用并释放了它，该端口就可以被新的进程重新绑定和使用。此外，在一些情况下，如<strong>TCP连接结束后，可能会有一段等待时间（TIME_WAIT状态），在此期间端口暂时不可用，以确保网络上的数据包不会被错误地路由到新建立的连接上。</strong></p></li></ul><h4 id="1-3-网络分层模型"><a href="#1-3-网络分层模型" class="headerlink" title="1.3 网络分层模型"></a>1.3 网络分层模型</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202503282055052.png" alt="image-20250325150840912" style="zoom:67%;"></p><ul><li><p><strong>应用层</strong>：直接为用户提供服务，负责处理特定的应用程序细节。</p></li><li><p><strong>表示层</strong>：将数据转换为兼容格式进行传输，包括加密、压缩等操作。</p></li><li><strong>会话层</strong>：管理不同机器上进程之间的对话，控制对话连接的建立和终止。</li><li><strong>传输层</strong>：确保端到端的数据可靠传输，提供错误检测和恢复功能。主要协议有TCP和UDP。</li><li><strong>网络层</strong>：负责数据包的路由选择和转发，决定数据如何从源地址到达目的地址。IP协议工作在此层。</li><li><strong>数据链路层</strong>：在不可靠的物理连接上提供可靠的数据传输，处理错误检测和纠正。以太网协议工作于此层。</li><li><strong>物理层</strong>：定义了硬件设备的标准，如电压水平、线缆类型、针脚布局等，以及如何通过物理媒介传输比特流。</li></ul><h3 id="2-socket编程"><a href="#2-socket编程" class="headerlink" title="2.socket编程"></a>2.socket编程</h3><h4 id="2-1-字节序"><a href="#2-1-字节序" class="headerlink" title="2.1 字节序"></a>2.1 字节序</h4><p><strong>字节序:</strong> 大于一个字节类型的数据在内存中的存放顺序，也就是说对于单字符来说是没有字节序问题的，字符串是单字符的集合，因此字符串也没有字节序问题。</p><ul><li><p><strong>主机字节序 (小端):</strong> 数据的低位字节存储到内存的低地址位, 数据的高位字节存储到内存的高地址位</p></li><li><p><strong>网络字节序 (大端):</strong> 数据的低位字节存储到内存的高地址位, 数据的高位字节存储到内存的低地址位</p><p><em>注：<strong>套接字通信过程中操作的数据都是大端存储的</strong>，包括：接收/发送的数据、IP地址、端口。</em></p></li></ul><h4 id="2-2-大小端转换"><a href="#2-2-大小端转换" class="headerlink" title="2.2 大小端转换"></a>2.2 大小端转换</h4><p><strong>主机字节序的IP地址转换为网络字节序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>; </span><br></pre></td></tr></table></figure><p><code>af</code>: 地址族(IP地址的家族包括ipv4和ipv6)协议</p><ul><li><code>AF_INET</code>: ipv4格式的ip地址</li><li><code>AF_INET6</code>: ipv6格式的ip地址</li></ul><p><code>src</code>: 传入参数</p><p><code>dst</code>: 传出参数, 函数调用完成, 转换得到的大端整形IP被写入到这块内存中</p><p>返回值：成功返回1，失败返回0或者-1</p><p><strong>将大端的整形数, 转换为小端的点分十进制的IP地址 :</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p><code>af</code>: 地址族(IP地址的家族包括ipv4和ipv6)协议</p><ul><li><code>AF_INET</code>: ipv4格式的<code>ip</code>地址</li><li><code>AF_INET6</code>: ipv6格式的<code>ip</code>地址</li></ul><p><code>src</code>: 传入参数, 这个指针指向的内存中存储了大端的整形IP地址</p><p><code>dst</code>: 传出参数, 存储转换得到的小端的点分十进制的IP地址 </p><p><code>size</code>: 修饰<code>dst</code>参数的, 标记<code>dst</code>指向的内存中最多可以存储多少个字节</p><p>返回值:</p><ul><li>成功: 指针指向第三个参数对应的内存地址, 通过返回值也可以直接取出转换得到的IP字符串</li><li>失败: <code>NULL</code></li></ul><h4 id="2-3-sockaddr"><a href="#2-3-sockaddr" class="headerlink" title="2.3 sockaddr"></a>2.3 sockaddr</h4><p><code>sockaddr</code>: 一个通用的、协议无关的套接字地址结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;       <span class="comment">// 地址族协议, 比如 IPv4 (AF_INET)</span></span><br><span class="line">    <span class="type">char</span>        sa_data[<span class="number">14</span>];     <span class="comment">// 端口(2字节) + IP地址(4字节) + 填充(8字节)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sockaddr_in</code>: 是专门针对 IPv4 协议设计的套接字地址结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>   <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;      <span class="comment">// 端口类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;      <span class="comment">// IP 地址类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>; <span class="comment">// 地址族类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof(unsigned short int))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;          <span class="comment">// 地址族协议: AF_INET</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;              <span class="comment">// 端口, 2 字节 -&gt; 大端</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;         <span class="comment">// IP 地址, 4 字节 -&gt; 大端</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>];       <span class="comment">// 填充 8 字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;  <span class="comment">// IP 地址，4 字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-4-套接字函数"><a href="#2-4-套接字函数" class="headerlink" title="2.4 套接字函数"></a>2.4 套接字函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个套接字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p><code>domain</code>: 使用的地址族协议</p><ul><li>AF_INET: 使用IPv4格式的ip地址</li><li>AF_INET6: 使用IPv6格式的ip地址</li></ul><p><code>type</code>:</p><ul><li>SOCK_STREAM: 使用流式的传输协议</li><li>SOCK_DGRAM: 使用报式(报文)的传输协议</li></ul><p><code>protocol</code>: 一般写0即可, 使用默认的协议</p><ul><li>SOCK_STREAM: 流式传输默认使用的是tcp</li><li>SOCK_DGRAM: 报式传输默认使用的udp</li></ul><p><strong>函数的返回值是一个文件描述符，通过这个文件描述符可以操作内核中的某一块内存，网络通信是基于这个文件描述符来完成的。</strong></p><h4 id="2-5-bind"><a href="#2-5-bind" class="headerlink" title="2.5 bind"></a>2.5 bind</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将文件描述符和本地的IP与端口进行绑定   </span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure><p>参数:</p><ul><li><code>sockfd</code>: 监听的文件描述符, 通过<code>socket()</code>调用得到的返回值</li><li><code>addr</code>: 传入参数, 要绑定的IP和端口信息需要初始化到这个结构体中，IP和端口要转换为网络字节序</li><li><code>addrlen</code>: 参数<code>addr</code>指向的内存大小, <code>sizeof(struct sockaddr)</code></li></ul><h3 id="3-TCP通信流程"><a href="#3-TCP通信流程" class="headerlink" title="3.TCP通信流程"></a>3.TCP通信流程</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202503282055645.png" alt="image-20250325161611700" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503282055352.png" alt="image-20250325161638441" style="zoom:67%;"></p><p><strong>在tcp的服务器端, 有两类文件描述符：</strong></p><ul><li><p><strong>监听的文件描述符</strong></p><ul><li><strong>只需要有一个</strong></li><li>不负责和客户端通信, 负责检测客户端的连接请求, 检测到之后调用accept就可以建立新的连接</li></ul></li><li><p><strong>通信的文件描述符</strong></p><ul><li>负责和建立连接的客户端通信</li><li><strong>如果有N个客户端和服务器建立了新的连接, 通信的文件描述符就有N个</strong>，每个客户端和服务器都对应一个通信的文件描述符</li></ul></li></ul><p><strong>基于tcp的服务器端通信代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏一般用于本地的绑定操作</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line"><span class="comment">//    inet_pton(AF_INET, &quot;192.168.237.131&quot;, &amp;addr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliaddr;</span><br><span class="line">    <span class="type">int</span> clilen = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">    <span class="comment">//(struct sockaddr*)&amp;cliaddr：用于存储客户端的地址信息（IP 地址和端口号）。</span></span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印客户端的地址信息</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">24</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP地址: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">           <span class="built_in">inet_ntop</span>(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, <span class="built_in">sizeof</span>(ip)),</span><br><span class="line">           <span class="built_in">ntohs</span>(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 和客户端通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(cfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">            <span class="built_in">write</span>(cfd, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于tcp通信的客户端通信代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;192.168.237.131&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 和服务器端通信</span></span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;你好, 服务器...%d\n&quot;</span>, number++);</span><br><span class="line">        <span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器say: %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);   <span class="comment">// 每隔1s发送一条数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-补充"><a href="#4-补充" class="headerlink" title="4.补充"></a>4.补充</h3><h4 id="4-1-什么是-Socket？"><a href="#4-1-什么是-Socket？" class="headerlink" title="4.1 什么是 Socket？"></a>4.1 什么是 Socket？</h4><p>Socket 可以看作是一个<strong>应用程序与网络之间的接口</strong>，它定义了如何进行数据发送和接收的方式。</p><h4 id="4-2-Socket-的类型有哪些？"><a href="#4-2-Socket-的类型有哪些？" class="headerlink" title="4.2 Socket 的类型有哪些？"></a>4.2 Socket 的类型有哪些？</h4><ul><li><strong>流式套接字（SOCK_STREAM）</strong>：基于 TCP 协议，面向连接，可靠。</li><li><strong>数据报套接字（SOCK_DGRAM）</strong>：基于 UDP 协议，无连接，不可靠。</li></ul><h4 id="4-3-如何创建一个-Socket？"><a href="#4-3-如何创建一个-Socket？" class="headerlink" title="4.3 如何创建一个 Socket？"></a>4.3 如何创建一个 Socket？</h4><p><strong>创建一个 Socket需要指定所使用的地址族和协议类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sockfd = socket(AF_INET, SOCK_STREAM, 0);</span><br></pre></td></tr></table></figure><ul><li><code>AF_INET</code>：IPv4 地址族。</li><li><code>SOCK_STREAM</code>：流式套接字。</li><li>第三个参数通常为 0，表示使用默认协议。</li></ul><h4 id="4-4-bind-函数的作用是什么？"><a href="#4-4-bind-函数的作用是什么？" class="headerlink" title="4.4 bind 函数的作用是什么？"></a>4.4 bind 函数的作用是什么？</h4><p>将 Socket 绑定到指定的 IP 地址和端口号。</p><h4 id="4-5-listen-函数的作用是什么？"><a href="#4-5-listen-函数的作用是什么？" class="headerlink" title="4.5 listen 函数的作用是什么？"></a>4.5 listen 函数的作用是什么？</h4><p>将 Socket 设置为监听状态（它并不会阻塞程序，而是告诉操作系统：“我现在准备好了，可以开始接受客户端的连接请求了。”）</p><h4 id="4-6-accept-函数的作用是什么？"><a href="#4-6-accept-函数的作用是什么？" class="headerlink" title="4.6 accept 函数的作用是什么？"></a>4.6 accept 函数的作用是什么？</h4><p><strong>进入阻塞状态</strong>等待接受客户端的连接请求，并返回一个新的 Socket 文件描述符用于通信。</p><h4 id="4-7-connect-函数的作用是什么？"><a href="#4-7-connect-函数的作用是什么？" class="headerlink" title="4.7 connect 函数的作用是什么？"></a>4.7 connect 函数的作用是什么？</h4><p>客户端调用该函数向服务器发起连接请求。</p><h4 id="4-8-服务器中的两个文件描述符各自的作用？"><a href="#4-8-服务器中的两个文件描述符各自的作用？" class="headerlink" title="4.8 服务器中的两个文件描述符各自的作用？"></a>4.8 服务器中的两个文件描述符各自的作用？</h4><p>服务器上分别有用于监听的文件描述符和用于通信的文件描述符，其各自有两个缓冲区，读缓冲区和写缓冲区。</p><p>监听的文件描述符所对应的读缓冲区用于接收客户端的连接请求，当调用accept()时会检测监听的文件描述符的读缓冲区是否有请求数据，如果有请求数据accept()会解除阻塞和对应的客户端建立连接。</p><p>通信的文件描述符的读缓冲区用于存储客户端所发送的通信数据，调用read()（没有数据则阻塞）可以把数据从读缓冲区读出来，write()把数据再写入写缓冲区（缓冲区满则阻塞），然后内核会将写缓冲区的数据发送给对应的客户端的读缓冲区。</p><h4 id="4-9-read-recv-write-send区别？"><a href="#4-9-read-recv-write-send区别？" class="headerlink" title="4.9 read/recv write/send区别？"></a>4.9 read/recv write/send区别？</h4>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++八股6</title>
      <link href="/posts/a371aaff.html"/>
      <url>/posts/a371aaff.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-为什么虚函数能实现动态绑定？"><a href="#1-为什么虚函数能实现动态绑定？" class="headerlink" title="1.为什么虚函数能实现动态绑定？"></a>1.为什么虚函数能实现动态绑定？</h4><p>虚函数能实现动态绑定主要通过虚函数表和虚函数指针实现的</p><p><strong>动态绑定的具体过程：</strong></p><ul><li><p><strong>调用虚函数：</strong></p><p>当通过基类指针或引用调用虚函数时，编译器生成的代码不会直接调用函数，而是<strong>通过虚函数指针查找虚函数表中的函数地址。</strong></p></li><li><p><strong>查找虚函数表：</strong></p><ul><li>编译器会根据对象的虚函数指针找到该对象所属类的虚函数表。</li><li>在虚函数表中查找对应虚函数的地址。</li></ul></li><li><p><strong>调用实际函数：</strong></p><ul><li>根据虚函数表中的地址，调用实际的函数版本。</li><li>如果派生类重写了虚函数，则调用派生类的版本；否则调用基类的版本。</li></ul><p><strong>注：虚函数表 vs 虚函数指针</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503250956902.png" alt="image-20250323153658854" style="zoom:67%;"></p></li></ul><h4 id="2-如何禁止程序自动生成拷贝构造函数？"><a href="#2-如何禁止程序自动生成拷贝构造函数？" class="headerlink" title="2.如何禁止程序自动生成拷贝构造函数？"></a>2.如何禁止程序自动生成拷贝构造函数？</h4><ul><li><strong>方法一：将拷贝构造函数和拷贝赋值函数设置为 <code>private</code></strong></li><li><strong>方法二：直接使用 <code>= delete</code> 来显式删除函数</strong></li></ul><h4 id="3-你知道回调函数吗？它的作用？"><a href="#3-你知道回调函数吗？它的作用？" class="headerlink" title="3.你知道回调函数吗？它的作用？"></a>3.你知道回调函数吗？它的作用？</h4><p>回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。（Qt中的槽函数）</p><h4 id="4-介绍一下友元函数和友元类的用法和作用"><a href="#4-介绍一下友元函数和友元类的用法和作用" class="headerlink" title="4.介绍一下友元函数和友元类的用法和作用"></a>4.介绍一下友元函数和友元类的用法和作用</h4><p>友元（friend）机制允许某些函数或类访问另一个类的私有（private）和保护（protected）成员。</p><p><strong>友元关系打破了封装性，但提供了灵活性。</strong></p><p><strong>友元函数：</strong>友元函数是一个非成员函数（定义在类外的普通函数，不属于任何类），但它可以访问类的私有和保护成员。<strong>友元函数在类的外部定义，但在类内部声明为友元。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> data) : <span class="built_in">privateData</span>(data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPrivateData</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义友元函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPrivateData</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Private data: &quot;</span> &lt;&lt; obj.privateData &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPrivateData</span>(obj);  <span class="comment">// 输出: Private data: 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>友元类</strong>: 友元类是一个类，它的所有成员函数都可以访问另一个类的私有和保护成员。友元类在类内部声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> data) : <span class="built_in">privateData</span>(data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元类</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printPrivateData</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Private data: &quot;</span> &lt;&lt; obj.privateData &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    FriendClass friendObj;</span><br><span class="line">    friendObj.<span class="built_in">printPrivateData</span>(obj);  <span class="comment">// 输出: Private data: 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li><strong>封装性</strong>：友元机制破坏了封装性，应谨慎使用，避免过度依赖。</li><li><strong>单向性</strong>：友元关系是单向的且没有传递性。如果类A是类B的友元，类B不会自动成为类A的友元。</li><li><strong>继承</strong>：友元关系不继承。如果类A是类B的友元，类A的派生类不会自动成为类B的友元。</li></ul><h4 id="5-delete和delete-区别？"><a href="#5-delete和delete-区别？" class="headerlink" title="5.delete和delete[]区别？"></a>5.delete和delete[]区别？</h4><ul><li>delete只会调用⼀次析构函数。</li><li>delete[]会调用数组中每个元素的析构函数。</li></ul><h4 id="6-类的对象存储空间？"><a href="#6-类的对象存储空间？" class="headerlink" title="6.类的对象存储空间？"></a>6.类的对象存储空间？</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202503250956132.png" alt="image-20250323161815483" style="zoom: 50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503250956935.png" alt="image-20250323162003652" style="zoom: 50%;"></p><h4 id="7-构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"><a href="#7-构造函数能否声明为虚函数或者纯虚函数，析构函数呢？" class="headerlink" title="7.构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"></a>7.构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</h4><p><strong>析构函数： </strong>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。</p><p><em>注1：只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</em></p><p><em>注2：析构函数也可以是纯虚函数。</em></p><p><strong>构造函数：</strong>构造函数不能定义为虚函数。</p><p><strong>虚函数要使用虚函数指针（vptr）调用，而对象没有进行初始化就没有虚函数指针（vptr）。</strong></p><h4 id="8-什么是线程？线程与进程的区别是什么？"><a href="#8-什么是线程？线程与进程的区别是什么？" class="headerlink" title="8.什么是线程？线程与进程的区别是什么？"></a>8.什么是线程？线程与进程的区别是什么？</h4><ul><li>线程是操作系统调度的最小单位，进程是资源分配的基本单位。</li><li>同一进程内的线程共享内存空间，而不同进程有独立的地址空间。</li></ul><h4 id="9-线程同步有哪些常见方式？请简要说明。"><a href="#9-线程同步有哪些常见方式？请简要说明。" class="headerlink" title="9.线程同步有哪些常见方式？请简要说明。"></a>9.线程同步有哪些常见方式？请简要说明。</h4><ul><li><strong>互斥锁 (Mutex)</strong>: 防止多个线程同时访问共享资源。</li><li><strong>条件变量 (Condition Variable)</strong>: 用于线程间的通信。</li><li><strong>信号量 (Semaphore)</strong>: 控制对共享资源的访问数量。</li><li><strong>原子操作 (Atomic)</strong>: 保证某些操作的不可分割性。</li></ul><h4 id="10-什么是死锁？如何避免死锁？"><a href="#10-什么是死锁？如何避免死锁？" class="headerlink" title="10.什么是死锁？如何避免死锁？"></a>10.什么是死锁？如何避免死锁？</h4><p><strong>定义</strong>: 多个线程因为循环等待资源而无法继续执行。</p><p><strong>避免方法</strong>:</p><ul><li>按顺序获取锁。</li><li>使用超时机制尝试加锁。</li></ul><h4 id="11-什么是线程安全？如何实现线程安全？"><a href="#11-什么是线程安全？如何实现线程安全？" class="headerlink" title="11.什么是线程安全？如何实现线程安全？"></a>11.什么是线程安全？如何实现线程安全？</h4><p><strong>线程安全的定义：</strong>如果多线程程序每一次的运行结果和单线程程序的运行结果始终一样，那么就是线程安全的</p><p><strong>实现方法</strong>:</p><ul><li>使用互斥锁保护共享资源。</li><li>使用原子变量（如 <code>std::atomic</code>）</li></ul><h4 id="12-什么是线程池？为什么使用线程池？"><a href="#12-什么是线程池？为什么使用线程池？" class="headerlink" title="12.什么是线程池？为什么使用线程池？"></a>12.什么是线程池？为什么使用线程池？</h4><p><strong>线程池（Thread  Pool）</strong>是一种用于管理线程的机制，预先创建一组线程，并将任务提交到一个任务队列中，线程从队列中取出任务并执行。</p><p><strong>优点</strong>:</p><ul><li>减少频繁创建和销毁线程的开销。</li><li>提高响应速度。</li><li>控制并发线程的数量，避免资源耗尽。</li></ul><h4 id="13-什么是原子操作？C-中如何使用原子操作？"><a href="#13-什么是原子操作？C-中如何使用原子操作？" class="headerlink" title="13.什么是原子操作？C++中如何使用原子操作？"></a>13.什么是原子操作？C++中如何使用原子操作？</h4><p><strong>原子操作(Atomic Operation)：</strong>是指在多线程环境下不会被线程调度机制打断的操作，这种操作一旦开始，就会一直运行到结束，中间不会有任何线程切换。原子操作是线程安全的基本保证。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// 原子整型变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        counter++; <span class="comment">// 原子自增操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-在多线程环境下，如何正确地停止一个线程？"><a href="#14-在多线程环境下，如何正确地停止一个线程？" class="headerlink" title="14.在多线程环境下，如何正确地停止一个线程？"></a>14.在多线程环境下，如何正确地停止一个线程？</h4><p><strong>使用标志变量控制线程的退出:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">stop</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Working...\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread stopped.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(worker)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-线程池是怎么构建的，遇到过什么问题是怎样解决的？"><a href="#15-线程池是怎么构建的，遇到过什么问题是怎样解决的？" class="headerlink" title="15.线程池是怎么构建的，遇到过什么问题是怎样解决的？"></a>15.线程池是怎么构建的，遇到过什么问题是怎样解决的？</h4><p><strong>构建线程池的一般步骤：</strong></p><ul><li><strong>确定线程池大小</strong>：线程池的大小通常基于可用的处理器核心数以及程序的具体需求进行设置。</li><li><strong>任务队列</strong>：用于存放待执行的任务。</li><li><strong>工作线程</strong>：这是线程池中的实际工作者。</li><li><strong>管理机制</strong>：包括添加任务、关闭线程池、处理异常等操作。</li></ul><p><strong>问题：</strong></p><ul><li>访问任务队列时，要加互斥锁和条件变量</li><li>析构函数要正确地退出所有线程，如果没有正确管理线程生命周期，可能会出现线程泄漏的情况，即线程完成任务后没有正常退出。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程编程</title>
      <link href="/posts/2148a8a.html"/>
      <url>/posts/2148a8a.html</url>
      
        <content type="html"><![CDATA[<h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><p><strong>头文件：</strong><code>#include&lt;thread&gt;</code></p><p><strong>创建线程:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个线程并执行 threadFunction</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    <span class="comment">// 主线程继续执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main!\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 等待线程 t 完成(join是一个阻塞等待)</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分离线程:</strong> 不希望主线程等待子线程完成，可以调用<code>detach()</code>方法。分离后的线程将在后台运行，主线程不再与之关联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    <span class="comment">// 分离线程</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">// 主线程继续执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main!\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 注意：分离后的线程无法再 join</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>传递参数给线程函数:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, str = &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="comment">// 创建线程并传递参数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction, x, str)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>std::thread</code> :</strong> 提供了一个成员函数 <code>joinable()</code>，用于检查一个线程对象是否可以被 <strong>join</strong> 或 <strong>detach</strong>。</p><p><strong><code>std::ref</code>:</strong> 创建对象的引用包装器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x += <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(foo, std::ref(a))</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子线程调用类的成员函数"><a href="#子线程调用类的成员函数" class="headerlink" title="子线程调用类的成员函数"></a>子线程调用类的成员函数</h4><p><strong>直接传递成员函数指针和对象实例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunction</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Member function called with x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="comment">// 直接传递成员函数指针和对象实例</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(&amp;MyClass::memberFunction, &amp;obj, <span class="number">42</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 std::shared_ptr 来管理类对象的生命周期，确保在线程执行期间对象不会被销毁:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() </span><br><span class="line">        &lt;&lt; <span class="string">&quot; started&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; obj = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(&amp;MyClass::func, obj)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="互斥量解决多线程数据共享问题"><a href="#互斥量解决多线程数据共享问题" class="headerlink" title="互斥量解决多线程数据共享问题"></a>互斥量解决多线程数据共享问题</h4><p><strong>头文件：</strong><code>#include &lt;mutex&gt;</code></p><p><strong>线程安全的定义：</strong>如果多线程程序每一次的运行结果和单线程程序的运行结果始终一样，那么就是线程安全的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        mtx.<span class="built_in">lock</span>();<span class="comment">//加锁</span></span><br><span class="line">        shared_data++;        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; n </span><br><span class="line">        &lt;&lt; <span class="string">&quot; increment shared_data to &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>(); <span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final shared_data = &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="互斥量封装类"><a href="#互斥量封装类" class="headerlink" title="互斥量封装类"></a>互斥量封装类</h4><ul><li><p><strong><code>std::lock_guard</code></strong>：作用是在构造时自动锁定互斥锁，在析构时自动解锁互斥锁。</p><p>注：不支持手动控制锁的行为（如延迟锁定、提前解锁等）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动加锁</span></span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">// 自动解锁（当 lock 超出作用域时）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 2&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::unique_lock</code></strong>: 允许对锁进行更细粒度的控制，例如延迟锁定、手动解锁、尝试锁定等。</p><p><em>注：相对于 <code>std::lock_guard</code>，开销稍大（因为它需要维护更多的状态）。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::defer_lock)</span></span>; <span class="comment">// 延迟锁定</span></span><br><span class="line">    lock.<span class="built_in">lock</span>(); <span class="comment">// 手动加锁</span></span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    lock.<span class="built_in">unlock</span>(); <span class="comment">// 手动解锁</span></span><br><span class="line">    <span class="comment">// 锁会在 unique_lock 析构时自动解锁（如果尚未解锁）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printMessage, <span class="string">&quot;Hello from thread 2&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::lock_guard</code> 和 <code>std::unique_lock</code> 的对比</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503261056266.png" alt="image-20250323210830055" style="zoom:50%;"></p></li></ul><h4 id="std-call-once"><a href="#std-call-once" class="headerlink" title="std::call_once"></a>std::call_once</h4><p><code>std::call_once</code> 用于确保某个函数或代码块在多线程环境中只被执行一次。</p><p><strong><code>std::call_once</code> 的主要作用是：</strong></p><ul><li><strong>线程安全的单次执行</strong>：确保某个函数或代码块在多个线程中只会被执行一次。</li><li><strong>避免竞态条件</strong>：在多线程环境下，多个线程可能同时尝试执行某段代码，<code>std::call_once</code> 可以保证只有一个线程能够成功执行，其他线程会等待该操作完成后再继续。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::once_flag flag;  <span class="comment">// 定义一个 once_flag 对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initialization function executed by thread &quot;</span></span><br><span class="line">              &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(flag, initialize);  <span class="comment">// 确保 initialize 函数只被调用一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread_func)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread_func)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(thread_func)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景：</strong></p><ul><li><strong>延迟初始化</strong>：在某些情况下，对象的初始化成本较高，或者只有在需要时才进行初始化。可以使用 <code>std::call_once</code> 来确保初始化逻辑只执行一次。</li><li><strong>单例模式</strong>：在实现线程安全的单例模式时，可以使用 <code>std::call_once</code> 来确保实例化过程只发生一次。</li></ul><p><em>注：<code>std::call_once</code>只能在线程函数中才能使用</em></p><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p><strong>条件变量（<code>std::condition_variable</code>）</strong>是一个用于线程间通信的同步原语。允许一个线程等待某个条件成立，而另一个线程可以在该条件满足时通知等待的线程继续执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cond_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(data++);</span><br><span class="line">        cond_var.<span class="built_in">notify_one</span>(); <span class="comment">// 通知正在等待的消费者线程</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// 模拟生产时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cond_var.<span class="built_in">wait</span>(lock, []()&#123;<span class="keyword">return</span> !q.<span class="built_in">empty</span>();&#125;); <span class="comment">// 等待直到队列非空</span></span><br><span class="line">        <span class="type">int</span> value = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong>生产者线程</strong>：不断地将数据添加到队列中，并通过 <code>cond_var.notify_one()</code> 通知可能正在等待的消费者线程，表示有新的数据可以处理了。</li><li><strong>消费者线程</strong>：首先尝试获取互斥锁，然后调用 <code>cond_var.wait(lock, condition)</code> 方法检查队列是否为空。如果队列为空，则当前线程会释放锁并进入等待状态，直到被生产者线程通知且条件满足（即队列非空）。一旦条件满足，消费者线程重新获取锁，并从队列中取出数据进行处理。</li></ul><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p><strong>线程池（Thread  Pool）</strong>是一种用于管理线程的机制，旨在减少频繁创建和销毁线程的开销。它<strong>预先创建一组线程</strong>，并将任务提交到一个<strong>任务队列</strong>中，<strong>线程从队列中取出任务并执行。</strong>这种方式特别适用于需要频繁执行短任务的场景，因为线程池可以避免每次任务执行时都创建新线程所带来的性能开销。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> numThreads) : <span class="built_in">stop</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">            threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//每个线程会不断地运行，直到满足特定的退出条件（如线程池关闭且任务队列为空）</span></span><br><span class="line">                    std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mutex);</span><br><span class="line">                    <span class="comment">//stop || !tasks.empty()是解锁的条件</span></span><br><span class="line">                    condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> stop || !tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                    <span class="keyword">if</span> (stop &amp;&amp; tasks.<span class="built_in">empty</span>()) &#123;<span class="comment">//线程退出的条件</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; <span class="built_in">task</span>(std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>()));</span><br><span class="line">                    tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    lock.<span class="built_in">unlock</span>();</span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        condition.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有等待的线程。</span></span><br><span class="line">        <span class="keyword">for</span> (std::thread&amp; thread : threads) &#123;<span class="comment">//等待所有线程完成其当前任务并退出</span></span><br><span class="line">            thread.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123; <span class="comment">//f是函数，args是参数</span></span><br><span class="line">        <span class="comment">//将用户提交的任务（函数 f 和其参数 args...）封装成一个无参数、无返回值的函数对象</span></span><br><span class="line">        <span class="comment">//std::bind 的作用是将函数及其参数绑定在一起，生成一个无参数的函数对象，从而满足任务队列的要求。</span></span><br><span class="line">        <span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...))</span></span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">            tasks.<span class="built_in">emplace</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">        &#125;</span><br><span class="line">        condition.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;<span class="comment">//保存线程池中的所有线程。</span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;<span class="comment">//任务队列</span></span><br><span class="line">    std::mutex mutex;<span class="comment">//用于保护对共享资源（如任务队列）的访问，确保线程安全</span></span><br><span class="line">    std::condition_variable condition;<span class="comment">//条件变量，用于在线程间进行同步。线程会在任务队列为空时等待，直到有新任务被加入队列。</span></span><br><span class="line">    <span class="type">bool</span> stop;<span class="comment">//标志位，用于指示线程池是否停止运行。当线程池析构时，会设置该标志为 true，通知所有线程退出。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        pool.<span class="built_in">enqueue</span>([i] &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; is running in thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; is done&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步并发机制"><a href="#异步并发机制" class="headerlink" title="异步并发机制"></a>异步并发机制</h4><p><strong><code>std::async</code> 和<code>std::future</code>：</strong></p><ul><li><code>std::async</code>: <strong>启动一个异步任务</strong>，返回一个<code>std::future</code>对象</li><li>两种启动策略：<ul><li><code>std::launch::async</code>：立即在新线程中执行</li><li><code>std::launch::deferred</code>：延迟执行，直到调用<code>future.get()</code></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 异步执行compute函数</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(std::launch::async, compute);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以做其他工作...</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing other work...\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取结果(会阻塞直到结果就绪)</span></span><br><span class="line">    <span class="type">int</span> value = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>std::future:</strong> <strong>表示异步操作的结果</strong><ul><li><code>get()</code>：获取结果，会阻塞直到结果就绪</li><li><code>wait()</code>：等待结果就绪</li><li><code>valid()</code>：检查future是否关联了共享状态</li><li><code>share()</code>：转换为<code>std::shared_future</code></li></ul></li></ul><p><strong>std::packaged_task:</strong> 是一个可调用的对象包装器，它将函数调用与future关联起来。</p><ul><li><p>比<code>std::async</code>更灵活，可以控制任务的执行方式</p></li><li><p>可以多次使用（通过重置）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个packaged_task，包装compute函数</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(compute)</span></span>;</span><br><span class="line">    <span class="comment">// 获取与任务关联的future</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// 在另一个线程中执行任务</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task), <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>(); <span class="comment">// 或使用t.join()</span></span><br><span class="line">    <span class="comment">// 获取结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>std::promise:</strong> 提供了更底层的设置异步结果的方式，允许显式设置值或异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compute</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp;&amp; prom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟计算</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 设置结果</span></span><br><span class="line">        prom.<span class="built_in">set_value</span>(<span class="number">42</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="comment">// 捕获异常并存储到promise中</span></span><br><span class="line">        prom.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = prom.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(compute, std::move(prom))</span></span>;</span><br><span class="line">    <span class="comment">// 获取结果</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++八股5</title>
      <link href="/posts/3a78fb45.html"/>
      <url>/posts/3a78fb45.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-怎样判断两个浮点数是否相等？"><a href="#1-怎样判断两个浮点数是否相等？" class="headerlink" title="1.怎样判断两个浮点数是否相等？"></a>1.怎样判断两个浮点数是否相等？</h4><p>由于浮点数在计算机中的表示方式和存储限制，直接使用 <code>==</code> 操作符来判断两个浮点数是否相等可能会导致不准确的结果，即使这两个数看起来应该是相等的。这是因为浮点数的精度有限，在某些计算后可能产生非常小的<strong>舍入误差。</strong></p><p>正确的做法是比较两个浮点数之间的差值是否在一个很小的范围内，而不是直接检查它们是否完全相等。可以将这两个浮点数相减，然后取结果的绝对值，并与一个预设的小阈值（也称为“精度”）进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">abs</span><span class="params">(a - b)</span> &lt; epsilon:</span></span><br><span class="line"><span class="function">    print(<span class="string">&quot;a and b are considered equal&quot;</span>)</span></span><br><span class="line"><span class="function">else:</span></span><br><span class="line"><span class="function">    print(<span class="string">&quot;a and b are not equal&quot;</span>)</span></span><br></pre></td></tr></table></figure><h4 id="2-类如何实现只能静态分配和只能动态分配"><a href="#2-类如何实现只能静态分配和只能动态分配" class="headerlink" title="2.类如何实现只能静态分配和只能动态分配"></a>2.类如何实现只能静态分配和只能动态分配</h4><ul><li><p><strong>只能静态分配:</strong> 类的对象只能在栈上创建,将 <code>new</code> 和 <code>delete</code> 运算符重载并声明为 <code>private</code> 属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackOnly</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 重载new和delete运算符，并将它们设为private</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom new is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 不应该实际调用，因为我们不希望在堆上创建对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Custom delete is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 不应该实际调用</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StackOnly</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;StackOnly object created on stack.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">StackOnly</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;StackOnly object destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StackOnly obj; <span class="comment">// 正确：在栈上创建对象</span></span><br><span class="line">    <span class="comment">// 错误：尝试在堆上创建对象（这将导致编译错误）</span></span><br><span class="line">    <span class="comment">// StackOnly* obj2 = new StackOnly();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>只能动态分配:</strong> 类的对象只能在堆上创建,将构造函数和析构函数设为 <code>protected 属性</code>，并提供一个公有的静态成员函数用来创建对象实例。</p><ul><li><strong>限制直接实例化</strong>：通过将构造函数和析构函数设为 <code>protected</code>，可以防止外部代码直接使用构造函数来创建对象实例。</li><li><strong>允许继承</strong>：将构造函数和析构函数设为 <code>protected</code> 而不是 <code>private</code>，使得派生类仍然能够调用基类的构造函数进行初始化。</li><li><strong>集中控制对象创建逻辑</strong>：通过提供一个静态成员函数如 <code>createInstance</code> 来负责对象的创建，可以集中控制对象的创建过程。</li><li><strong>静态成员函数无需实例即可调用</strong>：静态成员函数不依赖于类的具体实例，可以直接通过类名调用。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个只能动态分配的基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OnlyDynamic</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 构造函数和析构函数都设置为protected</span></span><br><span class="line">    <span class="built_in">OnlyDynamic</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OnlyDynamic Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">OnlyDynamic</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OnlyDynamic Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 提供一个静态成员函数用于创建对象实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> OnlyDynamic* <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OnlyDynamic</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Display function of OnlyDynamic&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-继承机制中对象之间如何转换？指针和引用之间如何转换？"><a href="#3-继承机制中对象之间如何转换？指针和引用之间如何转换？" class="headerlink" title="3.继承机制中对象之间如何转换？指针和引用之间如何转换？"></a>3.继承机制中对象之间如何转换？指针和引用之间如何转换？</h4><ul><li><p><strong>向上类型转换:</strong> 派生类的指针或引用转换为基类的指针或引用。这种转换是安全的，并且在C++中会自动进行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line">Base* ptr = &amp;d;  <span class="comment">// 自动向上类型转换</span></span><br></pre></td></tr></table></figure></li><li><p><strong>向下类型转换:</strong> 将基类的指针或引用转换为派生类的指针或引用。向下类型转换不会自动进行，必须显式地执行,通常是通过<code>dynamic_cast</code> 来实现的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();  <span class="comment">// 假设我们知道这个基类指针实际指向一个派生类对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 dynamic_cast 进行向下类型转换，注意这里需要包含正确的头文件</span></span><br><span class="line">Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"><span class="keyword">if</span> (derivedPtr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 转换成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 转换失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-知道C-中的组合吗？它与继承相比有什么优缺点吗？"><a href="#4-知道C-中的组合吗？它与继承相比有什么优缺点吗？" class="headerlink" title="4.知道C++中的组合吗？它与继承相比有什么优缺点吗？"></a>4.知道C++中的组合吗？它与继承相比有什么优缺点吗？</h4><p><strong>继承：</strong></p><ul><li><p><strong>优点：</strong></p><ul><li>子类可以重写父类的方法来方便地扩展功能。</li></ul></li><li><p><strong>缺点：</strong></p><ul><li><strong>高耦合性</strong>：子类依赖于父类的实现细节，这增加了耦合度</li><li><strong>编译时绑定</strong>：子类从父类继承的方法在编译期就已经确定，无法在运行时改变行为。</li><li><strong>维护成本</strong>：如果修改了父类的方法（如添加参数），则所有相关的子类也需要相应调整，否则可能导致错误。</li></ul></li></ul><p><strong>组合：</strong>一个类中包含另一个类的对象作为成员变量，体现了“有一个”（Has-a）的关系。</p><ul><li><p><strong>优点：</strong></p><ul><li><strong>低耦合性</strong>：通过组合的方式，外部对象只能通过接口访问被包含对象的功能，因此内部实现细节对外部不可见。</li><li><strong>灵活性</strong>：由于当前对象和被包含的对象之间是低耦合的，所以对被包含对象的修改不需要修改当前对象的代码。</li><li><strong>动态绑定</strong>：可以在运行时动态地替换所包含的对象，提供了更大的灵活性。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个接口或抽象类，用于定义技能的行为</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Skill</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数，定义了技能的使用方法</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Skill</span>() &#123;&#125; <span class="comment">// 虚析构函数，确保派生类能正确释放</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现具体的技能A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkillA</span> : <span class="keyword">public</span> Skill &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using Skill A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现具体的技能B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkillB</span> : <span class="keyword">public</span> Skill &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using Skill B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏角色类，通过组合方式包含技能对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Skill&gt; skill; <span class="comment">// 使用智能指针管理技能对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 设置技能的方法，允许在运行时更换技能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSkill</span><span class="params">(std::unique_ptr&lt;Skill&gt; newSkill)</span> </span>&#123;</span><br><span class="line">        skill = std::<span class="built_in">move</span>(newSkill);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 角色使用当前装备的技能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">performSkill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (skill) &#123;</span><br><span class="line">            skill-&gt;<span class="built_in">use</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No skill available.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    GameCharacter character;</span><br><span class="line">    <span class="comment">// 初始设置为SkillA</span></span><br><span class="line">    character.<span class="built_in">setSkill</span>(std::<span class="built_in">make_unique</span>&lt;SkillA&gt;());</span><br><span class="line">    character.<span class="built_in">performSkill</span>(); <span class="comment">// 输出: Using Skill A</span></span><br><span class="line">    <span class="comment">// 动态替换为SkillB</span></span><br><span class="line">    character.<span class="built_in">setSkill</span>(std::<span class="built_in">make_unique</span>&lt;SkillB&gt;());</span><br><span class="line">    character.<span class="built_in">performSkill</span>(); <span class="comment">// 输出: Using Skill B</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>缺点</strong>：</p><ul><li><strong>对象管理复杂</strong>：过多使用组合可能会导致创建大量小对象，增加了系统的复杂性。</li><li><strong>接口设计要求高</strong>：为了有效地组合多个对象，必须仔细设计接口，确保它们能够良好协作。</li></ul></li></ul><h4 id="5-函数指针？"><a href="#5-函数指针？" class="headerlink" title="5.函数指针？"></a>5.函数指针？</h4><p><strong>函数指针的声明方法:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*pf)(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;);</span><br></pre></td></tr></table></figure><p><em>注：<code>pf</code> 是一个指向函数的指针，该函数返回 <code>int</code> 类型并且接受两个 <code>const int&amp;</code> 类型的参数。注意这里的括号非常重要：`(</em>pf)<code>确保了</code><em><code>被应用到</code>pf<code>上，表明这是一个指针；如果没有这些括号，如</code>int </em>pf(const int&amp;, const int&amp;);<code>，这将被解析为一个返回</code>int<em>` 的函数声明。</em></p><p><strong>两种方法赋值：</strong></p><ul><li><p><strong>直接使用函数名：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pf = functionName;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用取地址运算符<code>&amp;</code>:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pf = &amp;functionName;</span><br></pre></td></tr></table></figure></li></ul><p><strong>函数指针的作用：动态选择函数执行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义几个基本的数学操作函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="number">0</span>) <span class="keyword">return</span> a / b;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error: Division by zero!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0作为错误处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数指针类型，简化声明</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*MathFunc)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeOperation</span><span class="params">(MathFunc operation, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; <span class="built_in">operation</span>(a, b) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">5</span>;</span><br><span class="line">    MathFunc operation;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Choose an operation (1: Add, 2: Subtract, 3: Multiply, 4: Divide): &quot;</span>;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    std::cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            operation = add; <span class="comment">// 函数名直接赋值给函数指针</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            operation = subtract;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            operation = multiply;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            operation = divide;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Invalid choice.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">executeOperation</span>(operation, x, y); <span class="comment">// 使用函数指针调用对应的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-结构体变量比较是否相等"><a href="#6-结构体变量比较是否相等" class="headerlink" title="6.结构体变量比较是否相等"></a>6.结构体变量比较是否相等</h4><p><strong>重载 <code>==</code> 操作符</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 == 操作符</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> foo&amp; rhs) <span class="type">const</span> &#123; <span class="comment">// 注意这里的 const 修饰符</span></span><br><span class="line">        <span class="built_in">return</span> (a == rhs.a) &amp;&amp; (b == rhs.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-函数调用过程栈的变化，返回值和参数变量哪个先入栈？"><a href="#7-函数调用过程栈的变化，返回值和参数变量哪个先入栈？" class="headerlink" title="7.函数调用过程栈的变化，返回值和参数变量哪个先入栈？"></a>7.函数调用过程栈的变化，返回值和参数变量哪个先入栈？</h4><ul><li><p><strong>参数入栈:</strong>调用者（caller）需要将被调函数（callee）所需的参数按照与形参顺序相反的顺序压入栈中。</p><p>对于函数调用 <code>func(a, b, c)</code>，则它们会以 <code>c</code>, <code>b</code>, <code>a</code> 的顺序依次压入栈中。</p></li><li><p><strong>调用和返回地址入栈:</strong> 使用 <code>call</code> 指令进行函数调用时，该指令除了跳转到被调函数的起始地址执行外，还会自动将 <code>call</code> 指令的下一条指令的地址（即返回地址）压入栈中。</p></li><li><strong>设置新的栈帧:</strong> 一旦控制权转移到被调函数，首先要做的就是设置一个新的栈帧。</li><li><strong>局部变量和临时变量入栈:</strong> 在新栈帧内，局部变量根据定义顺序分配空间，地址随栈的增长方向递减。</li></ul><h4 id="8-C-中类成员的访问权限和继承权限问题"><a href="#8-C-中类成员的访问权限和继承权限问题" class="headerlink" title="8.C++中类成员的访问权限和继承权限问题"></a>8.C++中类成员的访问权限和继承权限问题</h4><p><strong>三种访问权限:</strong></p><ul><li>一个类的public成员变量、成员函数，可以通过类的成员函数、类的实例变量进行访问</li><li>一个类的protected成员变量、成员函数，无法通过类的实例变量进行访问。但是可以通过<strong>类的友元函数、友元类</strong>进行访问。</li><li>一个类的private成员变量、成员函数，无法通过类的实例变量进行访问。但是<strong>可以通过类的友元函数、友元类进行访问。</strong></li></ul><p><strong>继承权限:</strong></p><ul><li><p><strong>public继承:</strong> 基类的各种权限不变 。</p></li><li><p><strong>protected继承:</strong> 派生类通过protected继承，基类的public成员在派生类中的权限变成了protected 。protected和private不变。</p></li><li><p><strong>private继承:</strong> private继承看成派生类将基类的public,protected成员囊括到派生类，全部作为派生类的private成员，但是不包括private成员。</p><p><em>注：基类的私有成员都不会直接被派生类继承</em></p></li></ul><h4 id="9-cout和printf有什么区别？"><a href="#9-cout和printf有什么区别？" class="headerlink" title="9.cout和printf有什么区别？"></a>9.cout和printf有什么区别？</h4><p><code>cout&lt;&lt;</code>是一个函数，<code>cout&lt;&lt;</code>后可以跟不同的类型是因为<code>cout&lt;&lt;</code>已存在针对各种类型数据的重载，所以会自动识别数据的类型。</p><p><strong>缓冲机制:</strong></p><ul><li><strong><code>cout</code>（有缓冲输出）</strong>: 输出到<code>cout</code>的内容首先会被放入缓冲区，然后根据特定条件（如遇到换行符<code>\n</code>、程序结束、手动刷新缓冲区等）才会从缓冲区输出到屏幕。为了确保立即输出内容，可以使用<code>endl</code>或者显式地调用<code>flush</code>方法（如<code>cout &lt;&lt; &quot;abc&quot; &lt;&lt; endl;</code> 或 <code>cout &lt;&lt; &quot;abc\n&quot; &lt;&lt; flush;</code>）。<code>endl</code>不仅插入了一个换行符，还会导致流被刷新；而<code>flush</code>仅刷新流而不添加任何字符。</li><li><strong><code>printf</code>（无缓冲输出）</strong>: 传统上认为<code>printf</code>是无缓冲输出，意味着当你调用<code>printf</code>时，输出几乎是立即显示的。</li></ul><h4 id="10-为什么可以为类的成员函数创建模板，但不能是虚函数和析构函数？"><a href="#10-为什么可以为类的成员函数创建模板，但不能是虚函数和析构函数？" class="headerlink" title="10.为什么可以为类的成员函数创建模板，但不能是虚函数和析构函数？"></a>10.为什么可以为类的成员函数创建模板，但不能是虚函数和析构函数？</h4><p>析构函数：没有参数，不需要使用模板</p><p>虚函数：由于模板成员函数的实例化是编译时的行为，而虚函数的动态绑定是运行时的行为，这两者无法同时满足。</p><h4 id="11-定义和声明的区别"><a href="#11-定义和声明的区别" class="headerlink" title="11.定义和声明的区别"></a>11.定义和声明的区别</h4><p><strong>变量的声明和定义：</strong></p><ul><li><strong>声明</strong>：当提到变量时，声明是指告诉编译器存在某个类型的变量，但并<strong>不会为这个变量分配内存空间</strong>。</li><li><strong>定义</strong>：而定义则是实际为变量<strong>分配内存空间</strong>的过程。这意味着系统会为该变量预留一定的存储空间，用于<strong>存放它的值</strong>。</li></ul><p><strong>函数的声明和定义：</strong></p><ul><li><strong>声明</strong>：对于函数来说，<strong>声明位于头文件（.h文件）中</strong>，其目的是通知编译器有关该函数的一些基本信息，比如函数名称、返回类型以及参数列表等。</li><li><strong>定义</strong>：函数的定义则包含了函数的实际实现代码，即函数体。它描述了函数执行的操作，并且<strong>位于源文件（.c或.cpp文件）中。</strong></li></ul><h4 id="12-静态成员与普通成员的区别是什么？"><a href="#12-静态成员与普通成员的区别是什么？" class="headerlink" title="12.静态成员与普通成员的区别是什么？"></a>12.静态成员与普通成员的区别是什么？</h4><p><strong>生命周期：</strong></p><ul><li><strong>静态成员变量</strong>：其生命周期从类被加载到内存开始，直到类被卸载为止。</li><li><strong>普通成员变量</strong>：它们的生命周期<strong>与对象实例</strong>紧密相关，只有当创建了一个类的对象时，普通成员变量才会存在</li></ul><p><strong>共享方式：</strong></p><ul><li><strong>静态成员变量</strong>：所有的对象都共享同一个静态成员变量</li><li><strong>普通成员变量</strong>：每个对象都有自己的一份副本</li></ul><p><strong>定义位置：</strong></p><ul><li><strong>普通成员变量</strong>：通常存储在栈或堆中，具体取决于它们是如何被声明和使用的。</li><li><strong>静态成员变量</strong>：存储在<strong>静态全局区</strong>，这意味着它们的存储空间是在程序启动时分配的，并且不会随对象的创建和销毁而变化。</li></ul><p><strong>初始化位置：</strong></p><ul><li><strong>普通成员变量</strong>：可以在类定义中直接初始化</li><li><strong>静态成员变量</strong>：必须<strong>在类外部进行初始化</strong>（除非是静态常量整型成员，可以直接在类定义中初始化）。</li></ul><h4 id="13-说一下你理解的-ifdef-endif代表着什么？"><a href="#13-说一下你理解的-ifdef-endif代表着什么？" class="headerlink" title="13.说一下你理解的 ifdef endif代表着什么？"></a>13.说一下你理解的 ifdef endif代表着什么？</h4><p><code>#ifdef</code>和<code>#endif</code>是C/C++语言中的预处理指令，用于<strong>实现条件编译</strong>。</p><p><strong>防止头文件重复包含</strong>（头文件卫士）：避免因多次包含同一头文件而导致的重定义问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEADER_FILE_NAME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEADER_FILE_NAME_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件的内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HEADER_FILE_NAME_H</span></span></span><br></pre></td></tr></table></figure><h4 id="14-隐式转换，如何消除隐式转换？"><a href="#14-隐式转换，如何消除隐式转换？" class="headerlink" title="14.隐式转换，如何消除隐式转换？"></a>14.隐式转换，如何消除隐式转换？</h4><p><strong>隐式转换:</strong></p><ul><li><strong>子类对象可以隐式地转换为父类对象(多态）</strong></li><li><strong>从小的数据类型（如<code>char</code>或<code>short</code>）向大的数据类型（如<code>int</code>或<code>long</code>）转换</strong></li></ul><p><strong>消除隐式转换的方法：</strong></p><ul><li><p><strong>使用<code>explicit</code>关键字</strong>：在构造函数声明时加上<code>explicit</code>关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="comment">/* 构造函数体 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="15-如果有一个空类，它会默认添加哪些函数？"><a href="#15-如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="15.如果有一个空类，它会默认添加哪些函数？"></a>15.如果有一个空类，它会默认添加哪些函数？</h4><ul><li><strong>默认构造函数</strong> (<code>Empty::Empty()</code>)</li><li><strong>拷贝构造函数</strong> (<code>Empty::Empty(const Empty&amp;)</code>)</li><li><strong>析构函数</strong> (<code>Empty::~Empty()</code>)</li><li><strong>赋值运算符重载函数</strong> (<code>Empty&amp; Empty::operator=(const Empty&amp;)</code>)</li></ul><h4 id="16-你知道const-char-与string之间的关系是什么吗？"><a href="#16-你知道const-char-与string之间的关系是什么吗？" class="headerlink" title="16.你知道const char* 与string之间的关系是什么吗？"></a>16.你知道const char* 与string之间的关系是什么吗？</h4><ul><li><strong><code>std::string</code></strong> 是C++标准库提供的一个类，用于封装字符串操作</li><li><strong><code>const char\*</code></strong> 是C风格的字符串表示形式，它实际上是一个指向以空字符（<code>\0</code>）结尾的字符数组的指针</li></ul><p>相互转换：</p><ul><li><p><strong>从 <code>std::string</code> 转换为 <code>const char\*</code></strong>： 使用 <code>std::string</code> 的成员函数 <code>c_str()</code> 可以获取一个 C 风格的字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = s.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure></li><li><p><strong>从 <code>const char\*</code> 转换为 <code>std::string</code></strong>： 可以直接通过构造函数将 <code>const char*</code> 转换为 <code>std::string</code>，这是隐式转换的一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(c_s)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="17-你什么情况用指针当参数，什么时候用引用，为什么？"><a href="#17-你什么情况用指针当参数，什么时候用引用，为什么？" class="headerlink" title="17.你什么情况用指针当参数，什么时候用引用，为什么？"></a>17.你什么情况用指针当参数，什么时候用引用，为什么？</h4><p>简单的数据类型：可以按值传递，因为复制成本低</p><p>数组只能使用指针</p><p>类对象使用引用传递</p><h4 id="18-如何设计一个类计算子类的个数？"><a href="#18-如何设计一个类计算子类的个数？" class="headerlink" title="18.如何设计一个类计算子类的个数？"></a>18.如何设计一个类计算子类的个数？</h4><p><strong>static静态变量coun计数：</strong></p><ul><li><p>为类设计一个static静态变量count作为计数器；</p></li><li><p>类定义结束后初始化count;</p></li><li><p>在构造函数中对count进行+1;</p></li><li><p>设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作；</p></li><li><p>设计复制构造函数，在进行复制函数中对count+1操作；</p></li><li><p>在析构函数中对count进行-1；</p></li></ul><h4 id="19-说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#19-说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="19.说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>19.说一说strcpy、sprintf与memcpy这三个函数的不同之处</h4><ul><li><p><strong><code>strcpy</code></strong>: 将<code>src</code>指向的字符串（包括终止符<code>\0</code>）复制到<code>dest</code>指向的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>sprintf</code></strong>: 根据提供的格式化字符串<code>format</code>和后续参数，生成一个格式化的字符串，并存储在<code>str</code>指向的缓冲区中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;The answer is %d&quot;</span>, number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>memcpy</code>:</strong> 从<code>src</code>指向的内存地址开始复制<code>n</code>个字节到<code>dest</code>指向的内存地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> src[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> dest[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="built_in">strlen</span>(src) + <span class="number">1</span>); <span class="comment">// 包括终止符&#x27;\0&#x27;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Copied string: %s\n&quot;</span>, dest);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="20-如何阻止一个类被实例化？有哪些方法？"><a href="#20-如何阻止一个类被实例化？有哪些方法？" class="headerlink" title="20.如何阻止一个类被实例化？有哪些方法？"></a>20.如何阻止一个类被实例化？有哪些方法？</h4><ul><li><p><strong>将类定义为抽象基类:</strong> <strong>抽象基类</strong>是一种不能实例化的类，它包含至少一个纯虚函数（即没有实现体的虚函数）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pureVirtualFunction</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractClass</span>() &#123;&#125; <span class="comment">// 虚析构函数确保派生类正确释放资源</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码会导致编译错误，因为不能实例化抽象类</span></span><br><span class="line"><span class="comment">// AbstractClass obj;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>将构造函数声明为<code>private</code></strong>: 提供静态成员函数来允许有限制地创建对象，或者根本不提供创建对象的方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonInstantiableClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">NonInstantiableClass</span>() &#123;&#125; <span class="comment">// 私有构造函数</span></span><br><span class="line">    ~<span class="built_in">NonInstantiableClass</span>() &#123;&#125; <span class="comment">// 私有析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以在这里执行一些操作，但不能创建对象实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码会导致编译错误，因为构造函数是私有的</span></span><br><span class="line"><span class="comment">// NonInstantiableClass obj;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>静态成员函数来允许有限制地创建对象:</strong></p><ul><li><p><strong>单例模式:</strong> 单例模式确保一个类只有一个实例，使用一个静态方法来返回唯一的实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonInstantiableClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="built_in">NonInstantiableClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有析构函数</span></span><br><span class="line">    ~<span class="built_in">NonInstantiableClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">NonInstantiableClass</span>(<span class="type">const</span> NonInstantiableClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    NonInstantiableClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonInstantiableClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态方法用于获取唯一实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> NonInstantiableClass&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> NonInstantiableClass instance; <span class="comment">// 局部静态变量保证线程安全</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Doing something...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过静态方法获取唯一实例并调用其方法</span></span><br><span class="line">    NonInstantiableClass&amp; obj = NonInstantiableClass::<span class="built_in">getInstance</span>();</span><br><span class="line">    obj.<span class="built_in">doSomething</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>工厂方法模式:</strong> 工厂方法模式允许类将对象的创建过程封装在一个或多个工厂方法中。这种方式可以控制对象的创建逻辑，并且可以隐藏具体的实现细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonInstantiableClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="built_in">NonInstantiableClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有析构函数</span></span><br><span class="line">    ~<span class="built_in">NonInstantiableClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">NonInstantiableClass</span>(<span class="type">const</span> NonInstantiableClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    NonInstantiableClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonInstantiableClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态工厂方法用于创建对象实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::unique_ptr&lt;NonInstantiableClass&gt; <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;NonInstantiableClass&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Doing something...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用工厂方法创建对象实例</span></span><br><span class="line">    std::unique_ptr&lt;NonInstantiableClass&gt; obj = NonInstantiableClass::<span class="built_in">createInstance</span>();</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        obj-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="21-虚基类"><a href="#21-虚基类" class="headerlink" title="21.虚基类"></a>21.虚基类</h4><p>虚基类主要用于解决多重继承中的菱形继承（多义性）问题</p><p>当一个类从多个类继承，而这些类又有一个共同的基类时，如果不使用虚基类，可能会导致基类部分被多次复制。通过将共同基类声明为虚基类，可以确保该基类在派生类中只存在一份实例。</p><p>在<code>FinalClass</code>类的构造函数中，需要显式调用 <code>Base</code> 类的构造函数，因为 <code>Base</code> 是虚基类，必须明确初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">// 定义基类 Base</span><br><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    int baseValue;</span><br><span class="line"></span><br><span class="line">    Base(int val) : baseValue(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Base constructor called, value = &quot; &lt;&lt; baseValue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void show() const &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Base value: &quot; &lt;&lt; baseValue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义 Derived1 类，从 Base 继承，并且 Base 是虚基类</span><br><span class="line">class Derived1 : virtual public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    Derived1(int val) : Base(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Derived1 constructor called&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义 Derived2 类，从 Base 继承，并且 Base 是虚基类</span><br><span class="line">class Derived2 : virtual public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    Derived2(int val) : Base(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Derived2 constructor called&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义 FinalClass 类，从 Derived1 和 Derived2 继承</span><br><span class="line">class FinalClass : public Derived1, public Derived2 &#123;</span><br><span class="line">public:</span><br><span class="line">    FinalClass(int val) : Base(val), Derived1(val), Derived2(val) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;FinalClass constructor called&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建 FinalClass 的对象</span><br><span class="line">    FinalClass obj(10);</span><br><span class="line"></span><br><span class="line">    // 调用 Base 类的方法</span><br><span class="line">    obj.show();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++泛编程</title>
      <link href="/posts/24f68203.html"/>
      <url>/posts/24f68203.html</url>
      
        <content type="html"><![CDATA[<h3 id="C-泛编程"><a href="#C-泛编程" class="headerlink" title="C++泛编程"></a>C++泛编程</h3><h4 id="1-auto"><a href="#1-auto" class="headerlink" title="1.auto"></a>1.auto</h4><p><strong>auto的主要用途：</strong>让编译器自动推断变量的类型</p><ul><li>代替冗长复杂的变量声明（函数指针）</li><li>在模板中，用于声明依赖模板参数的变量</li><li>函数模板依赖模板参数的返回值</li><li>用于Lambda表达式中</li></ul><h4 id="2-函数模板"><a href="#2-函数模板" class="headerlink" title="2.函数模板"></a>2.函数模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T &amp;a,T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注1：可以为类的成员函数创建模板，但不能是虚函数和析构函数。</em></p><p><em>注2：使用函数模板时，如果自动类型推导，不会发生隐式类型转换，而如果显式指定了函数模板的数据类型，则可以发生隐式类型转换。</em></p><p><strong>编译器使用各种函数的规则：</strong></p><ul><li><p>普通函数&gt;具体化&gt;常规模板</p></li><li><p>如果希望使用函数模板，可以用空模板参数强制使用函数模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;普通函数: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;函数模板: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认情况下，编译器可能优先选择普通函数</span></span><br><span class="line">    <span class="built_in">show</span>(value); <span class="comment">// 输出: 普通函数: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制使用函数模板</span></span><br><span class="line">    show&lt;&gt;(value); <span class="comment">// 输出: 函数模板: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果函数模板能产生更好的匹配，将优先于普通函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">long</span> a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;普通函数: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;函数模板: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽管有一个接受long类型的普通函数，</span></span><br><span class="line">    <span class="comment">// 但函数模板提供了对int类型更直接的匹配。</span></span><br><span class="line">    <span class="built_in">display</span>(value); <span class="comment">// 输出: 函数模板: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>函数模板分文件编写：</strong></p><ul><li><em>函数模板只是函数的描述，没有实体，创建函数模板的代码放在头文件中</em></li><li><em>函数模板具体化有实体，编译原理和普通函数一样，声明放在头文件中，定义放在源文件中。</em></li></ul><h4 id="3-类模板（泛化、全特化、偏特化）"><a href="#3-类模板（泛化、全特化、偏特化）" class="headerlink" title="3.类模板（泛化、全特化、偏特化）"></a>3.类模板（泛化、全特化、偏特化）</h4><p><strong>模板泛化</strong></p><p>模板泛化是不关心具体的类型，而是提供了通用的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 泛化的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic process: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>全特化</strong></p><p><strong>全特化：</strong>为某些类型提供更高效的实现</p><p>成员函数的全特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员函数的特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> MyClass&lt;<span class="type">int</span>&gt;::<span class="built_in">process</span>(<span class="type">int</span> data) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Specialized process for int: &quot;</span> &lt;&lt; data * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板全特化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板的特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized implementation for int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>偏特化</strong></p><p>模板偏特化是指在泛化的模板基础上，对其中的某一部分进行特化。</p><p><strong>模板参数数量的偏特化：</strong>特化部分参数，还存在一部分参数使用通用的模板定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板，有两个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T first;</span><br><span class="line">    U second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板参数数量的偏特化，对第一个模板参数进行特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;<span class="type">int</span>, U&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> first;</span><br><span class="line">    U second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>模板参数范围的偏特化：</strong>对模板的参数范围进行缩小</p><ul><li><strong>const 特化:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic process: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const 特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">const</span> T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> T data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized process for const type: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>指针特化：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic setValue: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span>&lt;T*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized setValue for pointers: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>左值引用特化:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyReference</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic printValue: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左值引用特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyReference</span>&lt;T&amp;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp; ref)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized printValue for lvalue references: &quot;</span> &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>右值引用特化:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRValueReference</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic printValue: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右值引用特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRValueReference</span>&lt;T&amp;&amp;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp;&amp; rvalue)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized printValue for rvalue references: &quot;</span> &lt;&lt; rvalue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>注：函数模板是不能偏特化的，只有类模板可以进行偏特化。函数模板可以不显式指定类型。</em></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++八股4</title>
      <link href="/posts/4d7fcbd3.html"/>
      <url>/posts/4d7fcbd3.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-malloc、realloc、calloc的区别"><a href="#1-malloc、realloc、calloc的区别" class="headerlink" title="1.malloc、realloc、calloc的区别"></a>1.malloc、realloc、calloc的区别</h4><ul><li><p><strong><code>malloc</code>函数：</strong></p><ul><li><p>用于分配指定大小的内存块，并返回指向该内存块的指针。如果分配失败，则返回 <code>NULL</code>。</p></li><li><p>使用 <code>malloc</code> 分配的内存不会被初始化，其中的数据是随机的。</p></li></ul></li><li><p><strong><code>calloc</code> 函数</strong>：</p><ul><li>原型为 <code>void* calloc(size_t n, size_t size);</code></li><li>第一个参数 <code>n</code> 表示要分配多少个元素；第二个参数 <code>size</code> 表示每个元素的大小（以字节为单位）。</li><li><code>calloc</code> 会将分配的内存初始化为零。</li></ul></li><li><p><strong><code>realloc</code> 函数</strong>：</p><ul><li><p>原型为 <code>void* realloc(void *p, size_t new_size);</code></p></li><li><p><code>realloc</code> 函数用来改变已经分配的内存块的大小。它可以扩大或缩小已有的内存块。如果新的内存大小大于原来的大小，那么新增的部分内容未定义（即可能包含任何值）。如果缩小内存块，超出部分会被丢弃。</p><p><em>注：C++中可以通过使用STL容器来避免使用<code>realloc</code>的情况,可以减少由于手动管理内存而引发错误的可能。</em></p></li></ul></li></ul><h4 id="2-类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？"><a href="#2-类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？" class="headerlink" title="2.类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"></a>2.类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</h4><p><strong>类成员初始化方式：</strong></p><ul><li><strong>赋值初始化</strong>：这是通过在<strong>构造函数体内</strong>对成员变量进行赋值来实现的。</li><li><strong>成员初始化列表</strong>：使用冒号(<code>:</code>)后跟随初始化列表的方式，在构造函数体执行前对成员变量进行初始化。</li></ul><p><strong>构造函数的执行顺序：</strong>（在创建派生类对象时，<strong>基类的构造函数会在派生类的构造函数之前执行</strong>。）</p><ol><li><strong>首先执行虚拟基类的构造函数</strong>（如果有多个虚拟基类，则按照它们被继承的顺序）。</li><li><strong>然后是普通基类的构造函数</strong>（如果有多个普通基类，则按照它们在派生类继承列表中的顺序）。</li><li><strong>接着是派生类中对象成员（包含其他类类型的对象作为其成员变量）的构造函数</strong>（这些成员对象按照它们在类定义中的声明顺序进行初始化，而不是按照初始化列表中的顺序）。</li><li><strong>最后是派生类自己的构造函数</strong>。</li></ol><p><strong>使用成员初始化列表更快的原因：</strong></p><ul><li><strong>C++的赋值操作是会产生临时对象的</strong>：使用赋值初始化时，首先会调用默认构造函数为成员变量分配空间并创建一个临时对象，然后将这个临时对象赋值给成员变量，这会产生额外的开销。</li><li>使用成员初始化列表直接在<strong>成员变量创建时就对其进行初始化</strong>，避免了创建临时对象的过程。</li></ul><h4 id="3-有哪些情况必须用到成员列表初始化？作用是什么？"><a href="#3-有哪些情况必须用到成员列表初始化？作用是什么？" class="headerlink" title="3.有哪些情况必须用到成员列表初始化？作用是什么？"></a>3.有哪些情况必须用到成员列表初始化？作用是什么？</h4><p><strong>成员列表初始化的四种必须使用的情况：</strong></p><ul><li><p><strong>初始化引用成员</strong>：引用成员必须在创建时初始化，且不能重新赋值。因此，必须在成员初始化列表中进行初始化。</p></li><li><p><strong>初始化常量成员</strong>：常量成员（<code>const</code>）一旦初始化后不能修改，因此必须在成员初始化列表中初始化。</p></li><li><p><strong>调用基类的构造函数</strong>：如果<strong>基类没有默认构造函数</strong>，或者需要传递参数给基类构造函数，必须在成员初始化列表中调用基类的构造函数。</p></li><li><p><strong>调用成员类的构造函数</strong>：如果类的成员是另一个类的对象，并且该<strong>成员类没有默认构造函数</strong>，或者需要传递参数，必须在成员初始化列表中调用该成员类的构造函数。</p><p><em>注：在函数体内进行赋值初始化时，成员就已经存在了</em></p></li></ul><p><strong>成员初始化列表的作用：</strong></p><ul><li><strong>初始化顺序</strong>：编译器会按照成员初始化列表中的顺序，在构造函数体内插入初始化操作，且这些操作在任何用户代码之前执行。</li><li><strong>初始化顺序的决定</strong>：初始化列表的顺序并不决定实际的初始化顺序，实际的初始化顺序由类中成员的<strong>声明顺序决定。</strong></li></ul><h4 id="4-C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的？"><a href="#4-C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的？" class="headerlink" title="4.C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？"></a>4.C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？</h4><ul><li><strong>string是对char*进行了封装</strong>，封装的string包含了char*数组，容量，长度等等属性。</li><li><strong>string可以进行动态扩展</strong>，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</li></ul><h4 id="5-什么是内存泄露，如何检测与避免"><a href="#5-什么是内存泄露，如何检测与避免" class="headerlink" title="5.什么是内存泄露，如何检测与避免"></a>5.什么是内存泄露，如何检测与避免</h4><p><strong>内存泄露：</strong>指的是堆内存的泄露，分配的内存块在使用完成后没有正确地释放。</p><p><strong>避免内存的泄露的方式：</strong></p><ul><li><p><strong>计数法：</strong>使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</p></li><li><p><strong>将基类的析构函数声明为虚函数：</strong>这可以保证当通过基类指针删除派生类对象时，派生类的析构函数能够被正确调用，从而避免因未正确调用析构函数导致的内存泄漏。</p><p><em>注：如果基类的析构函数不是<code>virtual</code>，通过基类指针删除派生类对象只会调用基类的析构函数。</em></p></li><li><p><strong>正确释放对象数组</strong>：对于使用 <code>new[]</code> 分配的对象数组，应使用 <code>delete[]</code> 来释放，而不是 <code>delete</code>，以避免内存泄漏。</p></li><li><strong>成对出现原则</strong>：确保每一对 <code>new</code>/<code>delete</code> 和 <code>malloc</code>/<code>free</code> 成对出现，即每次分配内存后都必须有相应的释放操作</li></ul><p><strong>检测工具</strong></p><ul><li>Linux下可以使用<strong>Valgrind工具</strong></li><li>Windows下可以使用<strong>CRT库</strong></li></ul><h4 id="6-对象复用的了解，零拷贝的了解"><a href="#6-对象复用的了解，零拷贝的了解" class="headerlink" title="6.对象复用的了解，零拷贝的了解"></a>6.对象复用的了解，零拷贝的了解</h4><p><strong>对象复用</strong>：在设计模式中通常指的是<strong>Flyweight（享元）模式</strong>。该模式旨在通过共享尽可能多的数据来最小化内存使用，特别是当系统需要创建大量细粒度的对象时。通过<strong>将相似或相同的对象存储在一个“对象池”中，并在需要时重复利用这些对象</strong>，可以有效<strong>减少内存占用和对象创建的开销。</strong></p><ul><li><p><strong>亨元模式：</strong> 由亨元工厂创建新的亨元对象前，先检查“对象池”中是否有相同属性对象，若有可以重复使用这些对象，而不是创建新的对象。</p><p>eg:假设我们正在开发一个<strong>文本编辑器</strong>，其中每个字符都由一个独立的对象表示。如果我们直接为每个字符创建一个新的对象实例，那么对于长文档来说，这将导致大量的内存消耗。Flyweight模式可以帮助我们通过共享相同字符的属性（如字体、颜色等）来优化这一过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Flyweight接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Character</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体Flyweight类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCharacter</span> : <span class="keyword">public</span> Character &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> font_family_;</span><br><span class="line">    <span class="type">int</span> font_size_;</span><br><span class="line">    std::string color_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCharacter</span>(<span class="type">char</span> font_family, <span class="type">int</span> font_size, <span class="type">const</span> std::string&amp; color)</span><br><span class="line">        : <span class="built_in">font_family_</span>(font_family), <span class="built_in">font_size_</span>(font_size), <span class="built_in">color_</span>(color) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character: &quot;</span> &lt;&lt; ch </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, Font Family: &quot;</span> &lt;&lt; font_family_ </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, Font Size: &quot;</span> &lt;&lt; font_size_ </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, Color: &quot;</span> &lt;&lt; color_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flyweight工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CharacterFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, Character*&gt; characters_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">CharacterFactory</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : characters_) &#123;</span><br><span class="line">            <span class="keyword">delete</span> pair.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Character* <span class="title">getCharacter</span><span class="params">(<span class="type">char</span> font_family, <span class="type">int</span> font_size, <span class="type">const</span> std::string&amp; color)</span> </span>&#123;</span><br><span class="line">        std::string key = std::<span class="built_in">string</span>(<span class="number">1</span>, font_family) + std::<span class="built_in">to_string</span>(font_size) + color;</span><br><span class="line">        <span class="keyword">if</span> (characters_.<span class="built_in">find</span>(key) == characters_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            characters_[key] = <span class="keyword">new</span> <span class="built_in">ConcreteCharacter</span>(font_family, font_size, color);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> characters_[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CharacterFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一些字符对象，但共享相同的属性</span></span><br><span class="line">    Character* charA = factory.<span class="built_in">getCharacter</span>(<span class="string">&#x27;T&#x27;</span>, <span class="number">12</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">    Character* charB = factory.<span class="built_in">getCharacter</span>(<span class="string">&#x27;T&#x27;</span>, <span class="number">12</span>, <span class="string">&quot;red&quot;</span>); <span class="comment">// 应该复用charA的实例</span></span><br><span class="line"></span><br><span class="line">    charA-&gt;<span class="built_in">display</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    charB-&gt;<span class="built_in">display</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即使请求了两次相同的属性组合，实际上只会有一个ConcreteCharacter实例被创建</span></span><br><span class="line">    <span class="keyword">if</span> (charA == charB) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;charA and charB are the same instance.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;charA and charB are different instances.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码中分别请求了两个具有相同属性的字符对象，但实际上它们引用的是同一个<code>ConcreteCharacter</code>实例,实现了对象复用的目的。</strong></p></li></ul><p><strong>零拷贝</strong>：一种优化技术，目的是<strong>减少数据从一处存储到另一处传输过程中CPU的参与程度</strong>，从而提高效率并降低资源消耗。传统上，数据传输可能涉及多次复制操作，比如从磁盘读取数据到内核空间，再复制到用户空间等。零拷贝技术减少了这种不必要的数据复制次数，降低了CPU的工作量和总线活动。</p><p><strong>*注：<code>vector</code>的一个成员函数emplace_back()很好地体现了零拷贝技术。</strong><code>emplace_back()</code> 是在容器内部直接构造对象，而不是先创建一个临时对象再进行拷贝或移动。这意味着它可以在不调用拷贝构造函数或移动构造函数的情况下，在容器预留的位置原地构造对象，这通常更高效。*</p><h4 id="7-介绍面向对象的三大特性，并且举例说明"><a href="#7-介绍面向对象的三大特性，并且举例说明" class="headerlink" title="7.介绍面向对象的三大特性，并且举例说明"></a>7.介绍面向对象的三大特性，并且举例说明</h4><ul><li><strong>继承：</strong> 让某种类型对象获得另一个类型对象的属性和方法。<ul><li>实现继承：指使用基类的属性和方法而无需额外编码的能力</li><li>接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力</li></ul></li><li><strong>封装：</strong> <strong>把客观事物封装成抽象的类</strong>，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏</li><li><strong>多态：</strong> 同一事物表现出不同事物的能力<ul><li><strong>实现多态有二种方式：覆盖（override），重载（overload）</strong></li><li>重载实现编译时多态，虚函数实现运行时多态</li></ul></li></ul><h4 id="8-C-的四种强制转换"><a href="#8-C-的四种强制转换" class="headerlink" title="8.C++的四种强制转换"></a>8.C++的四种强制转换</h4><p>C++提供了四种类型的显式类型转换运算符：<code>reinterpret_cast</code>、<code>const_cast</code>、<code>static_cast</code> 和 <code>dynamic_cast</code></p><ul><li><p><strong><code>reinterpret_cast</code></strong>：在不相关的类型之间进行低级别的强制转换。它可以将任何指针类型转换为另一个指针类型，或指针到整数类型的转换等。<strong>转换后的数和原来的数有相同的比特位。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *c = reinterpret_cast&lt;char*&gt;(p); // 将int指针转换为char指针</span><br></pre></td></tr></table></figure><p><em>注：<code>reinterpret_cast</code>没有进行任何的类型检查,因此很容易发生由于指针类型不匹配而引发的内存错误</em></p></li><li><p><strong><code>const_cast</code></strong>：主要用于添加或移除变量的<code>const</code>或<code>volatile</code>属性。它只能改变这些限定符，不能改变对象的实际类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char *p = &quot;hello&quot;;</span><br><span class="line">char *q = const_cast&lt;char*&gt;(p);</span><br></pre></td></tr></table></figure><p><em>注：这里将 `const char</em><code>类型的指针</code>p<code>转换为</code>char<em><code>类型的指针</code>q`。</em></p></li><li><p><strong><code>static_cast</code></strong>：用于类层次结构中的上行转换（派生类到基类）和下行转换（基类到派生类），以及基本数据类型之间的转换。</p><ul><li><p><strong>特点</strong>：<strong>不进行运行时类型检查</strong>，因此在下行转换时可能不安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">65</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(n);<span class="comment">//这里将 int 类型的变量 n 转换为 char 类型的变量 c。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>dynamic_cast</code>:</strong> 主要用于类层次结构中的上行转换和下行转换，特别是用于多态类型的转换。</p><ul><li><p><strong>特点：</strong>在运行时<strong>进行类型检查</strong>，如果转换不安全（如下行转换时基类指针不指向派生类对象），则返回 <code>nullptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Base *b = <span class="keyword">new</span> Son;</span><br><span class="line">Son *s = <span class="built_in">dynamic_cast</span>&lt;Son*&gt;(b);<span class="comment">//这里将 Base* 类型的指针 b 转换为 Son* 类型的指针 s，并在转换失败时返回 nullptr。</span></span><br><span class="line"><span class="keyword">if</span> (s) &#123;</span><br><span class="line">    <span class="comment">// 转换成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 转换失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="9-C-函数调用的压栈过程"><a href="#9-C-函数调用的压栈过程" class="headerlink" title="9.C++函数调用的压栈过程"></a>9.C++函数调用的压栈过程</h4><p><strong>函数调用的压栈过程:</strong></p><ul><li><strong>分配栈空间</strong>：为被调用函数分配栈空间，用于存储函数的局部变量、参数和返回地址等信息。</li><li><strong>参数压栈</strong>：将实参的值复制到形参的栈空间中。C++中，参数是从右到左依次压栈的。</li><li><strong>保存返回地址</strong>：将当前函数的返回地址（即调用函数的下一条指令地址）压入栈中，以便函数执行完毕后能正确返回到调用点。</li><li><strong>保存调用函数的运行状态</strong>：将调用函数的寄存器状态、局部变量等信息压入栈中，以便函数调用结束后恢复。</li><li><strong>执行被调用函数</strong>：跳转到被调用函数的代码并执行。</li><li><strong>函数返回</strong>：函数执行完毕后，从栈中弹出返回地址、恢复调用函数的运行状态，并释放栈空间。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> param1, <span class="type">int</span> param2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var1 = param1;</span><br><span class="line">    <span class="type">int</span> var2 = param2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;var1=%d,var2=%d&quot;</span>, <span class="built_in">f</span>(var1), <span class="built_in">f</span>(var2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">var1=1,var2=2</span><br></pre></td></tr></table></figure><h4 id="10-说说移动构造函数"><a href="#10-说说移动构造函数" class="headerlink" title="==10.说说移动构造函数=="></a>==10.说说移动构造函数==</h4><p><strong>既要实现资源的有效转移，又要避免潜在的双重释放的风险</strong></p><p><strong>移动构造函数：</strong>用“转移”代替“复制”来提高性能</p><p><strong>拷贝构造 vs 移动构造</strong></p><ul><li><strong>拷贝构造函数</strong>：通常涉及到深拷贝，特别是对于包含动态分配资源的对象。例如，如果一个类含有指针成员变量，那么在拷贝构造时需要为新对象分配新的内存，并将原始对象的数据复制过去。这增加了额外的时间和空间开销。</li><li><strong>移动构造函数</strong>：则是采用<strong>浅层复制</strong>的方式，直接<strong>将资源的所有权从一个对象转移到另一个对象</strong>，而不进行实际的数据复制。这样做的前提是确保源对象不再持有这些资源，以防止重复释放同一块内存导致的错误。</li><li><strong>参数类型差异</strong><ul><li><strong>拷贝构造函数</strong>：接受一个<strong>左值引用</strong>作为参数，意味着它可以接受任何有效的已有对象。</li><li><strong>移动构造函数</strong>：接受一个<strong>右值引用</strong>（或称为将亡值引用）作为参数。这意味着它只能用于那些即将销毁或不再使用的对象，比如临时对象或者通过<code>std::move</code>显式转换成右值的对象。</li></ul></li></ul><p><strong>如何实现安全的资源转移？</strong></p><p>​    为了避免因浅层复制导致的双重释放问题，移动构造函数会在获取源对象资源的同时，将源对象中的相应指针置为<code>nullptr</code>（或其他适当值）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 确保other不会在析构时释放data指向的内存</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass</code> 的移动构造函数接收一个右值引用 <code>MyClass&amp;&amp;</code>，并将<code>other</code>对象的数据成员<code>data</code>直接赋值给当前对象的<code>data</code>成员，然后将<code>other.data</code>设置为<code>nullptr</code>。这样做既实现了资源的有效转移，又避免了潜在的双重释放风险。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass a;</span><br><span class="line">MyClass b = std::<span class="built_in">move</span>(a); <span class="comment">// 调用移动构造函数</span></span><br></pre></td></tr></table></figure><p>注：<code>std::move(a)</code>使得<code>a</code>被视为一个右值，从而触发<code>MyClass</code>的移动构造函数。</p><h4 id="11-说一下C-左值引用和右值引用"><a href="#11-说一下C-左值引用和右值引用" class="headerlink" title="11.说一下C++左值引用和右值引用"></a>11.说一下C++左值引用和右值引用</h4><p><strong>左值（lvalue）:</strong></p><ul><li><p>可以获取地址的表达式。</p></li><li><p>通常有名字，可以出现在赋值语句的左边。</p></li><li><p>例如：变量、对象、函数返回的引用等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// a 是左值</span></span><br><span class="line"><span class="type">int</span>&amp; b = a;  <span class="comment">// b 是左值引用</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>右值（rvalue）</strong>：</p><ul><li><p>不能获取地址的表达式。</p></li><li><p>通常是临时的、没有名字的值。</p></li><li><p>例如：常量、临时对象、函数返回值（非引用）、表达式结果等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c = <span class="number">5</span> + <span class="number">10</span>;  <span class="comment">// 5 + 10 是右值</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; d = <span class="number">10</span>;    <span class="comment">// 10 是右值</span></span><br></pre></td></tr></table></figure><ul><li><strong>纯右值（prvalue）</strong>：如字面量、临时对象、表达式结果等。</li><li><strong>将亡值（xvalue）</strong>：与右值引用相关的表达式，通常是通过 <code>std::move</code> 或返回右值引用的函数得到的值。</li></ul></li></ul><p><strong>左值引用</strong>：用 <code>&amp;</code> 声明。</p><p><strong>右值引用</strong>：用 <code>&amp;&amp;</code> 声明。主要用于实现 <strong>移动语义</strong> 和 <strong>完美转发</strong>。</p><p><strong>右值引用的特点:</strong></p><ul><li><p><strong>延长右值的生命周期</strong>：右值引用可以将临时对象（右值）的生命周期延长到与右值引用变量的生命周期一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; d = <span class="number">10</span>;  <span class="comment">// 临时对象 10 的生命周期被延长</span></span><br></pre></td></tr></table></figure></li><li><p><strong>右值引用可能是左值或右值</strong>：右值引用类型的变量本身可能是左值或右值，取决于其初始化方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; e = <span class="number">10</span>;  <span class="comment">// e 是右值引用，但 e 本身是左值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>自动类型推断中的右值引用</strong>：在模板函数中，<code>T&amp;&amp;</code> 可以是左值引用或右值引用，取决于传入的参数类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">fun</span>(a);  <span class="comment">// t 是左值引用</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="number">10</span>); <span class="comment">// t 是右值引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>移动语义</strong>：通过 <code>std::move</code> 将左值强制转换为右值引用，从而避免不必要的拷贝操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2 = std::<span class="built_in">move</span>(v1);  <span class="comment">// v1 的资源被移动到 v2</span></span><br></pre></td></tr></table></figure><p><strong>完美转发</strong>：通过右值引用和 <code>std::forward</code>，将参数按照其原始类型转发给其他函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 完美转发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-C-中将临时变量作为返回值时的处理过程"><a href="#12-C-中将临时变量作为返回值时的处理过程" class="headerlink" title="12.C++中将临时变量作为返回值时的处理过程"></a>12.C++中将临时变量作为返回值时的处理过程</h4><p>在C++中，当函数返回临时变量时，虽然该临时变量会在函数退出时被销毁，但由于<strong>返回值是通过寄存器而非栈或堆内存进行传递的</strong>，因此返回值的正确性和完整性得到了保证。</p><h4 id="13-静态类型和动态类型，静态绑定和动态绑定的介绍"><a href="#13-静态类型和动态类型，静态绑定和动态绑定的介绍" class="headerlink" title="13.静态类型和动态类型，静态绑定和动态绑定的介绍"></a>13.静态类型和动态类型，静态绑定和动态绑定的介绍</h4><p><strong>静态类型与动态类型</strong></p><ul><li><p><strong>静态类型：</strong>对象在声明时采⽤的类型，在编译期既已确定；例如，<code>A* pa</code>的静态类型是<code>A*</code>，无论<code>pa</code>指向的是哪个子类对象。</p></li><li><p><strong>动态类型：</strong>指针或引用实际指向的对象的类型，是在运行期决定的。例如，<code>A* pa = new B();</code>，<code>pa</code>的静态类型是<code>A*</code>，但动态类型是<code>B*</code>。</p></li></ul><p><strong>静态绑定与动态绑定</strong></p><ul><li><strong>静态绑定</strong>：绑定的是静态类型，函数或属性的调用依赖于对象的静态类型，发生在编译期。<strong>非虚函数通常使用静态绑定。</strong></li><li><strong>动态绑定</strong>：绑定的是动态类型，函数或属性的调用依赖于对象的动态类型，发生在运行期。<strong>虚函数使用动态绑定，从而实现多态性。</strong></li></ul><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*virtual*/</span> <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C* pc = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line">    B* pb = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    A* pa = pc;</span><br><span class="line">    pa = pb;</span><br><span class="line"></span><br><span class="line">    pa-&gt;<span class="built_in">func</span>(); <span class="comment">// 如果func不是虚函数，则总是调用A::func()</span></span><br><span class="line">    pc-&gt;<span class="built_in">func</span>(); <span class="comment">// 总是调用C::func()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pc;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注1：如果 <code>A</code> 中的 <code>func</code> 不是虚函数，那么 <code>pa-&gt;func()</code> 将总是调用 <code>A::func()</code>，因为这是基于 <code>pa</code> 的静态类型（即 `A</em>`）进行的静态绑定。*</p><p><em>注2：如果将 <code>func</code> 声明为虚函数（取消注释 <code>virtual</code>），那么 <code>pa-&gt;func()</code> 将根据 <code>pa</code> 所指向的实际对象类型（即动态类型）调用相应的 <code>func</code> 函数，实现动态绑定。</em></p><h4 id="14-引用是否能实现动态绑定，为什么可以实现？"><a href="#14-引用是否能实现动态绑定，为什么可以实现？" class="headerlink" title="14.引用是否能实现动态绑定，为什么可以实现？"></a>14.引用是否能实现动态绑定，为什么可以实现？</h4><p><strong>引用</strong>和<strong>指针</strong>都可以实现动态绑定，但这种动态绑定仅适用于<strong>虚函数</strong>。</p><p><strong>动态绑定的条件</strong></p><ul><li><strong>虚函数</strong>：只有当一个函数被声明为<code>virtual</code>时，才能通过基类的引用或指针调用派生类中的重写版本。这是因为<strong>虚函数支持运行期确定实际调用哪个函数</strong>，这被称为动态绑定或多态性。</li><li><strong>引用必须初始化</strong>：创建引用时必须同时初始化它，这意味着你必须指定引用所绑定的具体对象。一旦初始化完成，引用就不能再指向其他对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base :: fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;son :: fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;son :: not virtual function&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    Base&amp; b = s; <span class="comment">// 基类类型引用绑定到Son对象</span></span><br><span class="line">    s.<span class="built_in">fun</span>();     <span class="comment">// 输出: son::fun()</span></span><br><span class="line">    b.<span class="built_in">fun</span>();     <span class="comment">// 输出: son::fun()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++八股3</title>
      <link href="/posts/d31b5e70.html"/>
      <url>/posts/d31b5e70.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-什么是大小端存储？"><a href="#1-什么是大小端存储？" class="headerlink" title="1.什么是大小端存储？"></a>1.什么是大小端存储？</h4><p><strong>大端存储：</strong>数据的最高有效字节存放在内存地址的最低位置</p><p><strong>小端存储：</strong>最低有效字节被存放在内存地址的最低位置</p><p><em>注：在网络协议中通常使用大端序</em></p><h4 id="2-volatile、mutable和explicit关键字的用法"><a href="#2-volatile、mutable和explicit关键字的用法" class="headerlink" title="2.volatile、mutable和explicit关键字的用法"></a>2.volatile、mutable和explicit关键字的用法</h4><ul><li><strong>volatile：</strong></li></ul><p><strong><code>volatile</code></strong>关键字用于告诉编译器，该变量的值可能会在程序控制之外被改变（如硬件中断、操作系统、其他线程等）。因此，<strong>编译器不应该对涉及该变量的操作进行优化。</strong></p><p><strong>每次访问<code>volatile</code>变量时，都会从内存重新读取数据，而不是使用寄存器中的缓存副本。（这样可以防止变量被其他线程修改后读到错误的变量值）</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503191910704.png" alt="image-20250318133449499" style="zoom: 50%;"></p><p><em>注：现代编译器为了提高性能，通常会将经常访问的变量值保存在CPU寄存器中，以便快速访问。</em></p><ul><li><strong>mutable：</strong> <code>mutable</code>关键字用于<strong>允许对象的某些成员变量即使在<code>const</code>成员函数内也可以被修改。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> accessCount; <span class="comment">// 可变成员变量，用于记录访问次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a) : <span class="built_in">age</span>(a), <span class="built_in">accessCount</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 成员函数，理论上不应该修改类的数据成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 在 const 函数中修改非 mutable 成员会导致编译错误</span></span><br><span class="line">        <span class="comment">// age = 30; // 错误：不能修改</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改 mutable 成员是允许的</span></span><br><span class="line">        ++accessCount;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This method has been called &quot;</span> &lt;&lt; accessCount &lt;&lt; <span class="string">&quot; times.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> Person <span class="title">person</span><span class="params">(<span class="number">25</span>)</span></span>; <span class="comment">// 创建一个常量对象</span></span><br><span class="line">    person.<span class="built_in">getAge</span>(); <span class="comment">// 第一次调用</span></span><br><span class="line">    person.<span class="built_in">getAge</span>(); <span class="comment">// 第二次调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>explicit: </strong> <code>explicit</code>关键字用于<strong>防止单参数构造函数的隐式类型转换</strong>。只能应用于类内部的<strong>构造函数声明</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Integer</span><span class="params">(<span class="type">int</span> x)</span> : value(x) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 假设我们需要提供获取值的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printInteger</span><span class="params">(<span class="type">const</span> Integer&amp; i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印 Integer 对象的内容</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The integer value is: &quot;</span> &lt;&lt; i.<span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面这一行会导致编译错误，因为不允许隐式转换</span></span><br><span class="line">    <span class="comment">// printInteger(10);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确的做法是显式地构造 Integer 对象</span></span><br><span class="line">    <span class="built_in">printInteger</span>(<span class="built_in">Integer</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-什么情况下会调用拷贝构造函数"><a href="#3-什么情况下会调用拷贝构造函数" class="headerlink" title="3.什么情况下会调用拷贝构造函数"></a>3.什么情况下会调用拷贝构造函数</h4><ul><li><p><strong>对象初始化：</strong> 用类的一个<strong>实例化对象去初始化另一个对象</strong>的时候</p></li><li><p><strong>按值传递参数</strong>： 当一个函数的参数是类的对象且通过值传递（非引用传递），在函数调用时<strong>会创建一个参数的副本</strong>，此时会调用拷贝构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useClassA</span><span class="params">(A a)</span> </span>&#123;&#125;  <span class="comment">// 函数定义</span></span><br><span class="line"><span class="built_in">useClassA</span>(a1);          <span class="comment">// 调用时会调用拷贝构造函数</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-C-中有几种类型的new"><a href="#4-C-中有几种类型的new" class="headerlink" title="4.C++中有几种类型的new"></a>4.C++中有几种类型的new</h4><ul><li><strong>Plain New</strong></li></ul><p>​    <code>Plain new</code>指的是标准的、普通的<code>new</code>操作符，用于动态分配内存。它不仅负责分配所需的内存空间，还会调用对象的构造函数（如果是对象的话）。</p><p>​    <strong>异常处理</strong>: 在C++中，当使用<code>plain new</code>进行内存分配且分配失败时（例如，系统无法提供请求的内存大小），它会抛出一个<code>std::bad_alloc</code>异常，而不是返回<code>NULL</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试分配一个极大的内存空间，可能会失败</span></span><br><span class="line">        <span class="type">char</span> *p = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10e11</span>];  <span class="comment">// 这里尝试分配大约100GB的空间，很可能导致std::bad_alloc异常被抛出</span></span><br><span class="line">        <span class="keyword">delete</span>[] p;  <span class="comment">// 如果分配成功，则释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc &amp;ex) &#123;  <span class="comment">// 捕捉std::bad_alloc异常</span></span><br><span class="line">        cout &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">// 输出异常信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>nothrow new</strong></p><p><code>nothrow new</code>在空间分配失败的情况下是不抛出异常，而是返回NULL</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="number">10e11</span>];</span><br><span class="line"> <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;alloc failed&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">delete</span> p;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//运⾏结果：alloc failed</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Placement New</strong></p></li></ul><p>​    <code>placement new</code>允许在⼀块已经分配成功的内存上新构造对象或对象数组。<code>placement new</code>不用担心内存分配失败，因为它根本不分配内存，它做的唯⼀⼀件事情就是调⽤对象的构造函数。</p><p>​    <strong>用途</strong>: 主要用于<strong>优化性能和控制内存管理</strong>，例如<strong>在一个循环中反复创建和销毁对象时，可以避免频繁的内存分配和释放操作</strong>，从而提高效率。</p><p>​    <em>注1：<strong>显式调用析构函数</strong>：由于 <code>placement new</code> 只负责调用对象的构造函数，并不负责释放内存，因此当你不再需要对象时，必须手动调用对象的析构函数来清理资源。</em></p><p>​    <em>注2：<strong>不要使用 <code>delete</code></strong>：不能对通过 <code>placement new</code> 创建的对象直接使用 <code>delete</code>，因为这可能导致内存泄漏或其他运行时错误。应该首先显式调用对象的析构函数，然后根据情况决定是否释放底层内存。（因为 <code>delete</code> 预期的是由 <code>new</code> 返回的一个指针，它只知道如何释放这块特定类型的内存。）</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ADT</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ADT</span>() : <span class="built_in">i</span>(<span class="number">10</span>), <span class="built_in">j</span>(<span class="number">100</span>) &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ADT construct i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j=&quot;</span> &lt;&lt; j &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ADT</span>() &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ADT destruct&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="built_in">sizeof</span>(ADT)]; <span class="comment">// 动态分配足够大的内存来容纳一个ADT对象</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123; <span class="comment">// 注意：这里应该是检查 p 是否为 nullptr 而不是 NULL</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;alloc failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ADT *q = <span class="built_in">new</span>(p) ADT; <span class="comment">// 使用 placement new 在 p 所指向的内存上构造 ADT 对象</span></span><br><span class="line">    <span class="comment">// 不可以直接 delete q;</span></span><br><span class="line">    q-&gt;~<span class="built_in">ADT</span>(); <span class="comment">// 显式调用 ADT 的析构函数</span></span><br><span class="line">    <span class="keyword">delete</span>[] p; <span class="comment">// 最后释放最初分配的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-C-的异常处理的方法"><a href="#5-C-的异常处理的方法" class="headerlink" title="5.C++的异常处理的方法"></a>5.C++的异常处理的方法</h4><ul><li><p><strong>try、throw和catch关键字</strong></p><ul><li><p><strong>try</strong>:  <code>try</code>块用于包裹可能抛出异常的代码段。当<code>try</code>块中的任何代码抛出了一个异常，程序会立即寻找与之匹配的<code>catch</code>块进行处理。</p></li><li><p><strong>throw</strong>: 当程序检测到一个无法处理的错误时，可以使用<code>throw</code>语句抛出一个异常。这个异常可以是任意类型的数据（例如整数、浮点数、字符串或者自定义类对象），它包含了关于错误的信息。</p></li><li><p><strong>catch</strong>: <code>catch</code>块用于捕获由<code>throw</code>语句抛出的异常。每个<code>catch</code>后面都跟着一个参数列表，指定了它可以处理的异常类型。一旦某个异常被抛出，程序会查找最近的匹配<code>catch</code>块，并将控制权转移到该块。如果找不到匹配的<code>catch</code>块，程序将终止运行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> m = <span class="number">1</span>, n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">-1</span>; <span class="comment">// 抛出int型异常</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">-1.0</span>; <span class="comment">// 抛出 double 型异常</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; m / n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">double</span> d) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;catch (double)&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通用的catch(...)块</span></span><br><span class="line"><span class="built_in">catch</span> (...) &#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;catch (...)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;finished&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>函数的异常声明列表:</strong> 在定义函数的时候知道函数可能发⽣的异常，可以在函数声明和定义时，指出所能抛出异常的列表.</p><p><code>int fun() throw(int,double,A,B,C)&#123;...&#125;;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义三个可能被抛出的异常类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionA</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionB</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExceptionC</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数fun声明和定义时指定了它可能抛出的异常类型：int, double, ExceptionA, ExceptionB, ExceptionC</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>, ExceptionA, ExceptionB, ExceptionC)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> condition = <span class="number">3</span>; <span class="comment">// 假设根据某种条件决定抛出何种异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (condition == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">1</span>; <span class="comment">// 抛出int型异常</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">2.0</span>; <span class="comment">// 抛出double型异常</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ExceptionA</span>(); <span class="comment">// 抛出自定义异常ExceptionA</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ExceptionB</span>(); <span class="comment">// 抛出自定义异常ExceptionB</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ExceptionC</span>(); <span class="comment">// 抛出自定义异常ExceptionC</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">fun</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an int exception: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">double</span> e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught a double exception: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (ExceptionA&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an ExceptionA&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (ExceptionB&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an ExceptionB&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (ExceptionC&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an ExceptionC&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; <span class="comment">// 捕获所有其他未列出的异常</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught an unspecified exception&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>C++标准异常类exception</strong></p><p>C++ 标准库中有⼀些类代表异常，这些类都是从 exception 类派⽣⽽来的</p><ul><li><p><code>std::bad_typeid:</code> 当使用<code>typeid</code>运算符对一个多态类的指针进行操作时，如果该指针的值为<code>NULL</code>（即指向空），则会抛出<code>std::bad_typeid</code>异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">typeid</span>(*ptr).<span class="built_in">name</span>() &lt;&lt; std::endl; <span class="comment">// 这里会抛出 std::bad_typeid 异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_typeid&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_typeid: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>std::bad_cast:</code> 当使用<code>dynamic_cast</code>进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的（例如，基类指针实际上并不指向正确的派生类对象），则会抛出<code>std::bad_cast</code>异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="keyword">public</span>: <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Derived&amp; derivedRef = <span class="built_in">dynamic_cast</span>&lt;Derived&amp;&gt;(*basePtr); <span class="comment">// 这里会抛出 std::bad_cast 异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_cast&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_cast: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>std::bad_alloc</code>: 当使用<code>new</code>运算符进行动态内存分配时，如果没有足够的内存，则会引发<code>std::bad_alloc</code>异常。</p></li><li><p><code>std::out_of_range</code>: 当你使用<code>vector</code>或<code>string</code>的<code>at()</code>成员函数根据下标访问元素时，如果提供的下标越界了，则会抛出<code>std::out_of_range</code>异常。</p></li></ul></li></ul><h4 id="6-形参与实参的区别？"><a href="#6-形参与实参的区别？" class="headerlink" title="6.形参与实参的区别？"></a>6.形参与实参的区别？</h4><ul><li><strong>形参变量的作用范围</strong>：形参是在定义函数时声明的变量，它们只有在函数被调用时才会分配内存单元，并且<strong>仅在函数内部有效。</strong></li><li><strong>实参的类型与值确定性</strong>：这就要求在调用函数之前，确保所有实参都有明确的值。</li><li><strong>实参与形参的一致性</strong>：实参和形参的数量、类型以及顺序需要严格匹配。</li><li><strong>非指针类型的形参与实参的独立性</strong>：如果形参和实参都不是指针类型，那么在函数执行期间，形参会创建实参的一个副本，即形参获得的是实参值的一份拷贝。这样，在函数内部对形参所做的任何改变都不会影响到外部的实参。当函数执行完毕后，形参占用的内存被释放，而实参保持不变。</li></ul><h4 id="7-值传递、指针传递、引用传递的区别和效率"><a href="#7-值传递、指针传递、引用传递的区别和效率" class="headerlink" title="7.值传递、指针传递、引用传递的区别和效率"></a>7.值传递、指针传递、引用传递的区别和效率</h4><ul><li><strong>值传递：</strong>将实际参数的值<strong>复制</strong>一份传递给函数的形式参数。函数内部对形参的修改不会影响到实参。如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。<strong>实参和形参在不同的内存位置，它们占用不同的存储空间。</strong>形参是实参的一个副本，当<strong>函数调用结束后，形参占用的内存空间会被释放。</strong></li><li><strong>指针传递：</strong>函数参数为指针类型。通过传递变量的地址，<strong>函数内部可以通过这个地址访问和修改原始变量的值。</strong>（<strong>传值</strong>，传递的是固定为<strong>4字节的地址值</strong>）</li><li><strong>引用传递：</strong>在函数调用时，将实际参数的引用（别名）传递给函数的形式参数。对形参的操作<strong>实际上就是对实参的操作</strong>。（<strong>传地址</strong>）</li></ul><p><strong>效率上，指针传递和引用传递比值传递效率高。</strong></p><p>注：<strong>需要返回多个值时可以使用指针作为参数</strong>：当一个函数需要返回多个值时，可以使用指针作为参数来允许函数修改传入的变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor, <span class="type">int</span>* quotient, <span class="type">int</span>* remainder)</span> </span>&#123;</span><br><span class="line">    *quotient = dividend / divisor;</span><br><span class="line">    *remainder = dividend % divisor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-局部变量什么时候初始化"><a href="#8-局部变量什么时候初始化" class="headerlink" title="8.局部变量什么时候初始化"></a>8.局部变量什么时候初始化</h4><ul><li><p><strong>普通局部变量：</strong></p><ul><li><strong>初始化时机</strong>：普通局部变量在每次进入其作用域时被创建，并且可以在声明时或者之后进行初始化。<strong>初始化不是自动的</strong>，需要显式地给它们赋值。</li></ul></li><li><p><strong>静态局部变量：</strong></p><ul><li><strong>初始化时机</strong>：在<strong>首次用到时初始化</strong>，可使用变量初始化，这是因为初始化要执行构造函数</li><li><strong>析构顺序</strong>：当程序结束时，静态局部变量会按照它们构造的逆序进行析构。此外，C++通过<code>atexit()</code>函数来管理这些对象的析构顺序，确保它们能以正确的顺序被销毁。</li></ul></li><li><p><strong>全局静态变量：</strong></p><ul><li><strong>初始化时机</strong>：全局静态变量和静态局部变量类似，在程序开始执行前就已初始化。然而，在不同编译单元中的全局静态对象的初始化顺序是不确定的，这可能导致依赖于特定初始化顺序的问题。</li><li><strong>解决方法</strong>：一种常用的解决方案是使用单例模式中的静态局部变量。由于静态局部变量具有“延迟初始化”的特点，即只有在首次使用时才会初始化，因此可以用来控制初始化顺序，避免跨编译单元初始化顺序导致的问题。</li></ul></li></ul><h4 id="9-深拷贝与浅拷贝"><a href="#9-深拷贝与浅拷贝" class="headerlink" title="9.深拷贝与浅拷贝"></a>9.<strong>深拷贝与浅拷贝</strong></h4><ul><li><strong>浅拷贝：</strong>浅拷贝是指简单地将原对象的<strong>基本数据类型</strong>的值<strong>复制</strong>给新对象，并且对于<strong>引用类型的数据</strong>（如指针），只是<strong>复制了指向实际数据的引用</strong>（即<strong>内存地址</strong>），并<strong>没有为引用类型的数据开辟新的内存空间。</strong></li><li><strong>深拷贝：</strong>深拷贝不仅复制了基本数据类型的值，而且对于引用类型的成员变量，还<strong>会在堆上为其指向的数据分配新的内存空间</strong>，并将这些数据复制到新的内存位置，从而使得<strong>新对象拥有自己的独立数据副本</strong>。</li></ul><h4 id="10-new、delete-p、delete-p、allocator都有什么作用？"><a href="#10-new、delete-p、delete-p、allocator都有什么作用？" class="headerlink" title="10.new、delete p、delete [] p、allocator都有什么作用？"></a>10.new、delete p、delete [] p、allocator都有什么作用？</h4><ul><li><p><strong><code>new[]</code>创建动态数组</strong>：当使用<code>new</code>分配一个数组时，方括号<code>[]</code>内的值必须是整数类型，它<strong>可以是变量</strong>（即运行时确定的值），而不必是常量表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 合法，size可以是变量</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>new</code>返回元素类型的指针:</strong> 当使用<code>new[]</code>来动态创建数组时，<strong>返回的是指向数组第一个元素的指针</strong>，而不是一个数组类型的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arrayPtr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// arrayPtr 是一个 int 类型的指针</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>delete[]</code>销毁顺序:</strong> 使用<code>delete[]</code>删除通过<code>new[]</code>分配的数组时，数组中的对象会按照它们被构造的逆序进行析构。因为C++保证了对象的析构顺序与它们的构造顺序相反，以确保资源正确释放。</p></li><li><p><strong><code>new/delete</code> vs <code>allocator</code></strong></p><ul><li><p><strong><code>new/delete</code>局限性</strong>：将构造函数/析构函数与内存管理绑定在一起不够灵活</p></li><li><p><strong><code>std::allocator</code>（分配器）的作用</strong>：<code>std::allocator</code>是C++标准库提供的一个工具，用于分离内存分配和对象构造的过程。它允许程序员先申请一块未初始化的内存，然后根据需要手动构造对象。这种方式提供了更大的灵活性，比如延迟对象的初始化时间或者复用已分配的内存块，从而可能提高性能或减少内存碎片。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::allocator&lt;<span class="type">int</span>&gt; alloc; <span class="comment">// 创建一个 allocator 对象</span></span><br><span class="line"><span class="type">int</span>* p = alloc.<span class="built_in">allocate</span>(<span class="number">10</span>); <span class="comment">// 分配内存但不初始化</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(p, <span class="number">100</span>); <span class="comment">// 初始化某个位置的对象</span></span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p, <span class="number">10</span>); <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="11-new和delete的实现原理，-delete是如何知道释放内存的大小的额？"><a href="#11-new和delete的实现原理，-delete是如何知道释放内存的大小的额？" class="headerlink" title="11.new和delete的实现原理， delete是如何知道释放内存的大小的额？"></a>11.new和delete的实现原理， delete是如何知道释放内存的大小的额？</h4><p>对于数组，<code>new[]</code>会额外存储数组的大小，<code>delete[]</code>会根据这个大小正确地调用析构函数并释放内存。</p><h4 id="12-malloc与free的实现原理？"><a href="#12-malloc与free的实现原理？" class="headerlink" title="12.malloc与free的实现原理？"></a>12.malloc与free的实现原理？</h4><p><code>alloc</code> 和 <code>free</code> 的底层实现依赖于操作系统提供的系统调用，主要包括：</p><ul><li><code>brk</code>：通过调整堆的边界来分配内存。</li><li><code>mmap</code>：在进程的虚拟地址空间中映射一块内存区域。</li><li><code>munmap</code>：释放由 <code>mmap</code> 分配的内存。</li></ul><p><strong>内存分配的两种方式:</strong></p><ul><li><p><strong><code>brk</code> 系统调用(小于 128KB)</strong>：调整堆的边界（即数据段的最高地址指针 <code>_edata</code>）来分配内存； <strong>分配的内存是连续的，释放时需要从高地址向低地址依次释放。</strong></p><ul><li><code>brk</code> 将 <code>_edata</code> 指针向高地址方向移动，扩展堆的大小。</li><li>分配的内存是虚拟内存，物理内存并未立即分配。</li><li>当程序首次访问这块内存时，操作系统会触发缺页中断，分配物理内存并建立虚拟内存与物理内存的映射关系。</li></ul></li><li><p><strong><code>mmap</code> 系统调用(大于 128KB)</strong>：<code>mmap</code> 在进程的虚拟地址空间中（<strong>堆和栈之间的文件映射区域</strong>）找一块空闲的虚拟内存。； <strong>分配的内存可以单独释放，灵活性更高。</strong></p><ul><li><code>mmap</code> 在文件映射区域中分配一块虚拟内存。</li><li>同样，物理内存并未立即分配，而是在首次访问时通过缺页中断分配。</li></ul></li><li><p><strong>内存紧缩（trim）</strong>：</p><ul><li>当 <code>free</code> 释放内存后，如果堆顶的空闲内存超过一定阈值（默认 128KB，可通过 <code>M_TRIM_THRESHOLD</code> 调节），操作系统会执行内存紧缩操作（trim）。</li><li>内存紧缩会将空闲的内存归还给操作系统，减少进程的内存占用。</li></ul></li></ul><p><strong><code>malloc</code> 的具体实现机制：</strong></p><ul><li><p><strong>空闲内存链表</strong>：</p><ul><li>操作系统中维护一个记录空闲内存地址的链表。</li><li>当程序<strong>调用 <code>malloc</code></strong> 时，操作系统会<strong>遍历这个链表</strong>，寻找第一个大小满足需求的空闲内存块。</li><li>如果找到合适的内存块，则将其从空闲链表中删除，并分配给程序。</li><li>如果<strong>没有找到合适的内存块，则会通过 <code>brk</code> 或 <code>mmap</code> 系统调用</strong>向操作系统申请更多的内存。</li></ul></li><li><p><strong>内存分配算法</strong>：</p><ul><li><code>malloc</code> 通常使用一些内存分配算法（如首次适应、最佳适应或伙伴系统）来管理空闲内存链表，以提高内存分配的效率。</li></ul></li></ul><p><strong><code>free</code> 的具体实现机制：</strong></p><ul><li><strong>释放内存</strong>：<ul><li>当程序调用 <code>free</code> 时，操作系统会将释放的内存块重新加入到空闲内存链表中。</li><li>如果释放的内存是通过 <strong><code>brk</code> 分配的</strong>，且位于堆的顶部，则<strong>可能会触发内存紧缩操作，将空闲内存归还给操作系统。</strong></li><li>如果释放的内存是通过 <code>mmap</code> 分配的，则直接调用 <strong><code>munmap</code> 系统调用</strong>将内存归还给操作系统。</li></ul></li></ul><h4 id="13-内联函数和普通函数的区别"><a href="#13-内联函数和普通函数的区别" class="headerlink" title="13.内联函数和普通函数的区别"></a>13.内联函数和普通函数的区别</h4><ul><li><p><strong>执行效率</strong>：内联函数效率高</p><ul><li><strong>内联函数</strong>：当一个函数被声明为内联函数时，编译器会在每次调用该函数的地方将其代码展开，而不是进行常规的函数调用（如保存当前环境、跳转到函数入口地址执行等）。这样做可以<strong>减少函数调用带来的开销</strong>，特别是对于简单的、短小的函数来说，能提高程序运行效率。</li><li><strong>普通函数</strong>：普通函数调用涉及到栈帧的创建与销毁、参数传递、返回值处理等一系列操作，这些都会带来一定的性能开销。</li></ul></li><li><p><strong>代码大小</strong>：内联函数会增大代码量</p><ul><li><strong>内联函数</strong>：由于内联函数是将函数体直接插入到调用点，如果一个内联函数在一个程序中被多次调用，那么这个函数的代码就会被复制多份，这可能导致生成的可执行文件变大。</li><li><strong>普通函数</strong>：普通函数只有一份副本，无论它被调用多少次，都不会增加代码量。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++八股2</title>
      <link href="/posts/a41c6ee6.html"/>
      <url>/posts/a41c6ee6.html</url>
      
        <content type="html"><![CDATA[<h2 id="C-八股2"><a href="#C-八股2" class="headerlink" title="C++八股2"></a>C++八股2</h2><h4 id="1-C-中const和static的作用"><a href="#1-C-中const和static的作用" class="headerlink" title="1.C++中const和static的作用"></a>1.C++中const和static的作用</h4><p><strong>static：</strong></p><ul><li><p><strong>不考虑类的情况</strong></p><ul><li><p><strong>隐藏</strong>：当使用<code>static</code>修饰全局变量或函数时，它们将仅在定义它们的文件内可见（即具有内部链接性），而没有<code>static</code>修饰的全局变量和函数则可以在其他文件中通过声明来引用。</p><p><strong><em>注：当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</em></strong></p></li><li><p><strong>默认初始化为0</strong>：无论是未初始化的全局静态变量还是局部静态变量，默认情况下都会被初始化为0，并且这些变量都存储在全局未初始化区。</p></li><li><p><strong>持久存在与记忆性</strong>：如果在函数内部定义了静态变量，那么这个变量在整个程序运行期间一直存在，只会被初始化一次，并且即使函数退出后仍然存在，但它的作用域是局部的。</p></li></ul></li><li><p><strong>考虑类的情况</strong></p><ul><li><strong>static成员变量</strong>：必须在类外部进行初始化</li><li><strong>static成员函数</strong>：没有<code>this</code>指针，不能访问类的非静态成员变量或调用非静态成员函数。</li></ul></li></ul><p><strong>const:</strong></p><ul><li><strong>不考虑类的情况:</strong><ul><li><strong>不可变性</strong>：一旦定义了一个<code>const</code>常量，就必须同时对其进行初始化，之后其值不能再被修改。</li><li><strong>参数传递：</strong>用const修饰传入参数，则函数保证传入参数不发生改变</li></ul></li><li><strong>考虑类的情况</strong><ul><li><strong>const成员变量</strong>：必须通过构造函数的初始化列表进行初始化，不能在类定义之外进行初始化。</li><li><strong>const成员函数</strong>：这种函数承诺不会修改对象的数据成员（除非数据成员被声明为<code>mutable</code>），<code>const</code>成员函数不可以调用非<code>const</code>成员函数；<code>const</code>对象只能调用<code>const</code>成员函数，而非<code>const</code>对象既可以调用<code>const</code>也可以调用非<code>const</code>成员函数。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非const成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modifyValue</span><span class="params">(<span class="type">int</span> newVal)</span> </span>&#123;</span><br><span class="line">        value = newVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不能修改任何非mutable数据成员</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> MyClass <span class="title">constObj</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 创建一个const对象</span></span><br><span class="line">    <span class="function">MyClass <span class="title">nonConstObj</span><span class="params">(<span class="number">20</span>)</span></span>;    <span class="comment">// 创建一个非const对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行会导致编译错误，因为尝试在一个const对象上调用非const成员函数</span></span><br><span class="line">    <span class="comment">// constObj.modifyValue(30);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在一个const对象上调用const成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;constObj value: &quot;</span> &lt;&lt; constObj.<span class="built_in">getValue</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在非const对象上调用const成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;nonConstObj value: &quot;</span> &lt;&lt; nonConstObj.<span class="built_in">getValue</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以在非const对象上调用非const成员函数</span></span><br><span class="line">    nonConstObj.<span class="built_in">modifyValue</span>(<span class="number">40</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After modification, nonConstObj value: &quot;</span> &lt;&lt; nonConstObj.<span class="built_in">getValue</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-C-的顶层const和底层const"><a href="#2-C-的顶层const和底层const" class="headerlink" title="2.C++的顶层const和底层const"></a>2.C++的顶层const和底层const</h4><p><strong>顶层const（*在左边）</strong>：表示被修饰的对象本身是一个常量，不能通过这个对象改变它的值。（指针指向不可变）</p><p><strong>底层const（*在右边）</strong>：指针所指向的对象是不可变的。（指针指向的对象是常量）</p><p><em>注：标准的<code>const int</code>是顶层; const用于声明引用变量是底层</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> b1 = &amp;a;        <span class="comment">// 顶层const，b1本身是一个常量，即b1必须始终指向a</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* b2 = &amp;a;        <span class="comment">// 底层const，b2本身可变，但b2指向的对象（即*a）是常量，不可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b3 = <span class="number">20</span>;         <span class="comment">// 顶层const，b3是常量不可变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> b4 = &amp;a;  <span class="comment">// 前一个const为底层，后一个为顶层，b4不可变且*b4也不可变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; b5 = a;         <span class="comment">// 用于声明引用变量，都是底层const，a的值可通过非const引用改变，但b5无法修改a</span></span><br></pre></td></tr></table></figure><p>注：具有底层<code>const</code>的指针或引用不能直接赋值给没有<code>const</code>限定的指针或引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demonstrateConstRestrictions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向普通int类型的指针（无底层const）</span></span><br><span class="line">    <span class="type">int</span>* nonConstPtr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向const int类型的指针（有底层const）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* constPtr = &amp;b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行会导致编译错误：</span></span><br><span class="line">    <span class="comment">// error: invalid conversion from &#x27;const int*&#x27; to &#x27;int*&#x27;</span></span><br><span class="line">    <span class="comment">// nonConstPtr = constPtr;  // 错误：试图将底层const转换为非const</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确的做法是使用const_cast，但要小心使用，确保原始数据确实是可修改的</span></span><br><span class="line">    <span class="comment">// 在这个特定情况下，由于&#x27;b&#x27;是一个const int，这样做实际上是不安全的</span></span><br><span class="line">    <span class="comment">// nonConstPtr = const_cast&lt;int*&gt;(constPtr);  // 不建议这么做</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是，从非const到const的转换总是安全的</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* safePtr = &amp;a;  <span class="comment">// 安全：增加const限定不会有问题</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value via safePtr: &quot;</span> &lt;&lt; *safePtr &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">demonstrateConstRestrictions</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-数组名和指针（这里为指向数组首元素的指针）区别"><a href="#3-数组名和指针（这里为指向数组首元素的指针）区别" class="headerlink" title="3.数组名和指针（这里为指向数组首元素的指针）区别"></a>3.数组名和指针（这里为指向数组首元素的指针）区别</h4><ul><li><p>数组名不是真正意义上的指针，可以理解为常指针，所以<strong>数组名没有自增、自减等操作。</strong></p></li><li><p>当数组名当<strong>做形参</strong>传递给调用函数后，就失去了原有特性，<strong>退化成一般指针，多了自增、自减操作</strong>，但sizeof运算符不能再得到原数组的大小了。</p></li></ul><h4 id="4-final和override关键字"><a href="#4-final和override关键字" class="headerlink" title="4.final和override关键字"></a>4.final和override关键字</h4><p><strong>override:</strong> </p><p>​    指定了子类的这个虚函数是重写的父类的,如果函数名输错，编译器会报错</p><p><strong>final：</strong></p><p>​    当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;    </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">           <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// foo 被override并且是最后一个override，在其子类中不可以重写&#125;;</span></span><br></pre></td></tr></table></figure><h4 id="5-拷贝初始化和直接初始化"><a href="#5-拷贝初始化和直接初始化" class="headerlink" title="5.拷贝初始化和直接初始化"></a>5.拷贝初始化和直接初始化</h4><ul><li><p><strong>直接初始化</strong>：直接调用与实参匹配的构造函数来初始化对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;I am a string&quot;</span>)</span></span>; <span class="comment">// 语句1：直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(str1)</span></span>;            <span class="comment">// 语句2：直接初始化，使用另一个对象进行初始化</span></span><br></pre></td></tr></table></figure></li><li><p><strong>拷贝初始化</strong>：首先<strong>创建一个临时对象</strong>，然后使用拷贝构造函数将这个临时对象的内容拷贝到正在创建的对象中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str3 = <span class="string">&quot;I am a string&quot;</span>; <span class="comment">// 语句3：拷贝初始化</span></span><br><span class="line">string str4 = str1;            <span class="comment">// 语句4：拷贝初始化</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="6-野指针和悬空指针"><a href="#6-野指针和悬空指针" class="headerlink" title="6.野指针和悬空指针"></a>6.野指针和悬空指针</h4><p><strong>野指针：</strong></p><p>​    没有被初始化过的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;         </span><br><span class="line"><span class="type">int</span>* p;     <span class="comment">// 未初始化    </span></span><br><span class="line">std::cout&lt;&lt; *p &lt;&lt; std::endl; <span class="comment">// 未初始化就被使用,可能会报错        </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：确保指针在声明时就被初始化。如果暂时没有有效的内存地址可以赋值给指针，应该将其设置为<code>nullptr</code>。这样，如果尝试解引用一个<code>nullptr</code>，大多数现代编译器会在运行时抛出异常或给出错误提示，从而帮助开发者快速定位问题。</p><p><strong>悬空指针:</strong></p><p>​    最初指向的内存已经被释放了的一种指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;   </span><br><span class="line"><span class="type">int</span> * p = <span class="literal">nullptr</span>;  </span><br><span class="line"><span class="type">int</span>* p2 = <span class="keyword">new</span> <span class="type">int</span>;   </span><br><span class="line"> p = p2;  <span class="keyword">delete</span> p2;</span><br><span class="line">&#125; <span class="comment">// 此时p和p2都变成了悬空指针</span></span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：</p><ul><li>在释放指针所指向的内存之后，立即将指针设置为<code>nullptr</code>。</li><li>C++引入了智能指针（如<code>std::unique_ptr</code>和<code>std::shared_ptr</code>），它们能够自动管理内存的分配和释放，从而有效避免悬空指针的产生。</li></ul><h4 id="7-C-中的重载、重写（覆盖）和隐藏的区别"><a href="#7-C-中的重载、重写（覆盖）和隐藏的区别" class="headerlink" title="7.C++中的重载、重写（覆盖）和隐藏的区别"></a>7.C++中的重载、重写（覆盖）和隐藏的区别</h4><p><strong>重载： </strong>重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，<strong>不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。</strong></p><p><strong>重写（override）：</strong>在派生类中覆盖基类中的同名函数，<strong>重写就是重写函数体</strong>，<strong>要求基类函数必须是虚函数</strong>且：</p><ul><li>与基类的虚函数有相同的参数个数</li><li>与基类的虚函数有相同的参数类型</li><li>与基类的虚函数有相同的返回值类型</li></ul><p><strong>隐藏（hide）:</strong> 派生类中的函数屏蔽了基类中的同名函数</p><p><strong>隐藏和重写的区别：</strong>  重写可以体现多态性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base: &quot;</span> &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; endl; &#125; <span class="comment">// 重写了基类中的foo(int x)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl; &#125; <span class="comment">// 隐藏了基类中的foo(int x, int y)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *pb = <span class="keyword">new</span> Derived;</span><br><span class="line">    pb-&gt;<span class="built_in">foo</span>(<span class="number">1</span>);     <span class="comment">// 调用的是Derived::foo(int x)，因为Base::foo(int x)是虚函数且被重写</span></span><br><span class="line">    pb-&gt;<span class="built_in">foo</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 调用的是Base::foo(int x, int y)，因为Derived::foo(int x, int y)隐藏了基类的同名函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503162026007.png" alt="image-20250316202637727" style="zoom:67%;"></p><h4 id="8-C-有哪几种的构造函数"><a href="#8-C-有哪几种的构造函数" class="headerlink" title="8.C++有哪几种的构造函数"></a>8.C++有哪几种的构造函数</h4><ul><li><p><strong>默认构造函数:</strong> 不带任何参数的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="comment">// 默认构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj; <span class="comment">// 调用默认构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化构造函数:</strong> 接受一个或多个参数以初始化对象的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123; <span class="comment">// 初始化构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameterized Constructor with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 调用有参数的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>拷贝构造函数:</strong>  使用<strong>同一类型的另一个对象</strong>来初始化新创建的对象时调用的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass &amp;other) : <span class="built_in">value</span>(other.value) &#123; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy Constructor, value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    MyClass obj2 = obj1; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>移动构造函数（Move和右值引用）：</strong>用于实现资源转移而非复制，避免不必要的深拷贝操作。它通常与右值引用一起使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123; <span class="comment">// 移动构造函数</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">//确保原对象不再拥有对资源的所有权,防止悬空指针</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> size) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[size]) &#123;&#125; <span class="comment">// 简化的构造函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    MyClass obj2 = std::<span class="built_in">move</span>(obj1); <span class="comment">// 调用移动构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>委托构造函数： </strong>允许在一个构造函数内部调用同一个类的其他构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">MyClass</span>(<span class="number">0</span>) &#123; &#125; <span class="comment">// 委托构造函数，委托给下面的构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123; <span class="comment">// 初始化构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameterized Constructor with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj; <span class="comment">// 调用默认构造函数，但实际通过委托构造函数间接调用了有参数的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>转换构造函数:</strong> 允许编译器隐式地将一种类型的值转换为类的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Temperature</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> celsius;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换构造函数：从 double 到 Temperature 的转换</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Temperature</span><span class="params">(<span class="type">double</span> c)</span> : celsius(c) &#123;</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Conversion Constructor, Celsius: &quot;</span> &lt;&lt; celsius &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示当前温度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Temperature is &quot;</span> &lt;&lt; celsius &lt;&lt; <span class="string">&quot; degrees Celsius.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，接受一个 Temperature 对象并显示其值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayTemperature</span><span class="params">(<span class="type">const</span> Temperature&amp; temp)</span> </span>&#123;</span><br><span class="line">    temp.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用显式构造函数调用创建对象</span></span><br><span class="line">    <span class="function">Temperature <span class="title">t1</span><span class="params">(<span class="number">36.5</span>)</span></span>; <span class="comment">// 正确：显式调用转换构造函数</span></span><br><span class="line">    t1.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行会导致编译错误，因为构造函数被声明为 explicit</span></span><br><span class="line">    <span class="comment">// Temperature t2 = 40.0; // 错误：不允许隐式转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过辅助函数传递 double 值，但需要显式转换</span></span><br><span class="line">    <span class="built_in">displayTemperature</span>(<span class="built_in">Temperature</span>(<span class="number">25.0</span>)); <span class="comment">// 正确：显式创建临时对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果去掉 explicit 关键字，则下面的语句也会合法</span></span><br><span class="line">    <span class="comment">// Temperature t3 = 37.0; // 如果构造函数不是 explicit，则这是合法的隐式转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-浅拷贝和深拷贝的区别"><a href="#9-浅拷贝和深拷贝的区别" class="headerlink" title="9.浅拷贝和深拷贝的区别"></a>9.浅拷贝和深拷贝的区别</h4><p><strong>浅拷贝共享数据：</strong> 浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p><p><strong>深拷贝各自拥有独立的数据副本：</strong> 开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。</p><p><em>注：浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源</em></p><h4 id="10-内联函数和宏定义的区别"><a href="#10-内联函数和宏定义的区别" class="headerlink" title="10.内联函数和宏定义的区别"></a>10.内联函数和宏定义的区别</h4><ul><li><strong>处理时机</strong>：宏定义是在预处理阶段进行简单的文本替换； 内联函数则是在编译时进行处理，并且可以进行参数类型检查。这使得内联函数更加安全和可靠。</li><li><strong>类型检查与返回值</strong>：由于宏只是简单的字符串替换，它无法进行任何类型检查，也无法直接拥有返回值的概念。内联函数支持参数类型检查，确保传入参数的类型正确，并能够像普通函数一样有明确的返回值。</li></ul><p><strong>内联函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 定义一个内联函数来计算两个整数的和</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 使用内联函数计算两数之和</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">add</span>(num1, num2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>宏：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 定义一个宏来计算两个整数的和</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(a, b) ((a) + (b))</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 使用宏计算两数之和</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">ADD</span>(num1, num2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title=" "></a> </h4>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake</title>
      <link href="/posts/42cbd3c8.html"/>
      <url>/posts/42cbd3c8.html</url>
      
        <content type="html"><![CDATA[<h3 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h3><h4 id="CMake编译过程"><a href="#CMake编译过程" class="headerlink" title="CMake编译过程"></a>CMake编译过程</h4><ul><li>创建CMakeLists.txt文件：<code>touch CMakeLists.txt</code></li><li>使⽤cmake，生成makefile文件</li><li>使⽤make命令编译，生成了可执行程序</li></ul><p><strong>PROJECT</strong></p><p><code>PROJECT:</code>来指定工程的名称</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span> (HELLO)</span><br></pre></td></tr></table></figure><p><strong>add_executable</strong>：定义工程会生成一个可执行程序</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(可执行程序名 源文件名称)</span><br></pre></td></tr></table></figure><h4 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h4><ul><li><p><strong>显示地指定变量</strong></p><p><code>SET(SRC_LIST main.cpp)</code> SRC_LIST变量就包含了main.cpp</p><p>多个cpp文件：<code>SET(SRC_LIST main.cpp t1.cpp t2.cpp)</code></p></li><li><p><strong>在 CMakeLists.txt 中通过 set 命令指定所使用的C++标准：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加-std=c++11</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment">#增加-std=c++14</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="comment">#增加-std=c++17</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>指定输出的路径：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(HOME /home/robin/Linux/Sort)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>/bin)</span><br></pre></td></tr></table></figure><p><em>注：<code>EXECUTABLE_OUTPUT_PATH</code>是可执行程序输出的路径对应的宏，如果这个路径中的子目录不存在，会自动生成，无需自己手动创建</em></p></li></ul><h4 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h4><ul><li><p><strong><code>aux_source_directory</code> 命令可以查找某个路径下的所有源文件</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 搜索 src 目录下的源文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src SRC_LIST)</span><br><span class="line"><span class="keyword">add_executable</span>(app  <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure></li></ul><p>​    <em>注1：<code>PROJECT_SOURCE_DIR</code>是执行<code>cmake</code>命令时指定的路径； <code>CMAKE_CURRENT_SOURCE_DIR</code>是当前的CMakeLists.txt所对应的路径</em></p><p>​    <em>注2：<code>PROJECT_SOURCE_DIR</code>和<code>CMAKE_CURRENT_SOURCE_DIR</code>存储的值是一样的</em></p><ul><li><p><strong><code>file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</code></strong></p><ul><li><p><code>GLOB</code>: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。</p></li><li><p><code>GLOB_RECURSE</code>：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>include_directories</code>: 用于指定头文件的路径</strong></p></li></ul><h4 id="制作动态库和静态库"><a href="#制作动态库和静态库" class="headerlink" title="制作动态库和静态库"></a>制作动态库和静态库</h4><ul><li><strong>制作静态库：<code>add_library(&lt;库名称&gt; STATIC &lt;源文件&gt;)</code></strong></li></ul><p>​    <em>注1：在Linux中，静态库名分为三部分：<code>lib+库名称+.a</code></em></p><ul><li><p><strong>制作动态库：<code>add_library(&lt;库名称&gt; SHARE &lt;源文件&gt;)</code></strong></p></li><li><p><strong>使用<code>LIBRARY_OUTPUT_PATH</code>指定生成的库文件的路径</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="comment"># 设置动态库/静态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment">#add_library(calc SHARED $&#123;SRC_LIST&#125;)</span></span><br><span class="line"><span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>链接静态库：</strong><code>link_libraries(&lt;库名称&gt;...)</code></p><p><em>注：如果静态库是自定义的，要使用<code>link_directories(&lt;lib path&gt;)</code>来指定库路径</em></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="comment"># 搜索指定目录下源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="comment"># 包含头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 包含静态库路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line"><span class="keyword">link_libraries</span>(calc)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>链接动态库：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">    &lt;需要链接动态库的文件&gt; </span><br><span class="line">    &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;库名称&gt;... </span><br><span class="line">    [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;库名称&gt;...]...)</span><br></pre></td></tr></table></figure><p>注：默认权限为<code>PUBLIC</code>,<code>PUBLIC</code>具有传递性； <code>INTERFACE</code>只会导出符号</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 添加并指定最终生成的可执行程序名</span></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 指定可执行程序要链接的动态库名字</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread)</span><br></pre></td></tr></table></figure></li></ul><h4 id="日志信息"><a href="#日志信息" class="headerlink" title="日志信息"></a>日志信息</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] <span class="string">&quot;message to display&quot;</span> ...)</span><br></pre></td></tr></table></figure><ul><li>(无) ：重要消息</li><li><code>STATUS</code>：非重要消息</li><li><code>WARNING</code>：CMake 警告, 会继续执行</li><li><code>AUTHOR_WARNING</code>：CMake 警告 (dev), 会继续执行</li><li><code>SEND_ERROR</code>：CMake 错误, 继续执行，但是会跳过生成的步骤</li><li><code>FATAL_ERROR</code>：CMake 错误, 终止所有处理过程</li></ul><h4 id="变量的操作"><a href="#变量的操作" class="headerlink" title="变量的操作"></a>变量的操作</h4><ul><li><p><strong>字符串拼接：</strong></p><ul><li><p><code>set(变量名1 $&#123;变量名1&#125; $&#123;变量名2&#125; ...)</code></p></li><li><p><code>list(APPEND &lt;list&gt; [&lt;element&gt; ...])</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">set</span>(TEMP <span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src1/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_2 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src2/*.cpp)</span><br><span class="line"><span class="comment"># 追加(拼接)</span></span><br><span class="line"><span class="keyword">list</span>(APPEND SRC_1 <span class="variable">$&#123;SRC_1&#125;</span> <span class="variable">$&#123;SRC_2&#125;</span> <span class="variable">$&#123;TEMP&#125;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>字符串移除:</strong></p><p><code>list(REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...])</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 移除 main.cpp</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/main.cpp)</span><br></pre></td></tr></table></figure></li></ul><h4 id="定义宏"><a href="#定义宏" class="headerlink" title="定义宏"></a>定义宏</h4><p><code>add_definitions(-D宏名称)</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="comment"># 自定义 DEBUG 宏</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-DDEBUG)</span><br><span class="line"><span class="keyword">add_executable</span>(app ./<span class="keyword">test</span>.c)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#define NUMBER  3</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">#ifdef DEBUG</span></span><br><span class="line">    printf(<span class="string">&quot;我是一个程序猿, 我不会爬树...\n&quot;</span>);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    for(int i=<span class="number">0</span>; i&lt;NUMBER; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;hello, GCC!!!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌套的CMake"><a href="#嵌套的CMake" class="headerlink" title="嵌套的CMake"></a>嵌套的CMake</h4><p><strong>建立父子节点之间的关系：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(source_dir)</span><br></pre></td></tr></table></figure><p><code>source_dir:</code> 子节点所在的目录</p><p><em>注：子节点可以使用根节点定义的变量，而根节点不可以使用子节点的变量</em></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Protobuf</title>
      <link href="/posts/608ca7e8.html"/>
      <url>/posts/608ca7e8.html</url>
      
        <content type="html"><![CDATA[<h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><h4 id="Protobuf序列化的步骤"><a href="#Protobuf序列化的步骤" class="headerlink" title="Protobuf序列化的步骤"></a>Protobuf序列化的步骤</h4><p><strong>protobuf中的数据类型 和 C++ 数据类型对照:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503131059638.png" alt="image-20250313100438695" style="zoom:67%;"></p><p><strong>使用protobuf进行序列化的步骤：</strong></p><ul><li><strong>定义.proto文件：</strong> <code>.proto</code>文件来描述要序列化的数据结构</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明所使用的protobuf版本号</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> id = <span class="number">2</span>;</span><br><span class="line">  <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：等号后面的编号要<strong>从1开始</strong>，每个成员都有一个<strong>唯一的编号</strong>，不能重复，一般连续编号即可。</em></p><ul><li><strong>编译.proto文件：</strong>使用<code>protoc</code>编译器将<code>user_info.proto</code>文件编译成C++代码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I path &lt;user_info.proto&gt; --cpp_out=输出路径(存储生成的c++文件)</span><br></pre></td></tr></table></figure><p><em>注1：<code>-I</code>: 参数后面可以跟随一个或多个路径，用于告诉编译器在哪些路径下查找导入的文件或依赖的文件,如<code>protoc -I path1 -I path2</code> 或 <code>protoc -I path1:path2</code></em></p><p><em>注2：这会在输出路径下生成<code>user_info.pb.h</code>和<code>user_info.pb.cc</code>两个文件。</em></p><ul><li><strong>在C++项目中集成：</strong></li></ul><p>在项目的源文件中包含生成的头文件：<code>#include &quot;user_info.pb.h&quot;</code></p><ul><li><p><strong>序列化和反序列化:</strong></p><ul><li><p><strong>序列化：</strong>创建一个<code>UserInfo</code>对象并设置其字段值，然后调用<code>SerializeToArray</code>或<code>SerializeToString</code>方法将其序列化为字节流。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UserInfo user;</span><br><span class="line">user.<span class="built_in">set_id</span>(<span class="number">1</span>);</span><br><span class="line">user.<span class="built_in">set_name</span>(<span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">user.<span class="built_in">set_email</span>(<span class="string">&quot;johndoe@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">std::string data;</span><br><span class="line"><span class="comment">//接受一个std::string类型的引用作为输出参数</span></span><br><span class="line">user.<span class="built_in">SerializeToString</span>(&amp;data);</span><br></pre></td></tr></table></figure></li><li><p><strong>反序列化</strong>：创建一个<code>UserInfo</code>对象，并通过调用<code>ParseFromArray</code>或<code>ParseFromString</code>方法从字节流中恢复数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UserInfo user;</span><br><span class="line"><span class="keyword">if</span> (user.<span class="built_in">ParseFromString</span>(data)) &#123;</span><br><span class="line">    <span class="comment">// 成功解析后，可以访问user的字段了</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; user.<span class="built_in">id</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; user.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Email: &quot;</span> &lt;&lt; user.<span class="built_in">email</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 解析失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="repeated-限定修饰符"><a href="#repeated-限定修饰符" class="headerlink" title="repeated 限定修饰符"></a>repeated 限定修饰符</h4><p><strong><code>repeated</code>：</strong> 用于定义可重复字段的关键字，与数组或列表概念相似。</p><p>eg:</p><ul><li><strong>定义 .proto 文件：</strong></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">string</span> title = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">string</span> authors = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int32</span> year_published = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用生成的类：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;book.pb.h&quot;</span> <span class="comment">// 假设生成的文件名为book.pb.h</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddBookInfo</span><span class="params">(Book &amp;book)</span> </span>&#123;</span><br><span class="line">    book.<span class="built_in">set_title</span>(<span class="string">&quot;Example Book Title&quot;</span>);</span><br><span class="line">    book.<span class="built_in">add_authors</span>(<span class="string">&quot;Author One&quot;</span>);</span><br><span class="line">    book.<span class="built_in">add_authors</span>(<span class="string">&quot;Author Two&quot;</span>);</span><br><span class="line">    book.<span class="built_in">set_year_published</span>(<span class="number">2025</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Book book;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加书籍信息</span></span><br><span class="line">    <span class="built_in">AddBookInfo</span>(book);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问并打印书籍信息</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Title: &quot;</span> &lt;&lt; book.<span class="built_in">title</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Year Published: &quot;</span> &lt;&lt; book.<span class="built_in">year_published</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Authors:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; book.<span class="built_in">authors_size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; book.<span class="built_in">authors</span>(i) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p><strong>c++中的枚举类型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    Red = <span class="number">5</span>,<span class="comment">// 可以不给初始值, 默认为0</span></span><br><span class="line">    Green,</span><br><span class="line">    Yellow,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <strong>.proto 文件中：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    Red = <span class="number">0</span>;</span><br><span class="line">    Green = <span class="number">3</span>;<span class="comment">// 第一个元素以外的元素值可以随意指定</span></span><br><span class="line">    Yellow = <span class="number">6</span>;</span><br><span class="line">    Blue = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：第一个元素的元素值必须为0，元素之间使用<code>;</code></em></p><h4 id="Protobuf中包的概念"><a href="#Protobuf中包的概念" class="headerlink" title="Protobuf中包的概念"></a>Protobuf中包的概念</h4><p>Protobuf使用包的概念避免消息类型之间的命名冲突</p><p>eg:</p><p><strong>定义 .proto 文件:</strong></p><ul><li><p><strong>user_info.proto:</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> user.profile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">2</span>;</span><br><span class="line">    <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>order_info.proto:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package order.details;</span><br><span class="line"></span><br><span class="line">message OrderInfo &#123;</span><br><span class="line">    string product_name = 1;</span><br><span class="line">    int32 order_id = 2;</span><br><span class="line">    string customer_email = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>在C++中使用:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user_info.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;order_info.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用user.profile.UserInfo(需要指定命名空间)</span></span><br><span class="line">    user::profile::UserInfo user;</span><br><span class="line">    user.<span class="built_in">set_name</span>(<span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">    user.<span class="built_in">set_id</span>(<span class="number">1234</span>);</span><br><span class="line">    user.<span class="built_in">set_email</span>(<span class="string">&quot;johndoe@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;User Info:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; user.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; user.<span class="built_in">id</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Email: &quot;</span> &lt;&lt; user.<span class="built_in">email</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用order.details.OrderInfo</span></span><br><span class="line">    order::details::OrderInfo order;</span><br><span class="line">    order.<span class="built_in">set_product_name</span>(<span class="string">&quot;Example Product&quot;</span>);</span><br><span class="line">    order.<span class="built_in">set_order_id</span>(<span class="number">5678</span>);</span><br><span class="line">    order.<span class="built_in">set_customer_email</span>(<span class="string">&quot;customer@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nOrder Info:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Product Name: &quot;</span> &lt;&lt; order.<span class="built_in">product_name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Order ID: &quot;</span> &lt;&lt; order.<span class="built_in">order_id</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Customer Email: &quot;</span> &lt;&lt; order.<span class="built_in">customer_email</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell基础</title>
      <link href="/posts/4544560.html"/>
      <url>/posts/4544560.html</url>
      
        <content type="html"><![CDATA[<h2 id="Shell基础"><a href="#Shell基础" class="headerlink" title="Shell基础"></a>Shell基础</h2><p>shell是一个命令行解释器，用于接收用户（应用程序）命令来调用系统内核。</p><ul><li><p><strong>脚本格式：</strong>以<strong><code>#!/bin/bash</code></strong>开头（指定解析器）</p></li><li><p><strong>执行方式：</strong></p><ul><li><p><strong><code>1.bash/sh + 绝对路径（相对路径）</code></strong></p></li><li><p><strong><code>2.绝对路径（相对路径）</code></strong></p><p>需要可执行(x)权限</p></li><li><p><strong><code>3.source + 绝对路径（相对路径）</code>:</strong> 在当前的shell下执行</p></li></ul></li></ul><p><strong>子shell：</strong>在子shell中设置的当前的环境变量，对于父shell不可见</p><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h3><h4 id="1-1-常用系统变量"><a href="#1-1-常用系统变量" class="headerlink" title="1.1 常用系统变量"></a>1.1 常用系统变量</h4><p><strong>常用系统变量：</strong>$HOME、$PWD、$USR、$SHELL、$PATH</p><p><code>env</code>: 列出当前 shell 的所有环境变量</p><p><code>set</code>: 显示所有 shell 变量（包括环境变量和局部变量）</p><p><code>printenv+环境变量名</code>: 输出某个环境变量的值</p><p><code>$PATH</code>: 保存了搜索系统命令的路径(<code>/usr/bin</code>)</p><h4 id="1-2-自定义变量"><a href="#1-2-自定义变量" class="headerlink" title="1.2 自定义变量"></a>1.2 自定义变量</h4><p><strong>自定义变量（局部变量）：</strong><code>变量名=变量值</code><strong>(等号前后不能有空格)</strong></p><p><strong>局部变量导出为全局变量：</strong><code>export + 变量名</code></p><p><em>注：在子shell中修改全局变量对父shell不可见</em></p><p><strong>只读变量：</strong><code>readonly 变量名=变量值</code></p><p><strong>撤销变量：</strong><code>unset + 变量名</code></p><p><em>注1：在bash中，变量默认的类型都是字符串类型，无法直接进行数值计算。</em></p><p><em>注2：只读变量不能unset。</em></p><h4 id="1-3-特殊变量"><a href="#1-3-特殊变量" class="headerlink" title="1.3 特殊变量"></a>1.3 特殊变量</h4><ul><li><code>$n</code>: n为数字，<code>$0</code>代表脚本名称，<code>$1</code>-<code>$9</code>代表第一到第九个参数，十个以上使用<code>&#123;&#125;</code>，如<code>$&#123;10&#125;</code>。</li><li><code>$#</code>: 获取所有输入参数的个数，常用于循环，判断参数的个数是否正确。</li><li><code>$*</code>: 获取命令行中的所有参数，并将其看成一个整体</li><li><p><code>$@</code>: 获取命令行中的所有参数，将其看作一个集合</p></li><li><p><code>$?</code>: 获取上一个命令的返回状态，返回0表示正常结束</p></li></ul><h3 id="2-运算"><a href="#2-运算" class="headerlink" title="2.运算"></a>2.运算</h3><h4 id="2-1-运算符"><a href="#2-1-运算符" class="headerlink" title="2.1 运算符"></a>2.1 运算符</h4><p><strong>语法格式：<code>$((运算式))</code>或<code>$[运算式]</code></strong></p><p><em>注：(( ))中可用使用数学表达式进行运算</em></p><p><strong>使用expr:</strong> <code>a=$(expr 5 \* 2)</code></p><h4 id="2-2-条件判断"><a href="#2-2-条件判断" class="headerlink" title="2.2 条件判断"></a>2.2 条件判断</h4><ul><li><p><strong><code>test +判断条件</code> :</strong> <code>test $a = 2</code></p></li><li><p><strong><code>[ 判断条件 ]</code></strong>: “[ ]”前后要有空格</p></li></ul><p><strong>判断条件：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503112004717.png" alt="image-20250311151642241" style="zoom:67%;"></p><p>​                                                      <img src="https://typoraimg.wangak.cc/2023/img/202503112004656.png" alt="image-20250311151752312" style="zoom:67%;"></p><p>​                                                  <img src="https://typoraimg.wangak.cc/2023/img/202503112004116.png" alt="image-20250311152111395" style="zoom:67%;"></p><p>​                                              <img src="https://typoraimg.wangak.cc/2023/img/202503112004470.png" alt="image-20250311152834726" style="zoom:67%;"></p><p><strong>eg:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断<span class="built_in">test</span>文件是否有读的权限</span></span><br><span class="line">[ -r test ]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断8是否小于2</span></span><br><span class="line">[ 8 -lt 2 ]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断目录是否存在</span></span><br><span class="line">[ -d /home/ubuntu/scripts ] </span><br></pre></td></tr></table></figure><p><strong>“[ ]”中的逻辑条件连接使用：<code>-a</code>(and)和<code>-o</code>(or)</strong></p><h4 id="2-3-流程控制"><a href="#2-3-流程控制" class="headerlink" title="2.3 流程控制"></a>2.3 流程控制</h4><p><strong>if判断</strong></p><ul><li><p><strong>单分支：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断 ];then</span><br><span class="line">程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p><strong>双分支:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断 ];then</span><br><span class="line">程序1</span><br><span class="line">else</span><br><span class="line">程序2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p><strong>多分支：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断1 ]</span><br><span class="line">then</span><br><span class="line">程序1</span><br><span class="line">elif [ 条件判断2 ]</span><br><span class="line">then</span><br><span class="line">程序2</span><br><span class="line">else</span><br><span class="line">程序3</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li></ul><p><strong>for循环</strong></p><p><strong>用法一：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sum=0</span><br><span class="line">for (( i=1 ;i &lt;= $1; i++))</span><br><span class="line">do</span><br><span class="line">        sum=$[ $sum + $i ]</span><br><span class="line">done</span><br><span class="line">echo sum=$sum</span><br></pre></td></tr></table></figure><p><strong>用法二：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3...</span><br><span class="line">do </span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sum=0</span><br><span class="line">for i in &#123;1..100&#125;</span><br><span class="line">do</span><br><span class="line">        sum=$[$sum + $i]</span><br><span class="line">done</span><br><span class="line">echo sum=$sum</span><br></pre></td></tr></table></figure><p><strong>while循环</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [条件判断式]</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="2-4-Read读取控制台的输入"><a href="#2-4-Read读取控制台的输入" class="headerlink" title="2.4 Read读取控制台的输入"></a>2.4 Read读取控制台的输入</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202503112004690.png" alt="image-20250311163511274" style="zoom:67%;"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置超时时间为 5 秒</span></span><br><span class="line">read -t 5 -p &quot;请在 5 秒内输入您的名字: &quot; name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查用户是否输入</span></span><br><span class="line">if [ -z &quot;$name&quot; ]; then</span><br><span class="line">    echo &quot;您未在规定时间内输入名字。&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;您好, $name! 欢迎使用本脚本。&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="2-5-函数"><a href="#2-5-函数" class="headerlink" title="2.5 函数"></a>2.5 函数</h4><p><strong>系统函数</strong></p><p><code>data +%s</code>: 输出时间戳</p><p><code>basename 路径 [后缀]</code>: 用于从文件路径中提取文件名或目录名，去除路径前缀和后缀</p><p><code>dirname 路径</code>: 用于从文件路径中提取目录部分，即去掉文件名，返回路径的父目录。</p><p><strong>自定义函数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名() &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">function add() &#123;</span><br><span class="line">    s=$[$1 + $2]</span><br><span class="line">    echo $s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;输入第一个数&quot; a</span><br><span class="line">read -p &quot;输入第二个数&quot; b</span><br><span class="line">sum=$(add $a $b)</span><br><span class="line">echo &quot;和:&quot;$sum</span><br></pre></td></tr></table></figure><p><em>注：不使用<code>$?</code>接受返回值，<code>$?</code>接收的范围为[0~255]</em></p><h4 id="2-6-正则表达式"><a href="#2-6-正则表达式" class="headerlink" title="2.6 正则表达式"></a>2.6 正则表达式</h4><ul><li><p><strong>常规匹配:</strong> 匹配常规字符”xxxx”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | grep xxxx</span><br></pre></td></tr></table></figure></li><li><p><strong>模糊匹配：</strong></p><ul><li><p><code>^</code>: 匹配一行的开头</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匹配所有以a开头的行</span></span><br><span class="line">cat /etc/passwd |grep ^a</span><br></pre></td></tr></table></figure></li><li><p><code>$</code>: 匹配一行的结束</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匹配所有以a结束的行</span></span><br><span class="line">cat /etc/passwd |grep a$</span><br></pre></td></tr></table></figure></li><li><p><code>.</code>: 匹配任意的字符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匹配所有r..t的行</span></span><br><span class="line">cat /etc/passwd |grep r..t</span><br></pre></td></tr></table></figure></li><li><p><code>*</code>: 不单独使用，与上一个字符连用，表示匹配上个字符的<strong>0次</strong>或多次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匹配rt,rot,root,rooot等所有行</span></span><br><span class="line">cat /etc/passwd |grep ro*t</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匹配以a开头，bash结尾,中间为任意字符的所有行</span></span><br><span class="line">cat /etc/passwd |grep ^a.*bash$</span><br></pre></td></tr></table></figure><ul><li><code>[ ]</code>: 匹配某个范围内的字符</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202503112004742.png" alt="image-20250311195601295" style="zoom:67%;"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++八股1</title>
      <link href="/posts/c2c0fb72.html"/>
      <url>/posts/c2c0fb72.html</url>
      
        <content type="html"><![CDATA[<h2 id="C-八股"><a href="#C-八股" class="headerlink" title="C++八股"></a>C++八股</h2><h4 id="1-在main执行之前和之后执行的代码可能是什么"><a href="#1-在main执行之前和之后执行的代码可能是什么" class="headerlink" title="1.在main执行之前和之后执行的代码可能是什么"></a><strong>1.在main执行之前和之后执行的代码可能是什么</strong></h4><ul><li><p>main函数执行之前，主要就是<strong>初始化系统相关资源</strong>：</p><ul><li>设置栈指针</li><li>初始化静态static变量和global全局变量</li><li>调用构造函数</li></ul></li><li><p>main函数执行之后：</p><ul><li>全局对象的析构函数</li></ul></li></ul><h4 id="2-指针和引用的区别"><a href="#2-指针和引用的区别" class="headerlink" title="2.指针和引用的区别"></a><strong>2.指针和引用的区别</strong></h4><ul><li><p><strong>指针是一个变量</strong>，存储的是一个地址，<strong>引用是原变量的别名</strong></p></li><li><p>指针可以为空，引用不能为NULL且在定义时必须初始化</p></li></ul><h4 id="3-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"><a href="#3-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？" class="headerlink" title="3.在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"></a><strong>3.在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</strong></h4><ul><li><strong>需要返回函数内局部变量的内存的时候用指针。</strong>指针作为函数参数，需要在堆上动态分配内存，在函数外部仍然可以访问这块内存。完要记得释放指针，不然会内存泄漏。</li><li>对栈空间大小比较敏感（比如递归）的时候使用引用。<strong>使用引用传递不需要创建临时变量，开销要更小</strong></li><li><strong>类对象作为参数传递的时候使用引用</strong>，这是C++类对象传递的标准方式</li></ul><h4 id="4-堆和栈的区别"><a href="#4-堆和栈的区别" class="headerlink" title="4.堆和栈的区别"></a><strong>4.堆和栈的区别</strong></h4><ul><li><p>申请<strong>方式</strong>不同。</p><ul><li>栈由系统自动分配。</li><li>堆是自己申请和释放的。</li></ul></li><li><p>申请<strong>大小限制</strong>不同。</p><ul><li><p>栈顶和栈底是之前预设好的，栈是向栈底扩展（从高地址向低地址扩展），大小固定</p><p>注：栈空间耗尽（例如递归调用过深），会导致 <strong>栈溢出</strong></p></li><li><p>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</p></li></ul></li><li><p>申请<strong>效率</strong>不同。</p><ul><li>栈由系统分配，<strong>速度快</strong>，不会有碎片。</li><li>堆由程序员分配，速度慢，且会有碎片。</li></ul></li></ul><h4 id="5-new-delete-与-malloc-free的异同"><a href="#5-new-delete-与-malloc-free的异同" class="headerlink" title="5.new / delete 与 malloc / free的异同"></a>5.new / delete 与 malloc / free的异同</h4><p><strong>相同点：</strong></p><ul><li>都可用于内存的动态申请和释放</li></ul><p><strong>不同点：</strong></p><ul><li>前者是C++运算符，后者是C/C++语言标准库函数。</li><li><code>new</code><strong>自动</strong>计算要分配的空间大小，<code>malloc</code>需要<strong>手工</strong>计算。</li><li><code>new</code> 在分配内存后会调用对象的构造函数初始化对象，在使用 <code>delete</code> 时则会先调用对象的析构函数再释放内存。后者均没有相关调用。</li><li><p><strong>new是类型安全的，malloc不是。</strong></p></li><li><p><code>new</code>是封装了<code>malloc</code>，直接<code>free</code>不会报错，但是这只是释放内存，而不会析构对象</p></li><li><p><strong>malloc和free返回的是void类型指针(void*)（必须进行类型转换）</strong>，new和delete返回的是具体类型指针。</p><p><em>注：虽然 <code>new</code> 和 <code>malloc</code> 都能用于内存的动态分配，但由于C++中面向对象特性的引入，<code>new</code> 提供了更高级、更安全的内存管理机制，包括自动计算内存大小、类型安全性和自动调用构造函数与析构函数等特性。</em></p></li></ul><p><code>new/delete</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个整型对象</span></span><br><span class="line"><span class="type">int</span>* pInt = <span class="keyword">new</span> <span class="type">int</span>; </span><br><span class="line">*pInt = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放该对象</span></span><br><span class="line"><span class="keyword">delete</span> pInt;</span><br></pre></td></tr></table></figure><p><code>malloc/free</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配空间用于存储一个整型值，并将其初始化为10</span></span><br><span class="line"><span class="type">int</span>* pInt = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*pInt = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放该对象</span></span><br><span class="line"><span class="built_in">free</span>(pInt);</span><br></pre></td></tr></table></figure><h4 id="6-new和delete是如何实现的？"><a href="#6-new和delete是如何实现的？" class="headerlink" title="6.new和delete是如何实现的？"></a>6.new和delete是如何实现的？</h4><p><strong>new：</strong></p><ul><li><strong>分配内存：</strong>调用名为<strong>operator new</strong>的标准库函数</li><li><strong>初始化构造对象：</strong>调用构造函数</li><li><strong>返回指针：</strong>返回指向新分配并构造后的的对象的指针</li></ul><p><strong>delete：</strong></p><ul><li><strong>调用析构函数</strong></li><li><strong>释放所用内存：</strong>调用名为<strong>operator delete</strong>的标准库函数释放所用内存</li></ul><h4 id="7-被free回收的内存是立即返还给操作系统吗？"><a href="#7-被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="7.被free回收的内存是立即返还给操作系统吗？"></a>7.被free回收的内存是立即返还给操作系统吗？</h4><p>​    不是的，被free回收的内存会首先被ptmalloc使用<strong>双链表保存</strong>起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就<strong>避免了频繁的系统调用</strong>，占用过多的系统资源。同时ptmalloc也会尝试对小块<strong>内存进行合并</strong>，<strong>避免过多的内存碎片。</strong></p><h4 id="8-宏定义和函数有何区别？"><a href="#8-宏定义和函数有何区别？" class="headerlink" title="8.宏定义和函数有何区别？"></a>8.宏定义和函数有何区别？</h4><ul><li><strong>宏在编译时完成替换</strong>，<strong>执行起来更快</strong>；函数调用在运行时需要跳转到具体调用函数。</li><li>宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。 </li><li>宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。</li></ul><h4 id="9-宏定义和typedef区别？"><a href="#9-宏定义和typedef区别？" class="headerlink" title="9.宏定义和typedef区别？"></a>9.宏定义和typedef区别？</h4><ul><li><p><strong>typedef主要用于定义类型别名。</strong></p></li><li><p>宏替换发生在编译阶段之前（预处理阶段），属于文本插入替换；<strong>typedef是编译的一部分。</strong></p></li><li>宏不检查类型；typedef会检查数据类型。</li></ul><h4 id="10-strlen和sizeof区别？"><a href="#10-strlen和sizeof区别？" class="headerlink" title="10.strlen和sizeof区别？"></a>10.strlen和sizeof区别？</h4><ul><li><p><strong><code>sizeof</code>是运算符</strong>，并不是函数，结果<strong>在编译时得到而非运行中获得</strong>；<code>strlen</code>是字符处理的库函数。</p></li><li><p><strong><code>sizeof</code>参数可以是任何数据类型或数据；<code>strlen</code>的参数只能是字符指针且结尾是’\0’的字符串</strong>：</p></li><li>因为<code>sizeof</code>值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。 </li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sizeof</span>(str); <span class="comment">// 取的是指针str的长度，是8</span></span><br><span class="line">    <span class="built_in">strlen</span>(str); <span class="comment">// 取的是这个字符串的长度，不包含结尾的 \0。大小是4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-常量指针和指针常量区别"><a href="#11-常量指针和指针常量区别" class="headerlink" title="11.常量指针和指针常量区别"></a>11.常量指针和指针常量区别</h4><ul><li>指针常量，如<code>int const *p</code>或<code>const int *p</code>，是一个指针指向一个只读变量。</li><li>常量指针是一个不能给改变指向的指针,<code>int *const p</code></li></ul><h4 id="12-数组名-a和取地址操作符-amp-a有什么区别"><a href="#12-数组名-a和取地址操作符-amp-a有什么区别" class="headerlink" title="12.数组名 a和取地址操作符 &amp;a有什么区别?"></a>12.数组名 <code>a</code>和取地址操作符 <code>&amp;a</code>有什么区别?</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C++</span><br><span class="line">假设数组</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">10</span>] = &amp;a;</span><br></pre></td></tr></table></figure><p><strong>数组名 <code>a</code>:</strong></p><ul><li><strong>作为首元素的指针</strong>：指向数组第一个元素</li><li><strong>加法运算</strong>：<code>a + 1</code>，它会<strong>根据数组元素的数据类型</strong>（在这个例子中是 <code>int</code>）来增加地址,<code>a + 1</code> 将会指向下一个 <code>int</code> 的位置</li></ul><p><strong>取地址操作符 <code>&amp;a</code>:</strong></p><ul><li><strong>指向整个数组的指针</strong>：<code>&amp;a + 1</code>，它会跳过整个数组的长度（即10个 <code>int</code> 的大小），指向数组最后一个元素之后的位置。</li></ul><h4 id="13-C-中struct和class的区别"><a href="#13-C-中struct和class的区别" class="headerlink" title="13.C++中struct和class的区别"></a>13.C++中struct和class的区别</h4><p><strong>相同点:</strong></p><ul><li>两者都拥有成员函数、公有和私有部分</li><li>任何可以使用class完成的工作，同样可以使用struct完成</li></ul><p><strong>不同点：</strong></p><ul><li>两者中如果不对成员不指定公私有，<strong>struct默认是公有的</strong>，<strong>class则默认是私有的</strong></li><li>class默认是private继承，而struct模式是public继承</li><li>struct一般用于描述一个数据结构的集合，而class是对一个对象数据的封装</li></ul><h4 id="14-C-代码生成可执行文件的过程有几个阶段？"><a href="#14-C-代码生成可执行文件的过程有几个阶段？" class="headerlink" title="14.C++代码生成可执行文件的过程有几个阶段？"></a>14.C++代码生成可执行文件的过程有几个阶段？</h4><ul><li><strong>预处理：</strong> 预处理器会处理源代码中的预处理指令，如<code>#include</code>、<code>#define</code>等。</li><li><strong>编译：</strong> 经过预处理后的代码翻译成特定于目标机器的汇编语言代码，这个过程进行了语法检查，每个源文件都会被单独编译成一个对象文件（.obj或.o文件）。。</li><li><strong>汇编：</strong> 汇编器将编译阶段生成的汇编代码转换为目标机器的二进制指令集</li><li><strong>链接：</strong> 链接器负责将编译阶段产生的多个对象文件合并成一个最终的可执行文件。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基础</title>
      <link href="/posts/5ae6092.html"/>
      <url>/posts/5ae6092.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-docker与VM"><a href="#1-docker与VM" class="headerlink" title="1.docker与VM"></a>1.docker与VM</h4><p><strong>docker的作用：</strong>实现跨平台的快速运行应用</p><p><strong>docker为什么比VM快？</strong></p><p><strong>docker有着比虚拟机更少的抽象层：</strong>docker 容器共享宿主机的操作系统内核，不需要为每个容器启动一个完整的操作系统实例。而虚拟机需要为每个虚拟机启动一个完整的操作系统实例，这会占用更多的内存和 CPU 资源。</p><p><strong>区别：</strong></p><ul><li><strong>虚拟机：</strong>虚拟机是通过Hypervisor(虚拟机管理系统，常见的有VMWare、workstation、VirtualBox)，虚拟出网卡、cpu、内存等虚拟硬件，再在其上建立虚拟机，每个虚拟机是个独立的操作系统，拥有自己的<strong>系统内核(GuestOS)</strong>。</li><li><strong>容器：</strong>容器是利用<strong>namespace</strong>将文件系统、进程、网络、设备等资源进行隔离，利用<strong>cgroup</strong>对权限、cpu资源进行限制，最终让容器之间互不影响，容器无法影响宿主机。</li></ul><h4 id="2-docker基本组成"><a href="#2-docker基本组成" class="headerlink" title="2.docker基本组成"></a>2.docker基本组成</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202503101222301.png" alt="image-20250310122147161" style="zoom: 50%;"></p><h4 id="3-docker常用指令"><a href="#3-docker常用指令" class="headerlink" title="3.docker常用指令"></a>3.docker常用指令</h4><p><code>docker images</code>:查看容器列表</p><p><strong>启动容器：</strong></p><p><code>docker run [-d]  [--name] [-p] [-v] [--network] 容器名（指定） 容器 [-e]</code></p><p><code>docker run -d --name mynginx -p 88:80 -v /app/nghtml:/usr/share/nginx/html nginx</code></p><ul><li><p><code>-d:</code> 后台启动容器</p></li><li><p><code>--name:</code> 指定容器的名字</p></li><li><p><code>-p</code>: 端口映射，如<code>-p 88:80</code>(将内部端口80映射到外部端口88)</p></li><li><p><code>-v</code>: 目录挂载(挂载后的目录要修改权限) </p></li><li><p><strong>卷映射：</strong><code>-v ngconf:/etc/nginx</code></p><p><em>注：卷的存储位置：/var/lib/docker/volumes/&lt;卷名&gt;</em></p></li><li><p><code>--network</code>: 指定自定义网络</p></li><li><p><code>-e</code> :设置环境变量</p></li></ul><p><strong><em>注：目录挂载和卷映射的目的都是数据持久化，其允许容器和主机之间共享数据。</em></strong></p><p><strong>删除容器：</strong></p><p><code>rm [-f] 容器id</code> : 不加<code>-f</code>不能删除正在运行的容器</p><p><strong>进入容器：</strong></p><p><code>docker exec [-it] &lt;容器名&gt; /bin/bash</code></p><p><code>docker exec -it mynginx /bin/bash</code></p><p><strong>删除镜像：</strong></p><p><code>docker rmi  &lt;镜像名&gt;</code></p><p><strong>保存镜像：</strong></p><ul><li><p><strong>提交：</strong><code>docker commit</code></p><p><code>docker commit -m &quot;update index.html&quot; mynginx mynginx:v1.0</code></p></li><li><p><strong>保存：</strong><code>docker save</code></p></li></ul><p>​    <code>docker save -o mynginx.tar mynginx:v1.0</code></p><ul><li><p><strong>加载：</strong><code>docker load -i &lt;镜像包&gt;</code></p><p><code>docker load -i mynginx.tar</code></p></li></ul><p><strong>docker自定义网络：</strong>实现容器之间的相互访问</p><ul><li><p><strong>创建网络：</strong><code>docker network create mynet</code></p></li><li><p><strong>查看容器ip:</strong><code>docker inspect app1</code></p></li><li><p><strong>容器1\<app1>访问容器2\<app2>:</app2></app1></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it app1 bash</span><br><span class="line">curl http://app2:80</span><br></pre></td></tr></table></figure><p><em>注1：这里的80是内部端口号</em></p><p><em>注2：docker为每个容器分配唯一ip，使用容器ip+容器端口可以互相访问。但由于ip可能会变化，可以创建自定义网络，<strong>容器名可以当作稳定的域名进行访问。</strong></em></p></li></ul><h4 id="4-docker-compose"><a href="#4-docker-compose" class="headerlink" title="4.docker compose"></a>4.docker compose</h4><p>利用docker compose可以快速启动或停止所有服务</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 定义数据库服务</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db_data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/myconf:/etc/mysql/conf.d</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blog</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 定义WordPress服务</span></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_NAME:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">wordpress:/var/www/html</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db_data:</span> </span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">blog:</span></span><br></pre></td></tr></table></figure><p><strong>启动docker compose:</strong> <code>docker compose -f compose.yaml up -d</code></p><p><strong>下线docker compose:</strong> <code>docker compose -f compose.yaml down -d</code></p><h4 id="5-Dockerfile"><a href="#5-Dockerfile" class="headerlink" title="5.Dockerfile"></a>5.Dockerfile</h4><p><strong>Dockerfile的常见指令：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202503101933618.png" alt="image-20250310190804854" style="zoom: 50%;"></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">17</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> author=aaa</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.jar /app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>构建镜像：</strong><code>docker build -f Dockerfile -t myjavaapp:v1.0 .</code></p><p>注：<code>-t</code>: 给镜像打上标签，<code>myjavaapp</code>是镜像名，<code>v1.0</code>是版本号</p><p><strong>镜像分层机制：</strong></p><ul><li><p><strong>基础层:</strong> 每个Docker镜像都始于一个基础层，这个基础层通常是操作系统的基础镜像，比如Ubuntu、Alpine等。</p></li><li><p><strong>中间层:</strong> 在基础层之上，你可以添加多个中间层。每执行一条指令（如安装软件包、复制文件等），都会创建一个新的层。这些层按照指令执行的顺序堆叠在一起。</p></li><li><strong>可写层: </strong>Docker会在镜像的最上层添加一个可写的容器层。在这个层中，可以进行修改（如写入数据、更改配置等）。但这些<strong>修改仅限于该容器，不会影响到原始镜像</strong>或其他使用同一镜像启动的容器。</li></ul><p><strong><em>注：镜像分层机制允许不同的镜像共享相同的层，减少了重复数据的存储需求。</em></strong></p><p><code>ARG DEBIAN_FRONTEND=noninteractive</code>: 禁用软件包安装时的交互式提示，确保自动化构建过程不会中断。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++设计模式</title>
      <link href="/posts/9725cb23.html"/>
      <url>/posts/9725cb23.html</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="1-模板模式"><a href="#1-模板模式" class="headerlink" title="1.模板模式"></a>1.模板模式</h3><p><strong>应用场景：</strong>算法所需的关键步骤已知，但具体实现未知</p><ul><li><strong>抽象类</strong>：定义算法的主体框架，具体实现由子类完成</li><li><strong>具体子类</strong>：提供步骤的具体实现</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 抽象类，定义了模板方法和步骤</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 模板方法，定义了制作饮料的步骤</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prepareRecipe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">boilWater</span>();</span><br><span class="line">        <span class="built_in">brew</span>();             <span class="comment">// 抽象步骤，由子类实现</span></span><br><span class="line">        <span class="built_in">pourInCup</span>();</span><br><span class="line">        <span class="built_in">addCondiments</span>();    <span class="comment">// 抽象步骤，由子类实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本步骤，不需要子类改变</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Boiling water...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pouring into cup...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象步骤，由子类实现具体逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Beverage</span>() = <span class="keyword">default</span>; <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体类：茶</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> Beverage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">brew</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Steeping the tea...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addCondiments</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Adding lemon...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体类：咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> Beverage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">brew</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dripping coffee through filter...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addCondiments</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Adding sugar and milk...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数演示模板方法的使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Tea tea;</span><br><span class="line">    Coffee coffee;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Making tea:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    tea.<span class="built_in">prepareRecipe</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nMaking coffee:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    coffee.<span class="built_in">prepareRecipe</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-策略模式"><a href="#2-策略模式" class="headerlink" title="2.策略模式"></a>2.策略模式</h3><p><strong>应用场景：</strong>在需要动态选择不同算法的场景，如有大量的<strong><code>if-else</code></strong>语句时，可以使用策略模式来进行优化。策略模式使不同的算法实现独立于使用它们的客户端进行管理和调用。</p><ul><li><p><strong>策略接口</strong>：定义算法的<strong>公共接口。</strong></p></li><li><p><strong>具体策略类</strong>：实现策略接口的不同算法。<strong>（对于同一个任务有不同的算法）</strong></p></li><li><p><strong>上下文类</strong>：持有一个策略对象的引用，并在客户端需要时调用策略对象的算法。</p></li></ul><p><strong>计算支付金额的例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略接口，定义算法接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PaymentStrategy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">int</span> amount)</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 定义一个纯虚函数，具体策略类实现该方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略类：信用卡支付</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreditCardPayment</span> : <span class="keyword">public</span> PaymentStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">int</span> amount)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Paid &quot;</span> &lt;&lt; amount &lt;&lt; <span class="string">&quot; using Credit Card.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略类：PayPal支付</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PayPalPayment</span> : <span class="keyword">public</span> PaymentStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">int</span> amount)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Paid &quot;</span> &lt;&lt; amount &lt;&lt; <span class="string">&quot; using PayPal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略类：比特币支付</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BitcoinPayment</span> : <span class="keyword">public</span> PaymentStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">int</span> amount)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Paid &quot;</span> &lt;&lt; amount &lt;&lt; <span class="string">&quot; using Bitcoin.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类，使用策略进行支付</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentContext</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;PaymentStrategy&gt; strategy;  <span class="comment">// 使用智能指针管理策略对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 设置策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(std::unique_ptr&lt;PaymentStrategy&gt; newStrategy)</span> </span>&#123;</span><br><span class="line">        strategy = std::<span class="built_in">move</span>(newStrategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行支付</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executePayment</span><span class="params">(<span class="type">int</span> amount)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strategy) &#123;</span><br><span class="line">            strategy-&gt;<span class="built_in">pay</span>(amount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No payment strategy set!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数演示策略模式的使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PaymentContext context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用信用卡支付</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(std::<span class="built_in">make_unique</span>&lt;CreditCardPayment&gt;());</span><br><span class="line">    context.<span class="built_in">executePayment</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用PayPal支付</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(std::<span class="built_in">make_unique</span>&lt;PayPalPayment&gt;());</span><br><span class="line">    context.<span class="built_in">executePayment</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用比特币支付</span></span><br><span class="line">    context.<span class="built_in">setStrategy</span>(std::<span class="built_in">make_unique</span>&lt;BitcoinPayment&gt;());</span><br><span class="line">    context.<span class="built_in">executePayment</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-观察者模式"><a href="#3-观察者模式" class="headerlink" title="3.观察者模式"></a>3.观察者模式</h3><p>当⼀个对象的改变需要同时改变其他对象，且不知道具体有多少对象有待改变时，应该考虑使⽤观察者模式。在观察者模式中，<strong>主体是通知的发布者</strong>，它发出通知时并不需要知道谁是它的观察者，<strong>可以有任意数目的观察者订阅并接收通知。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 定义一个纯虚函数，子类必须实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题类（被观察者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Observer*&gt; observers;  <span class="comment">// 保存观察者的列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Observer* observer)</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">(Observer* observer)</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(observers.<span class="built_in">begin</span>(), observers.<span class="built_in">end</span>(), observer), observers.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer* observer : observers) &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">update</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteObserver</span>(<span class="type">const</span> std::string&amp; observerName) : <span class="built_in">name</span>(observerName) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Observer &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; has been notified!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数演示</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建具体观察者</span></span><br><span class="line">    <span class="function">ConcreteObserver <span class="title">observer1</span><span class="params">(<span class="string">&quot;Observer 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ConcreteObserver <span class="title">observer2</span><span class="params">(<span class="string">&quot;Observer 2&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将观察者附加到主题</span></span><br><span class="line">    subject.<span class="built_in">attach</span>(&amp;observer1);</span><br><span class="line">    subject.<span class="built_in">attach</span>(&amp;observer2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知所有观察者</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Notifying observers...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    subject.<span class="built_in">notify</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除一个观察者</span></span><br><span class="line">    subject.<span class="built_in">detach</span>(&amp;observer1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次通知剩余的观察者</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Notifying observers after detaching one observer...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    subject.<span class="built_in">notify</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-装饰模式"><a href="#4-装饰模式" class="headerlink" title="4.装饰模式"></a>4.装饰模式</h3><p><strong>应用场景：</strong>通过组合来实现功能的扩展（通过减少继承关系，来减少代码冗余），允许向一个对象动态地添加新的行为，而不会影响其他同类对象。</p><p><strong>主要结构:</strong>装饰模式的组合是用于递归地增强对象的功能。</p><ul><li><strong>组件接口:</strong> 定义了可以被装饰的对象的接口。</li><li><strong>具体组件:</strong> 实现了组件接口，代表被装饰的对象。</li><li><strong>装饰器:</strong> 实现了组件接口，并持有一个组件对象的引用，可以在保持接口一致的情况下扩展组件的功能。</li><li><strong>具体装饰器:</strong> 继承自装饰器，实现具体的装饰功能。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件接口，定义对象的基础操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Component</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 定义了一个纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体组件，实现了组件接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Plain Text&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器基类，继承自组件接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::shared_ptr&lt;Component&gt; component;  <span class="comment">// 持有组件对象的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Decorator</span>(std::shared_ptr&lt;Component&gt; comp) : <span class="built_in">component</span>(comp) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (component) &#123;</span><br><span class="line">            component-&gt;<span class="built_in">operation</span>();  <span class="comment">// 转发给被装饰的组件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰器：加粗文本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BoldDecorator</span> : <span class="keyword">public</span> Decorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BoldDecorator</span>(std::shared_ptr&lt;Component&gt; comp) : <span class="built_in">Decorator</span>(comp) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&lt;b&gt;&quot;</span>;</span><br><span class="line">        Decorator::<span class="built_in">operation</span>();  <span class="comment">// 调用基础组件的操作</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&lt;/b&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰器：斜体文本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ItalicDecorator</span> : <span class="keyword">public</span> Decorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ItalicDecorator</span>(std::shared_ptr&lt;Component&gt; comp) : <span class="built_in">Decorator</span>(comp) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&lt;i&gt;&quot;</span>;</span><br><span class="line">        Decorator::<span class="built_in">operation</span>();  <span class="comment">// 调用基础组件的操作</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&lt;/i&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数演示装饰模式的使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建基础组件</span></span><br><span class="line">    std::shared_ptr&lt;Component&gt; text = std::<span class="built_in">make_shared</span>&lt;ConcreteComponent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将组件装饰为加粗文本</span></span><br><span class="line">    std::shared_ptr&lt;Component&gt; boldText = std::<span class="built_in">make_shared</span>&lt;BoldDecorator&gt;(text);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将组件装饰为斜体和加粗文本</span></span><br><span class="line">    std::shared_ptr&lt;Component&gt; italicBoldText = std::<span class="built_in">make_shared</span>&lt;ItalicDecorator&gt;(boldText);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Decorated text: &quot;</span>;</span><br><span class="line">    italicBoldText-&gt;<span class="built_in">operation</span>();  <span class="comment">// 输出 &lt;i&gt;&lt;b&gt;Plain Text&lt;/b&gt;&lt;/i&gt;</span></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-桥模式"><a href="#5-桥模式" class="headerlink" title="5.桥模式"></a>5.桥模式</h3><p><strong>应用场景：</strong>适用于需要分离抽象和实现，使它们可以分别进行扩展的场景。例如，图形绘制系统中形状（如圆、矩形）和颜色（如红色、蓝色）的组合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口（Implementor），定义绘制行为</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Color</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">applyColor</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数，具体实现由子类提供</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现类：红色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedColor</span> : <span class="keyword">public</span> Color &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">applyColor</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Red&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现类：蓝色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlueColor</span> : <span class="keyword">public</span> Color &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">applyColor</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Blue&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类（Abstraction），定义形状</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::shared_ptr&lt;Color&gt; color;  <span class="comment">// 持有实现接口的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>(std::shared_ptr&lt;Color&gt; col) : <span class="built_in">color</span>(col) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数，具体实现由子类提供</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展抽象类（RefinedAbstraction）：圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(std::shared_ptr&lt;Color&gt; col) : <span class="built_in">Shape</span>(col) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Circle drawn in &quot;</span>;</span><br><span class="line">        color-&gt;<span class="built_in">applyColor</span>();  <span class="comment">// 使用实现接口的功能</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; color.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展抽象类（RefinedAbstraction）：正方形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Square</span>(std::shared_ptr&lt;Color&gt; col) : <span class="built_in">Shape</span>(col) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Square drawn in &quot;</span>;</span><br><span class="line">        color-&gt;<span class="built_in">applyColor</span>();  <span class="comment">// 使用实现接口的功能</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; color.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数演示桥模式的使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建红色实现并绘制圆形</span></span><br><span class="line">    std::shared_ptr&lt;Color&gt; red = std::<span class="built_in">make_shared</span>&lt;RedColor&gt;();</span><br><span class="line">    std::shared_ptr&lt;Shape&gt; redCircle = std::<span class="built_in">make_shared</span>&lt;Circle&gt;(red);</span><br><span class="line">    redCircle-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建蓝色实现并绘制正方形</span></span><br><span class="line">    std::shared_ptr&lt;Color&gt; blue = std::<span class="built_in">make_shared</span>&lt;BlueColor&gt;();</span><br><span class="line">    std::shared_ptr&lt;Shape&gt; blueSquare = std::<span class="built_in">make_shared</span>&lt;Square&gt;(blue);</span><br><span class="line">    blueSquare-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-工厂方法"><a href="#6-工厂方法" class="headerlink" title="6.工厂方法"></a>6.工厂方法</h3><p><strong>应用场景：</strong>希望添加新产品时，只需添加新产品类和具体工厂类</p><ul><li><p><strong>抽象产品</strong>：定义产品的接口。</p></li><li><p><strong>具体产品</strong>：实现抽象产品接口的具体类。</p></li><li><p><strong>抽象工厂</strong>：声明工厂方法。</p></li><li><p><strong>具体工厂</strong>：实现工厂方法，返回具体产品实例。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品（Product）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Document</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">open</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Document</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：文本文档（ConcreteProduct）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextDocument</span> : <span class="keyword">public</span> Document &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Opening a text document.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：图像文档（ConcreteProduct）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageDocument</span> : <span class="keyword">public</span> Document &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Opening an image document.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂（Creator）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DocumentCreator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;Document&gt; <span class="title">createDocument</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">DocumentCreator</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂：文本文档工厂（ConcreteCreator）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextDocumentCreator</span> : <span class="keyword">public</span> DocumentCreator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Document&gt; <span class="title">createDocument</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;TextDocument&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂：图像文档工厂（ConcreteCreator）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageDocumentCreator</span> : <span class="keyword">public</span> DocumentCreator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Document&gt; <span class="title">createDocument</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;ImageDocument&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">openDocument</span><span class="params">(<span class="type">const</span> DocumentCreator&amp; creator)</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Document&gt; doc = creator.<span class="built_in">createDocument</span>();</span><br><span class="line">    doc-&gt;<span class="built_in">open</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TextDocumentCreator textCreator;</span><br><span class="line">    ImageDocumentCreator imageCreator;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using the text document creator:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">openDocument</span>(textCreator);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nUsing the image document creator:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">openDocument</span>(imageCreator);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-抽象工厂"><a href="#7-抽象工厂" class="headerlink" title="7.抽象工厂"></a>7.抽象工厂</h3><p>抽象工厂可以理解为在工厂方法的基础上再做一层的扩展。</p><p><strong>模式结构：</strong></p><ul><li><strong>抽象工厂</strong>：定义创建一系列相关对象的接口。</li><li><strong>具体工厂</strong>：实现抽象工厂接口，生成具体产品的实例。</li><li><strong>抽象产品</strong>：为每种产品声明接口。</li><li><strong>具体产品</strong>：实现抽象产品接口。</li><li><strong>客户端</strong>：使用抽象工厂和抽象产品接口来创建具体对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品：按钮</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">paint</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Button</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：Windows 按钮</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsButton</span> : <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rendering a button in Windows style.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：macOS 按钮</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButton</span> : <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rendering a button in macOS style.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品：文本框</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBox</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TextBox</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：Windows 文本框</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsTextBox</span> : <span class="keyword">public</span> TextBox &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Displaying a text box in Windows style.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品：macOS 文本框</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacTextBox</span> : <span class="keyword">public</span> TextBox &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Displaying a text box in macOS style.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂：GUI 工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;Button&gt; <span class="title">createButton</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;TextBox&gt; <span class="title">createTextBox</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">GUIFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂：Windows 工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsFactory</span> : <span class="keyword">public</span> GUIFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Button&gt; <span class="title">createButton</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;WindowsButton&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;TextBox&gt; <span class="title">createTextBox</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;WindowsTextBox&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂：macOS 工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacFactory</span> : <span class="keyword">public</span> GUIFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Button&gt; <span class="title">createButton</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MacButton&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;TextBox&gt; <span class="title">createTextBox</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MacTextBox&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildInterface</span><span class="params">(<span class="type">const</span> GUIFactory&amp; factory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> button = factory.<span class="built_in">createButton</span>();</span><br><span class="line">    <span class="keyword">auto</span> textBox = factory.<span class="built_in">createTextBox</span>();</span><br><span class="line">    </span><br><span class="line">    button-&gt;<span class="built_in">paint</span>();</span><br><span class="line">    textBox-&gt;<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WindowsFactory windowsFactory;</span><br><span class="line">    MacFactory macFactory;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Building Windows interface:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">buildInterface</span>(windowsFactory);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nBuilding macOS interface:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">buildInterface</span>(macFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-原型模式"><a href="#8-原型模式" class="headerlink" title="8.原型模式"></a>8.原型模式</h3><p>通过复制现有对象来创建新的对象，而不是通过实例化类来创建。</p><p><strong>模式结构:</strong></p><ul><li><p><strong>抽象原型</strong>：定义一个接口，用于复制自身。</p></li><li><p><strong>具体原型</strong>：实现复制自身的方法。</p></li><li><p><strong>客户端</strong>：通过调用原型对象的 <code>clone</code> 方法来创建新的对象。</p></li></ul><p><strong>示例：</strong></p><p>一个简单的图形编辑器，需要频繁创建和复制不同类型的图形（如圆形和矩形）。在未使用原型模式的情况下，要会使用 <code>new</code> 关键字手动创建对象。使用原型模式后，可以更灵活地通过克隆已有对象来创建新对象。</p><p><strong><em>没有使用原型模式的实现：</em></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图形基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体图形：圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">int</span> r) : <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle with radius: &quot;</span> &lt;&lt; radius &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体图形：矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> width, height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">int</span> w, <span class="type">int</span> h) : <span class="built_in">width</span>(w), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle with width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="string">&quot; and height: &quot;</span> &lt;&lt; height &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码，手动创建对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Shape&gt; shape1 = std::<span class="built_in">make_unique</span>&lt;Circle&gt;(<span class="number">5</span>);</span><br><span class="line">    std::unique_ptr&lt;Shape&gt; shape2 = std::<span class="built_in">make_unique</span>&lt;Rectangle&gt;(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    shape1-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    shape2-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 想要复制时，需要手动创建</span></span><br><span class="line">    std::unique_ptr&lt;Shape&gt; anotherCircle = std::<span class="built_in">make_unique</span>&lt;Circle&gt;(<span class="number">5</span>);</span><br><span class="line">    anotherCircle-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>使用原型模式的实现：</em></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;Shape&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 克隆方法</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型：圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">int</span> r) : <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle with radius: &quot;</span> &lt;&lt; radius &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Shape&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Circle&gt;(*<span class="keyword">this</span>);  <span class="comment">// 使用复制构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型：矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> width, height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">int</span> w, <span class="type">int</span> h) : <span class="built_in">width</span>(w), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle with width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="string">&quot; and height: &quot;</span> &lt;&lt; height &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Shape&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Rectangle&gt;(*<span class="keyword">this</span>);  <span class="comment">// 使用复制构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码，通过克隆创建对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Shape&gt; originalCircle = std::<span class="built_in">make_unique</span>&lt;Circle&gt;(<span class="number">5</span>);</span><br><span class="line">    std::unique_ptr&lt;Shape&gt; originalRectangle = std::<span class="built_in">make_unique</span>&lt;Rectangle&gt;(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    originalCircle-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    originalRectangle-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原型克隆对象</span></span><br><span class="line">    std::unique_ptr&lt;Shape&gt; clonedCircle = originalCircle-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    std::unique_ptr&lt;Shape&gt; clonedRectangle = originalRectangle-&gt;<span class="built_in">clone</span>();</span><br><span class="line"></span><br><span class="line">    clonedCircle-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    clonedRectangle-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-构建器模式"><a href="#9-构建器模式" class="headerlink" title="9.构建器模式"></a>9.构建器模式</h3><p><strong>应用场景：</strong>适用于构建复杂对象，特别是当对象包含多个可选或可变部分时。</p><p><strong>结构：</strong></p><ul><li><strong>产品类</strong>：需要构建的复杂对象。</li><li><strong>构建器接口</strong>：定义构建产品各个部分的<strong>方法</strong>。</li><li><strong>具体构建器</strong>：实现 <code>Builder</code> 接口并提供构建产品的方法<strong>（可扩展的具体实现，与产品类用组合代替继承）</strong>。</li><li><strong>指挥者</strong>：使用 <code>Builder</code> 来控制构建过程的顺序<strong>（步骤，可扩展）</strong>。</li><li><strong>客户端</strong>：创建 <code>Builder</code> 和 <code>Director</code>，并启动构建过程。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string engine;</span><br><span class="line">    std::string wheels;</span><br><span class="line">    std::string body;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showCar</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Car with engine: &quot;</span> &lt;&lt; engine &lt;&lt; <span class="string">&quot;, wheels: &quot;</span> &lt;&lt; wheels &lt;&lt; <span class="string">&quot;, body: &quot;</span> &lt;&lt; body &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象构建器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CarBuilder</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildEngine</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildWheels</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildBody</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Car&gt; <span class="title">getCar</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体构建器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SportsCarBuilder</span> : <span class="keyword">public</span> CarBuilder &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Car&gt; car;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SportsCarBuilder</span>() &#123;</span><br><span class="line">        car = std::<span class="built_in">make_shared</span>&lt;Car&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildEngine</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        car-&gt;engine = <span class="string">&quot;V8 Engine&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildWheels</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        car-&gt;wheels = <span class="string">&quot;Sports Wheels&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildBody</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        car-&gt;body = <span class="string">&quot;Sleek Sports Body&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Car&gt; <span class="title">getCar</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指挥者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(std::shared_ptr&lt;CarBuilder&gt; builder)</span> </span>&#123;</span><br><span class="line">        builder-&gt;<span class="built_in">buildEngine</span>();</span><br><span class="line">        builder-&gt;<span class="built_in">buildWheels</span>();</span><br><span class="line">        builder-&gt;<span class="built_in">buildBody</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;CarBuilder&gt; sportsCarBuilder = std::<span class="built_in">make_shared</span>&lt;SportsCarBuilder&gt;();</span><br><span class="line">    Director director;</span><br><span class="line">    director.<span class="built_in">construct</span>(sportsCarBuilder);</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;Car&gt; car = sportsCarBuilder-&gt;<span class="built_in">getCar</span>();</span><br><span class="line">    car-&gt;<span class="built_in">showCar</span>();  <span class="comment">// 输出：Car with engine: V8 Engine, wheels: Sports Wheels, body: Sleek Sports Body</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-单例模式"><a href="#10-单例模式" class="headerlink" title="10.单例模式"></a>10.单例模式</h3><p><strong>应用场景：</strong>确保某个类只有一个实例，并提供一个全局访问点来访问该实例。常用于需要控制全局访问、限制资源或共享资源的场景。<strong>用于减少创建对象的数量</strong></p><p><strong>特点：</strong></p><ul><li><strong>唯一性</strong>：保证一个类只有一个实例。</li><li><strong>全局访问点</strong>：提供对该实例的全局访问。</li><li><strong>延迟实例化</strong>：实例化通常是在首次访问时才创建，节省资源。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="built_in">Logger</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Logger created&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造函数和赋值运算符，防止拷贝</span></span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Logger&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 提供全局访问点的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Logger instance;  <span class="comment">// 静态本地变量，保证只创建一次</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Log: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 getInstance() 获取唯一的实例</span></span><br><span class="line">    Logger&amp; logger1 = Logger::<span class="built_in">getInstance</span>();</span><br><span class="line">    Logger&amp; logger2 = Logger::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    logger1.<span class="built_in">log</span>(<span class="string">&quot;This is the first message&quot;</span>);</span><br><span class="line">    logger2.<span class="built_in">log</span>(<span class="string">&quot;This is the second message&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出验证是否为同一实例</span></span><br><span class="line">    <span class="keyword">if</span> (&amp;logger1 == &amp;logger2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Both loggers are the same instance&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注1：<strong>私有构造函数</strong>防止类的外部创建实例。</em></p><p><em>注2：通过<strong>删除拷贝构造函数和赋值运算符</strong>，防止实例被复制。</em></p><p><em>注3：<strong><code>static</code> 变量</strong> <code>instance</code> 保证实例只创建一次，并在程序结束时自动销毁。：</em></p><h3 id="11-享元模式"><a href="#11-享元模式" class="headerlink" title="11.享元模式"></a>11.享元模式</h3><p><strong>应用场景：</strong>用于减少创建对象的数量，从而减少内存消耗并提高性能。常用于系统中需要大量细粒度对象的场景，比如图形编辑器中的图元或文字处理器中的字符。</p><p><strong>共享的部分做成员，外部状态做参数，调用时提供</strong></p><p><strong>特点：</strong></p><ul><li><strong>共享</strong>：将对象的共享部分提取出来，通过共享减少内存开销。</li><li><strong>分离状态</strong>：对象可以分为内部状态和外部状态。内部状态是共享的，外部状态是每个对象特有的，不会被共享。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string color;  <span class="comment">// 共享的内部状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">const</span> std::string&amp; col) : <span class="built_in">color</span>(col) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制时传递外部状态作为参数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> radius)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Circle: Color=&quot;</span> &lt;&lt; color &lt;&lt; <span class="string">&quot;, x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, radius=&quot;</span> &lt;&lt; radius &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, std::shared_ptr&lt;Circle&gt;&gt; circleMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Circle&gt; <span class="title">getCircle</span><span class="params">(<span class="type">const</span> std::string&amp; color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = circleMap.<span class="built_in">find</span>(color);</span><br><span class="line">        <span class="keyword">if</span> (it != circleMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> newCircle = std::<span class="built_in">make_shared</span>&lt;Circle&gt;(color);</span><br><span class="line">        circleMap[color] = newCircle;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Creating circle of color: &quot;</span> &lt;&lt; color &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> newCircle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CircleFactory circleFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> circle1 = circleFactory.<span class="built_in">getCircle</span>(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">    circle1-&gt;<span class="built_in">draw</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">5</span>);  <span class="comment">// 使用外部状态</span></span><br><span class="line">    circle1-&gt;<span class="built_in">draw</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">10</span>); <span class="comment">// 传递不同的外部状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> circle2 = circleFactory.<span class="built_in">getCircle</span>(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">    circle2-&gt;<span class="built_in">draw</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">15</span>); <span class="comment">// 共享颜色，外部状态不同</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> circle3 = circleFactory.<span class="built_in">getCircle</span>(<span class="string">&quot;Green&quot;</span>);</span><br><span class="line">    circle3-&gt;<span class="built_in">draw</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li><p><strong>共享部分</strong>：颜色信息在 <code>Circle</code> 类中存储和共享。</p></li><li><p><strong>外部状态</strong>：<code>x</code>、<code>y</code> 和 <code>radius</code> 作为参数传递给 <code>draw()</code> 方法，每个调用时提供不同的值，不共享。</p></li></ul><h3 id="12-面门模式"><a href="#12-面门模式" class="headerlink" title="12.面门模式"></a>12.面门模式</h3><p><strong>应用场景：</strong>为子系统中的一组复杂接口提供一个统一的接口，使得子系统更容易使用。<strong>适用于简化接口调用</strong></p><p><strong>客户端-》面门类-》子系统类</strong></p><p><em>注：客户端不需要直接依赖子系统的具体实现，而是依赖门面接口，降低了耦合性。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioPlayer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playAudio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Playing audio...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoPlayer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playVideo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Playing video...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subtitles</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadSubtitles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Loading subtitles...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 门面类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MediaFacade</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;AudioPlayer&gt; audioPlayer;</span><br><span class="line">    std::unique_ptr&lt;VideoPlayer&gt; videoPlayer;</span><br><span class="line">    std::unique_ptr&lt;Subtitles&gt; subtitles;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MediaFacade</span>() &#123;</span><br><span class="line">        audioPlayer = std::<span class="built_in">make_unique</span>&lt;AudioPlayer&gt;();</span><br><span class="line">        videoPlayer = std::<span class="built_in">make_unique</span>&lt;VideoPlayer&gt;();</span><br><span class="line">        subtitles = std::<span class="built_in">make_unique</span>&lt;Subtitles&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playMedia</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        audioPlayer-&gt;<span class="built_in">playAudio</span>();</span><br><span class="line">        videoPlayer-&gt;<span class="built_in">playVideo</span>();</span><br><span class="line">        subtitles-&gt;<span class="built_in">loadSubtitles</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 客户端使用门面类进行简化调用</span></span><br><span class="line">    MediaFacade mediaFacade;</span><br><span class="line">    mediaFacade.<span class="built_in">playMedia</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-代理模式"><a href="#13-代理模式" class="headerlink" title="13.代理模式"></a>13.代理模式</h3><p><strong>应用场景：</strong>用于为另一个对象提供一种“代理”或占位符以控制对这个对象的访问。例如<strong>延迟</strong>加载、控制访问权限、日志记录等。</p><p><strong>例：</strong>使用虚代理来实现按需加载图像资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Image</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealImage</span> : <span class="keyword">public</span> Image &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealImage</span>(<span class="type">const</span> std::string&amp; fileName) : <span class="built_in">fileName</span>(fileName) &#123;</span><br><span class="line">        <span class="built_in">loadImage</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Displaying image: &quot;</span> &lt;&lt; fileName &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string fileName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Loading image from &quot;</span> &lt;&lt; fileName &lt;&lt; <span class="string">&quot;...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyImage</span> : <span class="keyword">public</span> Image &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProxyImage</span>(<span class="type">const</span> std::string&amp; fileName) : <span class="built_in">fileName</span>(fileName), <span class="built_in">realImage</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!realImage) &#123;</span><br><span class="line">            realImage = std::<span class="built_in">make_unique</span>&lt;RealImage&gt;(fileName);  <span class="comment">// 延迟加载图像</span></span><br><span class="line">        &#125;</span><br><span class="line">        realImage-&gt;<span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string fileName;</span><br><span class="line">    <span class="keyword">mutable</span> std::unique_ptr&lt;RealImage&gt; realImage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建代理对象，不会立即加载图像</span></span><br><span class="line">    std::unique_ptr&lt;Image&gt; image = std::<span class="built_in">make_unique</span>&lt;ProxyImage&gt;(<span class="string">&quot;photo.jpg&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Image created, but not loaded yet.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当需要时才加载并显示图像</span></span><br><span class="line">    image-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-适配器模式"><a href="#14-适配器模式" class="headerlink" title="14.适配器模式"></a>14.适配器模式</h3><p><strong>应用场景：</strong>适配器模式主要解决接口不匹配的问题。</p><p><strong>组成：</strong></p><ul><li><strong>目标接口</strong>：客户端期望的接口。</li><li><strong>需要适配的类</strong>：拥有不兼容接口的类。</li><li><strong>适配器</strong>：将目标接口与需要适配的类进行连接，转换接口以满足客户端需求。</li><li><strong>客户端</strong>：通过目标接口与适配器交互。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="comment">//被适配类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OldPrinter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">oldPrint</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Old Printer: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewPrinterInterface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">NewPrinterInterface</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象适配器：通过组合实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrinterAdapter</span> : <span class="keyword">public</span> NewPrinterInterface &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;OldPrinter&gt; oldPrinter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrinterAdapter</span>(std::shared_ptr&lt;OldPrinter&gt; oldPrinter) : <span class="built_in">oldPrinter</span>(oldPrinter) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        oldPrinter-&gt;<span class="built_in">oldPrint</span>(text);  <span class="comment">// 调用 OldPrinter 的 oldPrint 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> oldPrinter = std::<span class="built_in">make_shared</span>&lt;OldPrinter&gt;();</span><br><span class="line">    <span class="function">PrinterAdapter <span class="title">adapter</span><span class="params">(oldPrinter)</span></span>;</span><br><span class="line">    adapter.<span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-中介者模式"><a href="#15-中介者模式" class="headerlink" title="15.中介者模式"></a>15.中介者模式</h3><p><strong>应用场景：</strong>用于减少多个对象之间的直接相互依赖。通过引入一个中介者对象，所有对象之间的通信都通过中介者完成，降低了对象之间的耦合性。</p><p><strong>未使用中介者模式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">User</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendMessage</span><span class="params">(User&amp; receiver, <span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; receiver.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">user1</span><span class="params">(<span class="string">&quot;Alice&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">user2</span><span class="params">(<span class="string">&quot;Bob&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    user1.<span class="built_in">sendMessage</span>(user2, <span class="string">&quot;Hello, Bob!&quot;</span>);</span><br><span class="line">    user2.<span class="built_in">sendMessage</span>(user1, <span class="string">&quot;Hi, Alice!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用中介者模式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中介者接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatMediator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message, <span class="keyword">class</span> User* sender, <span class="type">const</span> std::string&amp; receiverName)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addUser</span><span class="params">(std::shared_ptr&lt;<span class="keyword">class</span> User&gt; user)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ChatMediator</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    ChatMediator* mediator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">User</span>(<span class="type">const</span> std::string&amp; name, ChatMediator* mediator) : <span class="built_in">name</span>(name), <span class="built_in">mediator</span>(mediator) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> std::string&amp; message, <span class="type">const</span> std::string&amp; receiverName)</span> </span>&#123;</span><br><span class="line">        mediator-&gt;<span class="built_in">sendMessage</span>(message, <span class="keyword">this</span>, receiverName);  <span class="comment">// 通过中介者发送消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">receive</span><span class="params">(<span class="type">const</span> std::string&amp; message, <span class="type">const</span> std::string&amp; senderName)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; received from &quot;</span> &lt;&lt; senderName &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体中介者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteChatMediator</span> : <span class="keyword">public</span> ChatMediator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;User&gt;&gt; users;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addUser</span><span class="params">(std::shared_ptr&lt;User&gt; user)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        users.<span class="built_in">push_back</span>(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message, User* sender, <span class="type">const</span> std::string&amp; receiverName)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user-&gt;<span class="built_in">getName</span>() == receiverName) &#123;  <span class="comment">// 找到目标用户</span></span><br><span class="line">                user-&gt;<span class="built_in">receive</span>(message, sender-&gt;<span class="built_in">getName</span>());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;User &quot;</span> &lt;&lt; receiverName &lt;&lt; <span class="string">&quot; not found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcreteChatMediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> user1 = std::<span class="built_in">make_shared</span>&lt;User&gt;(<span class="string">&quot;Alice&quot;</span>, &amp;mediator);</span><br><span class="line">    <span class="keyword">auto</span> user2 = std::<span class="built_in">make_shared</span>&lt;User&gt;(<span class="string">&quot;Bob&quot;</span>, &amp;mediator);</span><br><span class="line">    <span class="keyword">auto</span> user3 = std::<span class="built_in">make_shared</span>&lt;User&gt;(<span class="string">&quot;Charlie&quot;</span>, &amp;mediator);</span><br><span class="line">    mediator.<span class="built_in">addUser</span>(user1);</span><br><span class="line">    mediator.<span class="built_in">addUser</span>(user2);</span><br><span class="line">    mediator.<span class="built_in">addUser</span>(user3);</span><br><span class="line">    <span class="comment">// A 向 B 发送消息</span></span><br><span class="line">    user1-&gt;<span class="built_in">send</span>(<span class="string">&quot;Hello Bob!&quot;</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="comment">// C 向 A 发送消息</span></span><br><span class="line">    user3-&gt;<span class="built_in">send</span>(<span class="string">&quot;Hi Alice!&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    <span class="comment">// A 向不存在的用户发送消息</span></span><br><span class="line">    user1-&gt;<span class="built_in">send</span>(<span class="string">&quot;Hello David!&quot;</span>, <span class="string">&quot;David&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-状态模式"><a href="#16-状态模式" class="headerlink" title="16.状态模式"></a>16.状态模式</h3><p><strong>应用场景：</strong>对象的行为由对象的状态所决定，而通过使用状态模式实现了状态和行为的分离。</p><p><strong>实现行为固定时，对状态的扩展</strong></p><p><strong>示例：</strong></p><p>电梯有以下状态：</p><ul><li><strong>运行中（Moving）</strong></li><li><strong>停止中（Stopped）</strong></li><li><strong>开门（Open）</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象状态类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//行为：</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openDoor</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">closeDoor</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">move</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">State</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明上下文类（为状态类使用）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Elevator</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类：停止中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoppedState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Elevator* elevator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">StoppedState</span><span class="params">(Elevator* elevator)</span> : elevator(elevator) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openDoor</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeDoor</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类：运行中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MovingState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Elevator* elevator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MovingState</span><span class="params">(Elevator* elevator)</span> : elevator(elevator) &#123;</span>&#125;<span class="comment">//使用原始指针防止循环引用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openDoor</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeDoor</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类：开门</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Elevator* elevator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">OpenState</span><span class="params">(Elevator* elevator)</span> : elevator(elevator) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openDoor</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeDoor</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类：电梯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Elevator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;State&gt; currentState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Elevator</span><span class="params">(std::shared_ptr&lt;State&gt; initialState)</span> : currentState(std::move(initialState)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(std::shared_ptr&lt;State&gt; state)</span> </span>&#123;</span><br><span class="line">        currentState = std::<span class="built_in">move</span>(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState-&gt;<span class="built_in">openDoor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState-&gt;<span class="built_in">closeDoor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState-&gt;<span class="built_in">move</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState-&gt;<span class="built_in">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现具体状态类的方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StoppedState::openDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Opening door...\n&quot;</span>;</span><br><span class="line">    elevator-&gt;<span class="built_in">setState</span>(std::<span class="built_in">make_shared</span>&lt;OpenState&gt;(elevator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StoppedState::closeDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Door is already closed.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StoppedState::move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elevator is starting to move...\n&quot;</span>;</span><br><span class="line">    elevator-&gt;<span class="built_in">setState</span>(std::<span class="built_in">make_shared</span>&lt;MovingState&gt;(elevator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StoppedState::stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elevator is already stopped.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MovingState::openDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Cannot open door while moving.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MovingState::closeDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Door is already closed.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MovingState::move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elevator is already moving.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MovingState::stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elevator is stopping...\n&quot;</span>;</span><br><span class="line">    elevator-&gt;<span class="built_in">setState</span>(std::<span class="built_in">make_shared</span>&lt;StoppedState&gt;(elevator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenState::openDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Door is already open.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenState::closeDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Closing door...\n&quot;</span>;</span><br><span class="line">    elevator-&gt;<span class="built_in">setState</span>(std::<span class="built_in">make_shared</span>&lt;StoppedState&gt;(elevator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenState::move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Cannot move with door open.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenState::stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elevator is already stopped.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 延迟初始化 Elevator 和 StoppedState，避免使用未初始化对象</span></span><br><span class="line">    <span class="keyword">auto</span> elevator = std::<span class="built_in">make_shared</span>&lt;Elevator&gt;(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">auto</span> initialState = std::<span class="built_in">make_shared</span>&lt;StoppedState&gt;(elevator.<span class="built_in">get</span>());</span><br><span class="line">    elevator-&gt;<span class="built_in">setState</span>(initialState);</span><br><span class="line"></span><br><span class="line">    elevator-&gt;<span class="built_in">openDoor</span>();  <span class="comment">// Opening door...</span></span><br><span class="line">    elevator-&gt;<span class="built_in">closeDoor</span>(); <span class="comment">// Closing door...</span></span><br><span class="line">    elevator-&gt;<span class="built_in">move</span>();      <span class="comment">// Elevator is starting to move...</span></span><br><span class="line">    elevator-&gt;<span class="built_in">stop</span>();      <span class="comment">// Elevator is stopping...</span></span><br><span class="line">    elevator-&gt;<span class="built_in">openDoor</span>();  <span class="comment">// Opening door...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-备忘录模式"><a href="#17-备忘录模式" class="headerlink" title="17.备忘录模式"></a>17.备忘录模式</h3><p><strong>应用场景：</strong>允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态（如浏览器回退、编辑器撤销）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Memento</span><span class="params">(<span class="type">const</span> std::string&amp; state)</span> : state(state) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getState</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">type</span><span class="params">(<span class="type">const</span> std::string&amp; newText)</span> </span>&#123;</span><br><span class="line">        text += newText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showContent</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Current Content: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建备忘录</span></span><br><span class="line">    <span class="function">Memento <span class="title">save</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Memento</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从备忘录恢复</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">restore</span><span class="params">(<span class="type">const</span> Memento&amp; memento)</span> </span>&#123;</span><br><span class="line">        text = memento.<span class="built_in">getState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理者类：进行保存备份副本、回档</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Memento&gt; history;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">(<span class="type">const</span> Memento&amp; memento)</span> </span>&#123;</span><br><span class="line">        history.<span class="built_in">push_back</span>(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Memento <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= history.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Invalid index&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> history[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TextEditor editor;</span><br><span class="line">    Caretaker caretaker;</span><br><span class="line"></span><br><span class="line">    editor.<span class="built_in">type</span>(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">    caretaker.<span class="built_in">save</span>(editor.<span class="built_in">save</span>()); <span class="comment">// 保存状态</span></span><br><span class="line"></span><br><span class="line">    editor.<span class="built_in">type</span>(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">    caretaker.<span class="built_in">save</span>(editor.<span class="built_in">save</span>()); <span class="comment">// 保存状态</span></span><br><span class="line"></span><br><span class="line">    editor.<span class="built_in">type</span>(<span class="string">&quot; New content.&quot;</span>);</span><br><span class="line">    editor.<span class="built_in">showContent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复到上一个状态</span></span><br><span class="line">    editor.<span class="built_in">restore</span>(caretaker.<span class="built_in">get</span>(<span class="number">1</span>));</span><br><span class="line">    editor.<span class="built_in">showContent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复到初始状态</span></span><br><span class="line">    editor.<span class="built_in">restore</span>(caretaker.<span class="built_in">get</span>(<span class="number">0</span>));</span><br><span class="line">    editor.<span class="built_in">showContent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-组合模式"><a href="#18-组合模式" class="headerlink" title="18.组合模式"></a>18.组合模式</h3><p>组合模式将对象组合成树形结构，来一致地处理单个对象和对象的组合。</p><p><strong>结构：</strong></p><ul><li><strong>Component（抽象组件）：</strong>定义了对象的公共接口，包括对组合对象的常见操作</li><li><strong>Leaf（叶子节点）：</strong>表示树形结构的最小单元，不包含子节点。</li><li><strong>Composite（组合节点）：</strong>包含子节点的容器，可以是<code>Leaf</code>或<code>Composite</code>，实现管理子节点的操作，例如添加、移除和遍历子节点。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象组件类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystemComponent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> depth = <span class="number">0</span>)</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 显示组件内容</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">FileSystemComponent</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶子节点类：文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> : <span class="keyword">public</span> FileSystemComponent &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">File</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> depth = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; std::<span class="built_in">string</span>(depth, <span class="string">&#x27;-&#x27;</span>) &lt;&lt; <span class="string">&quot;File: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合节点类：文件夹</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Folder</span> : <span class="keyword">public</span> FileSystemComponent &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;FileSystemComponent&gt;&gt; children;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Folder</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(std::shared_ptr&lt;FileSystemComponent&gt; component)</span> </span>&#123;</span><br><span class="line">        children.<span class="built_in">push_back</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> depth = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; std::<span class="built_in">string</span>(depth, <span class="string">&#x27;-&#x27;</span>) &lt;&lt; <span class="string">&quot;Folder: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; child : children) &#123;</span><br><span class="line">            child-&gt;<span class="built_in">display</span>(depth + <span class="number">2</span>); <span class="comment">// 递归调用子节点的 display 方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> file1 = std::<span class="built_in">make_shared</span>&lt;File&gt;(<span class="string">&quot;file1.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> file2 = std::<span class="built_in">make_shared</span>&lt;File&gt;(<span class="string">&quot;file2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> subFolder = std::<span class="built_in">make_shared</span>&lt;Folder&gt;(<span class="string">&quot;SubFolder&quot;</span>);</span><br><span class="line">    subFolder-&gt;<span class="built_in">add</span>(file1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> mainFolder = std::<span class="built_in">make_shared</span>&lt;Folder&gt;(<span class="string">&quot;MainFolder&quot;</span>);</span><br><span class="line">    mainFolder-&gt;<span class="built_in">add</span>(subFolder);</span><br><span class="line">    mainFolder-&gt;<span class="built_in">add</span>(file2);</span><br><span class="line"></span><br><span class="line">    mainFolder-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ori-Net: Orientation-guided Neural Network for Automated Coronary Arteries Segmentation</title>
      <link href="/posts/6e60e82b.html"/>
      <url>/posts/6e60e82b.html</url>
      
        <content type="html"><![CDATA[<h2 id="Ori-Net-Orientation-guided-Neural-Network-for-Automated-Coronary-Arteries-Segmentation"><a href="#Ori-Net-Orientation-guided-Neural-Network-for-Automated-Coronary-Arteries-Segmentation" class="headerlink" title="Ori-Net: Orientation-guided Neural Network for Automated Coronary Arteries Segmentation"></a>Ori-Net: Orientation-guided Neural Network for Automated Coronary Arteries Segmentation</h2><p><strong>论文：《Ori-Net: Orientation-guided Neural Network for Automated Coronary Arteries Segmentation》（ESWA 2024)</strong></p><p><strong>主要贡献：</strong></p><p>提出了一种利用预测方向和半径的定向制导跟踪方法。该算法迭代重建冠状动脉，并将重建与粗分割融合，进一步提高分割性能。</p><p><strong>冠状动脉结构可以被表示为由不同半径的、以方向为指导的球体包络所重建的外包络</strong></p><p>用半径和方向作为冠状动脉的两个基本度量。</p><p><em>注1：半径：当前位置到冠状动脉边界的距离；方向：从当前位置确定下一个位置的指向</em></p><p><em>注2：半径信息有助于确定血管的边界，而方向信息则确定血管延伸的方向。</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059067.png" alt="image-20241017150109306" style="zoom: 50%;"></p><h3 id="Ori-Net"><a href="#Ori-Net" class="headerlink" title="Ori-Net"></a><strong>Ori-Net</strong></h3><p>Ori-Net模型与UNet结构相似，Ori-Net模型利用了这种基于几何信息的分割方法，同时预测了冠状动脉的分割结果、半径和方向，并通过一个导向追踪的方法，利用预测的半径和方向来重建冠状动脉。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059629.png" alt="image-20241017150543948"></p><p><strong>多任务学习：</strong>Ori-Net有三个预测分支（分割分支、半径分支和方向分支），每个分支都有一个核大小为1的卷积层，分别用于预测分割、半径和方向。</p><p><strong>损失函数：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059765.png" alt="image-20241017150822909" style="zoom: 80%;"></p><p><em>注1：<script type="math/tex">L_{SEG}、L_{RAD}、L_{ORI}</script>​分别表示分割损失、半径分类损失和方向分类损失</em></p><p><em>注2：<script type="math/tex">L_{SEG}</script>使用dice损失：</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059150.png" alt="image-20241017151212125"></p><p><strong>如何基于分割标签𝑌生成半径标签𝑍和方向标签𝑂？</strong></p><h4 id="半径分支"><a href="#半径分支" class="headerlink" title="半径分支"></a>半径分支</h4><p>将回归问题转换为分类问题：</p><p>通过离散化半径标签来创建半径类别。</p><p>半径分支负责预测半径类别图Z，该图对冠状动脉体素进行半径类别预测。</p><p><strong>生成半径标签：</strong></p><ul><li><p>通过分割掩码来生成与输入图像大小相同的距离图，图中的每个值表示了每个像素点到前景边界的距离</p></li><li><p>使用one-hot编码将每个距离值量化到K个类别中，于是连续的距离图就变成了离散的边界距离图。在这个图中，每个体素都有一个对应的半径类别</p><p><em>注：参数K的设定，来自于统计出的先验知识</em></p></li></ul><p><strong>半径分类损失使用交叉熵损失：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059538.png" alt="image-20241017194423854" style="zoom:50%;"></p><h4 id="方向分支"><a href="#方向分支" class="headerlink" title="方向分支"></a>方向分支</h4><p><strong>任务背景：</strong>现有的冠状动脉方法忽略了冠状动脉结构中的体素的几何信息</p><p><strong>方向分类损失使用交叉熵损失：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059930.png" alt="image-20241017200442413" style="zoom:67%;"></p><p><strong>方向类别图的生成：</strong></p><ul><li><p><strong>确定点的属性</strong>：</p><ul><li><p>对于每个连通域，首先通过八叉树数据结构计算中心线</p><p><em>注：利用八叉树数据结构，可以优化中心线计算，由于八叉树将图像划分成了多个子区域，只需对包含冠状动脉的子区域进行进一步处理。这减少了不必要的计算负担。</em></p></li><li><p>计算中心线半径图</p></li><li><p>使用最短路径算法确定起点<script type="math/tex">v_0</script> 和终点<script type="math/tex">v_e</script>​</p></li><li><p>下一个点<script type="math/tex">v_t</script>是以<script type="math/tex">v_0</script>为中心、半径为<script type="math/tex">R_{v_0}</script>​​的球与中心线的交点</p><p><em>注：球的中心是当前的中心点 <script type="math/tex">v_0</script>，而半径 <script type="math/tex">R_{v_0}</script> 是通过距离变换计算得到的。这个半径值表示从当前点<script type="math/tex">v_0</script>到血管边界的距离，反映了该点处血管的局部粗细程度。</em></p></li><li><p>根据点<script type="math/tex">v_t</script>的斜率<script type="math/tex">N(v_t)</script>​的和来判断点的属性(起点、终点、直线路段上的点以及分支点)</p><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059615.png" alt="image-20241021204408286" style="zoom:50%;"></p></li></ul></li></ul><p><em>注1：<script type="math/tex">N(v_t) = 1</script>，则该点是起点或终点，这意味着该点只连接到一个其他点。<script type="math/tex">N(v_t)=2</script>，则该点处于直线段上，这意味着该点与前后两个点相连，并且没有其他分支。<script type="math/tex">N(v_t) > 2</script>​，则该点是一个分支点,这意味着该点连接到多个不同方向的点。</em></p><p><em>注2：为了计算某个点 <script type="math/tex">v_t</script>的斜率<script type="math/tex">N(v_t)</script>，算法会检查该点在局部邻域内的连通性。</em></p><p><strong>一旦确定了下一个点<script type="math/tex">v_t</script>，算法将<script type="math/tex">v_t</script> 作为新的中心点，并重复这一过程,直到到达终点。</strong></p><ul><li><strong>方向类别的生成</strong></li></ul><p>​    每个点<script type="math/tex">v_t</script>需要生成一个方向类别，方向类别用来表示该点的运动方向。</p><p><strong>起点、终点或分支点：</strong>对于起点、终点或分支点，这些点在冠状动脉的几何结构中具有特殊的意义。因此，在这些点的方向生成过程中，系统不需要复杂的计算，而是直接<strong>使用预定义的符号来标记其方向</strong>。</p><p><strong>直线路段的点：</strong>对于位于冠状动脉直线路段上的点，方向生成需要通过计算来确定。</p><ul><li><strong>位移向量 <script type="math/tex">\Delta v_t</script> 的计算</strong>：</li></ul><p>​                <script type="math/tex">Δvt=vt−v0</script></p><ul><li><strong>最小角度法则确定方向类别:</strong>遍历所有可能的球面坐标方向，计算这些方向与位移向量之间的角度，通过计算位移向量 <script type="math/tex">\Delta v_t</script> 和球面坐标系中不同方向的夹角，找到与 <script type="math/tex">\Delta v_t</script> <strong>夹角最小的方向</strong>，并将该方向的索引作为该点的方向类别。</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059280.png" alt="image-20241021205742932" style="zoom:67%;"></p><p><strong>测试阶段的方向引导追踪：</strong>根据预测的半径和方向信息，对初步的分割结果进行细化，以更好地重建冠状动脉的柱状结构。</p><p>Ori-Net有三个输出：P、D、G</p><ul><li><p>P:粗分割结果、D:方向预测结果、G：半径预测结果</p></li><li><p>细化分割结果为粗分割结果P和细化重建的结果<script type="math/tex">~\tilde{Y}~</script>的平均：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202410222059028.png" alt="image-20241022194605266" style="zoom: 50%;"></p></li></ul><p><strong>细化重建的结果的生成：</strong></p><ul><li><strong>方向引导的迭代追踪：</strong>从起点开始，沿着预测的方向和半径逐步找到下一个点，直到达到终点</li><li><strong>平滑处理：</strong>由于半径是离散预测的，这可能导致重建的冠状动脉表面不够光滑，因此，Ori-Net使用高斯核函数来对每个球进行平滑处理，确保最终生成的血管结构光滑、无断裂。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASSNet:Adaptive Semantic Segmentation Network for Microtumors and Multi-Organ Segmentation</title>
      <link href="/posts/425a95d.html"/>
      <url>/posts/425a95d.html</url>
      
        <content type="html"><![CDATA[<h2 id="ASSNet-Adaptive-Semantic-Segmentation-Network-for-Microtumors-and-Multi-Organ-Segmentation"><a href="#ASSNet-Adaptive-Semantic-Segmentation-Network-for-Microtumors-and-Multi-Organ-Segmentation" class="headerlink" title="ASSNet: Adaptive Semantic Segmentation Network for Microtumors and Multi-Organ Segmentation"></a>ASSNet: Adaptive Semantic Segmentation Network for Microtumors and Multi-Organ Segmentation</h2><p><strong>论文：</strong></p><p><strong>《ASSNet: Adaptive Semantic Segmentation Network for Microtumors and Multi-Organ Segmentation》（arXiv 2024）</strong></p><p><strong>主要贡献：</strong></p><ul><li>设计了一种结合ResUnet和Swin-transformer优点的混合模型ASSNet，该模型具有窗口注意力、空间注意力、U型架构和残差连接，以实现高效分割。</li><li>提出了一种自适应特征融合(AFF)解码器，该解码器能够最大化利用多尺度特征，同时捕捉远程依赖并细化目标边界。</li></ul><p>网络整体结构：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202410121507439.png" alt="image-20241008195242686" style="zoom:50%;"></p><p><strong>编码器：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202410121507617.png" alt="image-20241012125942275" style="zoom: 50%;"></p><ul><li>通过在不同分辨率上应用窗口注意力，编码器能够捕捉到图像中的多尺度信息</li><li>引入了一个增强的多层感知器，以在特征提取过程中显式地建模长距离依赖关系</li><li>EFFN结合深度卷积和像素卷积来增强局部特征的提取能力</li></ul><p><strong>Adaptive Feature Fusion (AFF) Decoder:</strong></p><p>该解码器包含三个关键组件:长距离依赖(LRD)块、多尺度特征融合(MFF)块和自适应语义中心(ASC)块。</p><p>Adaptive Feature Fusion (AFF) Decoder是为了解决多尺度特征融合和长距离依赖建模问题而设计的。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202410121507151.png" alt="image-20241012130531795" style="zoom: 50%;"></p><ul><li><p><strong>长距离依赖块(LRD)：</strong>通过一系列的卷积操作建模远距离像素间的关联。</p></li><li><p><strong>多尺度特征融合块(MFF):</strong>接收来自编码器不同分辨率层次的特征图,通过跳跃连接（skip connections）将这些多尺度特征与当前解码层的特征图进行融合。然后通过膨胀卷积扩张卷积处理这些融合的特征，提取出每个尺度下的关键信息。</p></li><li><p><strong>自适应语义中心块(ASC):</strong>类似于传统边缘检测方法,作者使用一种自适应平均池化（Adaptive Average Pooling）操作，结合全连接层对通道特征进行增强。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RotCAtt-TransUNet++:Novel Deep Neural Network for Sophisticated Cardiac Segmentation</title>
      <link href="/posts/2d5c3529.html"/>
      <url>/posts/2d5c3529.html</url>
      
        <content type="html"><![CDATA[<h2 id="RotCAtt-TransUNet-Novel-Deep-Neural-Network-for-Sophisticated-Cardiac-Segmentation"><a href="#RotCAtt-TransUNet-Novel-Deep-Neural-Network-for-Sophisticated-Cardiac-Segmentation" class="headerlink" title="RotCAtt-TransUNet++: Novel Deep Neural Network for Sophisticated Cardiac Segmentation"></a>RotCAtt-TransUNet++: Novel Deep Neural Network for Sophisticated Cardiac Segmentation</h2><p><strong>论文：《RotCAtt-TransUNet++: Novel Deep Neural Network for Sophisticated Cardiac Segmentation》（arXiv 2024）</strong></p><ul><li><p>提出了一种新颖的旋转注意力机制（Rotatory Attention），用于捕捉体数据中相邻切片的信息。</p></li><li><p>编码器部分引入了UNet++的嵌套跳跃连接和密集的多尺度下采样，确保了在不同尺度上保留关键特征</p></li><li>设计了一个通道交叉注意力机制，通过引导Transformer特征的通道和信息过滤，解决了编码器与解码器特征间语义模糊的问题。</li></ul><p>Transformer层有助于捕获片内交互，而旋转注意机制处理片间连接。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202409281659093.png" alt="image-20240927152207198" style="zoom: 50%;"></p><ul><li><p>在跳跃连接处对不同深度和不同分辨率的特征图进行了融合</p></li><li><p>对前三个特征映射X1、X2、X3以不同的patch大小进行线性嵌入（<script type="math/tex">Z_i</script>),然后，通过transformer块捕捉patch之间的交互，并通过旋转注意力机制聚合相邻切片的信息</p></li></ul><h4 id="Linear-Embedding-与-Positional-Embedding"><a href="#Linear-Embedding-与-Positional-Embedding" class="headerlink" title="Linear Embedding 与 Positional Embedding"></a><strong>Linear Embedding 与 Positional Embedding</strong></h4><p>对于不同分辨率的特征图采用不同大小的patch（这样做可以保持特征图的代表性，不同分辨率的特征图包含不同尺度的信息），较小的patch有助于提取图像的局部细节特征，而较大的patch则有助于提取全局或上下文特征，然后对使用卷积操作映射到一个统一的维度。</p><h4 id="Rotatory-Attention-Block"><a href="#Rotatory-Attention-Block" class="headerlink" title="Rotatory Attention Block"></a><strong>Rotatory Attention Block</strong></h4><p>作者使用旋转注意力机制来提取切片间的特征</p><p><img src="https://typoraimg.wangak.cc/2023/img/202409281659406.png" alt="image-20240927155203358" style="zoom: 50%;"></p><p>该机制来源于自然语言处理中的左-中-右分离神经网络，用于捕捉句子中相邻单词之间的上下文关系。（相邻的元素对理解的中心有重要贡献）</p><p><strong>输入：</strong>旋转注意力机制将批量大小视为多个连续切片的集合，并选择性地处理三个连续的切片—左切片（前一个切片）、目标切片（当前切片）和右切片（下一个切片）。     </p><p><strong>Left:</strong></p><ul><li>对左切片使用<script type="math/tex">W_k</script>和<script type="math/tex">W_v</script>来得到<script type="math/tex">K_l</script>和<script type="math/tex">V_l</script>​</li><li>使用对目标切片的平均池化的结果<script type="math/tex">r^t</script>作为查询，通过与<script type="math/tex">K_l</script>和<script type="math/tex">V_l</script>进行注意力的计算，得到左上下文融合后的特征</li></ul><p><strong>Right:</strong>同Left</p><p><strong>目标上下文交互：</strong>通过<strong>单注意力（SA）</strong>,将左上下文和右上下文整合到目标切片之中</p><p>最后，通过通道维度拼接和取平均的操作，得到最后的输出特征。</p><h4 id="Channel-wise-Attention-Gate-for-Feature-Fusion"><a href="#Channel-wise-Attention-Gate-for-Feature-Fusion" class="headerlink" title="Channel-wise Attention Gate for Feature Fusion"></a><strong>Channel-wise Attention Gate for Feature Fusion</strong></h4><ul><li><p>对输入特征图进行全局平均池化，生成一个描述各通道重要性的向量，通过线性层对该向量进行变换，生成一个注意力掩码。</p></li><li><p>将生成的注意力掩码与解码器的特征图进行逐元素相乘，从而得到加权后的特征图。</p></li><li>加权后的特征图与解码器的原始特征图进行连接，以增强解码过程中的信息流动，进一步提升分割精度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MobileUNETR:A Lightweight End-To-End Hybrid Vision Transformer For Efficient Medical Image Segmentation</title>
      <link href="/posts/c34814e1.html"/>
      <url>/posts/c34814e1.html</url>
      
        <content type="html"><![CDATA[<h3 id="MobileUNETR-A-Lightweight-End-To-End-Hybrid-Vision-Transformer-For-Efficient-Medical-Image-Segmentation"><a href="#MobileUNETR-A-Lightweight-End-To-End-Hybrid-Vision-Transformer-For-Efficient-Medical-Image-Segmentation" class="headerlink" title="MobileUNETR: A Lightweight End-To-End Hybrid Vision Transformer For Efficient Medical Image Segmentation"></a>MobileUNETR: A Lightweight End-To-End Hybrid Vision Transformer For Efficient Medical Image Segmentation</h3><p><strong>论文：《MobileUNETR: A Lightweight End-To-End Hybrid Vision Transformer For Efficient Medical Image Segmentation》（ECCV 2024）</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202409191008537.png" alt="image-20240918195745497"></p><p><strong>Hybrid Encoder Block:</strong>利用深度可分离卷积将特征投影到高维，再利用MobileViT block捕获局部和全局信息</p><p><strong>Hybrid Decoder Block:</strong>首先，使用转置卷积进行上采样；然后，将得到的特征与跳跃连接的特征进行拼接；最后，使用MobileViT block得到改进后的分割结果</p><h4 id="MobileViT-block"><a href="#MobileViT-block" class="headerlink" title="MobileViT block"></a>MobileViT block</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202409191008262.png" alt="image-20240918200915992" style="zoom:67%;"></p><ul><li><strong>Local representations:</strong>先使用n×n卷积进行特征提取，再使用1×1卷积调整通道数，获取局部特征</li><li><strong>global representations:</strong>通过Unfold和Fold操作实现，对相同颜色的小色块会进行Attention，以此来减小Attention计算的复杂度，来获取全局特征</li><li><strong>Fusion:</strong>通过与原始特征图的拼接，来实现融合</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Improving Transformers with Dynamically Composable Multi-Head Attention</title>
      <link href="/posts/2d10fdc6.html"/>
      <url>/posts/2d10fdc6.html</url>
      
        <content type="html"><![CDATA[<h2 id="Improving-Transformers-with-Dynamically-Composable-Multi-Head-Attention"><a href="#Improving-Transformers-with-Dynamically-Composable-Multi-Head-Attention" class="headerlink" title="Improving Transformers with Dynamically Composable Multi-Head Attention"></a>Improving Transformers with Dynamically Composable Multi-Head Attention</h2><p><strong>论文：《Improving Transformers with Dynamically Composable Multi-Head Attention》（ICML 2024）</strong></p><p><strong>多头注意力（MHA)的不足：</strong>对于多头注意力（MHA)，其注意力头是独立工作的，这种独立性限制了每个头能捕捉到的特征和关系的多样性，注意力矩阵存在低秩瓶颈和冗余。</p><p>作者提出了<strong>动态组合多头注意力（DCMHA)</strong>,其解决了MHA的不足，通过动态组合注意力头来提高模型的表达能力。</p><p>动态可组合多头注意力（DCMHA）中，核心是一个 <strong>Compose 函数</strong>，它根据查询 <script type="math/tex">Q_i</script>和键 <script type="math/tex">K_j</script>以及可训练参数 <script type="math/tex">\theta</script>，将它们的注意力向量 <script type="math/tex">A_{:ij}</script>∈<script type="math/tex">{R}^H</script>A:ij∈RH 转换为新的向量 <script type="math/tex">A'_{:ij}</script>​</p><p>注：假设T、S是查询和键序列长度，用<script type="math/tex">A_h</script>​表示第h个头的注意力矩阵</p><p>​    <script type="math/tex">A_{:ij}</script>表示注意力向量，它是查询向量 <script type="math/tex">Q_i</script>和键向量 <script type="math/tex">K_j</script>之间的注意力得分向量</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406251351820.png" alt="image-20240612150016488" style="zoom: 67%;"></p><p>​                                <img src="https://typoraimg.wangak.cc/2023/img/202406251351020.png" alt="image-20240612150213603" style="zoom:67%;">         </p><p>​        为了实现 DCMHA，在 MHA 的计算中插入两个 Compose 函数，其中一个在 softmax 之前应用于注意力分数张量 <script type="math/tex">A_S</script>，另一个在 softmax 之后应用于注意力权重张量 <script type="math/tex">A_W</script>，步骤如下：</p><ul><li>注意力分数 <script type="math/tex">A_S</script> 计算：</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202406251351826.png" alt="image-20240612150526297" style="zoom: 67%;"></p><ul><li>注意力权重 <script type="math/tex">A_W</script> 计算：</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202406251351155.png" alt="image-20240612150547712" style="zoom:67%;"></p><ul><li><p>DCMHA模块最后的输出为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406251351933.png" alt="image-20240612150756075" style="zoom:67%;"></p><p><strong>Compose 函数:</strong></p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202406251351096.png" alt="image-20240612161027897" style="zoom:67%;"></p><p>注意力向量<script type="math/tex">A_{:ij}</script>经过5个分支进行变化，然后相加</p><ul><li><p>第一个分支（基础投影）：<script type="math/tex">A_{:ij}</script>首先由一个权重矩阵<script type="math/tex">W_b</script>进行投影</p></li><li><p>第二个分支（查询的动态投影）：<script type="math/tex">A_{:ij}</script>通过 <script type="math/tex">w_{q1}∈R^{H×R}</script>投影到低维 <script type="math/tex">R</script>,再通过<script type="math/tex">w_{q2}∈R^{R×H}</script>投影回原始维度<script type="math/tex">H</script>,其中动态权重 <script type="math/tex">w_{q1}</script> 和 <script type="math/tex">w_{q2}</script>  由 查询向量<script type="math/tex">Q_i</script> 计算得出。</p></li><li><p>第三个分支（查询的动态门控）：<script type="math/tex">A_{:ij}</script>乘以一个门控权重<script type="math/tex">w_{qg}</script>控制每个头保留或忘记原始分数。</p></li><li><p>第四个分支（键的动态投影）：类似于第二个分支</p></li><li><p>第五个分支（键的动态门控）：类似于第三个分支</p></li></ul><p>最终的 <script type="math/tex">A'_{:ij}</script>为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406251351275.png" alt="image-20240612162302939" style="zoom:50%;"></p><p><em>注：DCMHA的可训练参数<script type="math/tex">\theta</script>为：{<script type="math/tex">W_b</script>、<script type="math/tex">w_{q1}</script>、<script type="math/tex">w_{q2}</script>、<script type="math/tex">w_{qg}</script>、<script type="math/tex">w_{k1}</script>、<script type="math/tex">w_{k2}</script>、<script type="math/tex">w_{kg}</script>}</em></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frequency Channel Attention Networks</title>
      <link href="/posts/eb050326.html"/>
      <url>/posts/eb050326.html</url>
      
        <content type="html"><![CDATA[<h2 id="FcaNet-Frequency-Channel-Attention-Networks"><a href="#FcaNet-Frequency-Channel-Attention-Networks" class="headerlink" title="FcaNet: Frequency Channel Attention Networks"></a>FcaNet: Frequency Channel Attention Networks</h2><p>通道注意力机制通常会为每个通道分配一个标量权重，用于加权通道特征图。然而，这种简单的标量表示可能无法充分表达通道之间的复杂关系，因此，设计更有效的通道注意力机制需要考虑如何更好地捕捉和利用通道之间的非线性关系，以充分挖掘通道特征图中的信息。</p><h4 id="DTC（离散余弦变换）"><a href="#DTC（离散余弦变换）" class="headerlink" title="DTC（离散余弦变换）"></a>DTC（离散余弦变换）</h4><p>DCT，即离散余弦变换，常用图像压缩算法，步骤如下：</p><ul><li>首先将图像分割成8x8或16x16的小块；</li><li>DCT变换，对每个小块进行DCT变换；</li><li>舍弃高频系数（AC系数），保留低频信息（DC系数）。高频系数一般保存的是图像的边界、纹理信息，低频信息主要是保存的图像中平坦区域信息。</li><li>图像的低频和高频，高频区域指的是空域图像中突变程度大的区域（比如目标边界区域），通常的纹理丰富区域。</li></ul><p>二维DCT变换就是将二维图像从空间域转换到频率域。形象的说，就是计算出图像由哪些二维余弦波构成，其主要用于数据或图像的压缩，能够将空间域的信号转换到频域上，具有良好的去相关性的性能。二维的DTC公式如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131003312.png" alt="image-20240516105445387" style="zoom:67%;"></p><p>二维的逆DTC公式如下:</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131003180.png" alt="image-20240516105508741" style="zoom:67%;"></p><p>注：逆变换，通过<strong>所有</strong>频率分量的在某点的叠加可以恢复像素值。</p><p>我们称二者的共有项为基函数:</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131003442.png" alt="image-20240516105537223" style="zoom:67%;"></p><h4 id="method"><a href="#method" class="headerlink" title="method"></a>method</h4><p>传统的通道注意方法致力于构建各种通道重要性权重函数，这种权重函数要求每个通道都有一个标量来进行计算，由于计算开销有限，简单有效的全局平均池化（GAP）成为了他们的不二之选。但是一个潜在的问题是GAP是否能够捕获丰富的输入信息，也就是说，仅仅平均值是否足够表示通道注意力中的各个通道。<br><strong>GAP的不足与分析：</strong><br> 1）不同的通道可能拥有相同的平均值，而其代表的语义信息是不相同的；<br> 2）从频率分析的角度，可以证明GAP等价于DCT的最低频率，仅仅使用GAP相当于丢弃了其他许多包含着通道特征的信息；<br> 3）CBAM还表示，仅使用GAP是不够的，因此额外引入了GMP。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131003894.png" alt="image-20240516140310965" style="zoom: 50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131003276.png" alt="image-20240516140405302" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131003179.png" alt="image-20240516140522027" style="zoom: 50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131003247.png" alt="image-20240516140545094" style="zoom:67%;"></p><p><strong>以往的通道注意力（比如下图SE）只考虑了GAP（最低频的分量信息），导致丢失了大量可利用的信息</strong>。</p><h4 id="利用频率信息重构通道注意力"><a href="#利用频率信息重构通道注意力" class="headerlink" title="利用频率信息重构通道注意力"></a>利用频率信息重构通道注意力</h4><p>将通道划分成n等分，之前我们提到“DCT可以被看作图像中每个输入的加权和”，在这里通过两步准则（后面实验会介绍），选择出收益最大的部分频率分量，与对应分组相乘，就得到我们的多光谱通道注意力。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131003328.png" alt="image-20240516141438646" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131004303.png" alt="image-20240516141553753" style="zoom:59%;"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SCConv: Spatial and Channel Reconstruction Convolution for Feature Redundancy</title>
      <link href="/posts/1c149dcc.html"/>
      <url>/posts/1c149dcc.html</url>
      
        <content type="html"><![CDATA[<h2 id="SCConv-Spatial-and-Channel-Reconstruction-Convolution-for-Feature-Redundancy"><a href="#SCConv-Spatial-and-Channel-Reconstruction-Convolution-for-Feature-Redundancy" class="headerlink" title="SCConv: Spatial and Channel Reconstruction Convolution for Feature Redundancy"></a>SCConv: Spatial and Channel Reconstruction Convolution for Feature Redundancy</h2><p><strong>论文：《SCConv: Spatial and Channel Reconstruction Convolution for Feature Redundancy》（cvpr2023）</strong></p><p><strong>SCConv由空间重构单元（SRU)和通道重构单元（CRU)组成。</strong></p><ul><li>SRU采用分离重构的方法来抑制空间冗余</li><li>CRU采用分离变换融合的策略减少通道冗余</li></ul><h4 id="SCConv的结构"><a href="#SCConv的结构" class="headerlink" title="SCConv的结构"></a><strong>SCConv的结构</strong></h4><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012152.png" alt="image-20240529144607573"></p><p>利用SRU运算获得空间细化特征<script type="math/tex">X^w</script>,然后利用CRU运算获得通道细化特征Y,通过SCConv可以减少中间特征映射之间的冗余并增强CNN的特征表示</p><p><strong>空间重构单元（SRU)：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012043.png" alt="image-20240529152914871" style="zoom: 50%;"></p><p>空间重构单元(SRU)利用了分离和重构操作，分离操作的目的是将信息丰富的特征图与空间内容对应的信息较少的特征图分离开来</p><ul><li>利用组归一化（GN)中的因子<script type="math/tex">\gamma</script>来评估不同特征图的信息内容：</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012790.png" alt="image-20240529150814239" style="zoom:67%;"></p><p><em>注：因子<script type="math/tex">\gamma</script>是可训练的参数<script type="math/tex">\gamma\in{R^C}</script>,可利用其测量通道的像素方差，更丰富的空间信息反映了更多空间像素的变化，从而导致更大的<script type="math/tex">\gamma</script></em></p><ul><li>归一化后的权重<script type="math/tex">W_{\gamma}</script>通过下式得到：</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012984.png" alt="image-20240529151546208" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012200.png" alt="image-20240529151624068" style="zoom:67%;"></p><p><em>注:通过Gate门控来得到信息权重<script type="math/tex">W_1</script>和非信息权重<script type="math/tex">W_2</script>（Gate门控通过设置一个阈值，大于阈值置为1得到信息权重，小于置为0得到非信息权重）</em></p><ul><li><p>然后用输入特征X分别乘以信息权重<script type="math/tex">W_1</script>和非信息权重<script type="math/tex">W_2</script>，得到信息量大的<script type="math/tex">X_1^w</script>和信息量小的<script type="math/tex">X_2^w</script></p></li><li><p>最后，使用交叉重构运算将加权后的两个不同的信息特征结合起来</p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012343.png" alt="image-20240529152948213" style="zoom:67%;"></p><p>​    <em>注：∪是concat操作</em></p><p><strong>通道重构单元（CRU)：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012084.png" alt="image-20240529154145674" style="zoom:67%;"></p><p>使用CRU来取代了标准卷积，其通过三个操作符实现（Split、Transform、Fuse)</p><ul><li><p><strong>Split:</strong>将输入的<script type="math/tex">X^w</script>的通道分割为αC和(1-α)C两部分（α是分割比），之后再使用1×1卷积来压缩特征通道，来提高计算效率</p></li><li><p><strong>Transform:</strong></p><ul><li><p>对<script type="math/tex">X_{up}</script>​​使用（GWC、PWC)取代标准卷积来降低计算成本，之后再对输出进行汇总：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012988.png" alt="image-20240529154614185" style="zoom:67%;"></p></li><li><p>对<script type="math/tex">X_{low}</script>使用PWC作为对<script type="math/tex">X_{up}</script>的补充</p></li></ul></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012549.png" alt="image-20240529155523501" style="zoom:67%;"></p><ul><li>Fuse:对<script type="math/tex">Y_1</script>和<script type="math/tex">Y_2</script>进行融合</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012883.png" alt="image-20240529155734692" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131012620.png" alt="image-20240529155800507" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202406131013076.png" alt="image-20240529155813158" style="zoom:67%;"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BEFUnet:A Hybrid CNN-Transformer Architecture for Precise Medical Image Segmentation</title>
      <link href="/posts/7a30900a.html"/>
      <url>/posts/7a30900a.html</url>
      
        <content type="html"><![CDATA[<h2 id="BEFUnet-A-Hybrid-CNN-Transformer-Architecture-for-Precise-Medical-Image-Segmentation"><a href="#BEFUnet-A-Hybrid-CNN-Transformer-Architecture-for-Precise-Medical-Image-Segmentation" class="headerlink" title="BEFUnet: A Hybrid CNN-Transformer Architecture for Precise Medical Image Segmentation"></a>BEFUnet: A Hybrid CNN-Transformer Architecture for Precise Medical Image Segmentation</h2><p>论文：《BEFUnet: A Hybrid CNN-Transformer Architecture for Precise Medical Image Segmentation》（arXiv 2024）</p><p>本文提出了一种创新的u型网络BEFUnet，该网络增强了体特征和边缘特征的融合，以实现精确的医学图像分割</p><p><strong>双分支编码器：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141006324.png" alt="image-20240504130415926" style="zoom:67%;"></p><ul><li><p><strong>边缘编码器：</strong>由四个阶段组成，每个阶段包含4个PDC块用于特征检测，并利用最大池化对各阶段之间的特征进行降采样来得到分层特征</p><p>注：PDC块包括一个深度卷积层、一个ReLU层和一个1×1的卷积层</p></li><li><p><strong>主体编码器：</strong>使用Swin-Transfomer对具有全局信息的高级特征进行编码</p></li></ul><p>将提取的边缘和体特征输入到LCAF模块进行融合</p><p><strong>LCAF：</strong>选择性地将边缘图和主体图进行交叉注意力，来融合边缘和主体的特征</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141006843.png" alt="image-20240504131627922" style="zoom:67%;"></p><p><strong>DLF模块：</strong>为确保层级之间的特征一致性，使用交叉注意力机制来跨尺度融合信息</p><p>较浅的层级包含更精确的定位信息，而较深的层级携带更适合解码器的更多语义信息，考虑到节省计算资源，只将最浅层（<script type="math/tex">P^l</script>)和最后一层（<script type="math/tex">P^s</script>)进行融合</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141006502.png" alt="image-20240504133235606" style="zoom:67%;"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
            <tag> 特征融合 </tag>
            
            <tag> 双编码器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGILEFORMER:SPATIALLY AGILE TRANSFORMER UNET FOR MEDICAL IMAGE SEGMENTATION</title>
      <link href="/posts/6b854769.html"/>
      <url>/posts/6b854769.html</url>
      
        <content type="html"><![CDATA[<h2 id="AGILEFORMER-SPATIALLY-AGILE-TRANSFORMER-UNET-FOR-MEDICAL-IMAGE-SEGMENTATION"><a href="#AGILEFORMER-SPATIALLY-AGILE-TRANSFORMER-UNET-FOR-MEDICAL-IMAGE-SEGMENTATION" class="headerlink" title="AGILEFORMER: SPATIALLY AGILE TRANSFORMER UNET FOR MEDICAL IMAGE SEGMENTATION"></a>AGILEFORMER: SPATIALLY AGILE TRANSFORMER UNET FOR MEDICAL IMAGE SEGMENTATION</h2><p>论文：《AGILEFORMER: SPATIALLY AGILE TRANSFORMER UNET FOR MEDICAL IMAGE SEGMENTATION》（arXiv 2024）</p><ul><li><p>作者使用了一种新的patch embedding取代了vit-unet中标准的patch embedding</p></li><li><p>采用空间动态自注意力来捕获空间变化特征</p></li><li><p>提出了一种新的多尺度可变形位置编码</p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202405141004754.png" alt="image-20240511095459528"></p><h4 id="可变形的patch-embedding"><a href="#可变形的patch-embedding" class="headerlink" title="可变形的patch embedding"></a><strong>可变形的patch embedding</strong></h4><p>通过可变形卷积卷积核的采样位置可以根据输入的特征图进行微小的偏移，从而可以实现更灵活的特征提取。通过引入可变形的采样位置，使得补丁嵌入可以更好地适应不规则的结构，从而提高了特征提取的灵活性和准确性。</p><ul><li><p>第一个patch embedding：使用两个连续的可变形卷积层，这两个连续重叠的可变形patch embedding可以更好地提取局部特征，弥补了自注意力中局部性的不足</p></li><li><p>下采样层：通过3×3卷积完成下采样</p></li></ul><h4 id="空间动态自注意力"><a href="#空间动态自注意力" class="headerlink" title="空间动态自注意力"></a><strong>空间动态自注意力</strong></h4><p><strong>可变形多头自注意力：</strong></p><p>第h个头的计算过程如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141004778.png" alt="image-20240511100930114" style="zoom:67%;"></p><p>注：f是输入的特征图，ϕ是插值函数，用于生成偏移后的特征图<script type="math/tex">\hat{f}</script>,<script type="math/tex">∆p_h</script>是第h个头部生成的偏移量,其通过一个卷积层生成</p><p><strong>邻域多头自注意力：</strong></p><p>与标准自注意力不同，标准自注意力计算特征图f中每个位置p的元素与其他位置元素的相似度，而邻域注意力只利用位置p周围k个最近邻的信息来计算注意力权重，而不是与所有位置的元素计算相似度。减少了标准自注意力的计算复杂度，从二次降至近似于空间维度线性的复杂度。重新引入了局部操作到自注意力中，使得模型具有平移等变性，从而提高了保留局部信息的能力。</p><h4 id="多尺度可变形位置编码"><a href="#多尺度可变形位置编码" class="headerlink" title="多尺度可变形位置编码"></a>多尺度可变形位置编码</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202405141004551.png" alt="image-20240511102232095" style="zoom:67%;"></p><p>通过在跨多个尺度对不规则采样的位置信息进行编码。</p><p>公式如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141004922.png" alt="image-20240511102056849"></p><p><em>注：f是输入特征图，<script type="math/tex">P_θ</script>实现为多尺度可变形深度卷积层，具有不同的核大小（3×3和5×5）</em></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
            <tag> 特征提取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SegMamba:Long-range Sequential Modeling Mamba For 3D Medical Image Segmentation</title>
      <link href="/posts/f4ee98c4.html"/>
      <url>/posts/f4ee98c4.html</url>
      
        <content type="html"><![CDATA[<h2 id="SegMamba-Long-range-Sequential-Modeling-Mamba-For-3D-Medical-Image-Segmentation"><a href="#SegMamba-Long-range-Sequential-Modeling-Mamba-For-3D-Medical-Image-Segmentation" class="headerlink" title="SegMamba: Long-range Sequential Modeling Mamba For 3D Medical Image Segmentation"></a>SegMamba: Long-range Sequential Modeling Mamba For 3D Medical Image Segmentation</h2><p>论文：《SegMamba: Long-range Sequential Modeling Mamba For 3D Medical Image Segmentation》（arXiv 2024）</p><p>论文贡献：</p><ul><li>设计了ToM模块，用以增强三维特征的顺序建模</li><li>设计了门控空间卷积模块（GSC)，用以增强每个ToM之前空间维度上的特征表示</li></ul><h4 id="网络结构："><a href="#网络结构：" class="headerlink" title="网络结构："></a><strong>网络结构：</strong></h4><p><img src="https://typoraimg.wangak.cc/2023/img/202405141007030.png" alt="image-20240507091527951"></p><p><strong>1.Stem</strong></p><p>采用深度卷积，内核大小为7×7×7，填充为3×3×3，步幅为2×2×2。</p><p><strong>2.TSMamba块</strong></p><p>计算过程如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141007633.png" alt="image-20240507091715749" style="zoom:67%;"></p><p><em>注：其中GSC和ToM分别表示所提出的门控空间卷积模块和三向Mamba模块</em></p><p><strong>3.门控空间卷积(GSC)</strong></p><p>门控空间卷积(GSC)用于提取mamba层之前的空间关系</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141007183.png" alt="image-20240507092130322" style="zoom:67%;"></p><p>计算过程如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141007271.png" alt="image-20240507092149524" style="zoom:67%;"></p><p><strong>4.三向mamba（ToM)</strong></p><p>从三个方向计算特征依赖关系，将三维输入特征平铺成三个序列，进行相应的特征交互，得到融合后的三维特征</p><p>计算过程如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405141007074.png" alt="image-20240507092415793" style="zoom:67%;"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
            <tag> 特征增强 </tag>
            
            <tag> mamba类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Medical Image Segmentation via Cascaded Attention Decoding</title>
      <link href="/posts/3790531e.html"/>
      <url>/posts/3790531e.html</url>
      
        <content type="html"><![CDATA[<h2 id="Medical-Image-Segmentation-via-Cascaded-Attention-Decoding"><a href="#Medical-Image-Segmentation-via-Cascaded-Attention-Decoding" class="headerlink" title="Medical Image Segmentation via Cascaded Attention Decoding"></a>Medical Image Segmentation via Cascaded Attention Decoding</h2><p><strong>论文：《Medical Image Segmentation via Cascaded Attention Decoding》（WACV 2023)</strong></p><p>这篇论文和之前看过的一些文章设计思路也差不多，通过对编码器四个阶段输出的特征进行了融合，不同之处在于这篇论文提出了AG和CAM两个模块进行特征的融合，先使用AG进行特征融合，再使用CAM进行增强</p><p><strong>级联注意解码器:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071929069.png" alt="image-20240426162057053" style="zoom:67%;"></p><p>UpConv:对特征进行上采样</p><p>CAM:用于增强特征映射</p><p>作者使用了四个CAM块聚合编码器四个阶段输出的特征，三个AG模块将先前解码器上采样的特征与跳跃连接的特征结合起来</p><p><strong>AG：用于级联的特征融合</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071929850.png" alt="image-20240427213751108" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071930154.png" alt="image-20240427213938485" style="zoom: 67%;"></p><p><strong>CAM:用于增强特征映射</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071930371.png" alt="image-20240427214031982" style="zoom: 80%;"></p><p>CAM由通道注意力、空间注意力和一个卷积块组成，使用通道注意力、空间注意力可以来抑制背景信息</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071930603.png" alt="image-20240427214223908" style="zoom:67%;"></p><p>注：这里的卷积块是由两个3×3的卷积层组成，每个卷积层后是一个BN和一个ReLU</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071930828.png" alt="image-20240427214438165" style="zoom:67%;"></p><p><strong>多阶段损失和特征聚合：</strong></p><p>作者是通过对分层编码器的四个阶段输出的结果使用加性聚合的方式生成最后的预测图：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071930176.png" alt="image-20240427214745978" style="zoom:67%;"></p><p><em>注1：p1、p2、p3、p4为四个预测头的特征映射，w、x、y、z为各个预测头像的权重。</em></p><p><em>注2：本文中作者将w、x、y、z均设为1</em></p><p>作者通过分别计算每个预测头的损失，来得到最终的损失：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071930911.png" alt="image-20240427215042984" style="zoom:67%;"></p><p><em>注：实验中作者将α, β, γ,  ζ均设为了1</em></p><p><strong>整体的网络结构如下：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071930348.png" alt="image-20240427215222965" style="zoom: 50%;"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
            <tag> 特征融合 </tag>
            
            <tag> 特征增强 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SegFormer3D</title>
      <link href="/posts/ee049a76.html"/>
      <url>/posts/ee049a76.html</url>
      
        <content type="html"><![CDATA[<h2 id="SegFormer3D"><a href="#SegFormer3D" class="headerlink" title="SegFormer3D"></a>SegFormer3D</h2><p><strong>论文：《SegFormer3D: an Efficient Transformer for 3D Medical Image Segmentation》（arXiv 2024）</strong></p><p>作者提出了SegFormer3D使用全mlp解码器来聚合局部和全局注意力特征，来产生高度准确的分割掩码</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071927153.png" alt="image-20240427155943100" style="zoom:67%;"></p><p><strong>对于编码器部分：</strong></p><ul><li><p>使用patch merging进行下采样：与池化操作相比克服了像素生成过程中的邻域信息丢失的问题，同时也能节省一定的运算量</p></li><li><p>使用efficient self-attention：捕获全局信息的同时，用缩放系数R减少了self-attention计算的时间复杂度</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071927313.png" alt="image-20240427161059247" style="zoom:67%;"></p></li><li><p>舍弃了固定的位置编码，使用mix ffn模块来提取位置信息：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071927148.png" alt="image-20240427161359128" style="zoom: 50%;"></p></li></ul><p><strong>对于解码器部分：</strong>使用了全MLP的结构，使用了一个统一的模块完成了对不同尺度的特征的解码过程，简化了解码过程，确保在各种数据集中对体积特征进行高效且一致的解码，避免了过度参数化。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071927399.png" alt="image-20240427161629423" style="zoom:67%;"></p><p><strong>参数量和性能的比较：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071927981.png" alt="image-20240427162144102" style="zoom: 50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202405071927799.png" alt="image-20240427162104575" style="zoom:67%;"></p><p>作者在编码器和解码器的设计中，都使用轻量化的操作（编码器部分的patch merging、efficient self-attention和解码器使用全mlp解码器来聚合局部和全局注意力特征），模型参数量和计算量都有明显的下降，但性能表现不如nnformer</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
            <tag> 特征融合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HCF-Net</title>
      <link href="/posts/d349cca5.html"/>
      <url>/posts/d349cca5.html</url>
      
        <content type="html"><![CDATA[<h2 id="HCF-Net-Hierarchical-Context-Fusion-Network-for-Infrared-Small-Object-Detection"><a href="#HCF-Net-Hierarchical-Context-Fusion-Network-for-Infrared-Small-Object-Detection" class="headerlink" title="HCF-Net: Hierarchical Context Fusion Network for Infrared Small Object Detection"></a>HCF-Net: Hierarchical Context Fusion Network for Infrared Small Object Detection</h2><p><strong>论文：《HCF-Net: Hierarchical Context Fusion Network for Infrared Small Object Detection》（arXiv 2024)</strong></p><p>PPA采用分层特征融合和注意机制来维护和增强对小物体的表示，确保关键信息通过多次下采样步骤得以保留。</p><p>DASI增强了U-Net中的跳跃连接，侧重于高维和低维特征的自适应选择和精细融合，以增强小物体的显著性。</p><p>位于网络深处的MDCR加强了多尺度特征提取和通道信息表示，捕捉各种感受野范围内的特征。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202404251920292.png" alt="image-20240416133737554" style="zoom:67%;"></p><h4 id="1-PPA"><a href="#1-PPA" class="headerlink" title="1.PPA"></a>1.PPA</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202404251920768.png" alt="image-20240416134505795" style="zoom:67%;"></p><p>对于小目标而言，经过多次下采样容易丢失关键信息，作者使用PPA模块取代了编码器和解码器中的传统卷积的操作，来解决此问题。</p><p>PPA使用了多分支提取策略，多分支策略有助于捕获物体的多尺度特征，从而提高对小目标的特征提取能力。其由三个平行分支组成：局部、全局、串行卷积。</p><p>PPA步骤如下：</p><ul><li>对于输入特征F,先使用点卷积调整通道数，然后输入到三个分支</li><li><p>通过三个分支分别计算得到<script type="math/tex">F_{local}、F_{global}、F_{conv}</script></p></li><li><p>将三个分支的输出结果相加得到最后的输出</p></li></ul><p><strong>Patch-Aware:</strong></p><p>使用 Unfold 和 reshape 操作将特征张量 F’ 划分为一组空间上连续的patch,对这些 patch 进行通道方向上的平均，得到大小为 (p × p, H’/p, W’/p) 的结果，接着使用 FFN 进行线性计算。随后，应用激活函数来获得线性计算特征在空间维度上的概率分布，并相应调整它们的权重,对加权结果进行特征选择，从 tokens 和通道中选择与任务相关的特征。</p><p><em>注：局部和全局分支的区分是通过patch的大小参数p来控制的</em></p><p><strong>特征融合和注意力：</strong></p><p>在进行了多分支的特征提取后，利用注意力机制进行自适应的特征增强，该注意力模块由通道注意力和空间注意力组成，其过程如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202404251920747.png" alt="image-20240416143044284" style="zoom:67%;"></p><p><em>注：其中，⊗ 表示元素相乘，<script type="math/tex">F_c∈ R^{H'×W'×C'}</script>、<script type="math/tex">F_s∈ R^{H'×W'×C'}</script>分别表示通道注意力和空间注意力处理后的特征，<script type="math/tex">M_c∈ R^{1×1×C'}</script>是通道注意力图,<script type="math/tex">M_s∈ R^{H'×W'×1}</script>是空间注意力图。δ和 B 分别表示ReLU和BN，F’’是PPA的最终的输出</em></p><h4 id="2-维度感知选择性整合模块"><a href="#2-维度感知选择性整合模块" class="headerlink" title="2.维度感知选择性整合模块"></a><strong>2.维度感知选择性整合模块</strong></h4><p><img src="https://typoraimg.wangak.cc/2023/img/202404251920269.png" alt="image-20240416144400263" style="zoom: 80%;"></p><p>DASI能够根据物体的大小自适应地选择合适的特征进行融合，DASI通过卷积、插值等操作，将高维特征<script type="math/tex">F_h∈R^{H_h×W_h×C_h}</script>和低维特征<script type="math/tex">F_l∈R^{H_l×W_l×C_l}</script>与当前层的特征<script type="math/tex">F_u∈R^{H×W×C}</script>进行初步对齐。随后，它将这些特征在通道维度上分成四个相等的部分，从而得到 <script type="math/tex">{(h_i)}_{i=1}^4 ∈R^{H × W × C/4}</script>, <script type="math/tex">{(I_i)}_{i=1}^4 ∈R^{H × W × C/4}</script>, <script type="math/tex">{(u_i)}_{i=1}^4 ∈R^{H × W × C/4}</script>,其中 <script type="math/tex">h_i、 I_i和 u_i</script> 分别表示高维、低维和当前层特征的第 i 个分区特征。<br>该模块最终的输出结构为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202404251920852.png" alt="image-20240416145650808" style="zoom:67%;"></p><p><em>注： α是通过应用于<script type="math/tex">u_i</script>的激活函数所得到的值，当α> 0.5，则模型优先考虑细粒度特征，当α &lt; 0.5，则强调上下文特征。</em></p><h4 id="3-MDCR"><a href="#3-MDCR" class="headerlink" title="3.MDCR"></a>3.MDCR</h4><p>在 MDCR 中，引入了多个深度可分离卷积层，以不同的扩张率捕捉各种感受野大小的空间特征，从而能够对物体和背景之间的差异进行更详细的建模，增强其分辨小物体的能力。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202404251920901.png" alt="image-20240416150546927" style="zoom:67%;"></p><p>将输入特征沿通道维度分成四部分，每个部分以不同的扩张率进行深度可分离卷积，然后通过对每个部分的通道交错重排来增强多尺度特征的多样性，最后使用点卷积将这四部分的信息进行融合。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
            <tag> 特征融合 </tag>
            
            <tag> 下采样模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LHU-NET</title>
      <link href="/posts/c46bf14d.html"/>
      <url>/posts/c46bf14d.html</url>
      
        <content type="html"><![CDATA[<h2 id="LHU-NET-A-LIGHT-HYBRID-U-NET-FOR-COST-EFFICIENT-HIGH-PERFORMANCE-VOLUMETRIC-MEDICAL-IMAGE-SEGMENTATION"><a href="#LHU-NET-A-LIGHT-HYBRID-U-NET-FOR-COST-EFFICIENT-HIGH-PERFORMANCE-VOLUMETRIC-MEDICAL-IMAGE-SEGMENTATION" class="headerlink" title="LHU-NET: A LIGHT HYBRID U-NET FOR COST-EFFICIENT, HIGH-PERFORMANCE VOLUMETRIC MEDICAL IMAGE SEGMENTATION"></a>LHU-NET: A LIGHT HYBRID U-NET FOR COST-EFFICIENT, HIGH-PERFORMANCE VOLUMETRIC MEDICAL IMAGE SEGMENTATION</h2><p><strong>论文：《LHU-Net: A Light Hybrid U-Net for Cost-Efficient, High-Performance Volumetric Medical Image Segmentation》（arXiv 2024)</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202404251917245.png" alt="image-20240414134752694" style="zoom:67%;"></p><p>LHU-Net：将基于卷积的块与混合注意力机制集成</p><p><strong>Init 阶段与Out阶段</strong>：</p><ul><li>该阶段从一个点卷积操作（PW-Conv）开始，应用于输入数据，调整通道维度以匹配后续级别的通道数。</li></ul><p><img src="/posts/c46bf14d.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20240414134832658.png" alt="image-20240414134832658"></p><ul><li><p>同时对于输入直接应用ResBlock，将其输出输入到Out阶段，与解码器的输出进行连接，产生最后的结果</p><p><img src="/posts/c46bf14d.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20240414135339973.png" alt="image-20240414135339973"></p></li></ul><p><em>注：<script type="math/tex">X_{CD}</script>​表示CNN解码器块输出</em></p><p><strong>CNN Blocks:</strong></p><p>初始空间维度需要大量的计算成本,Vit难以应用，故在此阶段的设计是为了优化参数效率和保留局部特征，在之后的阶段再提取全局特征</p><ul><li>Down Conv块的设计如下：</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202404251917748.png" alt="image-20240414140026771"></p><p><strong>Hybrid Blocks（混合注意力）：</strong></p><p>在此阶段将局部细节和全局信息进行融合</p><ul><li><p><strong>Self-Adaptive Contextual Fusion Module：</strong>将空间注意力模块与卷积模块相结合，这种空间注意力模块将LKAd模块与自注意力机制的输出进行并行计算</p><p><img src="https://typoraimg.wangak.cc/2023/img/202404251917014.png" alt="image-20240414141611267"></p></li></ul><p>​     该模块最终的输出为：</p><p>​                                                                  <img src="https://typoraimg.wangak.cc/2023/img/202404251918107.png" alt="image-20240414141723308" style="zoom:67%;"></p><p>​     <em>注1：<script type="math/tex">δ_s</script>和<script type="math/tex">γ_s</script>​表示每个通道的可学习参数，控制两种不同注意机制的组合权值</em></p><p>​     <em>注2：Comb函数的定义如下：DW-Conv3 是一个 3×3×3 的卷积块</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202404251918397.png" alt="image-20240414142913765" style="zoom:67%;"></p><ul><li><p><strong>LKAd:</strong></p><p>其步骤如下：</p><ul><li>输入经过一个点卷积操作（Conv1），然后应用激活函数（GELU），以引入非线性和降低维度。</li><li>变换后的张量经过一系列深度卷积（DW-Conv）和深度膨胀卷积（DWD-Conv）操作，以提取多尺度特征并保留空间信息。</li><li>DDW-Conv3集成了可变形深度卷积可以自适应地对特征图进行采样，从而增强了模型捕获细粒度细节和长距离依赖的能力。</li></ul></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202404251918886.png" alt="image-20240414142033147" style="zoom:67%;"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
            <tag> 卷积+注意力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D-Net</title>
      <link href="/posts/ceff47a.html"/>
      <url>/posts/ceff47a.html</url>
      
        <content type="html"><![CDATA[<h2 id="D-Net-Dynamic-Large-Kernel-with-Dynamic-Feature-Fusion-for-Volumetric-Medical-Image-Segmentation"><a href="#D-Net-Dynamic-Large-Kernel-with-Dynamic-Feature-Fusion-for-Volumetric-Medical-Image-Segmentation" class="headerlink" title="D-Net: Dynamic Large Kernel with Dynamic Feature Fusion for Volumetric Medical Image Segmentation"></a>D-Net: Dynamic Large Kernel with Dynamic Feature Fusion for Volumetric Medical Image Segmentation</h2><p><strong>论文：《D-Net: Dynamic Large Kernel with Dynamic Feature Fusion for Volumetric Medical Image Segmentation》（arXiv 2024）</strong></p><p>主要贡献：</p><ul><li>提出用于通用特征提取的大核模块（DLK)，其采用多个大卷积核来捕获多尺度特征，然后利用动态选择机制，根据全局上下文信息自适应地吐出最重要的空间特征</li><li>提出动态特征融合模块，实现自适应的特征融合（DFF)，其根据全局信息融合多尺度局部特征</li><li>提出D-Net用于3d医学图像分割，其将DLK和DFF模块结合到了分层Vit模块中，实现了更高的分割准确性</li></ul><p>使用固定大小的核的卷积在自适应地捕获多尺度特征方面存在不足，因而作者提出了动态大核（DLK)与动态特征融合模块（DFF)</p><p>(顺序地聚合大核卷积来扩大感受野)</p><p><strong>Dynamic Large Kernel (DLK)：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202404141315413.png" alt="image-20240413124105291" style="zoom:67%;"></p><p>作者采用了级联大核卷积的方法，其卷积核尺寸和膨胀率逐渐增大。这样设计使得有效感受野逐渐增大，从而有效地捕获更广泛的信息，在更深、更大的感受野内提取的特征对输出的贡献更显著，使得DLK能够捕获更细致和更具信息量的特征。</p><ul><li>作者使用了两个具有大核的深度卷积进行级联：</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202404141315469.png" alt="image-20240413124653183" style="zoom: 67%;"></p><p><em>注1：5，7是核大小，1，3是膨胀率</em></p><p><em>注2：通过级联大核卷积，DLK具有与23 × 23 × 23核大小的卷积相同的有效感受野</em></p><ul><li>随后，对两个级联的大核卷积的输出<script type="math/tex">X_1^l、X_2^l</script>应用平均池化(AVP)和最大池化（MAP)来建模局部特征之间的全局空间关系。</li></ul><p><img src="/posts/ceff47a.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20240413125400295.png" alt="image-20240413125400295" style="zoom:67%;"></p><ul><li>动态选择机制：通过一个7×7×7的卷积层来实现不同空间描述符<script type="math/tex">(w_{avg},w_{map})</script>之间的信息交互,并使用Sigmoid激活函数来获得动态选择值<script type="math/tex">w_1，w_2</script></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202404141315234.png" alt="image-20240413125635669" style="zoom:67%;"></p><p>​    <em>注：不同大核卷积的特征通过利用这些选择值来自适应地进行选择</em></p><ul><li><p>DLK最后的输出为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202404141315364.png" alt="image-20240413125821821" style="zoom:67%;"></p></li><li><p>DLK block的设计如下：</p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202404141315908.png" alt="image-20240413130239187" style="zoom:67%;"></p><p><strong>Dynamic Feature Fusion (DFF)：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202404141315381.png" alt="image-20240413130621926" style="zoom:67%;"></p><ul><li><p>将特征映射<script type="math/tex">F_1^l、F_2^l</script>沿通道方向进行连接，然后通过级联平均池化、卷积和Sigmoid来得到全局通道特征的重要性描述<script type="math/tex">w_{ch}</script></p><p><img src="https://typoraimg.wangak.cc/2023/img/202404141315609.png" alt="image-20240413131334972" style="zoom:67%;"></p></li><li><p>根据<script type="math/tex">w_{ch}</script>进行特征映射，然后利用1×1×1卷积进行映射(保留重要特征)</p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202404141315858.png" alt="image-20240413132012723" style="zoom:67%;"></p><ul><li>通过1×1×1卷积层、Sigmoid激活对特征映射<script type="math/tex">F_1^l、F_2^l</script>进行处理来捕获全局空间信息<script type="math/tex">w_{sp}</script></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202404141315379.png" alt="image-20240413132340534" style="zoom:67%;"></p><p><strong>D-Net:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202404141315703.png" alt="image-20240413132535496" style="zoom:67%;"></p><p><strong>实验部分：</strong></p><p><strong>多器官分割任务：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202404141315736.png" alt="image-20240413132922149" style="zoom:67%;"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
            <tag> 特征融合 </tag>
            
            <tag> 卷积block </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BiFormer</title>
      <link href="/posts/f56fa5b4.html"/>
      <url>/posts/f56fa5b4.html</url>
      
        <content type="html"><![CDATA[<h2 id="BiFormer-Vision-Transformer-with-Bi-Level-Routing-Attention"><a href="#BiFormer-Vision-Transformer-with-Bi-Level-Routing-Attention" class="headerlink" title="BiFormer: Vision Transformer with Bi-Level Routing Attention"></a>BiFormer: Vision Transformer with Bi-Level Routing Attention</h2><p><strong>论文：《BiFormer: Vision Transformer with Bi-Level Routing Attention》（CVPR 2023)</strong></p><p><strong>文章贡献：</strong></p><ul><li>作者提出了一种新颖的双层路由机制，将其应用于传统的注意力机制中。</li><li>基于双层路由注意力机制，作者提出了一种名为BiFormer的通用视觉Transformer模型。</li></ul><p>1.注意力：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202404131212635.png" alt="image-20240406101554182" style="zoom:67%;"></p><p>注：<script type="math/tex">\sqrt{C}</script>​是缩放因子用以避免梯度消失</p><p>多头注意力：对输入沿着通道维度分成h个块（头部），每个块使用一组独立的权重</p><p><img src="https://typoraimg.wangak.cc/2023/img/202404131212205.png" alt="image-20240406101842223" style="zoom: 67%;"></p><p><em>注1：<script type="math/tex">W_0</script>​是一个额外的线性变换用来组合所有的头</em></p><p><em>注2：MHSA的复杂度是<script type="math/tex">O(N^2)</script>,因为有N个查询，每个查询涉及N个键值对</em></p><p>2.双级路由注意力（BRA）</p><p>作者探索了一种动态的、查询感知的稀疏注意机制，在粗粒度的区域级别上过滤掉大多数不相关的键-值对，使得只有少部分的路由区域保留下来，在这些路由区域的并集上应用细粒度的令牌-令牌注意力。</p><p>算法步骤：</p><ul><li>区域划分和输入投影：对于输入<script type="math/tex">X\in{H×W×C}</script>,首先将其划分为<script type="math/tex">S×S</script>非重叠区域，每个区域包含<script type="math/tex">\large H×W\over{S^2}</script>个特征向量（通过对X进行reshape操作实现），然后进行线性投影得到Q、K、V:</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202404131212896.png" alt="image-20240406103338375" style="zoom:67%;"></p><ul><li>带有向图的区域到区域路由:得到区域级的<script type="math/tex">Q^r、K^r\in{R^{S×S×C}}</script>（通过对每个区域内的Q、K取平均值得到）,然后得到区域到区域亲和图<script type="math/tex">A^r</script></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202404131212827.png" alt="image-20240406104429624" style="zoom: 67%;"></p><p>注：<script type="math/tex">A^r</script>反应了两个区域在语义上的关联程度</p><ul><li>对<script type="math/tex">A^r</script>逐行进行top-k操作得到每个区域最相关的 k 个区域的索引，以此来修剪关联图</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202404131212647.png" alt="image-20240406104825390" style="zoom:67%;"></p><p><em>注：<script type="math/tex">I^r</script>的第i行包含了第i个区域最相关的k个区域的索引</em></p><p>3.Token-to-token注意</p><p>得到了区域到区域路由索引矩阵<script type="math/tex">I^r</script>后，即可进行Token-to-token关注，对于每个区域i中的Q,根据 k 个路由区域中的所有键值对，收集K、V:</p><p><img src="https://typoraimg.wangak.cc/2023/img/202404131212214.png" alt="image-20240406105921662" style="zoom: 67%;"></p><p>然后进行注意力计算：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202404131212315.png" alt="image-20240406110015427" style="zoom:67%;"></p><p><em>注：LCE是为了增强局部信息，其通过深度卷积实现</em></p><p>4.BRA的计算复杂度：包括三部分（线性投影、区域到区域路由和Token-to-token注意）</p><p>总计算量为:</p><p><img src="https://typoraimg.wangak.cc/2023/img/202404131212610.png" alt="image-20240406110454570" style="zoom:67%;"></p><p>作者所设计的网络模型如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202404131212482.png" alt="image-20240406110612740" style="zoom:67%;"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EPT-Net</title>
      <link href="/posts/2dfc19b2.html"/>
      <url>/posts/2dfc19b2.html</url>
      
        <content type="html"><![CDATA[<h2 id="EPT-Net-Edge-Perception-Transformer-for-3D-Medical-Image-Segmentation"><a href="#EPT-Net-Edge-Perception-Transformer-for-3D-Medical-Image-Segmentation" class="headerlink" title="EPT-Net: Edge Perception Transformer for 3D Medical Image Segmentation"></a>EPT-Net: Edge Perception Transformer for 3D Medical Image Segmentation</h2><p><strong>论文：《EPT-Net: Edge Perception Transformer for 3D Medical Image Segmentation》（TMI 2023)</strong></p><p><strong>EPT-NET:</strong>在编码器中通过CNN提取网络的详细的底层特征，作者提出了双位置Transformer模块通过学习位置编码和像素空间位置编码的过程，增强了定位能力，解决了多器官之间定位不准确的问题，增强了网络对复杂器官形状的理解能力。</p><ul><li><p>提出了一种双位置嵌入Transformer，包括可学习位置嵌入和体素空间位置嵌入。利用该方法对位置编码进行优化，可以有效地捕捉医学图像中不同器官位置之间的内在相关性。</p></li><li><p>提出了一个边缘权重指导模块来学习浅特征中的边缘信息，它可以捕获相邻器官之间的微小粘附。这种设计是在不增加网络参数的情况下最小化边缘信息功能。</p></li></ul><p>卷积操作在局部像素周围进行计算，只能捕获局部特征，缺乏全局上下文信息的提取能力，可能会导致边缘信息的处理不足。</p><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202404050928262.png" alt="image-20240326135759096" style="zoom:50%;"></p><p><strong>EPT-Net:</strong>基于U型网络，由DPT和EWG模块组成。</p><p><strong>双位置嵌入Transformer:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202404050928762.png" alt="image-20240326152549228" style="zoom:50%;"></p><ul><li><p><strong>Learnable Patch Embedding:</strong>使用位置嵌入，并且利用异步卷积，确保相邻的patch有特定的交互部分</p></li><li><p><strong>Voxel Spacial Positional Embedding:</strong>其通过一个3x3x3大小的深度卷积实现</p></li></ul><p><strong>Edge Weight Guidance Module(EWG):</strong></p><p><strong>浅层引导模块：</strong>用于提取低层特征中保留的边缘信息，其操作编码器的前两层，这两层通过一个3x3x3的卷积层调整到同一个分辨率进行级联，级联后的特征通过一个1x1x1的卷积层来得到浅层引导特征。</p><p><strong>加权注意力模块：</strong>通过特征像素之间的数学特性来评估每个特征点的优先级，通过测量目标特征和周围特征的<strong>线性可分性</strong>，<strong>优先级较高的特征点与周围的特征是线性不可分的。</strong></p><p>各特征点的优先级函数定义如下：<br>                                                  <img src="https://typoraimg.wangak.cc/2023/img/202404050929624.png" alt="image-20240326164429692" style="zoom: 67%;"></p><p><em>注1：<script type="math/tex">\hat{x_{i}}、\hat{y_{i}}</script>为特征点的局部信息，其为<script type="math/tex">x_i、y_i</script>通过线性变换得到，<script type="math/tex">ω_t</script>和<script type="math/tex">b_t</script>是变换的权值和偏置,<script type="math/tex">i</script>​为空间维度上的索引</em></p><p><em>注2：根据计算得到的特征点优先级，可以为每个特征点分配一个优先级系数。这个系数可以用来加权整个特征图，从而更好地捕获边缘信息。</em></p><p><script type="math/tex">ω_t</script>和<script type="math/tex">b_t</script>的定义如下：<br>                                                                          <img src="https://typoraimg.wangak.cc/2023/img/202404050929187.png" alt="image-20240330152301027" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202404050929943.png" alt="image-20240330152315586" style="zoom:67%;"></p><p>注：ξ是超参数，<script type="math/tex">m_i、v_i</script>是通道上除了<script type="math/tex">x_t</script>的所有特征点的均值和方差</p><p><script type="math/tex">\hat{p_t}</script>越小，表示特征点与周围的特征是线性不可分的，也就越重要，故定义优先级为<script type="math/tex">p=1/\hat{p_t}</script>​</p><p>所以最后的注意力计算为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202404050929675.png" alt="image-20240330154215190" style="zoom: 67%;"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3D Medical image segmentation using parallel transformers</title>
      <link href="/posts/c50c9556.html"/>
      <url>/posts/c50c9556.html</url>
      
        <content type="html"><![CDATA[<h2 id="3D-Medical-image-segmentation-using-parallel-transformers"><a href="#3D-Medical-image-segmentation-using-parallel-transformers" class="headerlink" title="3D Medical image segmentation using parallel transformers"></a>3D Medical image segmentation using parallel transformers</h2><p><strong>TransHRNet:</strong>为并行连接不同分辨率的流而设计</p><p>本文的贡献点：</p><ul><li>提出了一种基于Transfomer的新型深度神经网络（TransHRNet)，将不同分辨率的数据流并行连接，并融合不同分辨率的信息。</li><li>引入EffTrans模块来提高性能</li></ul><p><strong>网络结构：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403202000079.png" alt="image-20240319122733944" style="zoom: 50%;"></p><p>​        TransHRNet首先使用3D CNN生成X的紧凑特征表示来捕获空间和深度信息，在此过程中不断扩大感受野，并以不同的尺度对特征进行编码，但在此过程中仍然未充分利用图像的信息。作者提出了一个特征增强模块（EffTrans)，利用Transformer编码器来学习全局空间中的长距离依赖关系，同时并行连接不同的分辨率流，在分辨率上重复执行信息交互。之后，解码器通过上采样和卷积操作产生最后的分割结果。</p><p><strong>将图像转换为序列：</strong></p><p>将特征张量的空间和深度维度合并成一个维度，从而得到一个关于图像X的patch嵌入的1D序列。</p><p><strong>位置编码：</strong>使用正余弦位置编码</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403202000117.png" alt="image-20240319130344786" style="zoom: 67%;"></p><p>注：<script type="math/tex">\large \#∈{D, H,W},v =1/10000^{2k\over{C/{3}}},pos为当前编码在序列中的位置，k为位置编码维度的索引</script></p><p><strong>特征融合：</strong>特征增强模块重复融合多分辨率特征，以跨多分辨率交换信息</p><p>三种并行方式：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403202000398.png" alt="image-20240319132030789" style="zoom:50%;"></p><p>注：高分辨率（绿色）、中分辨率（蓝色）、低分辨率（淡粉色）</p><ul><li>高分辨率与其他分辨率通过上采样得到的结果进行融合，得到新的高分辨率特征</li><li><p>中分辨率、下采样的高分辨率和上采样的低分辨率进行融合，可以获得新的中分辨率特征。</p></li><li><p>低分辨率与其他分辨率通过下采样生成得到的结果进行融合，生成新的低分辨率特征。</p></li></ul><p><strong>Effective Transformer：</strong></p><p>首先使用DeLighT变换对输入进行降维，然后采用Spatial-Reduction Attention (SRA)层进一步降低学习高分辨率特征图的资源成本。最后，将维数从<script type="math/tex">d_m</script>降维到<script type="math/tex">d_m/4</script>，然后将维数从<script type="math/tex">d_m/4</script>展开到<script type="math/tex">d_m</script>，具体结构如下图：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403202001898.png" alt="image-20240319202446776" style="zoom:67%;"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DELIGHT DEEP AND LIGHT-WEIGHT TRANSFORMER</title>
      <link href="/posts/16e5c57e.html"/>
      <url>/posts/16e5c57e.html</url>
      
        <content type="html"><![CDATA[<h2 id="DELIGHT"><a href="#DELIGHT" class="headerlink" title="DELIGHT"></a>DELIGHT</h2><p><strong>论文：《DELIGHT DEEP AND LIGHT-WEIGHT TRANSFORMER》</strong></p><p>DeLighT比标准的基于Transfomer的模型具有更少的参数，在每个Transformer块中使用DeLighT转换</p><p>DeLighT架构促使在Transformer中用单头注意力和轻量级前馈层替代多头注意力和前馈层，从而减少了总网络参数和运算。</p><p>注：在多头注意力中，每个注意力头都有自己的参数矩阵，因此总参数量较大。而使用单头注意力，参数矩阵只需一个，可以减少参数量。多头注意力需要对每个头进行独立计算，然后将它们合并，而单头注意力只需要进行一次计算，因此在计算上更加高效。</p><h3 id="DeLighT-Transformer"><a href="#DeLighT-Transformer" class="headerlink" title="DeLighT Transformer"></a><strong>DeLighT Transformer</strong></h3><p><strong>DeLighT变换：</strong>将一个<script type="math/tex">d_m</script>维的输入向量映射到一个高维空间（Expansion），然后通过组线性变换（GLT)将其将维到一个<script type="math/tex">d_o</script>维的输出向量（Reduction)。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403191940652.png" alt="image-20240319143848797"></p><p><em>注：组线性变换（GLT)用于降低Transformer模型的计算复杂度，分成N个组，每个组共享权重矩阵，通过输入的特定部分来输出局部的特征表示，其比线性更高效</em></p><p>为了学习全局表示，DeLighT变换使用特征重排在组线性变换中共享信息。</p><p><strong>模型表达能力的增加：</strong>传统Transformer增加输入维度<script type="math/tex">d_m</script>以增加表达力，而为了增加DeLighT块的表达力，不是增加输入维度<script type="math/tex">d_m</script>，而是通过Expansion和Reduction阶段增加中间DeLighT变换的深度和宽度。这使得我们可以使用更小的维度来计算注意力，从而需要更少的操作。</p><p>注：DeLighT变换的配置参数：GLTs的层数N、宽度乘法器<script type="math/tex">w_m</script>、输入维度<script type="math/tex">d_m</script>、输出维度<script type="math/tex">d_o</script>和GLTs的最大组数<script type="math/tex">g_{max}</script></p><p><strong>DeLighT变换具体步骤如下：</strong></p><ul><li>Expansion：将<script type="math/tex">d_m</script>维输入投影到高维空间，<script type="math/tex">d_{max}=w_md_m</script></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202403191940643.png" alt="image-20240319151835407" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403191941700.png" alt="image-20240319153553608" style="zoom:50%;"></p><p><em>注：</em></p><ul><li><em><script type="math/tex">l</script>为GLT的层数，<script type="math/tex">g^l</script>表示<script type="math/tex">l</script>层的组数，W、b为可学习的权值和偏置</em></li><li><em><script type="math/tex">F</script>函数将输入分为<script type="math/tex">g^l</script>组然后进行线性变换得到Y</em></li><li><em><script type="math/tex">H</script>函数首先对<script type="math/tex">Y^{l-1}</script>​进行重排，来增加不同组间的信息的交互，然后将其和X进行混合</em></li></ul><p><strong>下图显示了DeLighT转换中的扩展阶段：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403191940523.png" alt="image-20240319153106416"></p><p><strong>DeLighT Block：</strong>一个包含n个输入token的序列，每个标记的维度为<script type="math/tex">d_m</script>。这些n个<script type="math/tex">d_m</script>维的输入首先被送入DeLighT变换，产生n个维度为<script type="math/tex">d_o</script>的输出，其中<script type="math/tex">d_o < d_m</script>。这些n个<script type="math/tex">d_o</script>维的输出同时经过三个线性层投影，产生<script type="math/tex">d_o</script>维的查询Q、键K和值V</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403191941128.png" alt="image-20240319160401455" style="zoom:50%;"></p><p><em>注：该模块将计算注意力的成本降低了<script type="math/tex">d_m/d_o</script>，作者取<script type="math/tex">d_o=d_m/2</script>​</em></p><p><strong>Light-weight FFN:</strong>r为降维因子，第一层将输入维度<script type="math/tex">d_m</script>降维到<script type="math/tex">d_m/r</script>，第二层将<script type="math/tex">d_m/r</script>再扩展到<script type="math/tex">d_m</script>​，相比于Transformer减少了FFN的参数和计算量</p><h3 id="块的扩展"><a href="#块的扩展" class="headerlink" title="块的扩展"></a><strong>块的扩展</strong></h3><p>与Transformer block相比，DeLighT block块的深度更深（N+4)</p><p>提高模型性能的方法通常通过<strong>增加模型维度（宽度缩放）、堆叠更多的块（深度缩放）</strong>，然而这种方式在小数据集上不是很有效。</p><p>作者认为这是因为缩放模型的宽度和深度在块之间是均匀分配参数的，这会导致模型学习到冗余的参数，于是作者<strong>将模型缩放扩展到块的级别</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403191941032.png" alt="image-20240319192955781" style="zoom: 50%;"></p><p><strong>缩放DeLighT块:</strong>其深度和宽度分别由两个配置参数控制:GLT层数<script type="math/tex">N</script>和宽度乘法器<script type="math/tex">w_m</script>，通过引入了逐块缩放，创建了一个具有可变大小的DeLighT块的网络，在输入附近分配较浅和较窄的DeLighT块，在输出附近分配较深和较宽的DeLighT块。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
            <tag> Transformer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSA</title>
      <link href="/posts/73df481.html"/>
      <url>/posts/73df481.html</url>
      
        <content type="html"><![CDATA[<h2 id="VSA-Learning-Varied-Size-Window-Attention-in-Vision-Transformers"><a href="#VSA-Learning-Varied-Size-Window-Attention-in-Vision-Transformers" class="headerlink" title="VSA: Learning Varied-Size Window Attention in Vision Transformers"></a>VSA: Learning Varied-Size Window Attention in Vision Transformers</h2><p><strong>论文：《VSA: Learning Varied-Size Window Attention in Vision Transformers》（ECCV 2022)</strong></p><p>对于Swin Transfomer中的窗口注意力机制，如果窗口大小为可变的矩形窗口，其大小和位置直接从数据中学习，则transfomer可以从不同的窗口中捕获丰富的上下文，并学习更强大的对象特征表示。</p><p>VSA使用窗口回归模块根据每个默认窗口中的token来预测目标窗口的大小和位置</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403191210588.png" alt="image-20240314104423831" style="zoom: 67%;"></p><p>VSA将可学习的可变大小的窗口注意力引入到Transformer中</p><p><strong>Varied-size window attention (VSA)的注意力机制:</strong>VSA允许查询令牌（query tokens）关注远处的区域，并赋予网络确定目标窗口大小（即注意力区域）的灵活性</p><ul><li><p>VSA先将输入特征划分为几个窗口，这些窗口的大小基于预定义的w，这样的窗口被称为<strong>默认窗口</strong></p></li><li><p>然后从默认窗口获取查询特征：通过一个线性变换来实现</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403191210967.png" alt="image-20240315133836606" style="zoom:67%;"></p></li><li><p><strong>VSR模块:</strong>用于估计每个默认窗口的目标窗口的大小和位置</p></li></ul><p>​        包括一个平均池化层（average pooling layer）、一个LeakyReLU激活层和一个步长为1的1×1卷积层，按顺序排列。池化层的核大小和步幅遵循默认窗口的大小。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403191210935.png" alt="image-20240315133540975"></p><p><em>注1：<script type="math/tex">S_w</script>表示目标窗口相对于默认窗口位置的水平和垂直方向上的缩放比例,<script type="math/tex">O_w</script>是目标窗口相对于默认窗口的水平和垂直方向上的偏移量。</em></p><p><em>注2：<script type="math/tex">S_w、O_w\in R^{2×N}</script>,N为注意力头的个数</em></p><p><strong>VSA的计算过程：</strong></p><ul><li><p>首先，从特征图X得到K、V:</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403191210047.png" alt="image-20240315135546889" style="zoom:67%;"></p><p><em>注：<script type="math/tex">K、V\in R^{H×W×C}</script></em></p></li><li><p>VSA模块分别在K、V上从每个不同大小的窗口（目标窗口）均匀采样M个特征，M设为w*w来使其计算的复杂度和窗口注意力相当。</p></li><li><p>对于Q、K、W进行注意力计算</p><p><em>注：由于K、V是从不同的位置采样得到的，因此使用相对位置嵌入可能无法很好地描述空间关系，所以在MHSA层之前采用<strong>条件位置嵌入（CPE)《Conditional positional encodings for vision transformers.（2021）》</strong>将空间关系提供给模型。</em></p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202403191210438.png" alt="image-20240315140839238" style="zoom:67%;"></p><p>​    <em>注：<script type="math/tex">Z^{l-1}</script>为前一个Transformer的输出特征，CPE由一个深度卷积层实现，其核大小设为窗口大小</em></p><p>模型的网络结构如下：<br><img src="https://typoraimg.wangak.cc/2023/img/202403191210313.png" alt="image-20240315142709174" style="zoom:67%;"></p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>对于语义分割任务：VSA模块可以提高baseline的性能<br><img src="https://typoraimg.wangak.cc/2023/img/202403191210600.png" alt="image-20240315143148652"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TransNeXt</title>
      <link href="/posts/965265e1.html"/>
      <url>/posts/965265e1.html</url>
      
        <content type="html"><![CDATA[<h2 id="TransNeXt"><a href="#TransNeXt" class="headerlink" title="TransNeXt"></a>TransNeXt</h2><p><strong>论文：《TransNeXt: Robust Foveal Visual Perception for Vision Transformers》（CVPR 2024）</strong></p><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结<strong>构</strong></h3><p><img src="https://typoraimg.wangak.cc/2023/img/202403081436489.png" alt="image-20240308133954690"></p><p>像素聚焦注意力机制：在每个查询附近具有细粒度感知，同时保持对全局的粗粒度感知（结合了滑动窗口注意力和集中注意力）</p><p><strong>像素聚焦注意力(pixel-focused attention (PFA) )</strong>具体过程如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403081436294.png" alt="image-20240307093447355" style="zoom: 67%;"></p><p><em>注1：定义输入特征图上以 <script type="math/tex">（i, j）</script>为中心的滑动窗口中的像素集合为<script type="math/tex">ρ(i, j）</script> 。对于固定的窗口大小 <script type="math/tex">k×k</script> ， <script type="math/tex">||ρ(i, j)|| = k^2</script>。同时, 作者定义从特征图池化得到的像素集合为的 σ(<script type="math/tex">X</script>) 。对于池化大小 <script type="math/tex">Hp×Wp</script>，<script type="math/tex">||σ(X) || = Hp×Wp</script>。</em></p><p><em>注2：PFA由滑动窗口注意力和池化窗口注意力两部分组成</em></p><p><strong>池化：</strong>平均池化操作会严重丢失信息，所以在池化之前使用单层神经网络进行投影和激活，提前压缩提取有用的信息，从而提高下采样后的信息压缩率</p><p>下采样算子（Activate and Pool）如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403081436127.png" alt="image-20240307094953654" style="zoom: 67%;"></p><p><strong>LKV通过添加一个可学习的查询嵌入（QE)，来聚合多样的注意力：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403081436731.png" alt="image-20240308093422092" style="zoom:67%;"></p><p><strong>QLV破坏了键和值之间的一对一对应关系，使当前查询学习更多的隐式相对位置信息</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403081436695.png" alt="image-20240308094738641" style="zoom:67%;"></p><p><strong>长度缩放余弦注意力:</strong>可以有效增强视觉模型的训练稳定性</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403081436647.png" alt="image-20240308100847389" style="zoom:67%;"></p><p><em>注1：注意力设计应表现出熵不变性，以促进对未知长度的更好泛化，<script type="math/tex">τ log N</script>是为了保持熵的不变性和忽略常数项。</em></p><p><em>注2:<script type="math/tex">τ</script>是可学习参数，N表示每个查询交互的有效键的计数（在本文中N为<script type="math/tex">N(i,j) = ∥ρ(i, j)∥+∥σ(X)∥− ∥µ(i, j)∥</script>),<script type="math/tex">\hat{Q}、\hat{K}</script>是L2正则化后的结果</em></p><p><strong>位置偏置：</strong></p><ul><li><strong>池化特征路径：</strong>log-CPB方法，即使用一个具有 ReLU 激活函数的 2 层 MLP 来计算从查询点到空间相对坐标之间的位置偏差</li></ul><p><em>注：池化使得特征的空间信息变得模糊或丢失，直接使用可学习的位置偏差可能无法有效地捕获到像素级别的位置偏差，所以使用对数间隔连续位置偏差（log-CPB）方法，通过 MLP 网络计算位置偏差，可以更好地捕获到细粒度的位置信息，从而提高模型对多尺度图像输入的泛化能力。</em></p><ul><li><strong>滑动窗口路径</strong>：在这条路径上，作者直接使用了一个可学习的位置偏差 B(i,j)∼ρ(i,j)。</li></ul><p><strong>聚合像素聚焦注意力(AA)：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403081436129.png" alt="image-20240308103811904" style="zoom: 67%;"></p><p>注：∆(i,j) ~ σ(X)为Q(i,j)和Kσ(X)之间的空间相对坐标</p><p><strong>卷积GLU通道混合器：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403081436975.png" alt="image-20240308110209837"></p><p><strong>SE 机制</strong>的全局平均池过于粗粒度</p><p><strong>卷积GLU通道混合器</strong>中的通道注意力是基于每个像素点的最近邻特征计算的（深度卷积），而且其可以提供一定的位置信息</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H2Former</title>
      <link href="/posts/457d0431.html"/>
      <url>/posts/457d0431.html</url>
      
        <content type="html"><![CDATA[<h2 id="H2Former"><a href="#H2Former" class="headerlink" title="H2Former"></a>H2Former</h2><p><strong>论文：《H2Former: An Efficient Hierarchical Hybrid Transformer for Medical Image Segmentation》（TMI 2023）</strong></p><p><strong>文章贡献：</strong></p><ul><li>提出了一个分层混合模型，整合了CNN的局部信息、多尺度通道注意力特征和Transformer的长距离特征在一个统一的块内。</li><li>一个轻量级的多尺度通道注意力（MSCA）</li><li>在三个2D和两个3D医学图像分割任务上证明了模型的有效性</li></ul><h3 id="网络结构："><a href="#网络结构：" class="headerlink" title="网络结构："></a>网络结构：</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202403081435594.png" alt="image-20240306092858101" style="zoom:67%;"></p><p><strong>Conv stem:</strong>由一个卷积层和一个最大池化层，将输入的图像划分成多个patch，并对每个小块进行特征提取。</p><p><strong>Hybrid Transformer Block：</strong>在特征提取过程中引入多尺度通道注意力、卷积层和Transformer层，以解决卷积的局部性和Transformer单一尺度特征的局限性。</p><ul><li><p><strong>Multi-Scale Channel Attention (MSCA)：</strong>捕捉不同形状和尺度的多尺度特征，并通过通道注意力机制对这些特征进行校准，从而去增强模型的表达能力</p><p>对于每个特征图，MSCA将其划分为多个尺度的token，并将这些token连接起来形成多尺度token(该过程通过使用具有不同大小的卷积核，步长为1的卷积操作来实现)</p><p>具体操作如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403081435419.png" alt="image-20240306154618072" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403081435989.png" alt="image-20240306154640535" style="zoom:67%;"></p></li></ul><p>​      注：MST是multi-scale tokenization layers，其是使用s×s的核，步长为1的卷积实现的*</p><p>​    之后再使用多尺度通道注意力对提取的特征进行校准：</p><p>​                                                <img src="https://typoraimg.wangak.cc/2023/img/202403081436595.png" alt="image-20240306155304766" style="zoom: 67%;"></p><p>​    注：GAP(全局平均池化)、σ（Sigmoid激活）、Conv1d(kernel为3的一维卷积层）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403081436773.png" alt="image-20240306154143774" style="zoom: 67%;"></p><p>​        为了降低MSCA的计算复杂度，大尺度时采用低维，小尺度时采用高维。对于第1阶段的高分辨率特征图，采用4 × 4、8 × 8、16 × 16和32 × 32四种尺度，输出维度分别为C/2、C/4、C/8和C/8。其余阶段，使用2 × 2和4 × 4两种尺度，输出维度分别为C/2、C/4。通过这样的方式，MSCA可以在合理的计算复杂度下提取多尺度特征。</p><ul><li><p><strong>Conv Block:</strong>采用卷积块提取局部空间特征</p></li><li><p><strong>Transformer Block:</strong>为了使Transfomer块能够感知多尺度通道特征和局部空间特征，将多尺度通道特征和局部空间特征集成为Transfomer块的输入。</p><p><em>注：MHSA是基于窗口的多头自注意</em></p></li></ul><h3 id="实验部分："><a href="#实验部分：" class="headerlink" title="实验部分："></a>实验部分：</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202403081436089.png" alt="image-20240306161724728" style="zoom: 50%;"><img src="https://typoraimg.wangak.cc/2023/img/202403081436692.png" alt="image-20240306161741487" style="zoom: 50%;"></p><p><em>注1：H2Former相较于纯Transformer方法、纯CNN方法具有比较明显的优势</em></p><p><em>注2：表一为皮肤病变分割任务，表二是息肉病灶分割任务</em></p><p><strong>分割结果的可视化的对比：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403081436935.png" alt="image-20240306162509652" style="zoom:67%;"></p><p><em>注：前两行是皮肤病变分割的结果，后两行是息肉分割的结果。</em></p><p><em>通过对比发现：第一排的皮肤图像被毛发遮挡，第三排的息肉图像也被遮挡，但该模型仍可以产生清晰的边界，而其他模型的分割性能会因遮挡而下降</em></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MedSegDiff-v2</title>
      <link href="/posts/2d77667e.html"/>
      <url>/posts/2d77667e.html</url>
      
        <content type="html"><![CDATA[<h2 id="MedSegDiff-v2"><a href="#MedSegDiff-v2" class="headerlink" title="MedSegDiff-v2"></a>MedSegDiff-v2</h2><p><strong>本文的贡献包括：</strong></p><ul><li>第一个将Transformer集成到基于扩散的通用医学图像分割模型中。 </li><li>提出了具有U-SA(Uncertain Spatial Attention)的Anchor Condition以减小扩散方差。</li><li>提出了具有SS-Former的Semantic Condition，以建模分割噪声和语义特征的相互作用。 </li><li>在包括5种图像模态的20个器官分割任务上实现了SOTA性能。</li></ul><h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构<img src="https://typoraimg.wangak.cc/2023/img/202403041215805.png" alt="image-20240104151754725"></h3><p><strong>条件模型（绿色UNet)：</strong>从原始图像中提取分割特征</p><p><strong>扩散模型（蓝色UNet)：</strong>有两个输入分别是锚点条件（蓝色箭头）和噪声分割信息（黑色箭头）</p><h3 id="锚定条件与U-SA"><a href="#锚定条件与U-SA" class="headerlink" title="锚定条件与U-SA"></a>锚定条件与U-SA</h3><p><strong>锚点条件：</strong>将条件模型的解码分割特征整合到扩散模型的编码器特征中（蓝色箭头）</p><p><strong>U-SA机制</strong>用于从条件模型中提取一个粗糙的锚点特征，并将其整合到扩散模型中，为扩散模型提供了一个正确的预测范围，同时也让它进一步完善了预测结果，具体做法如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403041215835.png" alt="image-20240104161300625" style="zoom:67%;"></p><p><em>注1：<script type="math/tex">f_c^{-1}</script>是来自原始图像的条件分割特征，<script type="math/tex">f_d^0</script>是噪声分割图像的扩散特征</em></p><p><em>注2：<script type="math/tex">k_{Gauss}</script>为高斯卷积核目的是做平滑处理，然后取最大值是为了保留最相关的信息并且消除一些噪声和不必要的细节</em></p><h3 id="语义条件与SS-Former"><a href="#语义条件与SS-Former" class="headerlink" title="语义条件与SS-Former"></a>语义条件与SS-Former</h3><p><strong>SS-Former：</strong>使得模型可以学习条件语义特征与噪声信息的交互。</p><p>具体设计如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403041215516.png" alt="image-20240104164023507"></p><p><strong><script type="math/tex">M=(F(c_0)W_q)(F(e)W_k)^T</script></strong></p><p><em>注1：绿色为语义信息，蓝色为噪声信息</em></p><p><em>注2：<script type="math/tex">W_q</script>和<script type="math/tex">W_k</script>是可学习的权重参数，它们用于线性映射，以调整语义信息和噪声信息之间的关系</em></p><p><strong>NBP-Filter:</strong>将语义信息和噪声信息交互得到的结果M调整到统一的频率范围(扩散模型生成的过程中具有一定的随机性，这种随机性会对数据进行一些扰动，NBP-Filter降低扩散生成过程中引入的随机性的影响)</p><p>NBP-Filter<strong>从坐标图学习权重图，坐标图的每个点代表了不同的频率分量，并且使用两个MLP层将时间信息投影到两个值</strong>，这两个值分别用于缩放和移位，然后使用得到的缩放因子和移位因子去调整坐标图的表示。</p><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p><strong>表1：MedSegDiff-V2在不同图像模态上与SOTA分割方法的比较。灰色背景表示这些方法是为特定任务提出的。</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403041215578.png" alt="image-20240105132907016"></p><p>注：REFUGE2（眼底图像）、BraTs （脑肿瘤分割)、TNMIX(甲状腺结节分割)、ISIC（皮肤病变分割）</p><p><strong>表2：使用Dice分数评估MedSegDiff-V2与SOTA分割方法在AMOS数据集上的比较。最佳结果以粗体表示。</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403041215186.png" alt="image-20240105133848749"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403041215066.png" alt="image-20240105134743328" style="zoom:50%;"></p><p><strong>表3：MedSegDiff-V2在BTCV数据集上与其他先进分割方法的比较结果的表格。Dice Score用于评估模型性能，最佳结果以粗体标注。</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403041215270.png" alt="image-20240105135108153"></p><h3 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a><strong>消融实验</strong></h3><p><img src="https://typoraimg.wangak.cc/2023/img/202403041215511.png" alt="image-20240105135511006"></p><p>提出的U-SA在所有数据集上均优于先前的空间注意力。</p><p>仅使用SS-Former提供了较小的改进，但与NBP-Filter结合使用则带来了显著的改进，证明了提出的SS-Former设计的有效性。</p><h3 id="采样次数对模型效果的影响"><a href="#采样次数对模型效果的影响" class="headerlink" title="采样次数对模型效果的影响"></a>采样次数对模型效果的影响</h3><p>扩散模型具有一定的随机性，所以需要进行多次采样，然后将采样后的结果集成在一起。</p><p><strong>作者评估了各种基于扩散的医学分割模型的采样次数对模型效果的影响</strong><img src="https://typoraimg.wangak.cc/2023/img/202403041215838.png" alt="image-20240105140410979" style="zoom: 67%;"></p><p>最佳性能在大约50个集成后实现</p><p>MedSegDiff-V2其他扩散方法进行比较时，观察到它需要更少的采样次数来收敛。</p><p>MedSegDiff-V2更优越的起始点和更稳定的预测可以导致更高的性能上限</p><p><strong>作者在REFUGE2-Cup数据集上讨论了样本多样性对模型效果的影响</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202403041215579.png" alt="image-20240105143354543" style="zoom:67%;"></p><p><strong>CI(置信区间):</strong>置信区间越大，一致性越好。</p><p><strong>GED(广义能量距离)：</strong>GED越低，表示一致性越好。</p><p>U-SA在CI方面较低，而在GED方面较高，表明样本的多样性较大，表明其生成的样本大部分落在目标的不确定性区域内，效果不好。</p><p>而单独使用SS-Former而没有U-SA时，该模型在CI最高、GED最低的情况下达到了最好的一致性，未能充分利用扩散模型的多样性集成能力。</p><p>将U-SA和SS-Former组合成MedSegDiff-V2，性能得到了显著提高，表明SS-Former有助于减轻U-SA中生成的噪声，而U-SA为模型提供了更多的多样性，从而相互改进。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConvFormer</title>
      <link href="/posts/badf7b43.html"/>
      <url>/posts/badf7b43.html</url>
      
        <content type="html"><![CDATA[<h2 id="ConvFormer"><a href="#ConvFormer" class="headerlink" title="ConvFormer"></a>ConvFormer</h2><p><strong>论文：《ConvFormer: Plug-and-Play CNN-Style Transformers for Improving Medical Image Segmentation》（MICCAI 2023）</strong></p><p><strong>以往方法的不足：</strong></p><p>由于训练数据的不足，transformers效果较差（另一方面，医学图像本身的高冗余性）</p><p>在CNN-Transformer混合方法中，一方面，训练数据不足会使得transformers学习到次优的长距离依赖性，另一方面，直接将CNNs与transformers结合会使得网络偏向于学习CNNs，因为与transformers相比，CNNs的收敛性更容易实现，特别是在小规模训练数据上。</p><p>为解决该问题，作者提出了一个名为<strong>ConvFormer</strong>的即插即用模块</p><h3 id="网络结构："><a href="#网络结构：" class="headerlink" title="网络结构："></a><strong>网络结构：</strong></h3><p><img src="https://typoraimg.wangak.cc/2023/img/202403081435986.png" alt="image-20240304145207066" style="zoom:67%;"></p><p><strong>卷积+池化：</strong></p><p>上图最左边是传统的ViT，用一个个的patch作为自注意力的输入。</p><p>而作者用二维图像直接建立足够长的长程依赖，而不是分割为一堆一维序列，对于一个输入的图像通过卷积和池化来降低分辨率。</p><p><em>注：</em></p><p><em>1.上图中CBR是指卷积、批量归一化和Relu的组合</em></p><p><em>2.d为ViT中的每个patch大小S的对数</em></p><p>在此过程中，<img src="/posts/badf7b43.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20240304150529624.png" alt="image-20240304150529624" style="zoom: 25%;"></p><p>其中，Cm对应于ViT中的嵌入维度</p><p><strong>CNN风格的自关注：</strong>为卷积+池化模块处理后的特征构建了一个自适应的卷积核</p><ul><li><p>利用可学习的矩阵乘上输入进来的特征，得到QKV：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403081435314.png" alt="image-20240304151242512" style="zoom:50%;"></p></li><li><p>Q和K按照如下方式进行计算(余弦相似度)，对应于ViT里面的注意力分数计算：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202403081435848.png" alt="image-20240304151521415" style="zoom: 67%;"></p></li></ul><p><em>注1：Q和K作为分母，这样一来I矩阵的元素就不太容易变成0（如果某些位置的注意力值为0，那么表示模型在计算该位置的输出时不考虑与其他位置的相关性，可能导致模型在捕捉输入序列中重要的依赖关系和特征时出现问题。）</em></p><p><em>注2：<script type="math/tex">c_q</script>对应于ViT中𝑄、𝐾和𝑉的嵌入维度</em></p><ul><li>引入一个可学习的高斯距离图M：</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202403081435731.png" alt="image-20240304151953190" style="zoom: 67%;"></p><p><em>注1：𝜃 ∈ (0, 1) 是一个可学习的网络参数，用于控制𝐴的感受野，𝛼 是一个超参数，用于控制感受野的倾向性。</em></p><p><em>注2：𝜃与感受野成正比。𝛼越大,𝐴越倾向于具有全局感受野。</em></p><p><strong>CFFN：</strong>仅由1 × 1卷积、批处理归一化和Relu两种组合组成。通过替换ViT中的线性投影和层归一化，CFFN使ConvFormer完全基于CNN，避免了CNN-Transformer混合方法在训练过程中CNN和Transformer之间的冲突。</p><h3 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202403081435131.png" alt="image-20240304160737425" style="zoom:67%;"></p><p><em>注：ACDC(心脏诊断)、ISIC（皮肤病变）、ICH（血肿分割）</em></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/posts/38a918c7.html"/>
      <url>/posts/38a918c7.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-RAll"><a href="#1-RAll" class="headerlink" title="1.RAll"></a>1.RAll</h3><p>RAII：用于有效地管理资源的获取和释放。</p><p>基本思想：资源的获取应当在对象的构造函数中进行，而资源的释放则应当在对象的析构函数中进行。</p><p><strong>RAII 的主要优势：</strong></p><ul><li>RAII 可以确保资源的正确获取和释放，避免了手动管理资源时可能发生的错误。</li><li>当使用 RAII 时，如果在构造函数中发生异常，对象会在析构函数中自动被销毁，从而保证资源被正确释放。</li></ul><h3 id="2-智能指针"><a href="#2-智能指针" class="headerlink" title="2.智能指针"></a>2.智能指针</h3><h4 id="2-1-普通指针存在的问题"><a href="#2-1-普通指针存在的问题" class="headerlink" title="2.1 普通指针存在的问题"></a>2.1 普通指针存在的问题</h4><p><strong>内存泄漏：</strong> 使用普通指针时，需要手动分配和释放内存，这就需要确保在适当的时候调用 <code>delete</code> 或 <code>delete[]</code> 来释放动态分配的内存，否则会导致会导致内存泄漏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态分配一个整数的内存</span></span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忘记释放内存</span></span><br><span class="line">    <span class="comment">// delete ptr;  // 此行代码注释掉了，导致内存泄漏</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：普通指针不会自动调用析构函数。</em></p><p><strong>悬挂指针：</strong>程序中的某个部分释放了一块动态分配的内存，而其他部分仍然持有指向该内存的指针，并尝试使用或修改这个指针所指向的内存时，就会导致悬挂指针问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">// 分配动态内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ptr;  <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptr 现在是悬挂指针，指向已释放的内存</span></span><br><span class="line">    <span class="comment">// 下面的访问操作是未定义行为</span></span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-std-shared-ptr"><a href="#2-2-std-shared-ptr" class="headerlink" title="2.2 std::shared_ptr"></a>2.2 std::shared_ptr</h4><p><strong><code>std::shared_ptr:</code></strong>共享式智能指针,允许多个指针共享对同一对象的所有权，通过引用计数机制来管理资源的生命周期。</p><p><strong>创建和初始化：</strong></p><ul><li><strong>方法一：使用<code>std::make_shared</code>(好)</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 std::make_shared 创建 shared_ptr</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>方法二：使用构造函数</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用构造函数创建 shared_ptr</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sharedPtr2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br></pre></td></tr></table></figure><p><strong>共享所有权：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass constructed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass destructed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 shared_ptr 共享同一个对象</span></span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; sharedPtr1 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;();</span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; sharedPtr2 = sharedPtr1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当最后一个 shared_ptr 离开作用域时，对象的析构函数会被调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引用计数：</strong>使用计数器，记录当前有多少个指针（引用）指向该资源。当计数器为零时，表示没有任何指针指向该资源，资源可以被释放。</p><p><em>注：<code>std::shared_ptr</code> 会为每个共享的对象分配一个控制块，这个控制块包含引用计数、指向实际对象的指针等信息。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr2 = sharedPtr1;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; sharedPtr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>std::shared_ptr的问题：循环引用</strong></p><p>循环引用是指两个或多个对象相互引用，形成一个环状结构，导致它们的引用计数永远不会降为零。这种情况可能导致内存泄漏，因为对象的资源（如动态分配的内存）将无法被释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span>;  <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;ClassB&gt; bPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;ClassA&gt; aPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象并建立循环引用</span></span><br><span class="line">    std::shared_ptr&lt;ClassA&gt; aPtr = std::<span class="built_in">make_shared</span>&lt;ClassA&gt;();</span><br><span class="line">    std::shared_ptr&lt;ClassB&gt; bPtr = std::<span class="built_in">make_shared</span>&lt;ClassB&gt;();</span><br><span class="line"></span><br><span class="line">    aPtr-&gt;bPtr = bPtr;  <span class="comment">// ClassA 包含 ClassB</span></span><br><span class="line">    bPtr-&gt;aPtr = aPtr;  <span class="comment">// ClassB 包含 ClassA</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的引用计数永远不会降为零，导致内存泄漏</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决循环引用的方法：</strong></p><ul><li><strong>使用 <code>std::weak_ptr</code> 打破循环引用</strong></li></ul><h4 id="2-3-std-weak-ptr"><a href="#2-3-std-weak-ptr" class="headerlink" title="2.3 std::weak_ptr"></a>2.3 std::weak_ptr</h4><p><code>std::weak_ptr:</code>用于解决循环引用和避免 <code>std::shared_ptr</code> 的引用计数增加导致的内存泄漏问题,通常用于与 <code>std::shared_ptr</code> 共同工作</p><p><code>std::weak_ptr</code> 不会增加对象的引用计数，因此它不会影响对象的生命周期。</p><p><strong>解决循环引用问题：当两个对象相互持有对方的 <code>std::shared_ptr</code> 时，其中一个或两个需要使用 <code>std::weak_ptr</code>，以避免形成循环引用，从而防止内存泄漏。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;ClassB&gt; bPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;ClassA&gt; aWeakPtr;  <span class="comment">// 使用 std::weak_ptr 避免循环引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 shared_ptr1 和 shared_ptr2</span></span><br><span class="line">    std::shared_ptr&lt;ClassA&gt; aPtr = std::<span class="built_in">make_shared</span>&lt;ClassA&gt;();</span><br><span class="line">    std::shared_ptr&lt;ClassB&gt; bPtr = std::<span class="built_in">make_shared</span>&lt;ClassB&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 shared_ptr1 和 shared_ptr2 关联起来</span></span><br><span class="line">    aPtr-&gt;bPtr = bPtr;</span><br><span class="line">    bPtr-&gt;aWeakPtr = aPtr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取 <code>std::shared_ptr</code>：</strong>用 <code>std::weak_ptr</code> 的 <code>lock</code> 成员函数来获取一个指向共享对象的 <code>std::shared_ptr</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">weakPtr</span><span class="params">(sharedPtr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 shared_ptr</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtrCopy = weakPtr.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sharedPtrCopy) &#123;</span><br><span class="line">    <span class="comment">// 共享对象存在</span></span><br><span class="line">    <span class="comment">// 使用 sharedPtrCopy...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 共享对象已销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断对象是否存在：</strong> 可以使用 <code>expired</code> 成员函数检查 <code>std::weak_ptr</code> 引用的对象是否已经被销毁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">weakPtr</span><span class="params">(sharedPtr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!weakPtr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">    <span class="comment">// 共享对象存在</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 共享对象已销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-std-unique-ptr"><a href="#2-4-std-unique-ptr" class="headerlink" title="2.4 std::unique_ptr"></a>2.4 std::unique_ptr</h4><p><strong><code>std::unique_ptr:</code></strong>与 <code>std::shared_ptr</code> 不同，<code>std::unique_ptr</code> 具有“独占”的所有权语义，即同一时刻只能有一个 <code>std::unique_ptr</code> 指向一个特定的对象。当 <code>std::unique_ptr</code> 被销毁或通过 <code>std::move</code> 转移所有权时，它所管理的对象将被销毁。</p><ul><li><strong>创建 <code>std::unique_ptr</code></strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::make_unique 创建 std::unique_ptr</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uniquePtr1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用构造函数创建 std::unique_ptr</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">uniquePtr2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>移动所有权</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uniquePtr1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动所有权</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uniquePtr2 = std::<span class="built_in">move</span>(uniquePtr1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：相对于 <code>std::shared_ptr</code>，<code>std::unique_ptr</code> 是一种更轻量级的智能指针，因为它不需要维护引用计数。</em></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++零碎知识</title>
      <link href="/posts/8948f962.html"/>
      <url>/posts/8948f962.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-静态绑定与动态绑定"><a href="#1-静态绑定与动态绑定" class="headerlink" title="1.静态绑定与动态绑定"></a>1.静态绑定与动态绑定</h3><p>“绑定”指的是将一个名字（例如变量名或函数名）与一个特定的实体（变量或函数）关联起来的过程。</p><p><strong>静态绑定：</strong>在<strong>编译阶段</strong>确定函数调用关系，编译器根据变量的<strong>声明类型</strong>或函数的定义位置来选择调用哪个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用的函数由变量的声明类型所决定</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base obj;</span><br><span class="line">    obj.<span class="built_in">foo</span>();  <span class="comment">// 静态绑定，调用Base类的foo()函数</span></span><br><span class="line"></span><br><span class="line">    Derived obj2;</span><br><span class="line">    obj2.<span class="built_in">foo</span>(); <span class="comment">// 静态绑定，调用Derived类的foo()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态绑定：</strong>在<strong>运行时</strong>确定函数的调用关系，根据对象的<strong>实际类型</strong>调用相应的函数。</p><p><em>注：动态绑定适用于虚函数，通过在基类中声明函数为虚函数，可以在派生类中重写该函数，并在运行时根据<strong>对象的实际类型</strong>调用相应的函数。</em></p><p>动态绑定的条件：</p><ul><li>必须通过指针来调用</li><li>该指针是向上转型的</li><li>调用的是虚函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">foo</span>();  <span class="comment">// 动态绑定，调用Derived类的foo()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：动态绑定与静态绑定相比具有更高的灵活性，但速度也会较慢</em></p><h3 id="2-两种转型"><a href="#2-两种转型" class="headerlink" title="2.两种转型"></a>2.两种转型</h3><h4 id="2-1-向上转型"><a href="#2-1-向上转型" class="headerlink" title="2.1 向上转型"></a>2.1 向上转型</h4><p><strong>向上转型：</strong>派生类向基类转换的过程，是隐式的，不需要显式的类型转换。</p><p><em>注：在向上转型的过程中没有发生对象的拷贝，而是将派生类对象的地址赋给基类指针，基类指针可以访问基类中定义的成员，但不能访问派生类特有的成员。向上转型体现了<strong>指针的多态性</strong>，可以用来实现<strong>动态绑定</strong>。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">baseFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">derivedFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derivedObj;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向上转型，将Derived对象的地址赋给Base指针</span></span><br><span class="line">    Base* basePtr = &amp;derivedObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过基类指针调用基类的成员函数</span></span><br><span class="line">    basePtr-&gt;<span class="built_in">baseFunction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向上转型比较安全，可以由编译器自动完成，不会有数据的丢失，在编译期间转换，如果转换失败会抛出编译错误，所以可以及时地发现错误。</p><p><strong>安全的原因：</strong></p><ul><li>基类指针只能访问基类成员，降低了误用的风险</li><li>向上转型只是将派生类对象的地址赋给基类指针，而不会改变对象本身的内存结构</li><li>在向上转型中，编译器能够静态地检查类型兼容性。如果存在不兼容的类型关系，编译时会发出错误，避免了一些在运行时才能检测到的问题。</li></ul><h4 id="2-2-向下转型"><a href="#2-2-向下转型" class="headerlink" title="2.2 向下转型"></a>2.2 向下转型</h4><p><strong>向下转型：</strong>从基类向派生类转换的过程，是显式的，需要使用类型转换操作符。</p><p><strong>静态转型：</strong><code>static_cast</code></p><p>静态转型是在编译时进行的转型，不提供运行时类型检查。</p><p><em>注：如果静态转型过程中出现错误，可能会导致未定义行为（如数据损坏、程序错误等）</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 static_cast 进行向下转型</span></span><br><span class="line">    Derived* derivedPtr = <span class="built_in">static_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用派生类指针调用派生类成员函数</span></span><br><span class="line">    derivedPtr-&gt;<span class="built_in">bar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态转型：</strong><code>dynamic_cast</code></p><p>动态转型是在运行时进行的转型，提供了类型安全检查。</p><p><em>注：动态转型只能用于含有虚函数的类层次结构，即只能用于多态类型之间的转换。多态类型是指至少有一个虚函数的类或结构体。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 dynamic_cast 进行向下转型</span></span><br><span class="line">    Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (derivedPtr) &#123;</span><br><span class="line">        <span class="comment">// 转型成功，使用派生类指针调用派生类成员函数</span></span><br><span class="line">        derivedPtr-&gt;<span class="built_in">bar</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 转型失败，可能是由于对象不是Derived类型</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dynamic casting failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：如果转型不安全，<code>dynamic_cast</code> 返回空指针（或引用），而不是导致未定义的行为。</em></p><h3 id="3-左值引用与右值引用"><a href="#3-左值引用与右值引用" class="headerlink" title="3.左值引用与右值引用"></a>3.左值引用与右值引用</h3><h4 id="3-1-左值引用"><a href="#3-1-左值引用" class="headerlink" title="3.1 左值引用"></a>3.1 左值引用</h4><p><strong>左值引用:</strong>给变量取别名，可以减少一层拷贝</p><ul><li><p><strong>修改引用对象的值:</strong>左值引用允许对左值进行引用，可以修改其值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp; lvalueRef = x;</span><br><span class="line">lvalueRef = <span class="number">10</span>;  <span class="comment">// 修改 x 的值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>传递引用参数：</strong>使函数直接操作传入的参数，而不是通过复制产生新的对象,避免不必要的对象复制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyValue</span><span class="params">(<span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">    value *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">modifyValue</span>(x);  <span class="comment">// 传递 x 的引用，函数可以修改 x 的值</span></span><br><span class="line">    <span class="comment">// 现在 x 的值为 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>函数返回引用：</strong>可以返回左值引用，避免创建临时对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp; ref = <span class="built_in">getReference</span>();</span><br><span class="line">    ref = <span class="number">10</span>;  <span class="comment">// 修改 x 的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-右值引用"><a href="#3-2-右值引用" class="headerlink" title="3.2 右值引用"></a>3.2 右值引用</h4><p><strong>右值：</strong>一个表达式，通常是一些临时对象、字面常量、表达式的计算结果等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;  <span class="comment">// 函数返回一个右值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;  <span class="comment">// x 是左值</span></span><br><span class="line">    <span class="type">int</span> y = x + <span class="number">5</span>;  <span class="comment">// x + 5 是一个右值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp;&amp; rvalueRef = <span class="built_in">getResult</span>();  <span class="comment">// getResult() 返回的是右值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：左值可以取地址，右值不能被取地址</em></p><p><strong>左值引用只能引用左值，经过const修饰的左值引用，既可以引用左值，也可以引用右值：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; constLvalueRef = <span class="number">42</span>;  <span class="comment">// 常量左值引用引用右值</span></span><br></pre></td></tr></table></figure><p><em>注：右值是不能被修改的值，所以左值引用被const修饰后才能引用右值</em></p><p><strong>右值引用可以引用move以后的左值:</strong>move相当于一个强制转换，将左值转换为右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::move 将左值 x 转换为右值引用</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; rvalueRef = std::<span class="built_in">move</span>(x);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x after std::move: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 输出 x 的值，已经被 std::move 转换过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>右值移动：</strong></p><ul><li><p><strong>移动语义：</strong>旨在提高对对象的资源管理效率，允许在对象资源的<strong>所有权转移（资源窃取）</strong>时，避免昂贵的深拷贝操作，而采用更经济高效的移动操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) : <span class="built_in">data</span>(other.data), <span class="built_in">size</span>(other.size) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        other.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyString source = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数被调用，资源的所有权从 source 转移到 destination</span></span><br><span class="line">    MyString destination = std::<span class="built_in">move</span>(source);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时 source 不再拥有资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>完美转发：</strong>实现一种通用的、保留原参数特性的参数传递机制（即接收左值作为参数，也可以接收右值作为参数）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">MyClass</span>(T&amp;&amp; arg) : <span class="built_in">data</span>(std::forward&lt;T&gt;(arg)) &#123;</span><br><span class="line">        <span class="comment">// 构造函数中的完美转发</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过完美转发调用构造函数</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(x)</span></span>;     <span class="comment">// 左值</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">10</span>)</span></span>;    <span class="comment">// 右值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：<code>std::forward</code>的作用是保留原始参数的左值或右值性质，以及 const 修饰符，实现一种通用的参数传递机制，其位于头文件 <code>&lt;utility&gt;</code> 中，并定义在命名空间 <code>std</code> 中</em></p></li></ul><h3 id="4-模板（泛化、全特化、偏特化）"><a href="#4-模板（泛化、全特化、偏特化）" class="headerlink" title="4.模板（泛化、全特化、偏特化）"></a>4.模板（泛化、全特化、偏特化）</h3><h4 id="4-1-模板泛化"><a href="#4-1-模板泛化" class="headerlink" title="4.1 模板泛化"></a>4.1 模板泛化</h4><p>模板泛化是不关心具体的类型，而是提供了通用的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 泛化的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic process: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-2-全特化"><a href="#4-2-全特化" class="headerlink" title="4.2 全特化"></a>4.2 全特化</h4><p><strong>全特化：</strong>为某些类型提供更高效的实现</p><p>成员函数的全特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员函数的特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> MyClass&lt;<span class="type">int</span>&gt;::<span class="built_in">process</span>(<span class="type">int</span> data) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Specialized process for int: &quot;</span> &lt;&lt; data * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板全特化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板的特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized implementation for int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-3-偏特化"><a href="#4-3-偏特化" class="headerlink" title="4.3 偏特化"></a>4.3 偏特化</h4><p>模板偏特化是指在泛化的模板基础上，对其中的某一部分进行特化。</p><p><strong>模板参数数量的偏特化：</strong>特化部分参数，还存在一部分参数使用通用的模板定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板，有两个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T first;</span><br><span class="line">    U second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板参数数量的偏特化，对第一个模板参数进行特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;<span class="type">int</span>, U&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> first;</span><br><span class="line">    U second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>模板参数范围的偏特化：</strong>对模板的参数范围进行缩小</p><ul><li><strong>const 特化:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic process: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const 特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">const</span> T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> T data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized process for const type: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>指针特化：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic setValue: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span>&lt;T*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized setValue for pointers: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>左值引用特化:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyReference</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic printValue: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左值引用特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyReference</span>&lt;T&amp;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp; ref)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized printValue for lvalue references: &quot;</span> &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>右值引用特化:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化的类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRValueReference</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generic printValue: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右值引用特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRValueReference</span>&lt;T&amp;&amp;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp;&amp; rvalue)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized printValue for rvalue references: &quot;</span> &lt;&lt; rvalue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>注：函数模板是不能偏特化的，只有类模板可以进行偏特化。函数模板可以不显式指定类型。</em></p><h3 id="5-vector-lt-shape-gt-和vector-lt-shape-gt-的多态性"><a href="#5-vector-lt-shape-gt-和vector-lt-shape-gt-的多态性" class="headerlink" title="5.vector&lt;shape&gt;和vector&lt;shape*&gt;的多态性"></a>5.<code>vector&lt;shape&gt;</code>和<code>vector&lt;shape*&gt;</code>的多态性</h3><p><strong><code>std::vector&lt;shape&gt;</code>：</strong></p><p>不支持多态性。如果有一个<code>shape</code>的派生类（例如<code>circle</code>），并且你试图将<code>circle</code>对象存储在<code>std::vector&lt;shape&gt;</code>中，会发生对象切片（object slicing），即只存储<code>shape</code>部分的数据。</p><p><strong><code>std::vector&lt;shape*&gt;</code>：</strong></p><p>支持多态性。可以将指向<code>shape</code>派生类对象的指针存储在<code>vector</code>中，并通过基类指针调用虚函数，实现多态行为。</p><p><em>注1：对象切片（object slicing）：派生类对象被赋值给基类对象，只会复制基类部分的成员变量，而派生类特有的成员变量会被丢弃。</em></p><p><em>注2：通过基类的指针或引用来指向派生类对象，可以避免对象切片。</em></p><h3 id="6-堆对象-栈对象"><a href="#6-堆对象-栈对象" class="headerlink" title="6.堆对象 栈对象"></a>6.堆对象 栈对象</h3><h4 id="6-1-栈对象"><a href="#6-1-栈对象" class="headerlink" title="6.1 栈对象"></a>6.1 栈对象</h4><p><strong>栈对象：</strong>在栈上分配内存的对象，通过直接声明变量的方式创建。</p><p><strong>特点：</strong></p><ul><li>自动内存管理：栈上的内存由编译器自动管理，超出作用域后自动释放，不需要程序员手动释放。</li><li><strong>分配速度快</strong>：栈内存分配是线性分配，速度非常快，因此栈对象创建和销毁的效率高。</li><li><strong>生命周期受限于作用域</strong>：栈对象的生命周期受到作用域的限制，一旦超出作用域，栈内存即被释放。</li><li><strong>大小受限</strong>：由于栈的大小有限，过大的对象在栈上分配可能会导致栈溢出，尤其是递归调用或大数组时。</li></ul><p>eg:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// x 是一个栈对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-堆对象"><a href="#6-2-堆对象" class="headerlink" title="6.2 堆对象"></a>6.2 堆对象</h4><p><strong>堆对象:</strong> 在堆上分配的对象，通过<code>new</code>关键字动态分配内存，或者通过智能指针等管理。堆是一块较大但相对慢的内存区域，适合在运行时动态分配大量内存。</p><p><strong>特点:</strong></p><ul><li><strong>动态内存管理</strong>：堆上的内存分配由程序员手动管理，必须使用<code>delete</code>来释放（或使用智能指针来自动管理）。</li><li><strong>分配速度较慢</strong>：由于堆内存需要动态管理和查找空闲区域，分配和释放速度较慢。</li><li><strong>生命周期灵活</strong>：堆对象的生命周期不受限于作用域，直到显式释放内存时才会销毁。</li><li><strong>适合大型数据</strong>：堆可以容纳较大的对象，不易出现栈溢出。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>); <span class="comment">// p 是一个指向堆对象的指针</span></span><br><span class="line">    <span class="comment">// ... 使用 p</span></span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 手动释放堆内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-实例"><a href="#6-3-实例" class="headerlink" title="6.3 实例"></a>6.3 实例</h4><p>堆对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;shape*&gt; shapevector;</span><br><span class="line">shapevector.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Line</span>(p1, p2));</span><br></pre></td></tr></table></figure><p><code>new</code>关键字会在堆上动态分配内存，并返回一个指向该内存的指针。它的生命周期不受限于当前作用域，只有在明确调用<code>delete</code>时才会释放内存。</p><p>而如果是栈对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Line line(p1, p2);</span><br><span class="line">shapevector.push_back(&amp;line);</span><br></pre></td></tr></table></figure><p>当作用域结束时，例如函数返回后，<code>line</code>会自动销毁。如果<code>shapevector</code>还保留着指向<code>line</code>的指针，那么这个指针会变成<strong>悬空指针</strong>（dangling pointer），引发未定义行为。</p><p>7.mutable</p><h3 id="8-explicit"><a href="#8-explicit" class="headerlink" title="8.explicit"></a>8.explicit</h3><p><strong>explicit:</strong>用于构造函数和转换运算符，防止隐式类型转换</p><ul><li><strong>用于构造函数：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;  <span class="comment">// 显式构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass constructed with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">42</span>)</span></span>;      <span class="comment">// 正确：显式调用构造函数</span></span><br><span class="line">    <span class="comment">// MyClass obj2 = 42;  // 错误：隐式调用被禁止</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>用于转换运算符:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">// 显式转换运算符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="comment">// int x = obj;  // 错误：隐式转换被禁止</span></span><br><span class="line">    <span class="type">int</span> y = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(obj);  <span class="comment">// 正确：显式转换</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpectFormer</title>
      <link href="/posts/aa01fe8.html"/>
      <url>/posts/aa01fe8.html</url>
      
        <content type="html"><![CDATA[<h2 id="SpectFormer"><a href="#SpectFormer" class="headerlink" title="SpectFormer"></a>SpectFormer</h2><p><strong>论文：《SpectFormer: Frequency and Attention is what you need in a Vision Transformer》（arxiv 2023）</strong></p><p>频域层和多头注意力层结合起来，可以使Transformer能够捕捉到适当的特征表示，提升模型的特征建模能力，从而提升模型的性能。</p><p>频域层由一个快速傅里叶变换层（FFT)和一个逆傅里叶层（IFFT)构成</p><p><em>注：FFT和IFFT的操作，也可使用小波变换和逆小波变换来实现</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312272028245.png" alt="image-20231224161116413" style="zoom:67%;"></p><p>FFT把图像信息转到频域空间，然后可以对频域信号进行操作，使用具有可学习权重参数<script type="math/tex">W_c</script>的门控层来确定每个频率分量的权重，以便适当地捕获图像的线条和边缘，如可以去除低频部分，保留高频部分，用于突出图像的主要特征，然后通过IFFT做一个逆变换，把频域图还原到时域中。频域层之后用层归一化和多层感知器 (MLP) 块用于通道混合。</p><p>SpecFormer考虑了局部特征，这有助于捕获局部频率，以及更深层的全局特征，这有助于捕获长期依赖关系。</p><p>与GFNnet对比：SpecFormer可以更加清晰地捕获局部特征，如图像的线条和边缘</p><p><em>注：GFNet是完全使用频域层来进行建模</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312272028521.png" alt="image-20231224161421871"></p><p><em>频域层和注意力层结合，通过频域层捕获局部信息，注意力层捕获全局信息，同时可以灵活调整频域层和注意力层各自的层数</em></p><p><strong>混合建模形式的实验验证：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312272028064.png" alt="image-20231224163639771" style="zoom:67%;"></p><p><em>注：Inverse SpecFormer是将频域层和注意力层对调，即注意力层在前，频域层在后</em></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shader</title>
      <link href="/posts/fff39e28.html"/>
      <url>/posts/fff39e28.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-GLSL中向量的数据类型"><a href="#1-GLSL中向量的数据类型" class="headerlink" title="1.GLSL中向量的数据类型"></a>1.GLSL中向量的数据类型</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202312252046456.png" alt="image-20231215145202684"></p><h4 id="2-Uniform"><a href="#2-Uniform" class="headerlink" title="2.Uniform"></a>2.Uniform</h4><p><strong>uniform</strong>是一种在顶点着色器和片段着色器之间进行数据传递的机制，uniform变量是全局的，其值在每个渲染迭代中对所有顶点或片段是一致的。</p><p><strong>变量声明：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniform vec3 cameraPosition;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//返回自窗口初始化以来的秒数</span><br><span class="line">float timeValue = glfwGetTime();</span><br><span class="line">//将timeValue缩放到[0, 1]范围</span><br><span class="line">float greenValue = sin(timeValue) / 2.0f + 0.5f;</span><br><span class="line">//查询uniform ourColor的位置值</span><br><span class="line">int vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);</span><br><span class="line">//设置uniform值</span><br><span class="line">glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);</span><br></pre></td></tr></table></figure><h4 id="3-颜色插值"><a href="#3-颜色插值" class="headerlink" title="3.颜色插值"></a>3.颜色插值</h4><p>OpenGL会自动在顶点着色器和片段着色器之间进行插值</p><p><strong>定义顶点着色器和片段着色器：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">float vertices[] = &#123;</span><br><span class="line">// 位置              // 颜色</span><br><span class="line"> 0.8f, 0.2f, 0.0f,  1.0f, 0.0f, 0.0f,   // 右下</span><br><span class="line"> 0.3f, 0.4f, 0.0f,  0.0f, 1.0f, 0.0f,   // 左下</span><br><span class="line"> 0.0f,  0.1f, 0.0f,  0.0f, 0.0f, 1.0f,    // 顶部</span><br><span class="line"> 0.2f,  0.9f, 0.0f,  0.8f, 0.6f, 1.0f</span><br><span class="line">&#125;;</span><br><span class="line">unsigned int indices[] = &#123;</span><br><span class="line">0,1,2, // 第一个三角形</span><br><span class="line">2,1,3  // 第二个三角形</span><br><span class="line">&#125;;</span><br><span class="line">const char* vertexShaderSource = &quot;#version 330 core\n&quot;</span><br><span class="line">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span><br><span class="line">&quot;layout(location=1) in vec3 aColor;&quot;</span><br><span class="line">&quot;out vec4 vertexColor;\n&quot;</span><br><span class="line">&quot;void main()\n&quot;</span><br><span class="line">&quot;&#123;\n&quot;</span><br><span class="line">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span><br><span class="line">&quot;vertexColor=vec4(aColor.x,aColor.y,aColor.z,1.0f);\n&quot;</span><br><span class="line">&quot;&#125;\0&quot;;</span><br><span class="line"></span><br><span class="line">const char* fragmentShaderSource =</span><br><span class="line">&quot;#version 330 core\n&quot;</span><br><span class="line">&quot;out vec4 FragColor;\n&quot;</span><br><span class="line">&quot;uniform vec4 ourColor; &quot;</span><br><span class="line">&quot;in vec4 vertexColor;\n&quot;</span><br><span class="line">&quot;void main()&#123;\n&quot;</span><br><span class="line">&quot;FragColor = vertexColor;&#125;\n &quot;;</span><br></pre></td></tr></table></figure><p><strong>配置顶点属性指针：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 位置属性</span><br><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line">// 颜色属性</span><br><span class="line">glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));</span><br><span class="line">glEnableVertexAttribArray(1);</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252046360.png" alt="image-20231215170557358" style="zoom:67%;"></p><p><em>注：片段着色器不会直接从 <code>VBO</code> 中读取数据，而是通过与顶点着色器的输出交互，通过插值的方式在片段上进行着色。</em></p><h4 id="4-文件流读取着色器内容"><a href="#4-文件流读取着色器内容" class="headerlink" title="4.文件流读取着色器内容"></a>4.文件流读取着色器内容</h4>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>窗口与三角形</title>
      <link href="/posts/aa216b4c.html"/>
      <url>/posts/aa216b4c.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-窗口"><a href="#1-窗口" class="headerlink" title="1.窗口"></a>1.窗口</h3><p><strong>创建GLFW窗口对象</strong></p><p><code>GLFWwindow* window = glfwCreateWindow(800, 600, &quot;opengl&quot;,NULL,NULL);</code></p><ul><li>800:width</li><li>600:height</li><li>“opengl”:title</li></ul><p><strong>初始化GLEW</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glewExperimental = true;//设置 GLEW 的实验性模式</span><br><span class="line">if (glewInit() != GLEW_OK)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Init GLEW failed&quot;);</span><br><span class="line">glfwTerminate();</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>窗口渲染框架：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#define GLEW_STATIC</span><br><span class="line">#include&lt;GL/glew.h&gt;</span><br><span class="line">#include&lt;GLFW/glfw3.h&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">void processInput(GLFWwindow* window)</span><br><span class="line">&#123;</span><br><span class="line">if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)//GLFW_KEY_ESCAPE:表示esc键，glfwGetKey：获取窗口中键的状态</span><br><span class="line">&#123;</span><br><span class="line">glfwSetWindowShouldClose(window, true);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">glfwInit();</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">//创建GLFW窗口对象</span><br><span class="line">GLFWwindow* window = glfwCreateWindow(800, 600, &quot;opengl&quot;,NULL,NULL);</span><br><span class="line">glfwMakeContextCurrent(window);//将当前需要渲染的窗口设置为window</span><br><span class="line">//初始化GLEW</span><br><span class="line">glewExperimental = true;//设置 GLEW 的实验性模式</span><br><span class="line">if (glewInit() != GLEW_OK)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Init GLEW failed&quot;);</span><br><span class="line">glfwTerminate();</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glViewport(0, 0, 800, 600);</span><br><span class="line">while (!glfwWindowShouldClose(window))//判断窗口是否被关闭，未关闭则一直循环</span><br><span class="line">&#123;</span><br><span class="line">processInput(window);</span><br><span class="line">glClearColor(0.5f, 0.2f, 0.3f, 1.0f);//定义一种颜色（rgba四通道），每个通道取值为0~1.</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT); </span><br><span class="line">//GL_COLOR_BUFFER_BIT:颜色缓冲,glClear:将颜色缓冲填充成glClearColor设置的颜色</span><br><span class="line">glfwSwapBuffers(window);//交换双缓冲，渲染先在后台缓冲区进行，之后再与前台缓冲区交换</span><br><span class="line">//使用双缓冲是为了避免用户看到不完整的、中间过程的渲染结果</span><br><span class="line">glfwPollEvents();//检查有没有触发什么事件（比如键盘输入、鼠标移动等）</span><br><span class="line">&#125;</span><br><span class="line">glfwTerminate();//释放 GLFW 库分配的资源和清理 GLFW 环境</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-三角形"><a href="#2-三角形" class="headerlink" title="2.三角形"></a>2.三角形</h3><p><strong>图形渲染管线：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312151450311.png" alt="image-20231215095323007" style="zoom:67%;"></p><h4 id="2-1-定义并绑定VAO"><a href="#2-1-定义并绑定VAO" class="headerlink" title="2.1 定义并绑定VAO"></a>2.1 定义并绑定VAO</h4><p><strong>VAO（Vertex Array Object）</strong>：**保存了一系列的VBO配置和顶点属性指针，它负责告诉GPU，VBO中的信息到底该以几个为一组，对VBO起到解释的作用。</p><p><em>注：一个VAO可以对应多个VBO</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312151450544.png" alt="image-20231215093925600" style="zoom:67%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned int VAO;//也可以是unsigned int VAO[n],n为VAO的个数</span><br><span class="line">glGenVertexArrays(1, &amp;VAO);</span><br><span class="line">glBindVertexArray(VAO);</span><br></pre></td></tr></table></figure><h4 id="2-2-定义并绑定VBO"><a href="#2-2-定义并绑定VBO" class="headerlink" title="2.2 定义并绑定VBO"></a>2.2 定义并绑定VBO</h4><p><strong>VBO（Vertex Buffer Object）:</strong>用于存储实际的顶点数据，可以包含顶点坐标、法线、颜色等信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned int VBO;</span><br><span class="line">glGenBuffers(1, &amp;VBO);</span><br><span class="line">//绑定VBO</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">//数据传输到缓冲区，GL_STATIC_DRAW：静态绘制，顶点数据不会被修改</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><h4 id="2-3-创建顶点着色器"><a href="#2-3-创建顶点着色器" class="headerlink" title="2.3 创建顶点着色器"></a>2.3 创建顶点着色器</h4><p><strong>顶点着色器：</strong>对每个输入顶点的坐标进行计算和变换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//vertexShaderSource</span><br><span class="line">const char* vertexShaderSource = &quot;#version 330 core\n&quot;</span><br><span class="line">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span><br><span class="line">&quot;void main()\n&quot;</span><br><span class="line">&quot;&#123;\n&quot;</span><br><span class="line">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span><br><span class="line">&quot;&#125;\0&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建顶点着色器对象</span><br><span class="line">unsigned int vertexShader;</span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">//设置顶点着色器源代码并编译</span><br><span class="line">glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);</span><br><span class="line">glCompileShader(vertexShader);</span><br></pre></td></tr></table></figure><h4 id="2-4-创建片段着色器"><a href="#2-4-创建片段着色器" class="headerlink" title="2.4 创建片段着色器"></a>2.4 创建片段着色器</h4><p><strong>片段着色器：</strong>用于对每个屏幕上的像素（片段）进行处理，决定最终的颜色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//fragmentShaderSource</span><br><span class="line">const char* fragmentShaderSource =</span><br><span class="line">&quot;#version 330 core\n&quot;</span><br><span class="line">&quot;out vec4 FragColor;\n&quot;</span><br><span class="line">&quot;void main()&#123;\n&quot;</span><br><span class="line">&quot;FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);&#125;\n &quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建片段着色器对象</span><br><span class="line">unsigned int fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">//设置源代码并编译</span><br><span class="line">glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);</span><br><span class="line">glCompileShader(fragmentShader);</span><br></pre></td></tr></table></figure><h4 id="2-5-创建着色器程序"><a href="#2-5-创建着色器程序" class="headerlink" title="2.5 创建着色器程序"></a>2.5 创建着色器程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned int shaderProgram;</span><br><span class="line">shaderProgram = glCreateProgram();</span><br><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">//将附加到着色器程序的各个着色器连接在一起，以形成一个完整的着色器程序。</span><br><span class="line">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure><h4 id="2-6-配置顶点属性指针"><a href="#2-6-配置顶点属性指针" class="headerlink" title="2.6 配置顶点属性指针"></a>2.6 配置顶点属性指针</h4><p><strong><code>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 \* sizeof(float), (void\*)0);</code></strong></p><ul><li><code>0</code>: 指定顶点着色器中的顶点属性位置（location）。在顶点着色器代码中，使用 <code>layout(location = 0)</code> 来定义的。</li><li><code>3</code>: 指定每个顶点属性包含的分量数量，这里是3，表示三维坐标x、y、z。</li><li><code>GL_FLOAT</code>: 指定顶点属性的数据类型，这里是浮点数。</li><li><code>GL_FALSE</code>: 指定是否要归一化数据，对于浮点数数据，通常设置为GL_FALSE。</li><li><code>3 * sizeof(float)</code>: 指定相邻顶点属性之间的偏移量（以字节为单位）。这里表示每个顶点的大小为3个浮点数，所以偏移量为3 * sizeof(float)。</li><li><code>(void*)0</code>: void*无类型指针，指定第一个顶点属性在缓冲区中的偏移量。这里表示从缓冲区的开头开始使用。</li></ul><p><strong><code>glEnableVertexAttribArray(0);</code></strong>:启用顶点属性数组，OpenGL会按照之前配置的顶点属性指针从缓冲区中读取数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br></pre></td></tr></table></figure><h4 id="2-7-绘制三角形"><a href="#2-7-绘制三角形" class="headerlink" title="2.7 绘制三角形"></a>2.7 绘制三角形</h4><p><strong><code>glDrawArrays(GL_TRIANGLES, 0, 3);</code></strong>:</p><ul><li><code>GL_TRIANGLES</code> 表示渲染的图元类型，这里是三角形。</li><li><code>0</code> 是起始顶点的索引，表示从顶点数组的第一个顶点开始渲染。</li><li><code>3</code> 是顶点的数量，表示渲染三个顶点。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, 0, 3);</span><br></pre></td></tr></table></figure><h4 id="2-8-绘制多边形"><a href="#2-8-绘制多边形" class="headerlink" title="2.8 绘制多边形"></a>2.8 绘制多边形</h4><p>注意：opengl的绘制顺序是逆时针（右手系），当启用背面剔除时，背面将不可见。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_CULL_FACE);</span><br><span class="line">glCullFace(GL_BACK);</span><br></pre></td></tr></table></figure><p><strong>EBO（索引缓冲对象）：</strong>用于优化和节省内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unsigned int indices[] = &#123;</span><br><span class="line">0, 1, 2, // 第一个三角形</span><br><span class="line">2, 1, 3  // 第二个三角形</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义并绑定EBO</span><br><span class="line">unsigned int EBO;</span><br><span class="line">glGenBuffers(1, &amp;EBO);</span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p><strong>绘制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">/*glDrawArrays(GL_TRIANGLES, 0,3);*/</span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span><br></pre></td></tr></table></figure><h4 id="2-9-线框模式"><a href="#2-9-线框模式" class="headerlink" title="2.9 线框模式"></a>2.9 线框模式</h4><p><strong>启用线框模式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span><br></pre></td></tr></table></figure><p><strong>取消线框模式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D-LKA Attention</title>
      <link href="/posts/bf4c3cab.html"/>
      <url>/posts/bf4c3cab.html</url>
      
        <content type="html"><![CDATA[<h1 id="D-LKA-Attention"><a href="#D-LKA-Attention" class="headerlink" title="D-LKA Attention"></a>D-LKA Attention</h1><p><strong>论文：《Beyond Self-Attention: Deformable Large Kernel Attention for Medical Image Segmentation》（WACV 2024)</strong></p><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><strong>网络结构：</strong><br>                                            <img src="https://typoraimg.wangak.cc/2023/img/202312252047820.png" alt="image-20231218151015722" style="zoom:67%;"></p><p><strong>LKA：</strong>将卷积分解为三个部分：深度卷积、深度空洞卷积和逐点卷积</p><p>LKA吸收了卷积和self-attention的优点，包括局部结构信息、长依赖性和适应性。</p><p><strong>DW-Conv:</strong>可以利用图像的局部上下文信息</p><p><strong>DW-D-Conv：</strong>捕获LKA中的长程依赖性方面起到了作用</p><p><strong>1×1 Conv：</strong>通道维度中的关系</p><p><strong>2d-LKA的参数量：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047832.png" alt="image-20231218150016851" style="zoom: 67%;"></p><p><em>注：普通卷积kernel大小为K，DW-Conv的kernel为K/d，DW-D-Conv的kernel为(2d-1)</em></p><p><strong>3d-LKA的参数量：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047618.png" alt="image-20231218150455218" style="zoom:67%;"></p><p>d（扩张率）是通过对参数量求导确定的，找使参数量导数为0，即参数量最小的扩张率</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047839.png" alt="image-20231218150728812" style="zoom:67%;"></p><p><strong>D-LKA：</strong>在LKA的基础上，使用可变形深度卷积代替深度卷积，用可变形深度空洞卷积代替空洞卷积</p><p><em>注：可变形卷积提高了捕获不规则形状和大小的物体的能力</em></p><p><strong>D-LKA模块结构：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047842.png" alt="image-20231218152019184" style="zoom: 50%;"></p><h3 id="2-实验"><a href="#2-实验" class="headerlink" title="2.实验"></a>2.实验</h3><p><strong>2d的D-LKA在多器官数据集上的表现：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047330.png" alt="image-20231218154533519" style="zoom:67%;"></p><p><strong>3d的D-LKA在多器官数据集上的表现：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047355.png" alt="image-20231218154633563"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>games作业4</title>
      <link href="/posts/db707014.html"/>
      <url>/posts/db707014.html</url>
      
        <content type="html"><![CDATA[<h3 id="递归绘制贝塞尔曲线"><a href="#递归绘制贝塞尔曲线" class="headerlink" title="递归绘制贝塞尔曲线"></a>递归绘制贝塞尔曲线</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cv::Point2f recursive_bezier(const std::vector&lt;cv::Point2f&gt; &amp;control_points, float t) </span><br><span class="line">&#123;</span><br><span class="line">    if (control_points.size() == 1) </span><br><span class="line">    &#123;</span><br><span class="line">        return control_points[0];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        std::vector&lt;cv::Point2f&gt; points;</span><br><span class="line">        for (int i = 0; i &lt; control_points.size()-1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cv::Point2f p;</span><br><span class="line">            p.x = (1-t) * control_points[i].x + t * control_points[i + 1].x;</span><br><span class="line">            p.y = (1-t) * control_points[i].y + t * control_points[i + 1].y;</span><br><span class="line">            points.push_back(p);</span><br><span class="line">        &#125;</span><br><span class="line">        return recursive_bezier(points, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bezier(const std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window) </span><br><span class="line">&#123;</span><br><span class="line">    for (float t = 0; t &lt;= 1; t += 0.0001)</span><br><span class="line">    &#123;</span><br><span class="line">        //调用递归贝塞尔曲线计算函数，计算曲线上的点坐标</span><br><span class="line">        cv::Point2f point=recursive_bezier(control_points,t);</span><br><span class="line">        window.at&lt;cv::Vec3b&gt;(point.y, point.x)[1] = 255;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光线追踪</title>
      <link href="/posts/426f6fb6.html"/>
      <url>/posts/426f6fb6.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Shadow-Mapping"><a href="#1-Shadow-Mapping" class="headerlink" title="1.Shadow Mapping"></a>1.<strong>Shadow Mapping</strong></h3><p><strong>光栅化的问题：</strong>不能很好地表示全局的效果</p><p><strong>Shadow Mapping：</strong> 主要是为了解决点光源的硬阴影的问题</p><p>阴影区域：点对相机可见，而对光源不可见</p><p>Shadow Map记录每个pixel是否在阴影区域， 其生成步骤如下：</p><ul><li><p>1.从光源位置出发找出可见点，记录光源可见点的深度，得到光源深度图。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910765.png" alt="image-20231210115113668" style="zoom:50%;"></p></li><li><p>2.从相机出发，找可见点，如果点可见，坐标变换求此点到光源的距离。如果此距离与光源深度图中此位置的深度一致，说明此点可以被光源照到，是为光源、相机能同时看到点；如果不一致，说明是阴影点。</p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910506.png" alt="image-20231210115203873" style="zoom:50%;"></p><p><strong>硬阴影与软阴影：</strong></p><p>软阴影的形成在于全影和半影的渐变，点光源不存在软阴影问题，出现软阴影一定是光源有大小、不同照射位置有全影和半影这种渐变。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910061.png" alt="image-20231210120318890" style="zoom:50%;"></p><h3 id="2-Whitted-Styled-Ray-Tracing"><a href="#2-Whitted-Styled-Ray-Tracing" class="headerlink" title="2.Whitted-Styled Ray Tracing"></a>2.Whitted-Styled Ray Tracing</h3><p><strong>光线追踪利用的就是光的可逆性</strong></p><p>利用递归的方法进行光线追踪，对每条光线，递归计算其多个弹射点，当前光线所对应的像素值是由全部弹射点共同决定的：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910583.png" alt="image-20231210124837928" style="zoom:50%;"></p><p><strong>光源的定义：起点+方向</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910866.png" alt="image-20231210124958832" style="zoom:50%;"></p><p>于是，光线上的点可表示为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910939.png" alt="image-20231210125038746" style="zoom:50%;"></p><h3 id="3-光线求交点"><a href="#3-光线求交点" class="headerlink" title="3.光线求交点"></a>3.光线求交点</h3><h4 id="3-1-隐式表面"><a href="#3-1-隐式表面" class="headerlink" title="3.1 隐式表面"></a>3.1 隐式表面</h4><p>隐式表面求交点：将光线上的一点代入隐式方程中求解</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910802.png" alt="image-20231210125547229" style="zoom:50%;"></p><h4 id="3-2-显式表面"><a href="#3-2-显式表面" class="headerlink" title="3.2 显式表面"></a>3.2 显式表面</h4><p>显式表面求交点：用光线与三角形求交</p><p><strong>光线与三角形求交：</strong>光线与平面求交+判断交点是否在三角形内</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910771.png" alt="image-20231210130304291" style="zoom:50%;"></p><p>平面的定义：平面上一点+平面的法线</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910972.png" alt="image-20231210130407893" style="zoom:50%;"></p><p>求解交点的过程：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910503.png" alt="image-20231210130538694" style="zoom:50%;"></p><p><strong>Möller Trumbore Algorithm：</strong>三角形的一个点可以使用重心坐标表示</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910163.png" alt="image-20231210130920469" style="zoom:50%;"></p><p><em>注：解上图的方程，若$(1-b_1,b_2)、b_1、b_2$为正数，则交点在三角形内部</em></p><h3 id="4-计算的加速"><a href="#4-计算的加速" class="headerlink" title="4.计算的加速"></a>4.计算的加速</h3><p>每个光线与全部三角形都要进行求交点的计算，会导致计算开销过大，所以需要进行计算的加速。</p><p><strong>包围盒方法：</strong>在物体外面包一个包围盒，如果光线与盒子都没交点，那跟物体里的所有面更不会有交集。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910024.png" alt="image-20231210133306097" style="zoom:50%;"></p><p><strong>一般使用轴对齐包围盒（Axis-Aligned Bounding Box、AABB)</strong></p><p><strong>判断光线和包围盒是否有交点：</strong>通过计算光线进入/离开长方体的三个对面的时间可以判断出，光线和包围盒是否有交点</p><p>立方体有三个对面：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910471.png" alt="image-20231210133558734" style="zoom:50%;"></p><p>进入/离开对面的时间：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910723.png" alt="image-20231210133643427" style="zoom:50%;"></p><p>进入盒、离开盒的时间为：<br><img src="https://typoraimg.wangak.cc/2023/img/202312101910186.png" alt="image-20231210133737225" style="zoom:50%;"></p><p><em>注：光线进入了三个对面则认为光线进入了盒子，而光线离开了任意一个对面，就认为光线离开了盒子。</em></p><p><strong>若$t<em>{enter}&lt;t</em>{exit}且t_{exit}&gt;=0$，则有交点</strong></p><p><em>注：$t_{exit}$&lt;0，表示盒在光源背后，没有交点</em></p><h3 id="5-加速结构"><a href="#5-加速结构" class="headerlink" title="5.加速结构"></a>5.加速结构</h3><h4 id="5-1-均匀空间划分-Uniform-Spatial-Partitions-Grids"><a href="#5-1-均匀空间划分-Uniform-Spatial-Partitions-Grids" class="headerlink" title="5.1 均匀空间划分 Uniform Spatial Partitions (Grids)"></a>5.1 均匀空间划分 Uniform Spatial Partitions (Grids)</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910051.png" alt="image-20231210140725279" style="zoom:50%;"></p><p>判断光线交到的是不是含有物体表面的格子，如果不是的话跳过，是的话和其中的物体求交</p><p><em>注：该方法适合物体分布较均匀的场景</em></p><h4 id="5-2-空间划分"><a href="#5-2-空间划分" class="headerlink" title="5.2 空间划分"></a>5.2 空间划分</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910649.png" alt="image-20231210141331964" style="zoom:50%;"></p><ul><li>Oct-Tree:八叉树</li><li>KD-Tree</li><li>BSP-Tree</li></ul><p><strong>KD-Tree</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910636.png" alt="image-20231210142240300" style="zoom:50%;"></p><p>注：</p><p>1.KD-Tree中一个物体可能存在多个格子中</p><p>2.KD-Tree要计算三角形与盒子的求交，这较为困难</p><h4 id="5-3-物体划分（BVH）"><a href="#5-3-物体划分（BVH）" class="headerlink" title="5.3 物体划分（BVH）"></a>5.3 物体划分（BVH）</h4><p><strong>步骤：</strong></p><p>1.找到一个包围盒</p><p>2.递归地将物体拆成两个部分</p><p>3.两个部分重新计算包围盒</p><p>4.在每个叶子节点中记录实际的物体</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910732.png" alt="image-20231210143955688" style="zoom: 67%;"></p><p><em>注：划分规则：选择最长轴划分，以中间位置的物体进行划分</em></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>辐射度量学</title>
      <link href="/posts/9c8d1a2b.html"/>
      <url>/posts/9c8d1a2b.html</url>
      
        <content type="html"><![CDATA[<h2 id="辐射度量学"><a href="#辐射度量学" class="headerlink" title="辐射度量学"></a>辐射度量学</h2><p><strong>Whitted-Styled Ray Tracing的缺陷：</strong></p><ul><li>Whitted-Styled Ray Tracing主要关注的是折射光线和反射光线，而没有对漫反射的光线进行追踪。</li><li>所使用的Blinn-Phong模型是一种简化的模型</li></ul><p>因而引入辐射幅度量学来解决此问题。</p><p><strong>辐射度量学</strong>对光照的一套测量系统和单位，它能够准确的描述光线的物理性质。</p><h3 id="1-物理量的定义"><a href="#1-物理量的定义" class="headerlink" title="1.物理量的定义"></a>1.物理量的定义</h3><h4 id="1-1-辐射能量-Radiant-energy-和辐射通量-Radiant-flux"><a href="#1-1-辐射能量-Radiant-energy-和辐射通量-Radiant-flux" class="headerlink" title="1.1. 辐射能量(Radiant energy)和辐射通量(Radiant flux)"></a>1.1. 辐射能量(Radiant energy)和辐射通量(Radiant flux)</h4><p><strong>辐射能量:</strong>描述在一定时间内，通过某个表面或在空间中传播的电磁辐射的总能量量,以焦耳(J)为单位</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619481.png" alt="image-20231211210954761" style="zoom: 67%;"></p><p><strong>辐射通量（Radiant Flux）：</strong>是指光源辐射出的总功率，是在所有方向上的辐射强度的总和，以瓦特(W)为单位</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619781.png" alt="image-20231211211004923" style="zoom:67%;"></p><h4 id="1-2-辐射强度-Radiant-intensity"><a href="#1-2-辐射强度-Radiant-intensity" class="headerlink" title="1.2 辐射强度(Radiant intensity)"></a>1.2 辐射强度(Radiant intensity)</h4><p><strong>立体角：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619827.png" alt="image-20231211211509949" style="zoom: 67%;"></p><p>注：整个球的立体角为4<script type="math/tex">\pi</script></p><p><strong>微分立体角<script type="math/tex">d\omega</script>与<script type="math/tex">d\theta</script>和<script type="math/tex">d\phi</script>的关系:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619950.png" alt="image-20231212140402409" style="zoom: 67%;"></p><p><strong>辐射强度(Radiant intensity)：</strong>光源向特定方向发射的单位立体角内的功率，反映了光源在特定方向上的亮度。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619264.png" alt="image-20231212141054230" style="zoom:50%;"></p><p><em>注：辐射强度等于辐射通量除以立体角（各向同性）</em></p><h4 id="1-3-irradiance"><a href="#1-3-irradiance" class="headerlink" title="1.3  irradiance"></a>1.3  irradiance</h4><p><strong>irradiance：</strong>每单位照射面积所接收到的光功率</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619651.png" alt="image-20231212141549887" style="zoom:50%;"></p><p>注：当光线斜着照射到平面时，<script type="math/tex">\theta</script>为光线与法线的夹角，该公式变为：<img src="https://typoraimg.wangak.cc/2023/img/202312121621359.png" alt="image-20231212141804496" style="zoom: 67%;"></p><p>当照射点离光源越远时，A（球的表面积）就越大，irradiance就越小：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619417.png" alt="image-20231212142046864" style="zoom:50%;"></p><h4 id="1-4-radiance"><a href="#1-4-radiance" class="headerlink" title="1.4 radiance"></a>1.4 radiance</h4><p><strong>Radiance：</strong>每单位立体角、每单位垂直面积的光功率。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619800.png" alt="image-20231212142754987" style="zoom:67%;"></p><p><em>注：与irradiance的单位照射面积不同，Radiance定义的是单位垂直面积，二者的关系为：dA⊥=dAcosθ</em></p><p><strong>radiance和irradiance的关系如下：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619856.png" alt="image-20231212143220911" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619776.png" alt="image-20231212143324793" style="zoom:67%;"></p><p><em>注:Irradiance是Radiance在整个半球面的立体角上的积累</em></p><h3 id="2-双向反射分布函数-BRDF"><a href="#2-双向反射分布函数-BRDF" class="headerlink" title="2.双向反射分布函数(BRDF)"></a>2.双向反射分布函数(BRDF)</h3><p>空间中的一点（面积微分），在接受到一定方向上的亮度<script type="math/tex">dE(\omega_i)</script>之后，再向不同方向把能量辐射出去<script type="math/tex">dL_r(\omega_r)</script></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619734.png" alt="image-20231212143746031" style="zoom:67%;"></p><p><em>注：能量辐射的过程（即产生<script type="math/tex">dL_r(\omega_r)</script>的过程）受物体表面材质的影响，如光滑表面会完全反射到镜面反射方向，而粗糙表面会反射到所有方向</em></p><p><strong>BRDF：</strong>从特定方向入射的光线经材料表面反射后，沿特定方向散射的相对强度，函数值为反射光的radiance与入射光的irradiance的比值，定义如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619943.png" alt="image-20231212145455775" style="zoom:67%;"></p><h3 id="3-反射方程与渲染方程"><a href="#3-反射方程与渲染方程" class="headerlink" title="3.反射方程与渲染方程"></a>3.反射方程与渲染方程</h3><p><strong>反射方程：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619468.png" alt="image-20231212145941600" style="zoom: 67%;"></p><p>注：</p><p>(1).反射光 <script type="math/tex">Lo(p,ω_r)</script>是由所有不同方向上的入射光线的辐照度 <script type="math/tex">Li(p,ω_i)</script>贡献得到的</p><p>(2).在相机位置不变的情况下，对于一个固定的表面点p，反射方向 <script type="math/tex">ω_r</script>是相对固定的</p><p><strong>渲染方程：</strong>在反射方程的基础上，增加了一个自发光项</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121621807.png" alt="image-20231212150332586" style="zoom:67%;"></p><p><strong>一个点光源和单个物体：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619946.png" alt="image-20231212150513332" style="zoom:50%;"></p><p><em>注：点光源对一个点来说自然只有一个方向有入射光</em></p><p><strong>多个点光源一个物体的情况：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619174.png" alt="image-20231212150612687" style="zoom:50%;"></p><p><em>注：对多个点光源产生的反射光求和即可</em></p><p><strong>面光源的情况：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619863.png" alt="image-20231212150741761" style="zoom:50%;"></p><p><em>注：对面光源所在的立体角的范围积分</em></p><p><strong>考虑场景中其他物体的反射造成的光线交互：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619374.png" alt="image-20231212151116699" style="zoom:50%;"></p><p><em>注：将其他物体当作面光源</em></p><p><strong>使用积分变换矩阵可将其写作：L=E+KL</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619557.png" alt="image-20231212151331626" style="zoom:50%;"></p><p>于是得到L:<br>                                                <img src="https://typoraimg.wangak.cc/2023/img/202312121619933.png" alt="image-20231212151431111" style="zoom: 67%;"></p><p>其中<script type="math/tex">I</script>为单位矩阵，再接着对<script type="math/tex">(I-K)^{-1}</script>使用广义二项式定理得到：<br>                                                <img src="https://typoraimg.wangak.cc/2023/img/202312121619858.png" alt="image-20231212151515813" style="zoom:67%;"></p><p>注：E为自发光项，E+KE为光栅化的结果，即直接光照。对于全局光照,<script type="math/tex">K^2E</script>，即一次弹射的间接照明，<script type="math/tex">K^3E</script>就是两次弹射的间接照明……</p><h3 id="4-蒙特卡洛路径追踪"><a href="#4-蒙特卡洛路径追踪" class="headerlink" title="4.蒙特卡洛路径追踪"></a>4.蒙特卡洛路径追踪</h3><h4 id="4-1-蒙特卡洛积分"><a href="#4-1-蒙特卡洛积分" class="headerlink" title="4.1 蒙特卡洛积分"></a>4.1 蒙特卡洛积分</h4><p><strong>蒙特卡洛积分：</strong>通过对函数进行随机采样来估计积分值的方法，定义如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619771.png" alt="image-20231212154356113" style="zoom:50%;"></p><p>蒙特卡洛的近似正是对积分值的一个无偏估计：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619445.png" alt="image-20231212154446422" style="zoom: 67%;"></p><p><em>注：蒙特卡洛是一种用来求困难积分的方法</em></p><h4 id="4-2-蒙特卡洛路径追踪"><a href="#4-2-蒙特卡洛路径追踪" class="headerlink" title="4.2 蒙特卡洛路径追踪"></a>4.2 蒙特卡洛路径追踪</h4><p>当不考虑自发光项时， 渲染方程：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619268.png" alt="image-20231212155049240" style="zoom:67%;"></p><p>使用蒙特卡洛积分后：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619695.png" alt="image-20231212155138653" style="zoom:67%;"></p><p><em>注：这里取了N个采样方向<script type="math/tex">\omega_i</script></em></p><p>只考虑直接光照时，伪代码如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619297.png" alt="image-20231212155412919" style="zoom:67%;"></p><p>加入间接光照后，使用递归的算法，伪代码如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121620829.png" alt="image-20231212155500528" style="zoom:67%;"></p><p><em>注：这时由于使用递归的算法，每次采样N，这会导致指数爆炸的问题</em></p><p>于是，修改N=1，每次只搜索一条路径，重复多次寻找到多条路径，将多条路径的结果求得平均：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619544.png" alt="image-20231212160230270" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619824.png" alt="image-20231212160403123" style="zoom: 67%;"></p><p><em>注：对经过像素的光线采样多次，而对反射的光线只采样一次</em></p><p>递归出口的设置：RR(俄罗斯轮盘赌)</p><p>设定一个概率P,即每次反射有概率P继续递归，递归的返回值为<script type="math/tex">L_0/P</script>，有（1-P)的概率停止</p><p>使用俄罗斯轮盘赌保证了所得到的Radiance的期望不变：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619719.png" alt="image-20231212160801671" style="zoom:67%;"></p><p>shade函数的伪代码如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619418.png" alt="image-20231212160916559" style="zoom:67%;"></p><p>这样的采样，路径追踪效率非常的低下:</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619630.png" alt="image-20231212161351867" style="zoom:67%;"></p><p>所以，为提高采样的效率，直接对光源进行采样，假设光源的面积为A，dA与<script type="math/tex">d\omega_i</script>的关系如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121620938.png" alt="image-20231212161554373" style="zoom:67%;"></p><p>于是渲染方程可改写为：<br>                                       <img src="https://typoraimg.wangak.cc/2023/img/202312121620560.png" alt="image-20231212161621658" style="zoom:67%;"></p><p>最终伪代码如下，分直接光照和间接光照两部分计算：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121620823.png" alt="image-20231212161812935" style="zoom:67%;"></p><p><em>注：在计算直接光照时，要判断光源与着色点之间是否有物体遮挡</em></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学几何</title>
      <link href="/posts/e4365916.html"/>
      <url>/posts/e4365916.html</url>
      
        <content type="html"><![CDATA[<h2 id="图形学几何"><a href="#图形学几何" class="headerlink" title="图形学几何"></a>图形学几何</h2><h3 id="1-几何的分类"><a href="#1-几何的分类" class="headerlink" title="1.几何的分类"></a>1.几何的分类</h3><p><strong>隐式几何:</strong> 无明确表示，如用函数表示曲面，如点（x, y, z) 满足一定函数f(x, y)关系就在一个曲面上。判断点的位置关系很方便，遍历绘制图形比较困难。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536222.png" alt="image-20231209124852632" style="zoom:67%;"></p><p><strong>显式几何:</strong> 有明确表示方法，直接给出，或通过参数映射给出几何信息，比如一般的点云或网格。遍历绘制图形比较方便， 但判断点的位置关系，如内外、是否在表面上比较困难。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535257.png" alt="image-20231209124540218" style="zoom: 67%;"></p><p><em>注：显式几何的点被直接给出或可通过映射关系得到。</em></p><p><strong>区别：</strong>区别隐式曲面与显示曲面的关键就在于是否可以直接表示出所有的点</p><p><em>注：隐式曲面难以采样曲面上的点，但是可以轻易判断点与曲面的关系，对于显式曲面来可以很轻易的采样到所有的点，但是给予你任意一点却很难判断它与曲面的关系。</em></p><h4 id="1-1-隐式几何的例子"><a href="#1-1-隐式几何的例子" class="headerlink" title="1.1 隐式几何的例子"></a>1.1 隐式几何的例子</h4><ul><li><strong>代数曲面</strong></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535303.png" alt="image-20231209125119599" style="zoom:67%;"></p><ul><li><strong>Constructive Solid Geometry(CSG):</strong>对各种不同的几何做布尔运算，如并，交，差</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535351.png" alt="image-20231209125221199" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535535.png" alt="image-20231209125238367" style="zoom:67%;"></p><ul><li><strong>距离函数:</strong>得到几何体的混合效果</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535344.png" alt="image-20231209125458243" style="zoom:67%;"></p><ul><li><strong>水平集：</strong>找出函数值为0的地方作为曲线</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535748.png" alt="image-20231209125824432" style="zoom:67%;"></p><ul><li><strong>分型几何：</strong>通过迭代、自相似性和尺度不变性来描述复杂的几何形状。</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535549.png" alt="image-20231209125952472" style="zoom: 50%;"></p><h4 id="1-2-显式几何的例子"><a href="#1-2-显式几何的例子" class="headerlink" title="1.2 显式几何的例子"></a>1.2 显式几何的例子</h4><ul><li><p><strong>点云：</strong>（x,y,z）的列表，用点代替面，可用于表示任何空间中的几何</p></li><li><p><strong>多边形面/三角形</strong>（使用的最广泛）</p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535443.png" alt="image-20231209130844203" style="zoom: 33%;"></p><p>用.obj格式的文件保存模型：顶点、法线、纹理坐标</p><p>如下，文件描述了一个立方体：8个顶点、6个法线（右图vn有8个是因为存在冗余）、纹理坐标（vt）</p><p>f:顶点/纹理坐标/法线,定义了哪三个顶点构成三角形</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535311.png" alt="image-20231209131213798" style="zoom:67%;"></p><h3 id="2-曲线"><a href="#2-曲线" class="headerlink" title="2.曲线"></a>2.曲线</h3><h4 id="2-1-贝塞尔曲线"><a href="#2-1-贝塞尔曲线" class="headerlink" title="2.1 贝塞尔曲线"></a>2.1 贝塞尔曲线</h4><p>贝塞尔曲线：用控制点去定义曲线</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535440.png" alt="image-20231209132251079" style="zoom: 33%;"></p><p><strong>de Casteljau Algorithm：</strong>画贝塞尔曲线</p><p>将问题转化为：t点该如何画</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535451.png" alt="image-20231209132632421" style="zoom:50%;"></p><p>由$b_0、b_1$得到$b_0^1$,$b_1、b_2$得到$b_1^1$,由$b_0^1$,$b_1^1$得到$b_0^2$,即为t点</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535890.png" alt="image-20231209132826273" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312100940592.png" alt="image-20231210094017798" style="zoom:50%;"></p><p>四个点的情况：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535312.png" alt="image-20231209133247407" style="zoom: 33%;"></p><p>给出n个控制点可以得到一个n阶的贝塞尔曲线：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535895.png" alt="image-20231209133842896" style="zoom: 50%;"></p><p><strong>伯恩斯坦多项式：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536748.png" alt="image-20231209134013528" style="zoom:50%;"></p><p><em>注：(n,i)是组合数</em></p><p>贝塞尔曲线的性质：</p><p>(1).必定经过起始与终止控制点<br>(2).必定经与起始与终止线段相切<br>(3).具有仿射变换性质，可以通过移动控制点移动整条曲线<br>(4).凸包性质，曲线一定不会超出所有控制点构成的多边形范围</p><p><em>注：将t从0到1进行迭代即可得到完整的贝塞尔曲线</em></p><p><strong>逐段定义贝塞尔曲线：</strong>更易使用控制点去控制曲线（常用四个控制点定义一段贝塞尔曲线）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536926.png" alt="image-20231209135657494" style="zoom:50%;"></p><h4 id="2-2-B样条"><a href="#2-2-B样条" class="headerlink" title="2.2 B样条"></a>2.2 B样条</h4><p>pass</p><h4 id="2-3-NURBS"><a href="#2-3-NURBS" class="headerlink" title="2.3 NURBS"></a>2.3 NURBS</h4><p>pass</p><h3 id="3-曲面"><a href="#3-曲面" class="headerlink" title="3.曲面"></a>3.曲面</h3><p><strong>贝塞尔曲面：</strong>需要有两个参数控制（时间u,v）,分别控制两次贝塞尔曲线的计算</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536201.png" alt="image-20231209142717655" style="zoom: 33%;"></p><h3 id="4-曲面细分"><a href="#4-曲面细分" class="headerlink" title="4.曲面细分"></a>4.曲面细分</h3><h4 id="4-1-Loop细分"><a href="#4-1-Loop细分" class="headerlink" title="4.1 Loop细分"></a>4.1 Loop细分</h4><p><strong>步骤：</strong></p><p><strong>1.生成更多三角形或顶点</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536280.png" alt="image-20231209144613202" style="zoom: 50%;"></p><p><strong>2.调整这些三角形的位置（顶点的位置）</strong></p><p>顶点分为两类，一类是新生成的顶点，一类是老的原来就有的顶点</p><p>对于新生成的顶点：其位置为周围顶点的权重之和</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536826.png" alt="image-20231209145401431" style="zoom:33%;"></p><p>对于旧的顶点：自身以及邻接顶点的权重和，权重的设置与旧的顶点的度有关</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536368.png" alt="image-20231209145809889" style="zoom:50%;"></p><h4 id="4-2-Catmull-Clark细分"><a href="#4-2-Catmull-Clark细分" class="headerlink" title="4.2 Catmull-Clark细分"></a>4.2 Catmull-Clark细分</h4><p>用于处理四边形面和三角面的混合的细分</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536889.png" alt="image-20231209150626897" style="zoom:50%;"></p><p><strong>Non-quad face:</strong>非四边形面</p><p><strong>奇异点:</strong>所有度不为4的顶点</p><p><strong>第一次细分所有面都会变成四边形，增加的奇异点个数为非四边形面的个数，之后再进行细分，奇异点个数不再增加</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536250.png" alt="image-20231209150826085" style="zoom:50%;"></p><p>点位置的调整：所有点分为：边上的点、面上的点、原来的点</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536387.png" alt="image-20231209151144071" style="zoom:50%;"></p><h3 id="5-曲面简化-Mesh-Smplication"><a href="#5-曲面简化-Mesh-Smplication" class="headerlink" title="5.曲面简化(Mesh Smplication)"></a>5.曲面简化(Mesh Smplication)</h3><p><strong>边坍缩：</strong>将一条边的两个顶点合成为一个顶点</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536794.png" alt="image-20231209152028718" style="zoom:50%;"></p><p>如何坍缩：使二次误差度量最小</p><p>二次误差度量：坍缩之后蓝色新顶点所在的位置与原来各个平面的垂直距离之和</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536192.png" alt="image-20231209152333304"></p><p><strong>步骤：</strong>（使用堆结构）</p><p><strong>1 为模型每条边赋值，其值为坍缩这条边之后，代替两个老顶点的新顶点所能得到的最小二次误差度量</strong><br> <strong>2 选取权值最小的边做坍缩，新顶点位置为原来计算得出使得二次误差最小的位置</strong><br> <strong>3 坍缩完之后，与之相连其他的边的位置会改动，更新这些边的权值</strong><br> <strong>4 重复上述步骤，直到到达终止条件</strong></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>games作业3</title>
      <link href="/posts/4514e5b7.html"/>
      <url>/posts/4514e5b7.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-透视投影变换"><a href="#1-透视投影变换" class="headerlink" title="1.透视投影变换"></a>1.透视投影变换</h4><p>投影接口的参数是张角fov，横纵比为aspect时，透视投影的变换矩阵如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090851755.png" alt="image-20231203092505302" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar)</span><br><span class="line">&#123;</span><br><span class="line">    Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();</span><br><span class="line">    projection(0, 0) = -(1 / (aspect_ratio * tan(eye_fov / 180.0 * MY_PI)));</span><br><span class="line">    projection(1, 1) = -(1 / (tan(eye_fov / 180.0 * MY_PI)));</span><br><span class="line">    projection(2, 2) = (zNear + zFar) / (zNear - zFar);</span><br><span class="line">    projection(2, 3) = (2 * zFar * zNear) / (zNear - zFar);</span><br><span class="line">    projection(3, 2) = 1;</span><br><span class="line">    projection(3, 3) = 0;</span><br><span class="line">    return projection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-判断点是否在三角形内"><a href="#2-判断点是否在三角形内" class="headerlink" title="2.判断点是否在三角形内"></a>2.判断点是否在三角形内</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static bool insideTriangle(int x, int y, const Vector4f* _v)&#123;</span><br><span class="line">    Eigen::Vector2f AB, BC, CA, AP, BP, CP, p;</span><br><span class="line">    float a, b, c;//用于保存叉乘的结果(是正还是负）</span><br><span class="line">    p &lt;&lt; x ,y;</span><br><span class="line">    AB = _v[1].head(2) - _v[0].head(2);</span><br><span class="line">    AP = p - _v[0].head(2);</span><br><span class="line">    BC = _v[2].head(2) - _v[1].head(2);</span><br><span class="line">    BP = p - _v[1].head(2);</span><br><span class="line">    CA = _v[0].head(2) - _v[2].head(2);</span><br><span class="line">    CP = p - _v[2].head(2);</span><br><span class="line">    //分别计算叉乘，x,y方向为0，故只计算z方向的结果</span><br><span class="line">    a = AB[0] * AP[1] - AB[1] * AP[0];</span><br><span class="line">    b = BC[0] * BP[1] - BC[1] * BP[0];</span><br><span class="line">    c = CA[0] * CP[1] - CA[1] * CP[0];</span><br><span class="line">    if (a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; c &gt; 0)</span><br><span class="line">        return true;</span><br><span class="line">    else if (a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; c &lt; 0)</span><br><span class="line">        return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-光栅化"><a href="#3-光栅化" class="headerlink" title="3.光栅化"></a>3.光栅化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//屏幕空间光栅化</span><br><span class="line">//view_pos：顶点在屏幕空间的坐标</span><br><span class="line">void rst::rasterizer::rasterize_triangle(const Triangle&amp; t, const std::array&lt;Eigen::Vector3f, 3&gt;&amp; view_pos)</span><br><span class="line">&#123;</span><br><span class="line">    auto v = t.toVector4();</span><br><span class="line">    float x_max = std::max(std::max(v[0].x(), v[1].x()), v[2].x());</span><br><span class="line">    float x_min = std::min(std::min(v[0].x(), v[1].x()), v[2].x());</span><br><span class="line">    float y_min = std::min(std::min(v[0].y(), v[1].y()), v[2].y());</span><br><span class="line">    float y_max = std::max(std::max(v[0].y(), v[1].y()), v[2].y());</span><br><span class="line">    for (int i = x_min; i &lt; x_max+1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = y_min; j &lt; y_max+1; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (insideTriangle(i, j, t.v))</span><br><span class="line">            &#123;</span><br><span class="line">                //计算当前像素在三角形内的重心坐标</span><br><span class="line">                auto [alpha, beta, gamma] = computeBarycentric2D(i, j, t.v);</span><br><span class="line"></span><br><span class="line">                //通过重心插值得到深度值z_interpolated</span><br><span class="line">                //w_reciprocal为透视修正系数</span><br><span class="line">                float w_reciprocal = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());</span><br><span class="line">                float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();</span><br><span class="line">                z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">                //Z-Buffer</span><br><span class="line">                if (depth_buf[get_index(i, j)] &gt; z_interpolated)</span><br><span class="line">                &#123;</span><br><span class="line">                    //利用重心坐标插值颜色、法线、纹理、shadingcoords（像素位置）</span><br><span class="line">                    auto interpolated_color = interpolate(alpha, beta, gamma, t.color[0], t.color[1], t.color[2], 1);</span><br><span class="line">                    auto interpolated_normal = interpolate(alpha, beta, gamma, t.normal[0], t.normal[1], t.normal[2], 1);</span><br><span class="line">                    auto interpolated_texcoords = interpolate(alpha, beta, gamma, t.tex_coords[0], t.tex_coords[1], t.tex_coords[2], 1);</span><br><span class="line">                    auto interpolated_shadingcoords = interpolate(alpha, beta, gamma, view_pos[0], view_pos[1], view_pos[2], 1);</span><br><span class="line">                    // 初始化 payload，用于传递给片段着色器</span><br><span class="line">                    fragment_shader_payload payload(interpolated_color, interpolated_normal.normalized(), interpolated_texcoords, texture ? &amp;*texture : nullptr);</span><br><span class="line">                    payload.view_pos = interpolated_shadingcoords;</span><br><span class="line"></span><br><span class="line">                    // 更新深度缓存</span><br><span class="line">                    depth_buf[get_index(i, j)] = z_interpolated;</span><br><span class="line"></span><br><span class="line">                    // 设置像素颜色，调用片段着色器</span><br><span class="line">                    Vector2i temp(i, j);</span><br><span class="line">                    set_pixel(temp, fragment_shader(payload));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Blinn-Phong反射模型"><a href="#4-Blinn-Phong反射模型" class="headerlink" title="4.Blinn-Phong反射模型"></a>4.Blinn-Phong反射模型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector3f phong_fragment_shader(const fragment_shader_payload&amp; payload)</span><br><span class="line">&#123;</span><br><span class="line">    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);//环境光反射率</span><br><span class="line">    Eigen::Vector3f kd = payload.color;//漫反射项系数</span><br><span class="line">    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);//高光项</span><br><span class="line">    //定义了两个光源</span><br><span class="line">    auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line">    auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;;//环境光</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;;//观察点的位置</span><br><span class="line">    float p = 150;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f color = payload.color;</span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f result_color = &#123;0, 0, 0&#125;;</span><br><span class="line">    for (auto&amp; light : lights)</span><br><span class="line">    &#123;</span><br><span class="line">        //计算光源到物体距离的平方r2</span><br><span class="line">        float r2 = (light.position - point).dot((light.position - point));//a.dot(a)=|a|^2</span><br><span class="line"></span><br><span class="line">        Eigen::Vector3f l = (light.position - point).normalized();//光线方向</span><br><span class="line">        Eigen::Vector3f v = (eye_pos - point).normalized();//观察方向</span><br><span class="line">        Eigen::Vector3f h = (l + v).normalized();//半程向量</span><br><span class="line"></span><br><span class="line">        //.cwiseProduct()用于向量对应位置的点相乘</span><br><span class="line">        //漫反射</span><br><span class="line">        Eigen::Vector3f diffuse = kd.cwiseProduct(light.intensity / r2) * std::max(0.0f, normal.normalized().dot(l));</span><br><span class="line">        //环境光</span><br><span class="line">        Eigen::Vector3f ambient = ka.cwiseProduct(amb_light_intensity);</span><br><span class="line">        //高光</span><br><span class="line">        Eigen::Vector3f specular = ks.cwiseProduct(light.intensity / r2) * pow(std::max(0.0f, normal.normalized().dot(h)), p);</span><br><span class="line"></span><br><span class="line">        result_color += ambient + diffuse + specular; </span><br><span class="line">    &#125;</span><br><span class="line">    return result_color * 255.f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-纹理映射"><a href="#5-纹理映射" class="headerlink" title="5.纹理映射"></a>5.纹理映射</h4><p>修改漫反射系数 <code>kd</code>即可，<code>kd</code> 是一个颜色向量，它表示了表面对漫反射光的反应程度，环境光和镜面反射成分通常是不受纹理映射直接影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector3f texture_fragment_shader(const fragment_shader_payload&amp; payload)</span><br><span class="line">&#123;</span><br><span class="line">    Eigen::Vector3f return_color = &#123;0, 0, 0&#125;;</span><br><span class="line">    if (payload.texture)</span><br><span class="line">    &#123;</span><br><span class="line">        //获取纹理坐标处的颜色</span><br><span class="line">        return_color = payload.texture-&gt;getColor(payload.tex_coords.x(), payload.tex_coords.y());</span><br><span class="line">    &#125;</span><br><span class="line">    Eigen::Vector3f texture_color;</span><br><span class="line">    texture_color &lt;&lt; return_color.x(), return_color.y(), return_color.z();</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);</span><br><span class="line">    Eigen::Vector3f kd = texture_color / 255.f;</span><br><span class="line">    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);</span><br><span class="line"></span><br><span class="line">    auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line">    auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;;</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;;</span><br><span class="line"></span><br><span class="line">    float p = 150;</span><br><span class="line">    Eigen::Vector3f color = texture_color;</span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f result_color = &#123;0, 0, 0&#125;;</span><br><span class="line"></span><br><span class="line">    for (auto&amp; light : lights)</span><br><span class="line">    &#123;</span><br><span class="line">        //计算光源到物体距离的平方r2</span><br><span class="line">        float r2 = (light.position - point).dot((light.position - point));//a.dot(a)=|a|^2</span><br><span class="line"></span><br><span class="line">        Eigen::Vector3f l = (light.position - point).normalized();//光线方向</span><br><span class="line">        Eigen::Vector3f v = (eye_pos - point).normalized();//观察方向</span><br><span class="line">        Eigen::Vector3f h = (l + v).normalized();//半程向量</span><br><span class="line"></span><br><span class="line">        //.cwiseProduct()用于向量对应位置的点相乘</span><br><span class="line">        //漫反射</span><br><span class="line">        Eigen::Vector3f diffuse = kd.cwiseProduct(light.intensity / r2) * std::max(0.0f, normal.normalized().dot(l));</span><br><span class="line">        //环境光</span><br><span class="line">        Eigen::Vector3f ambient = ka.cwiseProduct(amb_light_intensity);</span><br><span class="line">        //高光</span><br><span class="line">        Eigen::Vector3f specular = ks.cwiseProduct(light.intensity / r2) * pow(std::max(0.0f, normal.normalized().dot(h)), p);</span><br><span class="line"></span><br><span class="line">        result_color += ambient + diffuse + specular;</span><br><span class="line">    &#125;</span><br><span class="line">    return result_color * 255.f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-凹凸贴图"><a href="#6-凹凸贴图" class="headerlink" title="6.凹凸贴图"></a>6.凹凸贴图</h4><p>pass</p><h4 id="7-位移贴图"><a href="#7-位移贴图" class="headerlink" title="7.位移贴图"></a>7.位移贴图</h4><p>pass</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纹理映射</title>
      <link href="/posts/df375b66.html"/>
      <url>/posts/df375b66.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-纹理映射"><a href="#1-纹理映射" class="headerlink" title="1.纹理映射"></a>1.纹理映射</h3><p><strong>纹理映射：</strong>用于增强渲染的真实感和细节，允许在三维模型表面上贴附二维图像，以模拟材质、颜色、光照等细节。</p><p>纹理坐标的伪代码表示：<br><img src="https://typoraimg.wangak.cc/2023/img/202312090856218.png" alt="image-20231201125433593" style="zoom:50%;"></p><p>​        即通过对每个光栅化的屏幕坐标算出它的纹理坐标（u,v)(利用三角形顶点重心坐标插值),再利用这个u,v坐标去查询texture上的颜色，把这个颜色信息当作漫反射系数Kd。</p><h4 id="1-1-纹理过小的问题"><a href="#1-1-纹理过小的问题" class="headerlink" title="1.1 纹理过小的问题"></a>1.1 纹理过小的问题</h4><p><strong>问题：</strong>例如，有一张大小为100x100像素的纹理贴图，然后将这个贴图应用到一个500x500像素的屏幕上，这样多个像素点可能会映射到纹理贴图的相同区域，这使得纹理像素的信息被多个屏幕像素所共享。</p><p>​        如果只是简单地使用最近的纹理坐标点，即离目标点最近的(u, v)坐标，取样不足以准确反映屏幕上多个像素的信息，会导致渲染结果出现严重的走样问题。</p><p><strong>解决方法：</strong>使用更复杂的纹理过滤技术，如双线性插值，考虑周围像素的颜色信息，从而在渲染过程中更加平滑地处理纹理映射，减少走样的影响。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090856478.png" alt="image-20231201130205648" style="zoom:50%;"></p><p><em>注：Bicubic：双三次插值是利用三次方程来进行两次插值，但是计算开销过</em>大</p><h4 id="1-2-纹理过大的问题"><a href="#1-2-纹理过大的问题" class="headerlink" title="1.2 纹理过大的问题"></a>1.2 纹理过大的问题</h4><p><strong>现象：</strong><br><img src="https://typoraimg.wangak.cc/2023/img/202312090855369.png" alt="image-20231201130738219" style="zoom: 67%;"></p><p><strong>近处出现锯齿，远处出现摩尔纹</strong></p><p><strong>原因：</strong>根据近大远小，远处的一张完整的贴图可能在屏幕空间中仅仅是几个像素的大小，屏幕空间的一个像素对应了纹理贴图上的一片范围的点，而用一个点采样的结果代替纹理空间一片范围的颜色信息，必然会导致严重失真</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090855975.png" alt="image-20231201131153194" style="zoom:50%;"></p><p>如上图，一个屏幕空间的蓝色像素点离相机越远，对应在texture空间的范围也就越大</p><p><strong>解决方法：</strong>超采样（计算开销过大，不好）、MipMap</p><p><strong>纹理足迹（Texture Footprint）：</strong> 当纹理贴图映射到几何体表面时，每个像素在纹理空间中的足迹描述了纹理在几何体上的分布。</p><h4 id="1-3-MipMap"><a href="#1-3-MipMap" class="headerlink" title="1.3 MipMap"></a>1.3 MipMap</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202312090856328.png" alt="image-20231201132206220" style="zoom:50%;"></p><p>level 0代表的是原始texture，也是精度最高的纹理，随着level的提升，每提升一级将4个相邻像素点求均值合为一个像素点，因此越高的level也就代表了更大的footprint的区域查询。接下来要做的就是根据屏幕像素的footprint大小选定不同level的texture，再进行点查询即可，而这其实就相当于在原始texture上进行了区域查询。</p><p><em>注：通过MipMap将区域查询的问题，再次转换为点查询。使用MipMap仅将纹理map的大小扩大了1/3</em></p><p><strong>确定level：</strong>利用屏幕像素的相邻像素点估算footprint大小再确定level</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090856671.png" alt="image-20231201132617242" style="zoom: 67%;"></p><p>在屏幕空间中取当前像素点的右方和上方的两个相邻像素点(4个全取也可以)，分别查询得到这3个点对应在Texture space的坐标，计算出当前像素点与右方像素点和上方像素点在Texture space的距离，二者取最大值得到L,再通过L得到D。</p><p><strong>D算出的是一个连续值而不是整数的解决办法：</strong><br>（1）四舍五入取得最近的那个level D（纹理之间可能存在突变，不连续，故不好）</p><p>（2）利用D值在向下和向上取整的两个不同level进行三线性插值（即将level连续化），如下图。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090856929.png" alt="image-20231201133041710" style="zoom:50%;"></p><p>三线性插值的MipMap的效果：远处出现了过曝的现象<br><img src="https://typoraimg.wangak.cc/2023/img/202312090856355.png" alt="image-20231201133122841" style="zoom: 50%;"></p><p><em>出现该问题的原因是屏幕空间中的正方形的像素，在纹理空间中的形状可能是不规则的矩形</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090856608.png" alt="image-20231201133312851" style="zoom:50%;"></p><h4 id="1-4-各向异性过滤Mipmap"><a href="#1-4-各向异性过滤Mipmap" class="headerlink" title="1.4 各向异性过滤Mipmap"></a>1.4 各向异性过滤Mipmap</h4><p>各向异性的过滤：<img src="https://typoraimg.wangak.cc/2023/img/202312090856102.png" alt="image-20231201133512182" style="zoom:50%;"></p><p>将纹理分为水平方向上的level和竖直方向的level</p><h3 id="2-凹凸贴图"><a href="#2-凹凸贴图" class="headerlink" title="2.凹凸贴图"></a>2.凹凸贴图</h3><p><strong>凹凸贴图的原理:</strong>  利用凹凸贴图来改变原本光滑的平面的法线, 使原本光滑的平面产生凹凸感。</p><p> pass</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>games作业框架</title>
      <link href="/posts/b46ced9d.html"/>
      <url>/posts/b46ced9d.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Triangle类"><a href="#1-Triangle类" class="headerlink" title="1.Triangle类"></a>1.Triangle类</h3><h4 id="1-1-Triangle-hpp：类的声明"><a href="#1-1-Triangle-hpp：类的声明" class="headerlink" title="1.1 Triangle.hpp：类的声明"></a>1.1 Triangle.hpp：类的声明</h4><p><strong>定义了一个名为 <code>Triangle</code> 的类</strong></p><ul><li>三角形顶点的齐次坐标：（x,y,z,w)</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312090858570.png" alt="image-20231203094213284"></p><p><em>注：w=0时表示该点在无穷远处</em></p><ul><li><strong>ifndef</strong>：防止头文件的重复包含，确保在编译时，同一个头文件不会被多次包含，从而避免因重复包含导致的重定义报错。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TEST_H</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">...... #内容</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line">头文件结尾写上一行：</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><em>注：__TEST_H为标识符，通常是大写形式</em></p><ul><li><strong>void setNormals(const std::array<Vector3f, 3>&amp; normals)</Vector3f,></strong>：利用normals设置三角形顶点的法向量normal[3]<ul><li>std::array：标准库中的容器</li><li>Vector3f（元素类型）、3（数组大小）</li><li>const:保证normals不会被修改,&amp;:传递引用类型，避免对象的拷贝，提高执行效率</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#ifndef RASTERIZER_TRIANGLE_H</span><br><span class="line">#define RASTERIZER_TRIANGLE_H</span><br><span class="line"></span><br><span class="line">#include&lt;eigen3/Eigen/Eigen&gt;</span><br><span class="line">#include&quot;Texture.hpp&quot;//项目内的头文件用&quot;&quot;</span><br><span class="line">using namespace Eigen;</span><br><span class="line">class Triangle&#123;</span><br><span class="line">Vector4f v[3];//三角形三个顶点的其次坐标（x,y,z,w)</span><br><span class="line">Vector3f color[3];//顶点的颜色</span><br><span class="line">Vector2f tex_coords[3];//顶点的纹理坐标</span><br><span class="line">Vector3f normal[3];//顶点的法向量</span><br><span class="line"></span><br><span class="line">Texture* tex = nullptr;//指向其纹理信息的指针</span><br><span class="line"></span><br><span class="line">Triangle();//默认构造函数</span><br><span class="line"></span><br><span class="line">//获取三个顶点的坐标</span><br><span class="line">Eigen::Vector4f a() const &#123; return v[0]; &#125;</span><br><span class="line">Eigen::Vector4f b() const &#123; return v[1]; &#125;</span><br><span class="line">Eigen::Vector4f c() const &#123; return v[2]; &#125;</span><br><span class="line"></span><br><span class="line">//设置第i个顶点的坐标</span><br><span class="line">void setVertex(int ind,Vector4f ver);//将第i个顶点的坐标设置为ver</span><br><span class="line">//设置法向量</span><br><span class="line">void setNormal(int ind, Vector3f ver);</span><br><span class="line">//设置颜色</span><br><span class="line">void setColor(int ind, float r, float g, float b);</span><br><span class="line">//设置所有顶点的法向量</span><br><span class="line">void setNormals(const std::array&lt;Vector3f, 3&gt;&amp; normals);</span><br><span class="line">//设置所有顶点的颜色</span><br><span class="line">void setColors(const std::array&lt;Vector3f, 3&gt;&amp; colors);</span><br><span class="line">//设置第i个顶点的纹理</span><br><span class="line">void setTexCoord(int ind, Vector2f uv);</span><br><span class="line"></span><br><span class="line">std::array&lt;Vector4f, 3&gt; toVector4() const;//定义toVector4()函数，将齐次坐标（x,y,z,w)转换为（x/w,y/w,z/w,1)的形式</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">#endif // !RASTERIZER_TRIANGLE_H</span><br></pre></td></tr></table></figure><h4 id="1-2-Triangle-cpp：类的实现"><a href="#1-2-Triangle-cpp：类的实现" class="headerlink" title="1.2 Triangle.cpp：类的实现"></a>1.2 Triangle.cpp：类的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;Triangle.hpp&quot;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;array&gt;</span><br><span class="line"></span><br><span class="line">//构造函数的实现</span><br><span class="line">Triangle::Triangle() &#123;</span><br><span class="line">v[0] &lt;&lt; 0, 0, 0, 1;</span><br><span class="line">v[1] &lt;&lt; 0, 0, 0, 1;</span><br><span class="line">v[2] &lt;&lt; 0, 0, 0, 1;</span><br><span class="line">color[0] &lt;&lt; 0.0, 0.0, 0.0;</span><br><span class="line">color[1] &lt;&lt; 0.0, 0.0, 0.0;</span><br><span class="line">color[2] &lt;&lt; 0.0, 0.0, 0.0;</span><br><span class="line">tex_coords[0] &lt;&lt; 0.0, 0.0;</span><br><span class="line">tex_coords[1] &lt;&lt; 0.0, 0.0;</span><br><span class="line">tex_coords[2] &lt;&lt; 0.0, 0.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置指定索引的纹理</span><br><span class="line">void Triangle::setTexCoord(int ind, Vector2f uv) &#123;</span><br><span class="line">tex_coords[ind] = uv;</span><br><span class="line">&#125;</span><br><span class="line">//设置顶点</span><br><span class="line">void Triangle::setVertex(int ind, Vector4f ver) &#123;</span><br><span class="line">v[ind] = ver;</span><br><span class="line">&#125;</span><br><span class="line">//设置法线</span><br><span class="line">void Triangle::setNormal(int ind, Vector3f n) &#123;</span><br><span class="line">normal[ind] = n;</span><br><span class="line">&#125;</span><br><span class="line">//设置颜色</span><br><span class="line">void Triangle::setColor(int ind, float r, float g, float b) &#123;</span><br><span class="line">if ((r &lt; 0.0) || (r &gt; 255.) ||</span><br><span class="line">(g &lt; 0.0) || (g &gt; 255.) ||</span><br><span class="line">(b &lt; 0.0) || (b &gt; 255.)) &#123;</span><br><span class="line">fprintf(stderr, &quot;ERROR! Invalid color values&quot;);</span><br><span class="line">fflush(stderr);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">color[ind] = Vector3f((float)r / 255., (float)g / 255., (float)b / 255.);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//将顶点坐标转换为标准的四维齐次坐标</span><br><span class="line">std::array&lt;Vector4f, 3&gt; Triangle::toVector4() const</span><br><span class="line">&#123;</span><br><span class="line">std::array&lt;Vector4f, 3&gt; res;</span><br><span class="line">std::transform(std::begin(v), std::end(v), res.begin(), [](auto&amp; vec) &#123; return Vector4f(vec.x(), vec.y(), vec.z(), 1.f); &#125;);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">void Triangle::setNormals(const std::array&lt;Vector3f, 3&gt;&amp; normals)</span><br><span class="line">&#123;</span><br><span class="line">// 设置法向量</span><br><span class="line">normal[0] = normals[0];</span><br><span class="line">normal[1] = normals[1];</span><br><span class="line">normal[2] = normals[2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Triangle::setColors(const std::array&lt;Vector3f, 3&gt;&amp; colors)</span><br><span class="line">&#123;</span><br><span class="line">// 设置颜色</span><br><span class="line">auto first_color = colors[0];</span><br><span class="line">setColor(0, colors[0][0], colors[0][1], colors[0][2]);</span><br><span class="line">setColor(1, colors[1][0], colors[1][1], colors[1][2]);</span><br><span class="line">setColor(2, colors[2][0], colors[2][1], colors[2][2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>局部光照模型及着色方法</title>
      <link href="/posts/af9d8c8.html"/>
      <url>/posts/af9d8c8.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-局部光照模型"><a href="#1-局部光照模型" class="headerlink" title="1.局部光照模型"></a>1.局部光照模型</h3><p><strong>光线的简单分类：</strong></p><ul><li><p><strong>镜面反射</strong></p></li><li><p><strong>漫反射</strong></p></li></ul><ul><li><strong>环境光</strong></li></ul><h4 id="1-1-泛光模型"><a href="#1-1-泛光模型" class="headerlink" title="1.1 泛光模型"></a>1.1 泛光模型</h4><p>泛光模型即<strong>只考虑环境光</strong>，这是最简单的<strong>经验</strong>模型，只会去考虑环境光的影响，并且不会去精确的描述，而只是用一个简单的式子表示：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952046.png" alt="image-20231130091038413" style="zoom:50%;"></p><script type="math/tex; mode=display">注：K_a表示物体表面对环境光的反射率，I_a代表入射环境光的亮度，I_{env}存储结果，即人眼所能看到从物体表面反射的环境光的亮度。</script><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952312.png" alt="image-20231130091806017" style="zoom: 67%;"></p><h4 id="1-2-Lambert漫反射模型"><a href="#1-2-Lambert漫反射模型" class="headerlink" title="1.2 Lambert漫反射模型"></a>1.2 Lambert漫反射模型</h4><ul><li><p>在泛光模型的基础之上增加了<strong>漫反射项</strong></p><ul><li>每个不同方向反射的光的强度相等</li><li>产生漫反射的原因是物体表面的粗糙</li></ul></li><li><p><strong>漫反射光照强度与光线照射方向和表面法线之间的夹角余弦成正比</strong></p><p><em>注：漫反射与观察方向无关，光线照射方向和表面法线之间的夹角反应了对于光照的接受率</em></p></li><li><p><strong>公式表示：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952975.png" alt="image-20231130091906700" style="zoom:50%;"></p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952973.png" alt="image-20231130091824267"></p><h4 id="1-3-Blinn-Phong反射模型"><a href="#1-3-Blinn-Phong反射模型" class="headerlink" title="1.3 Blinn-Phong反射模型"></a>1.3 Blinn-Phong反射模型</h4><p>Blinn-Phong反射模型是Phong光照模型的一种改进，在模拟高光方面表现更为自然。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952864.png" alt="image-20231130092346846" style="zoom: 50%;"></p><p>注：$k_s$为镜面反射系数， I为入射光强， r为光源到入射点距离,指数p加速衰减(用于减小可以看到高光的角度）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952037.png" alt="image-20231130092850361" style="zoom:50%;"></p><p>注：使用半程向量简化了反射向量与人眼观察夹角的计算（Phong光照模型，即下图中R与v的夹角的计算）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952906.png" alt="image-20231130092457821" style="zoom:50%;"></p><p><strong>整体计算公式：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952426.png" alt="image-20231130092944573" style="zoom:50%;"></p><p><em>注：L=泛光（环境光）+漫反射项+高光</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953544.png" alt="image-20231130093045061" style="zoom:50%;"></p><h3 id="2-着色方法-频率"><a href="#2-着色方法-频率" class="headerlink" title="2.着色方法(频率)"></a>2.着色方法(频率)</h3><h4 id="2-1-Flat-Shading（面着色）"><a href="#2-1-Flat-Shading（面着色）" class="headerlink" title="2.1 Flat Shading（面着色）"></a>2.1 Flat Shading（面着色）</h4><p>模型数据大多以很多个三角面进行存储，因此也就记录了每个面的法线向量，利用每个面的法线向量进行一次Blinn-Phong反射光照模型的计算，将该颜色赋予整个面。</p><p>效果如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953328.png" alt="image-20231130093503703" style="zoom:50%;"></p><h4 id="2-2-Gouraud-Shading（顶点着色）"><a href="#2-2-Gouraud-Shading（顶点着色）" class="headerlink" title="2.2 Gouraud Shading（顶点着色）"></a>2.2 Gouraud Shading（顶点着色）</h4><p>Gouraud Shading会对每个三角形的顶点进行一次着色</p><p><strong>点法线：将所有共享这个点的面的法线向量加起来求均值，最后再标准化</strong></p><p><strong>三角形内部的每一个点：</strong>利用<strong>重心坐标来插值</strong></p><p>重心坐标：给定的三角形ABC和其中的一个点P，其重心坐标$(w_a,w_b,w_c)$满足以下条件：</p><ul><li>$w_a+w_b+w_c=1$</li><li>$P=w_a⋅A+w_b⋅B+w_c⋅C$</li></ul><p>重心坐标可以通过面积的比值求出：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312010916393.png" alt="image-20231130134307989" style="zoom:50%;"></p><p>注：三角形的重心为（1/3，1/3，1/3），其将三角形分为了面积相等的三份。</p><p>重心坐标一般的表达式：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312010916494.png" alt="image-20231130134715691" style="zoom:50%;"></p><p>重心插值公式如下:</p><p>$P_{interpolated}=w_a⋅P_A+w_b⋅P_B+w_c⋅P_C$</p><p><em>注：$P_A、P_B、P_C$分别是三个顶点上的属性值</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953992.png" alt="image-20231130094402265" style="zoom:50%;"></p><p><em>注：重心坐标经过投影之后可能会改变，在三维空间中插值一些属性时，要计算三维空间中重心的坐标。</em></p><h4 id="2-3-Phong-Shading-像素着色"><a href="#2-3-Phong-Shading-像素着色" class="headerlink" title="2.3 Phong Shading(像素着色)"></a>2.3 Phong Shading(像素着色)</h4><p>要对每个点都进行光照计算，三角形内部的每一个点的法线向量如插值颜色一样得到：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953798.png" alt="image-20231130094638524" style="zoom:50%;"></p><p><em>注：$n_0,n_1,n_2$分别是三角形三个顶点的法线向量,α,β,γ为三角形面内点的重心坐标</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953475.png" alt="image-20231130094743068" style="zoom:50%;"></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SG-Former</title>
      <link href="/posts/c53f4cce.html"/>
      <url>/posts/c53f4cce.html</url>
      
        <content type="html"><![CDATA[<h2 id="SG-Former"><a href="#SG-Former" class="headerlink" title="SG-Former"></a>SG-Former</h2><p><strong>论文：《SG-Former: Self-guided Transformer with Evolving Token Reallocation》（ICCV 2023)</strong></p><h4 id="1-探究动机"><a href="#1-探究动机" class="headerlink" title="1.探究动机"></a>1.探究动机</h4><p>ViT使用全局的自注意力机制，但带来了较高的计算成本。</p><p>Swin Transformer设计了窗口注意力，而牺牲了建模全局信息的能力。</p><p><strong>提出SG-Fomer（Self-guided Transformer):</strong>利用<strong>显著性</strong>图，根据每个区域的显著性来分配token，将更多的token分配给显著性区域以获取细粒度的注意力，而将更少的token分配给次要的区域以换取计算效率和全局的感受野。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145871.png" alt="image-20231130202913356"></p><p><em>注：在显著性区域（狗脸）分配更多的token</em></p><h4 id="2-网络设计"><a href="#2-网络设计" class="headerlink" title="2.网络设计"></a>2.网络设计</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145135.png" alt="image-20231130203138889" style="zoom:80%;"></p><p><strong>Hybrid-Scale Transformer blocks:</strong>提取多尺度的信息并为Self-Guided Transformer Block提供显著性图</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145630.png" alt="image-20231129153810548" style="zoom: 67%;"></p><p>把H个注意力头分成h组，在第j组的注意力头有一个尺度因子<script type="math/tex">S_j</script>,即对于K,V的每<script type="math/tex">S_j*S_j</script>个token合并为一个token，把K、V的窗口大小设为M,Q的窗口大小设为<script type="math/tex">S_jM*S_jM</script>(使Q中token与K、V中的token对齐）</p><p><em>注：</em></p><p><em>（1）K,V的窗口大小在所有组中都是固定的，均为M,而Q的窗口大小还和$S_j$有关</em>，每一组的输出均为N*M,N为token序列的长度</p><p><em>（2）token的合并是通过卷积实现的</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145504.png" alt="image-20231130205331048" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145396.png" alt="image-20231130205438728" style="zoom: 67%;"></p><p>Token 的重要性被视为所有 Token 和当前 Token 的乘积之和：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145068.png" alt="image-20231129153230302" style="zoom: 67%;"></p><p><em>注：S是对所有的$S_i$求和的结果，即为最终的注意力图，用于混合尺度引导</em></p><p><strong>Self-Guided Transformer Block：</strong></p><p>为了降低计算成本，同时保持计算后特征映射的大小不变，固定Q的大小，使用IAM（importance guided aggregation module)对K和V的token进行聚合</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145350.png" alt="image-20231130211007377" style="zoom: 80%;"></p><p><em>注：S为显著性图，r为合并比率</em></p><p>将S平均分为n个子区域S1，S2,……Sn,每个区域设置不同的合并比率r1,r2,……，rn,子区域越重要，合并比率越小，输入特征X按X1,X2,……,Xn分组，每组有不同的合并比率</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145872.png" alt="image-20231130212526902" style="zoom: 67%;"></p><p><em>注：token的合并通过全连接层实现</em></p><h4 id="3-实验"><a href="#3-实验" class="headerlink" title="3.实验"></a>3.实验</h4><p>与其他结构在语义分割任务中的对比：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312010859765.png" alt="image-20231130215028355" style="zoom: 50%;"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transformation</title>
      <link href="/posts/ac17f787.html"/>
      <url>/posts/ac17f787.html</url>
      
        <content type="html"><![CDATA[<h2 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h2><h3 id="1-2D变换"><a href="#1-2D变换" class="headerlink" title="1. 2D变换"></a>1. 2D变换</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207409.png" alt="image-20231126190707151" style="zoom:50%;"></p><h4 id="1-1-缩放-scaling"><a href="#1-1-缩放-scaling" class="headerlink" title="1.1 缩放(scaling)"></a>1.1 缩放(scaling)</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207653.png" alt="image-20231126190747793" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207767.png" alt="image-20231126190853847" style="zoom: 50%;"></p><h4 id="1-2-镜像变换"><a href="#1-2-镜像变换" class="headerlink" title="1.2 镜像变换"></a>1.2 镜像变换</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207557.png" alt="image-20231126191121990" style="zoom:50%;"></p><h4 id="1-3-切变（Shear-Matrix）"><a href="#1-3-切变（Shear-Matrix）" class="headerlink" title="1.3 切变（Shear Matrix）"></a>1.3 切变（Shear Matrix）</h4><p>如下图，变换过程中y坐标始终不变</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207966.png" alt="image-20231126192230389" style="zoom:50%;"></p><h4 id="1-4-旋转-Rotate"><a href="#1-4-旋转-Rotate" class="headerlink" title="1.4 旋转(Rotate)"></a>1.4 旋转(Rotate)</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208542.png" alt="image-20231126192327264" style="zoom:50%;"></p><h4 id="1-5-齐次坐标"><a href="#1-5-齐次坐标" class="headerlink" title="1.5 齐次坐标"></a>1.5 齐次坐标</h4><p><strong>平移：</strong><br><img src="https://typoraimg.wangak.cc/2023/img/202311271208287.png" alt="image-20231126193641073" style="zoom:50%;"></p><p><strong>为了表示平移操作引入了第三维坐标：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208639.png" alt="image-20231126193653818" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208486.png" alt="image-20231126193714639" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208369.png" alt="image-20231126193731535" style="zoom:50%;"></p><p><em>注：<strong>point+point</strong>的结果为两个点的中点</em></p><p><strong>仿射变换的两种形式：</strong><br><img src="https://typoraimg.wangak.cc/2023/img/202311271208436.png" alt="image-20231126194003729" style="zoom:50%;"></p><p><em>注：齐次坐标变换矩阵中的a,b,c,d与线性变换中的变换矩阵是对应的</em></p><h4 id="1-6-逆变换"><a href="#1-6-逆变换" class="headerlink" title="1.6 逆变换"></a>1.6 逆变换</h4><p><strong>逆变换：</strong>变换矩阵为原变换的逆矩阵</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208337.png" alt="image-20231126194715152" style="zoom:50%;"></p><h3 id="2-3D变换"><a href="#2-3D变换" class="headerlink" title="2. 3D变换"></a>2. 3D变换</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208498.png" alt="image-20231126195736702" style="zoom:50%;"></p><h4 id="2-1-仿射变换"><a href="#2-1-仿射变换" class="headerlink" title="2.1 仿射变换"></a>2.1 仿射变换</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208171.png" alt="image-20231126195828157" style="zoom:50%;"></p><p><em>注：该表示方法是先做线性变换，然后再平移</em></p><h4 id="2-2-旋转"><a href="#2-2-旋转" class="headerlink" title="2.2 旋转"></a>2.2 旋转</h4><ul><li><strong>在轴上</strong></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033304.png" alt="image-20231127122527405" style="zoom:50%;"></p><ul><li><p><strong>一般的旋转</strong>：可以将任意的旋转分为在三个轴上的旋转，其中在三个轴上的旋转角度称为欧拉角</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033703.png" alt="image-20231127122758750" style="zoom:50%;"></p></li></ul><p>​    <strong>罗德里格斯公式(Rodrigues’ Rotation Formula):</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033828.png" alt="image-20231127123545604"></p><p>注：四元数的应用</p><h3 id="2-3-视图-相机变换（View-Camera-Transformation）"><a href="#2-3-视图-相机变换（View-Camera-Transformation）" class="headerlink" title="2.3 视图/相机变换（View / Camera Transformation）"></a>2.3 视图/相机变换（View / Camera Transformation）</h3><p><strong>相机的参数：</strong>初始位置、观看角度（向量）、竖直角度（向量）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033677.png" alt="image-20231127125538822"></p><p><strong>标准化：</strong>观看位置为原点、观看角度为-Z、向上方向为Y</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033142.png" alt="image-20231127125835234" style="zoom:50%;"></p><p>变换的方法：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033832.png" alt="image-20231127125907343" style="zoom:50%;"></p><p>由于正向变换比较复杂，考虑<strong>通过其逆矩阵来实现</strong>：R为旋转变换矩阵、T为平移变换矩阵、M为整个过程的变换矩阵</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033482.png" alt="image-20231127130030303" style="zoom:50%;"></p><p><em>注：旋转矩阵为正交矩阵，逆矩阵即是其转置</em></p><p><em>注：视图变换变换的是相机，其他的物体随着相机一起变换</em></p><h3 id="3-投影变换"><a href="#3-投影变换" class="headerlink" title="3 投影变换"></a>3 投影变换</h3><h4 id="3-1-正交投影变换"><a href="#3-1-正交投影变换" class="headerlink" title="3.1 正交投影变换"></a>3.1 正交投影变换</h4><p><strong>正交投影变换：</strong>平移+压缩</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033623.png" alt="image-20231127131958838" style="zoom:50%;"></p><p><em>注：l,r为x轴上的距离，b,t为y轴上的距离</em></p><h4 id="3-2-透视投影变换"><a href="#3-2-透视投影变换" class="headerlink" title="3.2 透视投影变换"></a>3.2 透视投影变换</h4><p>透视投影类似人眼所看东西的方式，遵循近大远小,平行线也会变得不平行</p><p><strong>用正交变换表示透视投影变换：</strong><script type="math/tex">M_{ortho}M_{persp->ortho}</script></p><p>将透视变换压成投影<script type="math/tex">M_{persp->ortho}</script></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033023.png" alt="image-20231127212210693" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033371.png" alt="image-20231127212333846" style="zoom:50%;"></p><p><em>注：其中n是近平面，f是远平面，在公式推导的过程中是<strong>默认n、f</strong>均为负数</em></p><p>因而透视投影矩阵为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311301248538.png" alt="image-20231130123159569" style="zoom: 67%;"></p><p>又当投影接口的参数是张角fov，横纵比为aspect，近平面到原点的距离为near,远平面到原点的距离为far</p><p>由于长方体视窗体是轴对称，故有l=−r,b=−t,从原点看向−z方向看去，有n=−near,f=−far<br>                                                                    <img src="https://typoraimg.wangak.cc/2023/img/202311301247698.png" alt="image-20231130124140613" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311301248703.png" alt="image-20231130124220304" style="zoom:67%;"></p><p>所以透视投影矩阵可化简为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311301248469.png" alt="image-20231130124301880" style="zoom: 67%;"></p><h3 id="4-视口变换"><a href="#4-视口变换" class="headerlink" title="4.视口变换"></a>4.视口变换</h3><p><strong>视口变换</strong>用于将标准平面映射到屏幕的分辨率范围之内（缩放+平移），变换矩阵如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033944.png" alt="image-20231128150643474" style="zoom:50%;"></p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>将虚拟世界中以(x,y,z)为坐标的物体变换到以一个个像素位置(x,y) 来表示的屏幕坐标系之中(2维)的步骤：</p><ul><li><strong>模型变换(modeling tranformation)：</strong>这一步的目的是将虚拟世界中或者更具体点，游戏场景中的物体调整至他们应该在的位置</li><li><strong>摄像机变换(camera tranformation)：</strong>在游戏中我们真正在乎的是摄像机(或者说眼睛)所看到的东西，也就是需要得到物体与摄像机的相对位置</li><li><strong>投影变换(projection tranformation)：</strong>根据摄像机变换得到了所有可视范围内的物体对于摄像机的相对位置坐标(x,y,z)之后，便是根据是平行投影还是透视投影，将三维空间投影至标准二维平面([-1,1]^2)之上 （tips：这里的z并没有丢掉，为了之后的遮挡关系检测）</li><li><strong>视口变换(viewport transformation)：</strong>将处于标准平面映射到屏幕分辨率范围之内，即[-1,1]^2→[0,width]*[0,height], 其中width和height指屏幕分辨率大小</li></ul>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光栅化及深度测试</title>
      <link href="/posts/499d8707.html"/>
      <url>/posts/499d8707.html</url>
      
        <content type="html"><![CDATA[<h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p><strong>光栅化（Rasterization）</strong>是图形学中一种常用的渲染技术，用于将三维场景中的图形对象转换为二维像素表示，以便在计算机屏幕上显示，即将图形对象（通常是三角形）映射到屏幕上的像素格子，并确定每个像素的颜色值。</p><p><strong>选择三角形作为渲染的基本图元的原因：</strong></p><ul><li>因为三角形是最简单的几何形状之一，任意三个点可以确定一个平面上的三角形</li><li><p>任意多边形都可以被分解为若干个三角形，这种分解使得处理复杂的多边形图形变得更加容易。</p></li><li><p>三角形在仿射变换下保持平面性，对三角形的变换相对简单，而不会引入复杂的扭曲。</p></li></ul><h3 id="1-直线光栅化算法"><a href="#1-直线光栅化算法" class="headerlink" title="1.直线光栅化算法"></a>1.直线光栅化算法</h3><h4 id="1-1-DDA数值微分算法"><a href="#1-1-DDA数值微分算法" class="headerlink" title="1.1 DDA数值微分算法"></a>1.1 DDA数值微分算法</h4><p>通过两点确定一条直线的斜率（k)，若|k|&lt;=1,选择x方向作为步长（选择变换快的方向），若|k|&gt;1,选择y方向作为步长。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033642.png" alt="image-20231128195221236" style="zoom:50%;"></p><p>注：在所选的步长方向上，从起始点 <code>(x0, y0)</code> 开始，计算每个下一个点的坐标 <code>(xi, yi)</code>。对于x方向的步长，使用 <code>xi+1 = xi + 1</code>；对于 y 方向的步长，使用 <code>yi+1 = yi + m</code>。(y的结果要四舍五入)</p><h4 id="1-2-Bresenham直线绘制算法"><a href="#1-2-Bresenham直线绘制算法" class="headerlink" title="1.2 Bresenham直线绘制算法"></a>1.2 Bresenham直线绘制算法</h4><p>Bresenham直线绘制算法通过在每个步骤中选择最接近理想路径上的点来逐步绘制线段，从而避免了使用浮点数运算，提高了计算效率。</p><p><strong>pass</strong></p><h3 id="2-三角形光栅化算法"><a href="#2-三角形光栅化算法" class="headerlink" title="2.三角形光栅化算法"></a>2.三角形光栅化算法</h3><p><strong>每一个像素进行采样:</strong>判断像素中心是否在三角形内部</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034020.png" alt="image-20231128200407428" style="zoom: 50%;"></p><p><strong>判断一个点在三角形内部的方法：</strong>利用叉乘的性质</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034363.png" alt="image-20231128200536862" style="zoom:50%;"></p><p>​        分别计算 $P_0P_1×P_0Q、 P_1P_2×P_1Q、P_2P_0×P_2Q$，如果三者同号则代表点P在三条线段的同一边，那么必然处于三角形内部，如果不同号则代表该点一定在三角形外部<br><strong>利用bouding box减少点的计算：</strong>三角形通常只占屏幕很小的一部分，只对该bounding box内的点进行采样测试</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034364.png" alt="image-20231128201223186" style="zoom:50%;"></p><p><strong>锯齿现象：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034128.png" alt="image-20231128201443202" style="zoom:50%;"></p><p>产生的原因：只用了有限的采样点去逼近连续的三角形</p><h3 id="3-解决走样的方法"><a href="#3-解决走样的方法" class="headerlink" title="3.解决走样的方法"></a>3.解决走样的方法</h3><h4 id="3-1超采样反走样-Super-Sampling-AA"><a href="#3-1超采样反走样-Super-Sampling-AA" class="headerlink" title="3.1超采样反走样(Super Sampling AA)"></a>3.1超采样反走样(Super Sampling AA)</h4><p>用更多的采样点去逼近连续的三角形</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034872.png" alt="image-20231128201847832" style="zoom:50%;"></p><p>对着四个采样点分别计算颜色值，将这四个点的采样点的颜色值取均值，如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034448.png" alt="image-20231128202001340" style="zoom:50%;"></p><p><em>注：超采样的缺点是对计算资源的更高要求</em></p><h4 id="3-2多采样反走样-Multi-Sampling-AA"><a href="#3-2多采样反走样-Multi-Sampling-AA" class="headerlink" title="3.2多采样反走样(Multi-Sampling AA)"></a>3.2多采样反走样(Multi-Sampling AA)</h4><p>MSAA是对SSAA的改进，不再为每个采样点都计算颜色值，而只计算像素中采样点被覆盖的比例，而后在中心点处计算颜色值。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034470.png" alt="image-20231128202605057" style="zoom:50%;"></p><h4 id="3-3-先模糊（滤波），再采样"><a href="#3-3-先模糊（滤波），再采样" class="headerlink" title="3.3 先模糊（滤波），再采样"></a>3.3 先模糊（滤波），再采样</h4><p>通过在采样前进行滤波，可以去除信号中的高频分量，从而在采样时避免混叠效应，减少走样。</p><p>在频域中限制高频成分的影响，有助于避免走样问题</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034171.png" alt="image-20231128203246227" style="zoom:50%;"></p><h3 id="4-深度测试"><a href="#4-深度测试" class="headerlink" title="4.深度测试"></a>4.深度测试</h3><p>深度测试是指在渲染图像时确定像素的深度值（或称为Z值）以确定哪些像素应该显示在屏幕上。</p><p><em>注：深度测试是一种解决图形学中遮挡关系的技术，确保在屏幕上只显示最前面的像素，而将被遮挡的像素隐藏起来，从而呈现出正确的三维场景。</em></p><h4 id="Z-Buffer（深度缓冲）算法"><a href="#Z-Buffer（深度缓冲）算法" class="headerlink" title="Z-Buffer（深度缓冲）算法"></a>Z-Buffer（深度缓冲）算法</h4><p><strong>算法的基本思想：</strong>每个采样点（像素）存储当前的最小深度值，假设深度值（z值）始终为正值。如果一个像素的深度值较小，表示它离观察者更近；反之，如果深度值较大，则表示它离观察者更远。<strong>帧缓冲用于存储屏幕上每个像素的颜色信息，深度缓冲专门用于存储每个像素的深度值</strong>，如果当前像素的深度值较小（即更接近观察者），则更新深度缓冲和帧缓冲中的值；否则，将其视为被遮挡，不进行更新。</p><p>伪代码如下:</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312011217448.png" alt="image-20231130085326419" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312011217183.png" alt="image-20231130085351796" style="zoom:50%;"></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPM</title>
      <link href="/posts/236d2982.html"/>
      <url>/posts/236d2982.html</url>
      
        <content type="html"><![CDATA[<h2 id="SPM"><a href="#SPM" class="headerlink" title="SPM"></a>SPM</h2><p><strong>论文：《Learning with Explicit Shape Priors for Medical Image Segmentation》（TMI 2023)</strong></p><p><strong>探索形状先验(shape priors)对分割性能的影响</strong></p><p>基于unet的医学图像分割模型的局限性:cnn的感受野有限，无法利用器官或组织之间的远距离和全局空间关系，无法实现精细的形状表示。（注意力模块扩大模型的感受野，隐式地捕获形状信息）</p><p><em>注：通过设计特定的损失函数，而不是Dice损失或交叉熵损失，将明确的形状先验集成到分割框架中。但这些损失函数是特定于任务的，不能很容易地扩展到不同的数据集</em></p><p>提出了显式形状模型（SPM），以形状先验作为额外的输入来增强模型的形状表示能力。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436431.png" alt="image-20231120152537182" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436712.png" alt="image-20231120163304452" style="zoom:67%;"></p><p>其中F代表模型的前向传播，S代表构造图像I和标签L之间映射的形状先验。</p><p><strong>注意力图：</strong>生成的形状先验在推断阶段充当了注意力图，用于定位感兴趣的区域，并抑制背景区域</p><p><strong>SPM模块：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436670.png" alt="image-20231120153357914" style="zoom:67%;"></p><p>SPM模块由the self-update block (SUB)、cross-update block (CUB)</p><p><strong>the self-update block (SUB)：</strong>以形状先验作为输入，用于生成全局形状先验</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436041.png" alt="image-20231120154358605" style="zoom:50%;"></p><p>SUB的结构缺乏对局部视觉结构的建模，全局形状先验不具有精确的形状和轮廓信息。</p><p><strong>cross-update block (CUB)：</strong>建模局部形状先验</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436616.png" alt="image-20231120160130787" style="zoom: 50%;"></p><p><script type="math/tex">C_{map}</script>:一个C × N矩阵,用于评估C通道特征映射Fo和N通道形状先验之间的关系。</p><p>下采样<script type="math/tex">F_e</script>生成局部形状先验<script type="math/tex">S_L</script>:</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436429.png" alt="image-20231120160808202" style="zoom:50%;"></p><p>增强的形状先验融合了SUB生成全局形状先验及CUB生成的局部形状先验</p><h3 id="实验部分："><a href="#实验部分：" class="headerlink" title="实验部分："></a>实验部分：</h3><p><strong>与其他方法的对比：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436022.png" alt="image-20231120202559717" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436614.png" alt="image-20231120202723390" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436085.png" alt="image-20231120202732327" style="zoom: 67%;"></p><p><strong>消融实验：</strong>在BRATS 2020（脑肿瘤）、<strong>VerSe2019</strong>(脊柱)、ACDC（心脏）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436828.png" alt="image-20231120201045294" style="zoom: 80%;"></p><p>表明SPM有增强模型对相对规则的形状区域的表示能力</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MedNeXt</title>
      <link href="/posts/9ce6c01f.html"/>
      <url>/posts/9ce6c01f.html</url>
      
        <content type="html"><![CDATA[<h2 id="MedNeXt-Transformer-driven-Scaling-of-ConvNets-for-Medical-Image-Segmentation"><a href="#MedNeXt-Transformer-driven-Scaling-of-ConvNets-for-Medical-Image-Segmentation" class="headerlink" title="MedNeXt: Transformer-driven Scaling of ConvNets for Medical Image Segmentation"></a>MedNeXt: Transformer-driven Scaling of ConvNets for Medical Image Segmentation</h2><p><strong>论文：《MedNeXt: Transformer-driven Scaling of ConvNets for Medical Image Segmentation》(MICCAI 2023)</strong></p><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311130851990.png" alt="image-20231108195751803"></p><p><strong>MedNeXt Block:</strong></p><ul><li><p>深度卷积层（DW）：k × k × k的深度卷积，归一化使用channel-wise GroupNorm</p></li><li><p>Expansion Layer:较大的 R 值允许网络在宽度方向上扩展，而 1×1×1 核限制了计算量</p></li><li><p>Compression Layer:1×1×1卷积层对输出通道进行压缩</p></li></ul><p><strong>MedNeXt Down Block和MedNeXt Up Block：</strong></p><ul><li>添加了一个残差连接1×1×1卷积或转置卷积，步幅为2</li></ul><p>​    解码器层使用<strong>深度监督</strong>，在较低分辨率下具有较低的损失权值（深度监督：在网络的中间部分添加了额外的loss，不同位置的loss按系数求和。深度监督的目的是为了浅层能够得到更加充分的训练，解决深度神经网络训练梯度消失和收敛速度过慢等问题。）</p><p><strong>UpKern 初始化：</strong></p><p>大卷积核的缺陷：大卷积核性能可能更容易达到一个瓶颈，无法再进一步提高。(大卷积核模型有更多的参数，因此更容易过拟合训练数据)</p><p>医学图像分割任务的数据少之又少，性能更容易饱和。</p><p>为了帮助大卷积核网络在医学图像分割等任务中更好地利用有限数据，从而改善性能。</p><p>对预训练小核网络进行三线性上采样来初始化大核网络，从而<strong>迭代地增加核大小</strong>。其他的大小相同的层（包括归一化层）都通过直接复制预训练层的权重来初始化。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311130851317.png" alt="image-20231108204926791" style="zoom:67%;"></p><p><strong>MedNeXt四种配置及消融实验：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311130851800.png" alt="image-20231108211021855"></p><p>通道数（C)均设置为32</p><ul><li>在重采样时保留了特征映射中的语义丰富性</li><li>没有UpKern的大内核和小内核的性能是没有区别的</li><li>大卷积核中的性能提升是由于UpKern与大卷积核的结合，而不仅仅是更长的训练</li></ul><h3 id="2-实验结果"><a href="#2-实验结果" class="headerlink" title="2.实验结果"></a>2.实验结果</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311130851293.png" alt="image-20231108214400563"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nnUNet v2模型训练</title>
      <link href="/posts/4a35a285.html"/>
      <url>/posts/4a35a285.html</url>
      
        <content type="html"><![CDATA[<h2 id="nnUNet-v2模型训练"><a href="#nnUNet-v2模型训练" class="headerlink" title="nnUNet v2模型训练"></a>nnUNet v2模型训练</h2><h3 id="1-数据集处理"><a href="#1-数据集处理" class="headerlink" title="1.数据集处理"></a>1.数据集处理</h3><p><strong>nnUnet要求rgb-png格式的数据</strong>，故将原数据集由单通道堆叠成三通道的RGB图像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line">import os</span><br><span class="line">def gray_to_rgb(image_gray):</span><br><span class="line">    # 创建一个全零的三通道图像</span><br><span class="line">    height, width = image_gray.shape</span><br><span class="line">    image_rgb = np.zeros((height, width, 3), dtype=np.uint8)</span><br><span class="line">    # 将灰度图像的值复制到红通道</span><br><span class="line">    image_rgb[:, :, 2] = image_gray</span><br><span class="line">    image_rgb[:, :, 1] = image_gray</span><br><span class="line">    image_rgb[:, :, 0] = image_gray</span><br><span class="line">    return image_rgb</span><br><span class="line"># 设置目标文件夹路径</span><br><span class="line"> # 包含灰度PNG图像的文件夹路径</span><br><span class="line">output_folder = # 用于保存RGB图像的文件夹路径</span><br><span class="line">root_folder=</span><br><span class="line"># 创建输出文件夹（如果不存在）</span><br><span class="line">if not os.path.exists(output_folder):</span><br><span class="line">    os.makedirs(output_folder)</span><br><span class="line">for root, dirs, files in os.walk(root_folder):</span><br><span class="line">    # 遍历目标文件夹中的所有图像文件</span><br><span class="line">    if root == root_folder:</span><br><span class="line">        for dir_name in dirs:</span><br><span class="line">            input_folder = os.path.join(root, dir_name, dir_name + &quot;_label&quot;)</span><br><span class="line">            print(input_folder)</span><br><span class="line">            for filename in os.listdir(input_folder):</span><br><span class="line">                if filename.endswith(&#x27;.png&#x27;):</span><br><span class="line">                    # 构造图像文件的完整输入路径</span><br><span class="line">                    input_image_path = os.path.join(input_folder, filename)</span><br><span class="line">                    # 读取灰度图像</span><br><span class="line">                    image_gray = cv2.imread(input_image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">                    if image_gray is not None:</span><br><span class="line">                        # 转换为RGB图像</span><br><span class="line">                        image_rgb = gray_to_rgb(image_gray)</span><br><span class="line">                        # 构造保存的RGB图像文件名（输出路径）</span><br><span class="line">                        output_image_path = os.path.join(output_folder, filename.replace(&#x27;.png&#x27;, &#x27;_rgb.png&#x27;))</span><br><span class="line">                        # 保存RGB图像到指定输出路径</span><br><span class="line">                        cv2.imwrite(output_image_path, image_rgb)</span><br><span class="line">            print(&quot;Conversion completed.&quot;)</span><br></pre></td></tr></table></figure><p><strong>原先数据集的格式要求：</strong></p><ul><li><strong>train</strong><ul><li><strong>images</strong></li><li><strong>labels</strong></li></ul></li><li><strong>test</strong><ul><li><strong>images</strong></li><li><strong>labels</strong></li></ul></li></ul><p><strong>将数据集转化为nnUnet标准格式，改写nnUNet/nnunetv2/dataset_conversion/Dataset120_RoadSegmentation.py</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # extracted archive from https://www.kaggle.com/datasets/insaff/massachusetts-roads-dataset?resource=download</span><br><span class="line">    source = &#x27;/root/autodl-tmp/nnUNet/Coronary&#x27;</span><br><span class="line">    print(source)</span><br><span class="line">    dataset_name = &#x27;Dataset150_Segmentation&#x27;</span><br><span class="line">    nnUNet_raw = &#x27;/root/autodl-tmp/nnUNet/dataset/nnUNet_raw&#x27;</span><br><span class="line">    imagestr = join(nnUNet_raw, dataset_name, &#x27;imagesTr&#x27;)</span><br><span class="line">    imagests = join(nnUNet_raw, dataset_name, &#x27;imagesTs&#x27;)</span><br><span class="line">    labelstr = join(nnUNet_raw, dataset_name, &#x27;labelsTr&#x27;)</span><br><span class="line">    labelsts = join(nnUNet_raw, dataset_name, &#x27;labelsTs&#x27;)</span><br><span class="line">   </span><br><span class="line">    maybe_mkdir_p(imagestr)</span><br><span class="line">    maybe_mkdir_p(imagests)</span><br><span class="line">    maybe_mkdir_p(labelstr)</span><br><span class="line">    maybe_mkdir_p(labelsts)</span><br><span class="line"></span><br><span class="line">    train_source = join(source, &#x27;train&#x27;)</span><br><span class="line">    test_source = join(source, &#x27;test&#x27;)</span><br><span class="line"></span><br><span class="line">    with multiprocessing.get_context(&quot;spawn&quot;).Pool(8) as p:</span><br><span class="line"></span><br><span class="line">        # not all training images have a segmentation</span><br><span class="line">        valid_ids = subfiles(join(train_source, &#x27;labels&#x27;), join=False, suffix=&#x27;png&#x27;)</span><br><span class="line">        num_train = len(valid_ids)</span><br><span class="line">        r = []</span><br><span class="line">        for v in valid_ids:</span><br><span class="line">            r.append(</span><br><span class="line">                p.starmap_async(</span><br><span class="line">                    load_and_covnert_case,</span><br><span class="line">                    ((</span><br><span class="line">                         join(train_source, &#x27;images&#x27;, v),</span><br><span class="line">                         join(train_source, &#x27;labels&#x27;, v),</span><br><span class="line">                         join(imagestr, v[:-4] + &#x27;_0000.png&#x27;),</span><br><span class="line">                         join(labelstr, v),</span><br><span class="line">                         50</span><br><span class="line">                     ),)</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        # test set</span><br><span class="line">        valid_ids = subfiles(join(test_source, &#x27;labels&#x27;), join=False, suffix=&#x27;png&#x27;)</span><br><span class="line">        for v in valid_ids:</span><br><span class="line">            r.append(</span><br><span class="line">                p.starmap_async(</span><br><span class="line">                    load_and_covnert_case,</span><br><span class="line">                    ((</span><br><span class="line">                         join(test_source, &#x27;images&#x27;, v),</span><br><span class="line">                         join(test_source, &#x27;labels&#x27;, v),</span><br><span class="line">                         join(imagests, v[:-4] + &#x27;_0000.png&#x27;),</span><br><span class="line">                         join(labelsts, v),</span><br><span class="line">                         50</span><br><span class="line">                     ),)</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        _ = [i.get() for i in r]</span><br><span class="line"></span><br><span class="line">    generate_dataset_json(join(nnUNet_raw, dataset_name), &#123;0: &#x27;R&#x27;, 1: &#x27;G&#x27;, 2: &#x27;B&#x27;&#125;, &#123;&#x27;background&#x27;: 0, &#x27;coronary&#x27;: 1&#125;,</span><br><span class="line">                          num_train, &#x27;.png&#x27;, dataset_name=dataset_name)</span><br></pre></td></tr></table></figure><p><strong>生成的数据集：</strong></p><ul><li>数据集名称<ul><li>imagesTr</li><li>imagesTs</li><li>labelsTr</li><li>labelsTs</li><li>dataset.json</li></ul></li></ul><p><strong>添加环境变量：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export nnUNet_raw=&quot;/root/autodl-tmp/nnUNet/dataset/nnUNet_raw&quot;</span><br><span class="line">export nnUNet_preprocessed=&quot;/root/autodl-tmp/nnUNet/dataset/nnUNet_preprocessed&quot;</span><br><span class="line">export nnUNet_results=&quot;/root/autodl-tmp/nnUNet/dataset/nnUnet_results&quot;</span><br></pre></td></tr></table></figure><p><strong>预处理数据集：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNetv2_plan_and_preprocess -d 150 --verify_dataset_integrity #150为任务id</span><br></pre></td></tr></table></figure><h3 id="2-模型训练"><a href="#2-模型训练" class="headerlink" title="2.模型训练"></a>2.模型训练</h3><p><strong>开始训练：</strong></p><p><code>nnUNetv2_train CONFIGURATION TRAINER_CLASS_NAME TASK_NAME_OR_ID FOLD (additional options)</code></p><ul><li><code>CONFIGURATION：</code> 模型架构，三种Unet: 2D U-Net, 3D U-Net and a U-Net Cascade(U-Net级联)。</li><li><code>TASK_NAME_OR_ID：</code> 任务全名TaskXXX_MYTASK或者是ID号</li><li><code>FOLD：</code> 第几折交叉验证，可选 [0, 1, 2, 3, 4]，一共五折。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNetv2_train 666 2d 4</span><br></pre></td></tr></table></figure><p><strong>loss曲线：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115385.png" alt="image-20231106164804089" style="zoom: 67%;"></p><h3 id="3-模型测试"><a href="#3-模型测试" class="headerlink" title="3.模型测试"></a>3.模型测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNetv2_predict -i “测试集路径” -o “输出路径” -chk checkpoint_best.pth -c 2d -f 4 -d 150 --save_probabilities</span><br></pre></td></tr></table></figure><p>将二值掩码转换为0或255</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def process_images_in_folder(input_folder, output_folder):</span><br><span class="line">    for root, dirs, files in os.walk(input_folder):</span><br><span class="line">        for file in files:</span><br><span class="line">            if file.endswith(&quot;.png&quot;):</span><br><span class="line">                input_image_path = os.path.join(root, file)</span><br><span class="line">                output_image_path = os.path.join(output_folder, file)</span><br><span class="line"></span><br><span class="line">                # 打开输入图像</span><br><span class="line">                image = Image.open(input_image_path)</span><br><span class="line"></span><br><span class="line">                # 将像素值为1的通道变为255</span><br><span class="line">                image = image.convert(&quot;RGB&quot;)</span><br><span class="line">                data = image.getdata()</span><br><span class="line">                new_data = [(r, g, b) if r != 1 and g != 1 and b != 1 else (255, 255, 255) for (r, g, b) in data]</span><br><span class="line">                image.putdata(new_data)</span><br><span class="line"></span><br><span class="line">                # 保存修改后的图像</span><br><span class="line">                image.save(output_image_path)</span><br><span class="line"></span><br><span class="line"># 指定输入文件夹和输出文件夹的路径</span><br><span class="line">input_folder_path = &quot;&quot;</span><br><span class="line">output_folder_path = &quot;&quot;</span><br><span class="line"></span><br><span class="line">if not os.path.exists(output_folder_path):</span><br><span class="line">    os.makedirs(output_folder_path)</span><br><span class="line"></span><br><span class="line">process_images_in_folder(input_folder_path, output_folder_path)</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202311062116900.png" alt="image-20231106200912078"></p><p><strong>评价指标：</strong></p><p><strong>HD95: 5.20</strong></p><p><strong>Average Dice: 0.8144</strong></p>]]></content>
      
      
      <categories>
          
          <category> 模型训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模型训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3D UX-NET</title>
      <link href="/posts/eabf9f8.html"/>
      <url>/posts/eabf9f8.html</url>
      
        <content type="html"><![CDATA[<h2 id="3D-UX-NET"><a href="#3D-UX-NET" class="headerlink" title="3D UX-NET"></a>3D UX-NET</h2><p><strong>论文：《3D UX-NET: A LARGE KERNEL VOLUMETRIC CONVNET MODERNIZING HIERARCHICAL TRANSFORMER</strong><br><strong>FOR MEDICAL IMAGE SEGMENTATION》（ICLR 2023）</strong></p><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115336.png" alt="image-20231106201433865"></p><p>采用具备大卷积核的投影层来提取 patch-wise 特征作为编码器的输入</p><p><strong>对Swin transformer的transformer block做了替换：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115856.png" alt="image-20231106202256333" style="zoom:67%;"></p><p>使用大卷积核(7 × 7 × 7)的深度卷积来模仿Swin Transformer的局部自注意力和窗口移动。</p><p>使用2 × 2 × 2、步幅为2的标准卷积块来实现下采样</p><p>在Swin Transformer中MLP隐藏层维度比输入维度宽四倍，引入了具有 1 × 1 × 1 卷积核大小的深度卷积缩放(DCS)，以独立地线性缩放每个通道特征，减少跨通道上下文产生的冗余信息</p><p>DCS：1x1x1的深度卷积+1x1x1的分组卷积</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115037.png" alt="image-20231106205655475" style="zoom:67%;"></p><p>从实验中发现：使用深度卷积缩放(DCS)参数量得到了减小，效果并没有下降</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115199.png" alt="image-20231106204002121"></p><p>编码器的输出特征由残差块作进一步的处理，以稳定提取的特征。（残差块由两个经过实例归一化的后归一化3 × 3 × 3卷积层组成）</p><p>转置卷积层实现上采样，其输出的特征与编码器的输出进行连接后，再次输入到残差块中。</p><h3 id="2-实验结果"><a href="#2-实验结果" class="headerlink" title="2.实验结果"></a>2.实验结果</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115341.png" alt="image-20231106210428239"></p><p>3D UX-Net 在这几个分割任务中均展示出最佳性能，并且 Dice 分数有了一定的提高</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像分割常用指标</title>
      <link href="/posts/70fa35a7.html"/>
      <url>/posts/70fa35a7.html</url>
      
        <content type="html"><![CDATA[<h3 id="图像分割常用指标"><a href="#图像分割常用指标" class="headerlink" title="图像分割常用指标"></a>图像分割常用指标</h3><h4 id="1-DSC（Dice相似系数）"><a href="#1-DSC（Dice相似系数）" class="headerlink" title="1.DSC（Dice相似系数）"></a>1.DSC（Dice相似系数）</h4><p><strong>DSC：用于衡量区域的重合程度</strong></p><p><strong>计算公式：</strong></p><script type="math/tex; mode=display">DSC = (2 * |A ∩ B|) / (|A| + |B|)</script><p>其中，A为算法生成的分割结果的像素集合，B为参考分割结果的像素集合</p><ul><li><p>DSC值范围在0到1之间，其中0表示完全不相似，1表示完全相似。</p></li><li><p>DSC值越接近1，表示算法生成的分割结果与参考分割结果越相似</p></li></ul><p><em>注：Dice相似系数仅考虑了像素的重叠情况，而没有考虑像素之间的空间关系，在存在模糊边界的分割任务中,Dice系数可能无法准确评估模型的性能。</em></p><h4 id="2-HD-豪斯多夫距离"><a href="#2-HD-豪斯多夫距离" class="headerlink" title="2.HD(豪斯多夫距离)"></a>2.HD(豪斯多夫距离)</h4><p><strong>HD:表示预测分割区域边界与真实区域边界之间的最大距离，其值越小代表预测边界分割误差越小、质量越好。</strong></p><p><strong>计算公式：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312272119455.png" alt="image-20231102100120629" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312272119442.png" alt="image-20231102100057838" style="zoom:67%;"></p><p><strong>计算步骤：</strong></p><p>​    (1)对点集X中的每一个点x计算其到点集Y中的每一个点y的距离，保留最短距离，然后找出保留的最短距离中的最大距离记为Dxy。</p><p>​    (2)对点集Y中的每一个点y计算其到点集X中的每一个点x的距离，保留最短距离，然后找出保留最短距离中的最大距离记为Dyx。</p><p>​    (3)取Dxy和Dyx最大值作为点集X和Y之间的豪斯多夫距离。</p><p><strong>HD95(95％ 豪斯多夫距离):</strong></p><p>为了排除一些离群点造成的不合理距离，保持整体数值稳定性，一般选择从小到大排名前 95%的距离作为实际豪斯多夫距离，称之为 95% 豪斯多夫距离。</p><p><strong>注：Dice相似系数主要关注分割结果的整体准确性，HD95则更侧重于考虑分割边界的精确性</strong></p><p><strong>注： 豪斯多夫距离目标是捕捉两个集合之间的最大不一致，对于孤立的离群点或噪声非常敏感，不适用于噪声较多的图像。</strong></p><h4 id="3-ASD（平均表面距离）"><a href="#3-ASD（平均表面距离）" class="headerlink" title="3.ASD（平均表面距离）"></a>3.ASD（平均表面距离）</h4><p>平均表面距离：用来测量分割结果中的边界与真实标签中的边界之间的距离。</p><p><strong>计算分割结果中的每个像素与真实标签中的最近像素之间的距离，然后取平均值。</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312272120231.png" alt="image-20231102102746435" style="zoom: 50%;"></p><p><strong>ASSD(平均对称表面距离):</strong></p><p>​                                                            <script type="math/tex">\large ASSD(X,Y)={ASD(X,Y)+ASD(Y,X)}/2</script></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nnFormer</title>
      <link href="/posts/9e11ec23.html"/>
      <url>/posts/9e11ec23.html</url>
      
        <content type="html"><![CDATA[<h2 id="nnFormer"><a href="#nnFormer" class="headerlink" title="nnFormer"></a>nnFormer</h2><p><strong>论文：《nnFormer: Volumetric Medical Image Segmentation via a 3D Transformer》（TMI2022）</strong></p><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310252011844.png" alt="image-20231025201100423" style="zoom: 80%;"></p><h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h4><p><strong>nnFormer的输入：</strong>对原始图像中随机裁剪（HxWxD)，数据增强技术，有助于模型更好地学习不同部分的特征。</p><p><strong>The embedding layer:</strong>（将输入数据转换成高维张量）</p><ul><li><strong>使用卷积的好处：</strong>对比transformer使用线性层对patch的向量进行映射，卷积层能够更细致地捕获图像中的像素级信息（减少了训练的参数数量，卷积核在处理特定区域时更加专注）</li><li><strong>在初始阶段使用小卷积核的连续卷积层，相对于大卷积核的好处：</strong>降低计算复杂度,同时保持相同大小的感受野(非线性激活函数多了，语义表达能力增强了)</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202310252109346.png" alt="image-20231025210627610"></p><p><em>注：根据输入的patch大小卷积步长也会有相应的变化</em></p><p><strong>Local Volume-based Multi-head Self-attention (LV-MSA)：</strong>将不同尺度的信息和高分辨率的空间信息相互关联</p><p>不同尺度的特征由下采样层生成，高分辨率的空间信息则由嵌入层编码</p><p>使用的是一种基于局部三维图像块的self-attention计算方式（跟Swin-UNet类似)</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310252129451.png" alt="image-20231025212855680" style="zoom: 80%;"></p><p><strong>SLV-MSA:</strong>是LV-MSA的shifted版本（类似于Swin-UNet，目的是使局部的三维图像块之间产生联系）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310252130572.png" alt="image-20231025213050517" style="zoom: 67%;"></p><p><em>注：$S_H、S_W、S_D$代表每个图像块中的patch的数量</em></p><p>使用LV-MSA减少了计算的复杂度，计算复杂度和图像之间是线性的关系</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310252139215.png" alt="image-20231025213709821" style="zoom: 80%;"></p><p>使用相对位置偏置B来引入位置信息</p><p><strong>The down-sampling layer：</strong></p><p>与Swin-UNet使用patch merging不同，作者选择了使用简单的卷积来实现下采样，卷积下采样可以在不同空间维度上应用不同的步长，以根据问题的要求调整下采样率。（可以根据数据的特点来灵活设置，避免过度下采样，对于三维的图像在某些维度上数据切片数量有限，这时可以将该维度的步长设置为1）</p><h4 id="Bottleneck"><a href="#Bottleneck" class="headerlink" title="Bottleneck"></a>Bottleneck</h4><p>不同于编码器使用局部自注意力机制，Bottleneck中使用全局自注意力。</p><p>计算复杂度：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310271637998.png" alt="image-20231027153408838" style="zoom: 80%;"></p><p>编码器部分减小了h、w、d，这为GV-MSA的应用创造了条件，与LV-MSA相比，GV-MSA能够提供更大的感受野</p><h4 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h4><p><strong>上采样操作</strong>：使用转置卷积</p><p><strong>Skip Attention：</strong>（使不同层之间的信息交流变得更加灵活）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310271636161.png" alt="image-20231027155805206" style="zoom: 67%;"></p><h3 id="2-实验部分"><a href="#2-实验部分" class="headerlink" title="2.实验部分"></a>2.实验部分</h3><h4 id="与基于Transformer的方法学的比较"><a href="#与基于Transformer的方法学的比较" class="headerlink" title="与基于Transformer的方法学的比较"></a>与基于Transformer的方法学的比较</h4><p><strong>脑肿瘤分割</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310271636932.png" alt="image-20231027162254249" style="zoom: 67%;"></p><p>列出了所有模型在脑瘤分割任务上的实验结果,nnFormer在所有类别中取得了最低的HD95和最高的DSC分数。</p><p><strong>多器官分割（Synapse）</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310302100261.png" alt="image-20231029163515666"></p><p>与以前基于Transformer的方法相比，nnFormer在分割胰腺(Pancreas)和胃(Stomach)方面更有优势</p><p><strong>与nnUNet的比较</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310302100944.png" alt="image-20231030203836841"></p><p>nnFormer的HD95似乎更有优势，其可以更好地划分对象边界。</p><p>nnAvg：对nnFormer和nnUNet的预测结果进行平均化，发现整体的性能得到了提高，表明nnFormer和nnUNet是可以互补的。</p><h4 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202310302100685.png" alt="image-20231030205355146"></p><ul><li><p>嵌入层使用小卷积核大小的连续卷积层</p></li><li><p>卷积下采样层替换掉了patch Merging层</p></li><li><p>GV-MSA替换了Bottleneck的LV-MSA</p></li><li><p>Skip Attention代替跳跃连接</p></li><li>SLV-MSA层与LV-MSA层级联，全局自注意力层的数量增加一倍</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File类</title>
      <link href="/posts/c8b66f0a.html"/>
      <url>/posts/c8b66f0a.html</url>
      
        <content type="html"><![CDATA[<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><h3 id="1-创建File类的对象"><a href="#1-创建File类的对象" class="headerlink" title="1.创建File类的对象"></a>1.创建File类的对象</h3><p><img src="https://typoraimg.wangak.cc/2023/img/1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//创建一个File对象，指向某个具体的文件</span><br><span class="line">      File f1=new File(&quot;./data/test.txt&quot;);</span><br><span class="line">      System.out.println(f1.length());//文件大小</span><br><span class="line"></span><br><span class="line">      File f2=new File(&quot;./data/aaa.txt&quot;);//File对象可以指向空路径</span><br><span class="line">      System.out.println(f2.length());//0</span><br><span class="line">      System.out.println(f2.exists());//false</span><br></pre></td></tr></table></figure><h3 id="2-判断文件类型、获取文件信息"><a href="#2-判断文件类型、获取文件信息" class="headerlink" title="2.判断文件类型、获取文件信息"></a>2.判断文件类型、获取文件信息</h3><p><img src="https://typoraimg.wangak.cc/2023/img/2.png" alt="img" style="zoom: 50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//1.创建一个File对象，指向某个具体的文件</span><br><span class="line">      File f1=new File(&quot;./data/test.txt&quot;);</span><br><span class="line">      //2.判断文件路径是否存在</span><br><span class="line">      System.out.println(f1.exists());</span><br><span class="line">      //3.判断文件对象是否是文件</span><br><span class="line">      System.out.println(f1.isFile());</span><br><span class="line">      //4.判断文件对象是否是文件夹</span><br><span class="line">      System.out.println(f1.isDirectory());</span><br><span class="line">      //5.获取文件的名称</span><br><span class="line">      System.out.println(f1.getName());</span><br><span class="line">      //6.获取文件的大小，返回字节个数</span><br><span class="line">      System.out.println(f1.length());</span><br><span class="line">      //7.获取文件最后的修改时间</span><br><span class="line">      long time = f1.lastModified();</span><br><span class="line">      SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);</span><br><span class="line">      System.out.println(sdf.format(time));//2023/10/18</span><br><span class="line">      //8.获取创建文件对象时使用的路径</span><br><span class="line">      System.out.println(f1.getPath());</span><br><span class="line">      //9.获取文件对象的绝对路径</span><br><span class="line">      System.out.println(f1.getAbsolutePath());</span><br></pre></td></tr></table></figure><h3 id="3-创建、删除文件"><a href="#3-创建、删除文件" class="headerlink" title="3.创建、删除文件"></a>3.创建、删除文件</h3><p><strong>public boolean creatNewFile():</strong>创建一个新文件，创建成功返回true</p><p><strong>public boolean mkdir():</strong>创建文件夹（只能创建一级文件夹）</p><p><strong>public boolean mkdirs():</strong>创建文件夹,可以创建多级文件夹</p><p><strong>public boolean delete():</strong>删除文件或文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//1.创建一个新文件</span><br><span class="line">      File f1=new File(&quot;./data/test2.txt&quot;);</span><br><span class="line">      System.out.println(f1.createNewFile());</span><br><span class="line">      //2.创建文件夹</span><br><span class="line">      File f2=new File(&quot;./data/a&quot;);</span><br><span class="line">      System.out.println(f2.mkdir());</span><br><span class="line">      //3.创建多个文件夹</span><br><span class="line">      File f3=new File(&quot;./data/1/2&quot;);</span><br><span class="line">      System.out.println(f3.mkdirs());</span><br><span class="line">      //4.删除文件或文件夹</span><br><span class="line">      System.out.println(f1.delete());</span><br><span class="line">      System.out.println(f2.delete());</span><br><span class="line">      System.out.println(f3.delete());</span><br><span class="line">      //&quot;./data/1&quot;这个文件夹还存在</span><br></pre></td></tr></table></figure><h3 id="4-遍历文件夹"><a href="#4-遍历文件夹" class="headerlink" title="4.遍历文件夹"></a>4.遍历文件夹</h3><p><img src="https://typoraimg.wangak.cc/2023/img/3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">File f1=new File(&quot;./data&quot;);</span><br><span class="line">      //获取目录下文件的名称</span><br><span class="line">      String[] names=f1.list();</span><br><span class="line">      for(String x:names)&#123;</span><br><span class="line">          System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">      //获取当前目录下的文件对象</span><br><span class="line">      File[] files=f1.listFiles();</span><br><span class="line">      for (File file:files)&#123;</span><br><span class="line">          System.out.println(file.getPath());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷积编码位置信息</title>
      <link href="/posts/a8dea67.html"/>
      <url>/posts/a8dea67.html</url>
      
        <content type="html"><![CDATA[<p><strong>论文：《HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE?》（ICLR2020）</strong></p><h3 id="论文内容："><a href="#论文内容：" class="headerlink" title="论文内容："></a>论文内容：</h3><h4 id="初步实验："><a href="#初步实验：" class="headerlink" title="初步实验："></a>初步实验：</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412926.png" alt="1"></p><p>对原始图像和裁剪过的图像进行显著性检测。</p><p>显著的区域分析，对于相同的物体，在不同的边缘下，显著性区域始终靠近图像中心。</p><p>推测：<strong>位置信息在 CNN 网络提取的特征图中被隐式编码</strong></p><h4 id="Position-Encoding-Network："><a href="#Position-Encoding-Network：" class="headerlink" title="Position Encoding Network："></a>Position Encoding Network：</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412136.png" alt="2"></p><p><strong>a feed forward convolutional encoder network $f_{enc} $:</strong>使用预训练的VGG或者 ResNet，仅作为前馈网络，其参数不参与训练。为前馈网络的在五个卷积层产生的特征图，使用双线性插值缩放到统一尺寸进行拼接，之后输入到 Position Encoding Module 中。</p><p><strong>position encoding module：</strong>一般卷积网络，其卷积核未使用Padding。</p><p>作者使用该网络判断卷积层产生的特征图中是否包含位置信息。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412155.png" alt="3" style="zoom: 80%;"></p><p>垂直（H)和水平(V)方向的梯度掩码、应用高斯滤波器来设计另一种类型的真值图，高斯分布(G)、水平和垂直条纹（HS、VS)，使用这五种图像表示位置信息，作为Ground Truth，每次训练选择其中一种，<strong>所有样本的标签都是一样的</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412681.png" alt="4" style="zoom:80%;"></p><p>除了使用数据集中的原始图像，作者还分别将<strong>纯黑、纯白、高斯噪声图像作为输入</strong>，这是为了验证在没有语义信息的情况下，特征中是否包含绝对位置信息。</p><p><strong>评价指标：</strong> Spearmen Correlation (<strong>SPC</strong>) and Mean Absoute Error (<strong>MAE</strong>)，前者越高说明输出与目标图像的相关性越高，后者则相反。</p><p><strong>实验结果:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412217.png" alt="5"></p><p>单独使用PosENet得到的分数要低很多，这一结果表明，仅从输入图像中提取位置信息是非常困难的，<strong>PosENet要与编码器网络相结合才能更好地提取出位置信息</strong></p><p>发现基于ResNet的模型比基于VGG16的模型实现了更高的性能。</p><h4 id="探究卷积的参数对提取位置信息的影响"><a href="#探究卷积的参数对提取位置信息的影响" class="headerlink" title="探究卷积的参数对提取位置信息的影响"></a>探究卷积的参数对提取位置信息的影响</h4><p><strong>length of convolutional layers：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412853.png" alt="6" style="zoom: 67%;"></p><p><strong>kernel size:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412339.png" alt="7" style="zoom: 80%;"></p><p>​                                                                <strong>更大的感受野可以更好地解析位置信息</strong></p><p><strong>zero-padding：</strong>作者认为卷积中zero-padding 是 CNN 中位置信息的来源</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412058.png" alt="8" style="zoom:80%;"></p><p>从结果中可以看出，未添加 zero-padding 的 VGG16 的性能比默认设置（padding =  1）低得多。PosENet（padding = 1）实现了比原始（padding = 0）更高的性能，而当 padding 设置为 2  时，位置信息的作用更加明显。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架</title>
      <link href="/posts/9753a2e.html"/>
      <url>/posts/9753a2e.html</url>
      
        <content type="html"><![CDATA[<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><h3 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1.泛型"></a>1.泛型</h3><p><strong>泛型：</strong>允许在编写类、接口和方法时使用类型参数，以在运行时确定具体的数据类型，用于增强类型安全性和代码的可重用性</p><h4 id="1-1-泛型类"><a href="#1-1-泛型类" class="headerlink" title="1.1 泛型类"></a>1.1 泛型类</h4><p><strong>泛型类：</strong><code>类名&lt;T,...&gt;</code>,T是类型占位符，表示一种引用类型，如果编写多个用逗号隔开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGeneric</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//1.创建变量</span></span><br><span class="line">    T t;</span><br><span class="line">    <span class="comment">//2.使用泛型作为方法的参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T y)</span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.使用泛型作为方法的返回值</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用泛型类创建对象</span></span><br><span class="line">        MyGeneric&lt;String&gt; myGeneric1=<span class="keyword">new</span> <span class="title class_">MyGeneric</span>&lt;&gt;();</span><br><span class="line">        myGeneric1.t=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        MyGeneric&lt;Integer&gt; myGeneric2=<span class="keyword">new</span> <span class="title class_">MyGeneric</span>&lt;&gt;();</span><br><span class="line">        myGeneric2.t=<span class="number">100</span>;</span><br><span class="line">        myGeneric1.show();</span><br><span class="line">        myGeneric2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p>1.泛型只能是引用类型</p><p>2.不同泛型类型的对象之间不能相互赋值</p><h4 id="1-2-泛型接口"><a href="#1-2-泛型接口" class="headerlink" title="1.2 泛型接口"></a>1.2 泛型接口</h4><p><strong>泛型接口：</strong><code>接口名&lt;T&gt;</code></p><p><strong><em>注：不能使用泛型创建静态常量</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">server</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口实现方式一：class确定泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyImpl1</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&lt;String&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">server</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口实现方式二：class不确定泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyImpl2</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">server</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyImpl1 myImpl1=<span class="keyword">new</span> <span class="title class_">MyImpl1</span>();</span><br><span class="line">        myImpl1.server(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        MyImpl2&lt;Integer&gt; myImpl2a=<span class="keyword">new</span> <span class="title class_">MyImpl2</span>&lt;&gt;();</span><br><span class="line">        myImpl2a.server(<span class="number">100</span>);</span><br><span class="line">        MyImpl2&lt;String&gt; myImpl2b=<span class="keyword">new</span> <span class="title class_">MyImpl2</span>&lt;&gt;();</span><br><span class="line">        myImpl2b.server(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">hello</span><br><span class="line"><span class="number">100</span></span><br><span class="line">world</span><br></pre></td></tr></table></figure><h4 id="1-3-泛型方法"><a href="#1-3-泛型方法" class="headerlink" title="1.3 泛型方法"></a>1.3 泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenernicMod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">show</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;泛型方法:&quot;</span>+t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test4</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GenernicMod genernicMod=<span class="keyword">new</span> <span class="title class_">GenernicMod</span>();</span><br><span class="line">        genernicMod.show(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        genernicMod.show(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">泛型方法:hello</span><br><span class="line">泛型方法:<span class="number">123</span></span><br></pre></td></tr></table></figure><h4 id="1-4-泛型集合"><a href="#1-4-泛型集合" class="headerlink" title="1.4 泛型集合"></a>1.4 泛型集合</h4><p><strong>泛型集合：</strong>参数化类型、类型安全的集合，强制集合元素的类型必须一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;yyy&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; iterator=arrayList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String string=iterator.next();</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Collection体系集合"><a href="#2-Collection体系集合" class="headerlink" title="2.Collection体系集合"></a>2.Collection体系集合</h3><p><strong>集合和数组的区别：</strong></p><p>(1).数组长度固定，集合长度不固定</p><p>(2).数组可以存储基本类型和引用类型，集合只能存储引用类型。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201402167.png" alt="1"></p><ul><li><p><strong>Collection</strong> 接口存储一组不唯一，无序的对象</p></li><li><p><strong>List</strong> 接口存储一组不唯一，有序的对象。</p></li><li><p><strong>Set</strong> 接口存储一组唯一，无序的对象</p></li><li><p><strong>Map</strong> 接口存储一组键值对象，提供key到value的映射</p><p><strong>Collection的使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">       <span class="comment">//1.添加元素</span></span><br><span class="line">        collection.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">        <span class="comment">//*2.删除元素</span></span><br><span class="line"><span class="comment">//        collection.remove(&quot;a&quot;);//一次remove操作只删除一个元素，即使Collection中有相同元素</span></span><br><span class="line"><span class="comment">//        System.out.println(collection);</span></span><br><span class="line">        <span class="comment">//*3.1使用增强for遍历</span></span><br><span class="line"><span class="comment">//        for (Object object:collection) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(object);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//*3.2使用迭代器进行遍历</span></span><br><span class="line">        <span class="comment">//hasNext();判断有没有下一个元素</span></span><br><span class="line">        <span class="comment">//next();获取下一个元素</span></span><br><span class="line">        <span class="comment">//remove();删除当前元素</span></span><br><span class="line">        Iterator it= collection.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String s=(String)it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line"><span class="comment">//            it.remove();//删除当前元素</span></span><br><span class="line">        &#125;<span class="comment">//使用迭代器遍历时禁止使用Collection的其他的一些方法如remove()来改变集合的元素，可以使用迭代器的方法(it.remove())</span></span><br><span class="line"><span class="comment">//        System.out.println(collection);</span></span><br><span class="line">        <span class="comment">//*4.判断元素是否存在</span></span><br><span class="line">        System.out.println(collection.contains(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-1-List子接口"><a href="#2-1-List子接口" class="headerlink" title="2.1 List子接口"></a>2.1 List子接口</h4><p><strong>List：</strong>有序、有下标、元素可以重复</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201402726.png" alt="2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">List_test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//1.添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="number">0</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//2.删除元素</span></span><br><span class="line"><span class="comment">//        list.remove(&quot;c&quot;);//按元素删除</span></span><br><span class="line">        list.remove(<span class="number">0</span>);<span class="comment">//按下标删除</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//3.遍历</span></span><br><span class="line">        <span class="comment">//3.1使用for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.1使用for&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2使用增强for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.2使用增强for&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object object:list)&#123;</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.3使用迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.3使用迭代器&quot;</span>);</span><br><span class="line">        Iterator iterator=list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.4使用列表迭代器，ListIterator可以向前或向后遍历，可以添加、删除、修改元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.4使用列表迭代器向后遍历&quot;</span>);</span><br><span class="line">        ListIterator lit=list.listIterator();</span><br><span class="line">        <span class="keyword">while</span>(lit.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;3.4使用列表迭代器向前遍历&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(lit.hasPrevious())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.previous());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.获取元素的索引位置</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ArrayList存储结构：</strong>数组，查找速度快，增删速度慢，运行效率快，线程不安全</p><p><strong>Vector存储结构：</strong>数组，查找速度快，增删速度慢，运行效率慢，线程安全</p><p><strong>LinkedList存储结构:</strong>双向链表，增删速度快，查询速度慢</p><h4 id="2-2-set子接口"><a href="#2-2-set子接口" class="headerlink" title="2.2 set子接口"></a>2.2 set子接口</h4><h5 id="2-2-1-Set"><a href="#2-2-1-Set" class="headerlink" title="2.2.1 Set"></a>2.2.1 Set</h5><p><strong>Set:无序、无下标、元素不可重复</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set &lt;String&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[a, b, c]</span><br></pre></td></tr></table></figure><h5 id="2-2-2-HashSet"><a href="#2-2-2-HashSet" class="headerlink" title="2.2.2 HashSet"></a>2.2.2 HashSet</h5><p><strong>HashSet存储结构:</strong>哈希表（数组+链表+红黑树）</p><p><strong>存储过程：</strong></p><p>（1）根据hashcode计算保存的位置，如果此位置为空，则直接保存，如果不为空执行第二步。</p><p>（2）再执行equals方法，如果equals方法为true，则认为是重复，否则，形成链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet &lt;Person&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Person person1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;wang&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        Person person2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        set.add(person1);</span><br><span class="line">        set.add(person2);</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[Person@<span class="number">41629346</span>, Person@4eec7777, Person@3b07d329]</span><br></pre></td></tr></table></figure><p><strong>问题：相同name，age的对象于集合中重复添加</strong></p><p><strong>解决方法：重写hashcode、equals方法</strong></p><p><em>注：hashcode、equals方法定义了hashset的重复依据</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写hashCode和equals方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> n1=<span class="built_in">this</span>.name.hashCode();</span><br><span class="line">        <span class="type">int</span> n2=<span class="built_in">this</span>.age;</span><br><span class="line">        <span class="keyword">return</span> n1+n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>==obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Person)</span><br><span class="line">        &#123;</span><br><span class="line">            Person p=(Person) obj;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.name.equals(p.getName())&amp;&amp;<span class="built_in">this</span>.age==p.getAge())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet &lt;Person&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Person person1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;wang&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        Person person2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        set.add(person1);</span><br><span class="line">        set.add(person2);</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">2</span></span><br><span class="line">[Person<span class="meta">@f13</span>, Person@37921a]</span><br></pre></td></tr></table></figure><h5 id="2-2-3-TreeSet"><a href="#2-2-3-TreeSet" class="headerlink" title="2.2.3 TreeSet"></a>2.2.3 TreeSet</h5><p><strong>TreeSet:</strong></p><ul><li>基于排序顺序实现元素不重复</li><li>实现了SortedSet接口，对集合元素自动排序</li><li><strong>元素对象的类型必须实现Comparable接口，指定排序规则</strong></li><li>通过CompareTo方法确定是否为重复元素</li></ul><p><strong>TreeSet存储结构:</strong>红黑树</p><p><strong>TreeSet的使用一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt;&#123;<span class="comment">//TreeSet的元素类型必须实现Comparable接口</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;<span class="comment">//重写Comparable接口的compareTo方法，compareTo方法返回值为0认为是重复元素</span></span><br><span class="line">        <span class="type">int</span> n1=<span class="built_in">this</span>.name.compareTo(o.getName());</span><br><span class="line">        <span class="type">int</span> n2=<span class="built_in">this</span>.age-o.getAge();</span><br><span class="line">        <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        String str=<span class="built_in">this</span>.getName()+<span class="string">&quot;:&quot;</span>+<span class="built_in">this</span>.getAge();</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       TreeSet &lt;Person&gt; persons=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        Person person1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;wang&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        Person person2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        Person person3=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        persons.add(person1);</span><br><span class="line">        persons.add(person2);</span><br><span class="line">        persons.add(person3);</span><br><span class="line">        persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        System.out.println(persons.size());</span><br><span class="line">        System.out.println(persons.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[wang:<span class="number">23</span>, xu:<span class="number">22</span>, xu:<span class="number">24</span>]</span><br></pre></td></tr></table></figure><p><strong>TreeSet的使用二：Comparator实现比较器，无需实现Comparable接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TreeSet &lt;Person&gt; persons=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">               <span class="type">int</span> n1=o1.getName().compareTo(o2.getName());</span><br><span class="line">               <span class="type">int</span> n2=o1.getAge()-o2.getAge();</span><br><span class="line">               <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p><strong>利用TreeSet实现字符串排序：</strong>先按长度排，长度相同比大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;String&gt; treeSet=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">                <span class="type">int</span> n1=o1.length()-o2.length();</span><br><span class="line">                <span class="type">int</span> n2=o1.compareTo(o2);</span><br><span class="line">                <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeSet.add(<span class="string">&quot;peng&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;xu&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;an&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-Map集合体系"><a href="#3-Map集合体系" class="headerlink" title="3.Map集合体系"></a>3.Map集合体系</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201402328.png" alt="3" style="zoom: 80%;"></p><p><strong>Map:</strong>存储一对数据（Key-Value),无序、无下标、键不可重复、值可重复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class demo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;String, String&gt; map=new HashMap&lt;&gt;();</span><br><span class="line">        //1.添加元素</span><br><span class="line">        map.put(&quot;a&quot;,&quot;1&quot;);</span><br><span class="line">        map.put(&quot;b&quot;,&quot;2&quot;);</span><br><span class="line">        map.put(&quot;c&quot;,&quot;3&quot;);</span><br><span class="line">        map.put(&quot;d&quot;,&quot;4&quot;);</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">        //2.删除元素</span><br><span class="line">        map.remove(&quot;b&quot;);</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">        //3.1 使用keySet()遍历</span><br><span class="line">        System.out.println(&quot;使用keySet()遍历&quot;);</span><br><span class="line">//        Set&lt;String&gt; keys=map.keySet();</span><br><span class="line">        for (String key:map.keySet())&#123;</span><br><span class="line">            System.out.println(key+&quot;:&quot;+map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        //3.2 使用entrySet()遍历(效率高于keySet())</span><br><span class="line">        System.out.println(&quot;使用entrySet()遍历&quot;);</span><br><span class="line">//        Set&lt;Map.Entry&lt;String,String&gt; &gt; entrySet=map.entrySet();</span><br><span class="line">        for (Map.Entry&lt;String,String&gt; entry:map.entrySet())&#123;</span><br><span class="line">            System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        //4.判断是否包含</span><br><span class="line">        System.out.println(map.containsKey(&quot;a&quot;));</span><br><span class="line">        System.out.println(map.containsValue(&quot;1&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HashMap的存储结构：哈希表（数组+链表+红黑树）</strong></p><p>注：HashMap使用key的hashcode和equals作为重复的依据</p><p><strong>TreeMap:</strong>实现了SortedMap接口，可以对key自动排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        String str=this.getName()+&quot;:&quot;+this.getAge();</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       TreeMap &lt;Person,String&gt; persons=new TreeMap&lt;&gt;(new Comparator&lt;Person&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public int compare(Person o1, Person o2) &#123;</span><br><span class="line">               int n1=o1.getName().compareTo(o2.getName());</span><br><span class="line">               int n2=o1.getAge()-o2.getAge();</span><br><span class="line">               return n1==0?n2:n1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">        Person person1=new Person(&quot;wang&quot;,23);</span><br><span class="line">        Person person2=new Person(&quot;xu&quot;,22);</span><br><span class="line">        Person person3=new Person(&quot;xu&quot;,24);</span><br><span class="line">        persons.put(person1,&quot;a&quot;);</span><br><span class="line">        persons.put(person2,&quot;b&quot;);</span><br><span class="line">        persons.put(person3,&quot;c&quot;);</span><br><span class="line">        persons.put(new Person(&quot;xu&quot;,22),&quot;d&quot;);</span><br><span class="line">        System.out.println(persons.size());</span><br><span class="line">        System.out.println(persons.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Collections工具类"><a href="#4-Collections工具类" class="headerlink" title="4.Collections工具类"></a>4.Collections工具类</h3><p>Collections工具类：集合工具类，定义了除存取以外的集合常用方法。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201402950.png" alt="4"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SegFormer</title>
      <link href="/posts/9e1703d2.html"/>
      <url>/posts/9e1703d2.html</url>
      
        <content type="html"><![CDATA[<h2 id="SegFormer"><a href="#SegFormer" class="headerlink" title="SegFormer"></a>SegFormer</h2><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407750.png" alt="1" style="zoom:75%;"></p><p><strong>编码器:</strong>通过在不同阶段进行下采样，生成多尺度特征。</p><p><strong>Efficient Self-Attention:</strong></p><p><strong>原始的自注意力计算：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407939.png" alt="2" style="zoom: 67%;"></p><p>计算复杂度为O($N^2$),其中N为w*h</p><p><strong>高效的自关注机制:</strong>通过一个压缩比R对K进行处理，改进的计算过程如下.0</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407713.png" alt="3" style="zoom:67%;"></p><p>复杂度从O($N^2$)将至O($N^2 \over R$),降低了计算复杂度</p><p><em>注：论文中的R分别取64, 16, 4, 1</em></p><p>通过将K进行reshape将空间维度N的信息转移到通道维度C上，可以得到$\widehat K$；然后通过线性变换层将通道为降到原始维度C上，得到K’，实现空间下采样。</p><p><strong>Mix-FFN:</strong>为了解决使用位置编码引入位置信息，但由于在测试时的分辨率发生变化时，<strong>会引起精度下降的问题</strong>。</p><p>注：训练时生成的位置编码长度小于预测时的需要时，一种处理方法是使用<strong>插值</strong>将训练时的位置编码扩展到预测时所需的长度。</p><p>位置信息在语义分割中不是必需的</p><p>Mix-FFN：直接使用<strong>3*3卷积</strong>捕获一定程度上的位置信息</p><p>计算过程如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407101.png" alt="4" style="zoom:67%;"></p><p>注：$x_{in}$为自注意力模块的输出</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408906.png" alt="8"></p><p><strong>Overlapped Patch Merging:保持patch周围的局部连续性</strong></p><p>patch尺寸K、步长S、填充尺寸P，在网络中设置参了2套参数：<em>K</em> = 7, <em>S</em> = 4, <em>P</em> = 3 ；<em>K</em> = 3, <em>S</em> = 2, <em>P</em> = 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class OverlapPatchEmbed(nn.Layer):</span><br><span class="line">    def __init__(self,</span><br><span class="line">                 img_size=224,</span><br><span class="line">                 patch_size=7,          # 卷积核大小</span><br><span class="line">                 stride=4,                 # 下采样倍数</span><br><span class="line">                 in_chans=3,            # 输入通道数</span><br><span class="line">                 embed_dim=768):  # 输出通道数</span><br><span class="line">        super().__init__()</span><br><span class="line">        img_size = to_2tuple(img_size)</span><br><span class="line">        patch_size = to_2tuple(patch_size)</span><br><span class="line"></span><br><span class="line">        self.img_size = img_size</span><br><span class="line">        self.patch_size = patch_size</span><br><span class="line">        self.H, self.W = img_size[0] // patch_size[0], img_size[</span><br><span class="line">            1] // patch_size[1]</span><br><span class="line">        self.num_patches = self.H * self.W</span><br><span class="line">        # 定义投影变换所用的卷积</span><br><span class="line">        self.proj = nn.Conv2D(</span><br><span class="line">            in_chans,</span><br><span class="line">            embed_dim,</span><br><span class="line">            kernel_size=patch_size,</span><br><span class="line">            stride=stride,</span><br><span class="line">            padding=(patch_size[0] // 2, patch_size[1] // 2))</span><br><span class="line">        # 定义layer norm层</span><br><span class="line">        self.norm = nn.LayerNorm(embed_dim)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        x = self.proj(x)    # 通过卷积进行特征重投影，实现下采样、通道变换</span><br><span class="line">        x_shape = paddle.shape(x)</span><br><span class="line">        H, W = x_shape[2], x_shape[3]</span><br><span class="line">        x = x.flatten(2).transpose([0, 2, 1])  # 将H*W维度压缩成1个维度</span><br><span class="line">        x = self.norm(x)          # 标准化</span><br><span class="line"></span><br><span class="line">        return x, H, W</span><br></pre></td></tr></table></figure><p><strong>解码器</strong></p><p><strong>Lightweight All-MLP Decoder</strong>：在解码器部分，SegFormer采用了简单的结构，仅由MLP组成</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310212052806.jpg" alt="6" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408838.png" alt="5" style="zoom: 80%;"></p><p><strong>有效感受野分析</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408040.png" alt="7" style="zoom:80%;"></p><p>如图3的放大图所示，MLP头部(蓝框)的ERF与阶段4(红框)不同，除了非局部注意外，局部注意明显更强。</p><p>在上采样阶段，Head的感受野除了具有非局部关注外，还有较强的局部关注。</p><p>作者认为之所以这种简单的Decoder能够很好地工作，关键在于分层的Transformer Encoder比传统的基于CNN的Encoder具有更大的感受野。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408701.png" alt="9" style="zoom:80%;"></p><h3 id="2-实验结果"><a href="#2-实验结果" class="headerlink" title="2.实验结果"></a>2.实验结果</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408211.png" alt="10" style="zoom: 67%;"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MISSFormer</title>
      <link href="/posts/d6b0e04e.html"/>
      <url>/posts/d6b0e04e.html</url>
      
        <content type="html"><![CDATA[<h2 id="MISSFormer"><a href="#MISSFormer" class="headerlink" title="MISSFormer"></a>MISSFormer</h2><p><strong>论文：《MISSFormer: An Effective Medical Image Segmentation Transformer》（TMI2022）</strong></p><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404731.png" alt="1"></p><p><strong>编码器</strong>由Overlap Patch Embedding、Overlap Patch Merging以及Transformer Block with ReMix-FFN组成。</p><p><strong>EMix-FFN:</strong>在Enhanced Mix块中引入递归跳跃连接，给定输入特征映射xin，应用深度卷积层捕获局部上下文，然后进行递归跳跃连接</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404884.png" alt="2"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404240.png" alt="5" style="zoom: 80%;"></p><p><strong>Enhanced Transformer Context Bridge来捕获不同尺度特征的局部和全局相关性</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404308.png" alt="3" style="zoom: 50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404818.png" alt="4" style="zoom:50%;"></p><p>步骤：</p><p>1.将编码器生成的多尺度的特征的h、w，变成一个序列</p><p>2.将四个输出拼接到一起</p><p>3.对拼接后的结果进行注意力的计算</p><p>4.自注意力输出的结果和输出拼接的结果进行跳跃连接，然后进行层归一化</p><p>5.把归一化的结果再分成四个输出</p><p>6.将这四个输出再进行EMix-FFN</p><p>7.将四个输出的N（h*w)拼接到一起,再与归一化的结果进行跳跃连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class BridgeLayer_4(nn.Module):</span><br><span class="line">    def __init__(self, dims, head, reduction_ratios):</span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">        self.norm1 = nn.LayerNorm(dims)</span><br><span class="line">        self.attn = M_EfficientSelfAtten(dims, head, reduction_ratios)</span><br><span class="line">        self.norm2 = nn.LayerNorm(dims)</span><br><span class="line">        self.mixffn1 = MixFFN_skip(dims,dims*4)</span><br><span class="line">        self.mixffn2 = MixFFN_skip(dims*2,dims*8)</span><br><span class="line">        self.mixffn3 = MixFFN_skip(dims*5,dims*20)</span><br><span class="line">        self.mixffn4 = MixFFN_skip(dims*8,dims*32)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    def forward(self, inputs):</span><br><span class="line">        B = inputs[0].shape[0]</span><br><span class="line">        C = 64</span><br><span class="line">        if (type(inputs) == list):</span><br><span class="line">            # print(&quot;-----1-----&quot;)</span><br><span class="line">            c1, c2, c3, c4 = inputs</span><br><span class="line">            B, C, _, _= c1.shape</span><br><span class="line">            c1f = c1.permute(0, 2, 3, 1).reshape(B, -1, C)  # 3136*64</span><br><span class="line">            c2f = c2.permute(0, 2, 3, 1).reshape(B, -1, C)  # 1568*64</span><br><span class="line">            c3f = c3.permute(0, 2, 3, 1).reshape(B, -1, C)  # 980*64</span><br><span class="line">            c4f = c4.permute(0, 2, 3, 1).reshape(B, -1, C)  # 392*64</span><br><span class="line">            </span><br><span class="line">            # print(c1f.shape, c2f.shape, c3f.shape, c4f.shape)</span><br><span class="line">            inputs = torch.cat([c1f, c2f, c3f, c4f], -2)</span><br><span class="line">        else:</span><br><span class="line">            B,_,C = inputs.shape </span><br><span class="line"></span><br><span class="line">        tx1 = inputs + self.attn(self.norm1(inputs))</span><br><span class="line">        tx = self.norm2(tx1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        tem1 = tx[:,:3136,:].reshape(B, -1, C) </span><br><span class="line">        tem2 = tx[:,3136:4704,:].reshape(B, -1, C*2)</span><br><span class="line">        tem3 = tx[:,4704:5684,:].reshape(B, -1, C*5)</span><br><span class="line">        tem4 = tx[:,5684:6076,:].reshape(B, -1, C*8)</span><br><span class="line"></span><br><span class="line">        m1f = self.mixffn1(tem1, 56, 56).reshape(B, -1, C)</span><br><span class="line">        m2f = self.mixffn2(tem2, 28, 28).reshape(B, -1, C)</span><br><span class="line">        m3f = self.mixffn3(tem3, 14, 14).reshape(B, -1, C)</span><br><span class="line">        m4f = self.mixffn4(tem4, 7, 7).reshape(B, -1, C)</span><br><span class="line"></span><br><span class="line">        t1 = torch.cat([m1f, m2f, m3f, m4f], -2)</span><br><span class="line">        </span><br><span class="line">        tx2 = tx1 + t1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return tx2</span><br></pre></td></tr></table></figure><p><strong>上下文桥循环了四次：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class BridegeBlock_4(nn.Module):   #这是MISSFormer模型图中，上下文桥循环四次的代码</span><br><span class="line">    def __init__(self, dims, head, reduction_ratios):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.bridge_layer1 = BridgeLayer_4(dims, head, reduction_ratios) #定义上下文桥</span><br><span class="line">        self.bridge_layer2 = BridgeLayer_4(dims, head, reduction_ratios) </span><br><span class="line">        self.bridge_layer3 = BridgeLayer_4(dims, head, reduction_ratios) </span><br><span class="line">        self.bridge_layer4 = BridgeLayer_4(dims, head, reduction_ratios) </span><br><span class="line"></span><br><span class="line">    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:</span><br><span class="line">        bridge1 = self.bridge_layer1(x)    #输入数据至第一个上下文桥，得到第一个输出</span><br><span class="line">        bridge2 = self.bridge_layer2(bridge1)#将上一个输出输入至第二个上下文桥</span><br><span class="line">        bridge3 = self.bridge_layer3(bridge2)#将上一个输出输入至第三个上下文桥</span><br><span class="line">        bridge4 = self.bridge_layer4(bridge3)#将上一个输出输入至第四个上下文桥</span><br><span class="line"></span><br><span class="line">        B,_,C = bridge4.shape  #提取B和C大小</span><br><span class="line">        outs = []              #建立空列表，存储输出结果</span><br><span class="line"></span><br><span class="line">        sk1 = bridge4[:,:3136,:].reshape(B, 56, 56, C).permute(0,3,1,2)      #输出转换为二维形式</span><br><span class="line">        sk2 = bridge4[:,3136:4704,:].reshape(B, 28, 28, C*2).permute(0,3,1,2) </span><br><span class="line">        sk3 = bridge4[:,4704:5684,:].reshape(B, 14, 14, C*5).permute(0,3,1,2) </span><br><span class="line">        sk4 = bridge4[:,5684:6076,:].reshape(B, 7, 7, C*8).permute(0,3,1,2) </span><br><span class="line"></span><br><span class="line">        outs.append(sk1)  #将结果存储到列表中</span><br><span class="line">        outs.append(sk2)</span><br><span class="line">        outs.append(sk3)</span><br><span class="line">        outs.append(sk4)</span><br><span class="line"></span><br><span class="line">        return outs</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404365.png" alt="6"></p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404746.png" alt="7"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用类</title>
      <link href="/posts/df13c63f.html"/>
      <url>/posts/df13c63f.html</url>
      
        <content type="html"><![CDATA[<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="1-Object类"><a href="#1-Object类" class="headerlink" title="1.Object类"></a>1.Object类</h3><h4 id="1-1-clone方法"><a href="#1-1-clone方法" class="headerlink" title="1.1 clone方法"></a>1.1 clone方法</h4><p><strong>clone方法：</strong>clone方法执行的是浅拷贝</p><p><em>注：<strong>clone方法</strong>创建了一个新对象，但这个新对象和原始对象的引用变量相同（浅拷贝）。</em></p><p><strong>验证clone方法是浅拷贝的：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 声明静态内部类 Body，实现 Cloneable 接口以支持克隆</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Body</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Head head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Body</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Body</span><span class="params">(Head head)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.head = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">            <span class="comment">// 调用父类的 clone 方法以执行浅拷贝</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明静态内部类 Head，这个类不需要克隆功能</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Head</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Head</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个 Body 对象，并将其关联的 Head 对象初始化</span></span><br><span class="line">        <span class="type">Body</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Body</span>(<span class="keyword">new</span> <span class="title class_">Head</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用克隆方法复制 Body 对象，得到一个新的 Body 对象 body1</span></span><br><span class="line">        <span class="type">Body</span> <span class="variable">body1</span> <span class="operator">=</span> (Body) body.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查两个对象是否相同</span></span><br><span class="line">        System.out.println(<span class="string">&quot;body == body1 : &quot;</span> + (body == body1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查两个对象的 head 属性是否相同（因为是浅拷贝，所以 head 属性相同）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;body.head == body1.head : &quot;</span> + (body.head == body1.head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">body == body1 : <span class="literal">false</span></span><br><span class="line">body.head == body1.head : <span class="literal">true</span><span class="comment">//新对象和原对象共享相同的引用对象,故clone方法执行的是浅拷贝</span></span><br></pre></td></tr></table></figure><h4 id="1-2-toString-方法"><a href="#1-2-toString-方法" class="headerlink" title="1.2 toString()方法"></a>1.2 toString()方法</h4><p>Object 类的 toString 方法返回一个字符串，该字符串由类名、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。</p><p><em>注：通常情况下，<strong>应重写 <code>toString()</code> 方法</strong>，以便返回一个更有意义的、描述对象状态的字符串。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;, age=&quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 toString() 方法输出对象的字符串表示形式</span></span><br><span class="line">        System.out.println(person.toString()); <span class="comment">// 输出：Person&#123;name=&#x27;Alice&#x27;, age=30&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Alice&#x27;</span>, age=<span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-getClass-方法"><a href="#1-3-getClass-方法" class="headerlink" title="1.3 getClass()方法"></a>1.3 getClass()方法</h4><p><strong>getClass()方法：</strong>返回对象的运行时类，所有 Java 类都继承了这个方法，不可重写，要调用的话，一般和getName()联合使用，如getClass().getName()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetClassExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        <span class="comment">// 使用 getClass() 方法获取对象的运行时类</span></span><br><span class="line">        Class&lt;?&gt; cls = vehicle.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出类的名称</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName()); <span class="comment">// 输出：Class name: Car</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Class name: Car</span><br></pre></td></tr></table></figure><h4 id="1-4-equals-方法"><a href="#1-4-equals-方法" class="headerlink" title="1.4 equals()方法"></a>1.4 equals()方法</h4><p> Object中的equals方法是直接判断this和obj本身的值是否相等,如果this和obj指向的是同一块内存对象，则返回true,如果</p><p>this和obj指向的不是同一块内存，则返回false。</p><p><em>注：即便是内容完全相等的两块不同的内存对象，也返回false。</em></p><p>String类已经重写了object中的equals方法（比较内容是否相等）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">// 输出：true，内容相同</span></span><br><span class="line">System.out.println(str1.equals(str3)); <span class="comment">// 输出：true，内容相同</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="1-5-wait-方法"><a href="#1-5-wait-方法" class="headerlink" title="1.5 wait()方法"></a>1.5 wait()方法</h4><p>pass</p><h4 id="1-6-notify-方法"><a href="#1-6-notify-方法" class="headerlink" title="1.6  notify()方法"></a>1.6  notify()方法</h4><p>pass</p><h3 id="2-包装类"><a href="#2-包装类" class="headerlink" title="2.包装类"></a>2.包装类</h3><p>基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用,故Java为每种基本数据类型分别设计了对应的类，称之为<strong>包装类</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201401558.png" alt="1" style="zoom: 67%;"></p><h4 id="自动拆箱和装箱"><a href="#自动拆箱和装箱" class="headerlink" title="自动拆箱和装箱"></a>自动拆箱和装箱</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">500</span>;            <span class="comment">// 创建一个基本数据类型变量 m 并赋值为 500</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> m;        <span class="comment">// 自动装箱：将基本数据类型 m 装箱为 Integer 对象 obj</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obj;            <span class="comment">// 自动拆箱：将 Integer 对象 obj 拆箱为基本数据类型 n</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n = &quot;</span> + n);  <span class="comment">// 输出 n 的值</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="number">500</span>;     <span class="comment">// 创建一个 Integer 对象 obj1 并初始化为 500</span></span><br><span class="line">        System.out.println(<span class="string">&quot;obj 等价于 obj1？&quot;</span> + obj.equals(obj1));  <span class="comment">// 比较 obj 和 obj1 是否相等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">n = <span class="number">500</span></span><br><span class="line">obj 等价于 obj1？<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><em>注：所有的包装类（Integer、Long、Byte、Double、Float、Short）都是<strong>抽象类 Number</strong> 的子类。</em></p><h3 id="3-String类"><a href="#3-String类" class="headerlink" title="3.String类"></a>3.String类</h3><h4 id="3-1-创建字符串对象方式"><a href="#3-1-创建字符串对象方式" class="headerlink" title="3.1 创建字符串对象方式"></a>3.1 创建字符串对象方式</h4><p><strong>String类对象一旦声明则不可以改变，而改变的只是地址，原来的字符串还是存在的，并且产生垃圾。</strong></p><p><strong>直接赋值方式：</strong>创建对象是在方法区的<strong>常量池</strong></p><p><code>String str=&quot;hello&quot;;//直接赋值的方式</code></p><p><strong>构造方法：</strong>通过构造方法创建字符串对象是在<strong>堆内存</strong></p><p><code>String str=new String(&quot;hello&quot;);//实例化的方式</code></p><p><strong>两种实例化方式的比较:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Lance&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Lance&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;Lance&quot;</span>;</span><br><span class="line"><span class="comment">//String类对象==比较，比较的是地址，而不是内容</span></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str1==str3);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3==str2);<span class="comment">//true</span></span><br><span class="line">System.out.println(str1==str4);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//str1和str4引用的是字符串常量池中的同一个对象，因此它们的引用相等</span></span><br></pre></td></tr></table></figure><h4 id="3-2-字符串常量池"><a href="#3-2-字符串常量池" class="headerlink" title="3.2 字符串常量池"></a>3.2 字符串常量池</h4><p>​       在字符串中，如果采用直接赋值的方式（String str=”Lance”）进行对象的实例化，则会将匿名对象“Lance”放入对象池，每当下一次对不同的对象进行直接赋值的时候会直接利用池中原有的匿名对象</p><p><strong>两种实例化方式的区别:</strong></p><p><strong>直接赋值（String str = “hello”）：</strong>只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。</p><p><strong>构造方法（String str= new String(“hello”)）:</strong>连续两次new一个String对象，会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过public String intern();方法进行手工入池。</p><p><em>注：在开发的过程中不会采用构造方法进行字符串的实例化</em></p><h4 id="3-3-空指向异常"><a href="#3-3-空指向异常" class="headerlink" title="3.3 空指向异常"></a>3.3 空指向异常</h4><p><strong>equals</strong>比较的是字符串内容，在开发的过程中，equals()通过接受参数，可以避免空指向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(str.equals(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//此时会出现空指向异常 ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;hello&quot;</span>.equals(str))</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//此时equals会处理null值，可以避免空指向异常 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-StringBuilder-和-StringBuffer"><a href="#4-StringBuilder-和-StringBuffer" class="headerlink" title="4.StringBuilder 和 StringBuffer"></a>4.StringBuilder 和 StringBuffer</h3><p>pass</p><h3 id="5-File类"><a href="#5-File类" class="headerlink" title="5.File类"></a>5.File类</h3><p>pass</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法</title>
      <link href="/posts/ea538f2a.html"/>
      <url>/posts/ea538f2a.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h2><h3 id="1-浮点型拓展"><a href="#1-浮点型拓展" class="headerlink" title="1.浮点型拓展"></a>1.浮点型拓展</h3><h4 id="1-1浮点类型的舍入误差"><a href="#1-1浮点类型的舍入误差" class="headerlink" title="1.1浮点类型的舍入误差"></a>1.1浮点类型的舍入误差</h4><p>浮点类型<strong>float, double</strong>的数据不适合在<strong>不容许舍入误差</strong>的领域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 定义一个float类型变量f并赋值为0.1</span><br><span class="line">        float f = 0.1f;</span><br><span class="line"></span><br><span class="line">        // 定义一个double类型变量d并赋值为1.0除以10，即0.1</span><br><span class="line">        double d = 1.0 / 10;</span><br><span class="line">        System.out.println(f == d); // 输出：false，由于精度差异，比较结果为false</span><br><span class="line">        float d1 = 2131231231f;</span><br><span class="line"></span><br><span class="line">        // 定义一个float类型变量d2，将d1加1后的结果赋值给d2</span><br><span class="line">        float d2 = d1 + 1;</span><br><span class="line">        System.out.println(&quot;d1=&quot;+d1);</span><br><span class="line">        System.out.println(&quot;d2=&quot;+d2);</span><br><span class="line">        // 检查d1是否等于d2</span><br><span class="line">        if (d1 == d2) &#123;</span><br><span class="line">            // 如果d1等于d2，输出&quot;d1==d2&quot;</span><br><span class="line">            System.out.println(&quot;d1==d2&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果d1不等于d2，输出&quot;d1!=d2&quot;</span><br><span class="line">            System.out.println(&quot;d1!=d2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">false</span><br><span class="line">d1=2.13123123E9</span><br><span class="line">d2=2.13123123E9</span><br><span class="line">d1==d2</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p><em>1.浮点数一般都存在舍入误差，很多数字无法精确表示，其结果只能是接近，但不等于。</em></p><p><strong><em>2.避免比较中使用浮点数</em></strong></p><p><em>3.需要进行不产生舍入误差的精确数字计算，需要使用<strong>BigDecimal</strong>类</em></p><h4 id="1-2-BigDecimal类"><a href="#1-2-BigDecimal类" class="headerlink" title="1.2 BigDecimal类"></a><strong>1.2 BigDecimal类</strong></h4><p><strong>BigDecimal类：</strong>用于高精度数值运算的类，它允许你精确地表示和执行各种数学运算，包括加法、减法、乘法、除法等，而不会丢失精度。</p><p><strong>常用方法：</strong></p><p>1.BigDecimal(String val)：构造方法，将String类型转换成BigDecimal类型数据。</p><p>2.BigDecimal(double val)：构造方法，将double类型转换成BigDecimal类型数据。</p><p>3.BigDecimal(int val)：构造方法，将int类型转换成BigDecimal类型数据。</p><p>4.BigDecimal add(BigDecimal value)：加法，求两个BigDecimal类型数据的和。</p><p>5.BigDecimal subtract(BigDecimal value)：减法，求两个BigDecimal类型数据的差。</p><p>6.BigDecimal multiply(BigDecimal  value)：乘法，求两个BigDecimal类型数据的积。</p><p>7.BigDecimal divide(BigDecimal divisor)：除法，求两个BigDecimal类型数据的商。</p><p>8.BigDecimal remainder(BigDecimal divisor)：求余数，求BigDecimal类型数据除以divisor的余数。</p><p>9.BigDecimal max(BigDecimal value)：最大数，求两个BigDecimal类型数据的最大值。</p><p>10.BigDecimal min(BigDecimal value)：最小数，求两个BigDecimal类型数据的最小值。</p><p>11.BigDecimal abs()：绝对值，求BigDecimal类型数据的绝对值。</p><p>12.BigDecimal negate()：相反数，求BigDecimal类型数据的相反数。</p><p>13.BigDecimal compareTo()：比较两个BigDecimal 对象的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.math.BigDecimal;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal num1 = new BigDecimal(&quot;0.1&quot;);//字符串带双引号被解释为确切的数值,若不加会存在一个微小的舍入误差</span><br><span class="line">        BigDecimal num2 = new BigDecimal(&quot;0.2&quot;);</span><br><span class="line">        BigDecimal num3=num1.multiply(new BigDecimal(&quot;2&quot;));</span><br><span class="line">        BigDecimal sum = num1.add(num2);</span><br><span class="line">        System.out.println(num3.compareTo(num2));</span><br><span class="line">        System.out.println(&quot;sum=&quot;+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">0</span><br><span class="line">sum=0.3</span><br></pre></td></tr></table></figure><h3 id="2-Scanner对象"><a href="#2-Scanner对象" class="headerlink" title="2.Scanner对象"></a>2.Scanner对象</h3><h4 id="2-1-创建-Scanner-对象的基本语法："><a href="#2-1-创建-Scanner-对象的基本语法：" class="headerlink" title="2.1 创建 Scanner 对象的基本语法："></a>2.1 创建 Scanner 对象的基本语法：</h4><p><code>Scanner s = new Scanner(System.in)</code></p><p>通过 Scanner 类的 <strong>next()</strong> 或<strong>nextLine()</strong> 方法获取输入的字符串</p><p>读取前一般需要使用 <strong>hasNext()</strong> 或<strong>hasNextLine()</strong> 判断是否还有输入的数据</p><h4 id="2-2-next-amp-nextLine"><a href="#2-2-next-amp-nextLine" class="headerlink" title="2.2 next &amp; nextLine"></a>2.2 next &amp; nextLine</h4><p>使用<strong>next方式</strong>接收一下输入的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext()) &#123;</span><br><span class="line">            String token = scanner.next();</span><br><span class="line">            System.out.println(&quot;Next Token: &quot; + token);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in: </span><br><span class="line">hello world</span><br><span class="line">out:</span><br><span class="line">Next Token: hello</span><br><span class="line">Next Token: world</span><br></pre></td></tr></table></figure><p>使用<strong>nextLine方式</strong>接收一下输入的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNextLine()) &#123;</span><br><span class="line">            String token = scanner.nextLine();</span><br><span class="line">            System.out.println(&quot;Next Token: &quot; + token);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in:</span><br><span class="line">hello world</span><br><span class="line">out：</span><br><span class="line">Next Token: hello world</span><br></pre></td></tr></table></figure><p><strong>两者区别：</strong></p><p>1.next() 不能得到带有空格的字符串，nextLine()可以获得空白。</p><p>2.nextLine()：以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</p><h4 id="2-3-其他数据类型"><a href="#2-3-其他数据类型" class="headerlink" title="2.3 其他数据类型"></a>2.3 其他数据类型</h4><p>如果要输入int、float等类型的数据，在 Scanner 类中也有支持，使用<strong>hasNextXxx() 方法、 nextXxx() 方法</strong>来读取</p><h3 id="3-可变参数"><a href="#3-可变参数" class="headerlink" title="3.可变参数"></a>3.可变参数</h3><p><strong>可变参数的声明:</strong></p><p><code>typeName... parameterName</code></p><p><strong>注：一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Main&#123;</span><br><span class="line">    public static void printMax(double... num)&#123;</span><br><span class="line">        if(num.length==0)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;wrong!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        double result=0;</span><br><span class="line">        for (int i = 1; i &lt; num.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (num[i] &gt; result)</span><br><span class="line">            &#123; result = num[i]; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num[num.length-1]);</span><br><span class="line">    &#125;;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        printMax(1,2.3,5.0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">5.0</span><br></pre></td></tr></table></figure><h3 id="4-Arrays-类"><a href="#4-Arrays-类" class="headerlink" title="4.Arrays 类"></a>4.Arrays 类</h3><p>数组的工具类<strong>java.util.Arrays</strong></p><p><strong>常用功能：</strong></p><h4 id="4-1-打印数组"><a href="#4-1-打印数组" class="headerlink" title="4.1 打印数组"></a>4.1 打印数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        int []num=new int[10];</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            num[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure><h4 id="4-2-数组排序"><a href="#4-2-数组排序" class="headerlink" title="4.2 数组排序"></a>4.2 数组排序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        int []num= &#123;5,8,9,4,2&#125;;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        System.out.println(Arrays.toString(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[2, 4, 5, 8, 9]</span><br></pre></td></tr></table></figure><h4 id="4-3-二分法查找"><a href="#4-3-二分法查找" class="headerlink" title="4.3 二分法查找"></a>4.3 二分法查找</h4><p><strong>在进行此调用之前对数组进行排序(通 过sort方法等)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        int []num= &#123;5,8,9,4,2&#125;;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        System.out.println(&quot;索引为：&quot;+Arrays.binarySearch(num,4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">索引为：1</span><br></pre></td></tr></table></figure><h4 id="4-4-将数组转换成List集合"><a href="#4-4-将数组转换成List集合" class="headerlink" title="4.4 将数组转换成List集合"></a>4.4 将数组转换成List集合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int []num= &#123;5,2,9,4,2,3,10&#125;;</span><br><span class="line">List&lt;int[]&gt; list= Arrays.asList(num);</span><br></pre></td></tr></table></figure><h3 id="5-内部类"><a href="#5-内部类" class="headerlink" title="5.内部类"></a>5.内部类</h3><h4 id="5-1-成员内部类"><a href="#5-1-成员内部类" class="headerlink" title="5.1 成员内部类"></a>5.1 成员内部类</h4><p><strong>实例化内部类，首先需要实例化外部类，通过外部类去调用内部类</strong></p><p><em>注：成员内部类中不能写静态属性和方法</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ppublic class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1.实例化外部类</span><br><span class="line">        Outer out=new Outer();</span><br><span class="line">        //2.通过外部类调用内部类</span><br><span class="line">        Outer.Inner inObject = out.new Inner();</span><br><span class="line">        inObject.In();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Outer&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    public void out()&#123;</span><br><span class="line">        System.out.println(&quot;外部类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Outer()</span><br><span class="line">    &#123;</span><br><span class="line">        id=10;</span><br><span class="line">    &#125;</span><br><span class="line">    class Inner&#123;</span><br><span class="line">        private int id;</span><br><span class="line">        public void In()&#123;</span><br><span class="line">            System.out.println(&quot;内部类&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Inner()&#123;</span><br><span class="line">            id=1;</span><br><span class="line">            System.out.println(&quot;外部：&quot;+Outer.this.id);//Outer.this.显式调用外部类的变量</span><br><span class="line">            System.out.println(&quot;内部：&quot;+id);//内部类中的变量会暂时将外部类的成员变量给隐藏</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out：</span><br><span class="line">外部：10</span><br><span class="line">内部：1</span><br><span class="line">内部类</span><br></pre></td></tr></table></figure><h4 id="5-2-静态内部类"><a href="#5-2-静态内部类" class="headerlink" title="5.2 静态内部类"></a>5.2 静态内部类</h4><p>静态内部类能够直接被外部类给实例化，不需要使用外部类对象</p><p><strong>静态内部类只能访问自己属性和方法及外部类的静态属性和方法</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private static int outerStaticField = 42;</span><br><span class="line"></span><br><span class="line">    // 静态内部类</span><br><span class="line">    public static class StaticInnerClass &#123;</span><br><span class="line">        private int innerField;</span><br><span class="line"></span><br><span class="line">        public StaticInnerClass(int innerField) &#123;</span><br><span class="line">            this.innerField = innerField;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void printValues() &#123;</span><br><span class="line">            System.out.println(&quot;Outer static field: &quot; + outerStaticField);</span><br><span class="line">            System.out.println(&quot;Inner field: &quot; + innerField);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建静态内部类的实例</span><br><span class="line">        StaticInnerClass innerObj = new StaticInnerClass(10);</span><br><span class="line">        // 调用静态内部类的方法</span><br><span class="line">        innerObj.printValues();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-局部内部类"><a href="#5-3-局部内部类" class="headerlink" title="5.3 局部内部类"></a>5.3 局部内部类</h4><p><strong>局部内部类是在一个方法内部声明的一个类</strong></p><p>在局部内部类中，如果要<strong>访问局部变量</strong>，那么该<strong>局部变量</strong>要用<strong>final修饰</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class LocalInnerClassTest &#123;</span><br><span class="line">    // 外部类的成员变量</span><br><span class="line">    private String name;</span><br><span class="line">    private static int age;</span><br><span class="line">    LocalInnerClassTest(String name,int age)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">        this.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 外部类的实例方法</span><br><span class="line">    public void run() &#123;&#125;</span><br><span class="line">    // 外部类的静态方法</span><br><span class="line">    public static void go() &#123;&#125;</span><br><span class="line">    // 外部类的实例方法，包含局部内部类的定义</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        // 定义一个 final 局部变量</span><br><span class="line">        final String myname = &quot;xxx&quot;;</span><br><span class="line">        // 定义局部内部类 LocalInnerClass</span><br><span class="line">        class LocalInnerClass &#123;</span><br><span class="line">            // 局部内部类的成员变量</span><br><span class="line">            private String name;</span><br><span class="line">            // 局部内部类的方法，接受一个参数 name</span><br><span class="line">            public void test(String name) &#123;</span><br><span class="line">                // 在方法中访问参数 name</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                // 在局部内部类的成员方法中，可以使用 this 关键字访问局部内部类的成员变量</span><br><span class="line">                System.out.println(this.name);</span><br><span class="line">                // 在局部内部类中访问外部方法中的 final 变量 myname</span><br><span class="line">                System.out.println(myname);</span><br><span class="line">                // 在局部内部类中访问外部类的成员变量 name</span><br><span class="line">                System.out.println(LocalInnerClassTest.this.name);</span><br><span class="line">                // 在局部内部类中调用外部类的实例方法 run()</span><br><span class="line">                LocalInnerClassTest.this.run();</span><br><span class="line">                // 在局部内部类中调用外部类的静态方法 go()</span><br><span class="line">                LocalInnerClassTest.go();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 创建局部内部类的实例</span><br><span class="line">        LocalInnerClass lic = new LocalInnerClass();</span><br><span class="line">        // 修改局部内部类的成员变量 name</span><br><span class="line">        lic.name = &quot;tom&quot;;</span><br><span class="line">        // 调用局部内部类的方法 test()，传入参数 &quot;test&quot;</span><br><span class="line">        lic.test(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalInnerClassTest inner=new LocalInnerClassTest(&quot;wang&quot;,22);</span><br><span class="line">        inner.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">test</span><br><span class="line">tom</span><br><span class="line">xxx</span><br><span class="line">wang</span><br></pre></td></tr></table></figure><p><em>注：局部内部类不能通过外部类对象直接实例化，而是在方法中实例化出自己来，然后通过内部类对象调用自己类中的方法。</em></p><h4 id="5-4-匿名内部类"><a href="#5-4-匿名内部类" class="headerlink" title="5.4 匿名内部类"></a>5.4 匿名内部类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个接口</span><br><span class="line">interface Greeting &#123;</span><br><span class="line">    void greet();</span><br><span class="line">&#125;</span><br><span class="line">public class AnonymousInnerClassExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 使用匿名内部类创建实现 Greeting 接口并调用greet方法</span><br><span class="line">        new Greeting() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void greet() &#123;</span><br><span class="line">                System.out.println(&quot;Hello, world!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.greet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟环境命令</title>
      <link href="/posts/37951873.html"/>
      <url>/posts/37951873.html</url>
      
        <content type="html"><![CDATA[<p><strong>1.查看虚拟环境</strong><br>conda info —envs<br><strong>2.查看虚拟环境的Python版本</strong><br>python —version<br><strong>3.创建虚拟环境</strong><br>conda create —name 环境名<br><strong>4.激活环境</strong><br>conda activate 环境名<br><strong>5.使用pip下载特定版本的Python包</strong><br>pip install package_name==version_number<br><strong>6.查看虚拟环境中有哪些包</strong><br>conda list -n <env_name><br><strong>7.创建虚拟环境并安装python所需要的版本</strong><br>conda create -n your_env_name python=x.x<br><strong>8.删除虚拟环境</strong><br>conda env remove -n pytorch_env<br><strong>9.pip指定环境安装包</strong><br>pip install —target=/Anaconda/envs/env_name/Lib/site-packages -r requirements.txt</env_name></p>]]></content>
      
      
      <categories>
          
          <category> 模型训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模型训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNeXt</title>
      <link href="/posts/260cf31a.html"/>
      <url>/posts/260cf31a.html</url>
      
        <content type="html"><![CDATA[<h2 id="UNeXt"><a href="#UNeXt" class="headerlink" title="UNeXt"></a>UNeXt</h2><h3 id="1-网络设计"><a href="#1-网络设计" class="headerlink" title="1.网络设计"></a>1.网络设计</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411246.png" alt="1" style="zoom: 67%;"></p><p>分成卷积阶段、标记化MLP阶段</p><p>编码器：进行两倍的下采样（2×2的最大池化层）</p><p>解码器：进行两倍的上采样（双线性插值），使用双线性插值而不是转置卷积，因为转置卷积基本上是可学习的上采样，会增加更多可学习参数。</p><p>C为超参数，一般取C1=32、C2=64、C3=128、C4=160、C5=256(C的取值比UNet小，<strong>减少了参数和计算</strong>)</p><p><strong>注：充分考虑了模型维度对参数量和计算量的影响，采用了更少的参数设计</strong></p><p><strong>卷积阶段：</strong>每个卷积块配备了一个卷积层、一个批量归一化层和ReLU激活函数，使用3×3的卷积核大小，步幅为1，填充为1，用于保持特征图的空间分辨率不变，同时允许网络学习提取不同位置的特征信息。</p><p><strong>Tokenized MLP Stage：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411888.png" alt="2" style="zoom:67%;"></p><p>​    <strong>Conv:</strong>kernel_size=3，stride=2，padding=1,同时输出通道数(E)大于输入通道数(E为超参数，token数量)，把特征图大小缩小了一半，增加了通道数</p><p>​    <strong>Shifted MLP：</strong>让模型更加关注 local 的信息</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411232.png" alt="3"></p><p>先使用0填充特征图，填充过后在通道维度做切割，再做平移操作，然后将各个切片合并在一起，最后提取特征图中间部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">xn = x.transpose(1, 2).view(B, C, H, W).contiguous()</span><br><span class="line">xn = F.pad(xn, (self.pad, self.pad, self.pad, self.pad) , &quot;constant&quot;, 0)</span><br><span class="line">xs = torch.chunk(xn, self.shift_size, 1)</span><br><span class="line">x_shift = [torch.roll(x_c, shift, 3) for x_c, shift in zip(xs, range(-self.pad, self.pad+1))]</span><br><span class="line">x_cat = torch.cat(x_shift, 1)</span><br><span class="line">x_cat = torch.narrow(x_cat, 2, self.pad, H)</span><br><span class="line">x_s = torch.narrow(x_cat, 3, self.pad, W)</span><br><span class="line">x_s = x_s.reshape(B,C,H*W).contiguous()</span><br><span class="line">x_shift_c = x_s.transpose(1,2)</span><br><span class="line">x = self.fc2(x_shift_c)</span><br><span class="line">x = self.drop(x)</span><br><span class="line">return x</span><br></pre></td></tr></table></figure><p>  <strong>DWConv：</strong>编码MLP特征的位置信息、减少运算量的作用</p><h3 id="2-实验结果及消融实验"><a href="#2-实验结果及消融实验" class="headerlink" title="2.实验结果及消融实验"></a>2.实验结果及消融实验</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411020.png" alt="4"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411855.png" alt="5"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++(3)</title>
      <link href="/posts/3446eac5.html"/>
      <url>/posts/3446eac5.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1.运算符"></a>1.运算符</h3><h4 id="1-1-单目运算符重载"><a href="#1-1-单目运算符重载" class="headerlink" title="1.1 单目运算符重载"></a>1.1 单目运算符重载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyNumber&#123;</span><br><span class="line">    private:</span><br><span class="line">        int value;</span><br><span class="line">    public:</span><br><span class="line">        MyNumber(int v):value(v)&#123;&#125;;</span><br><span class="line">        MyNumber&amp; operator++()//重载前置递增运算符++,前置递增运算符返回引用(允许修改原始对象并立即访问修改后的对象)</span><br><span class="line">        &#123;</span><br><span class="line">            value++;</span><br><span class="line">            return *this;</span><br><span class="line">        &#125;</span><br><span class="line">        MyNumber operator++(int)//重载后置递增运算符++，返回原始对象的副本，int 参数只是为了区分前置和后置递增运算符</span><br><span class="line">        &#123;</span><br><span class="line">            MyNumber temp(*this);</span><br><span class="line">            value++;</span><br><span class="line">            return temp;</span><br><span class="line">        &#125;</span><br><span class="line">        void display()</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;value:&quot;&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    MyNumber num(5);</span><br><span class="line">    MyNumber num2=num++;</span><br><span class="line">    num2.display();</span><br><span class="line">    num.display();</span><br><span class="line">    ++num;</span><br><span class="line">    num.display();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">value:5</span><br><span class="line">value:6</span><br><span class="line">value:7</span><br></pre></td></tr></table></figure><p><em>注：如果只想执行递增运算，可使用++ object，也可使用 object ++，但应选择前者，这样避免创建一个未被使用的临时拷贝。</em></p><h4 id="1-2-转换运算符"><a href="#1-2-转换运算符" class="headerlink" title="1.2 转换运算符"></a>1.2 转换运算符</h4><p><strong>转换运算符 const char* ：</strong>对象的内容转换成 cout 能够接受的类型（const char*）</p><p><strong>ostringstream：</strong>属于 <code>&lt;sstream&gt;</code> 头文件，并提供了将各种数据类型（如整数、浮点数、字符串等）转换为字符串的能力</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt; // 用于 ostringstream</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 自定义日期类</span><br><span class="line">class Date &#123;</span><br><span class="line">private:</span><br><span class="line">    int day, month, year;</span><br><span class="line">    string dateInString;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 构造函数，用于初始化日期对象</span><br><span class="line">    Date(int inMonth, int inDay, int inYear) : month(inMonth), day(inDay), year(inYear) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 类型转换运算符，将日期对象转换为 const char* 类型的指针</span><br><span class="line">    operator const char*() &#123;</span><br><span class="line">        ostringstream formattedDate; // 辅助构建字符串</span><br><span class="line">        formattedDate &lt;&lt; month &lt;&lt; &quot; / &quot; &lt;&lt; day &lt;&lt; &quot; / &quot; &lt;&lt; year;</span><br><span class="line">        dateInString = formattedDate.str();</span><br><span class="line">        return dateInString.c_str();//dateInString.c_str(),返回一个 const char* 类型的指针</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建日期对象，表示圣诞节的日期</span><br><span class="line">    Date Holiday(12, 25, 2016);</span><br><span class="line"></span><br><span class="line">    // 直接输出日期对象，由于重载了类型转换运算符，它将自动转换为字符串并输出</span><br><span class="line">    cout &lt;&lt; &quot;Holiday is on: &quot; &lt;&lt; Holiday &lt;&lt; endl;</span><br><span class="line">    // 下面是其他使用示例的注释部分</span><br><span class="line">    // string strHoliday(Holiday); // 可行!</span><br><span class="line">    // strHoliday = Date(11, 11, 2016); // 也是可行的!</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-双目运算符重载"><a href="#1-3-双目运算符重载" class="headerlink" title="1.3 双目运算符重载"></a>1.3 双目运算符重载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Complex &#123;</span><br><span class="line">private:</span><br><span class="line">    double real;</span><br><span class="line">    double imaginary;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Complex(double r, double i) : real(r), imaginary(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 重载加法运算符 +</span><br><span class="line">    Complex operator+(const Complex&amp; other) &#123;</span><br><span class="line">        double newReal = real + other.real;</span><br><span class="line">        double newImaginary = imaginary + other.imaginary;</span><br><span class="line">        return Complex(newReal, newImaginary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打印复数的成员函数</span><br><span class="line">    void display() &#123;</span><br><span class="line">        std::cout &lt;&lt; real &lt;&lt; &quot; + &quot; &lt;&lt; imaginary &lt;&lt; &quot;i&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Complex num1(3.0, 4.0);</span><br><span class="line">    Complex num2(1.0, 2.0);</span><br><span class="line"></span><br><span class="line">    Complex sum = num1 + num2; // 使用重载的 + 运算符</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Sum: &quot;;</span><br><span class="line">    sum.display();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Sum: 4 + 6i</span><br></pre></td></tr></table></figure><h4 id="1-4-重载下标运算符"><a href="#1-4-重载下标运算符" class="headerlink" title="1.4 重载下标运算符"></a>1.4 重载下标运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyArray &#123;</span><br><span class="line">private:</span><br><span class="line">    int arr[10]; // 假设数组大小为 10</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 重载下标运算符 []</span><br><span class="line">    int&amp; operator[](int index) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt;= 10) &#123;</span><br><span class="line">            throw std::out_of_range(&quot;Index out of range&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyArray myArray;</span><br><span class="line"></span><br><span class="line">    // 初始化数组元素</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        myArray[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用下标运算符 [] 访问数组元素并输出</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;myArray[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; myArray[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">myArray[0] = 0</span><br><span class="line">myArray[1] = 1</span><br><span class="line">myArray[2] = 2</span><br><span class="line">myArray[3] = 3</span><br><span class="line">myArray[4] = 4</span><br><span class="line">myArray[5] = 5</span><br><span class="line">myArray[6] = 6</span><br><span class="line">myArray[7] = 7</span><br><span class="line">myArray[8] = 8</span><br><span class="line">myArray[9] = 9</span><br></pre></td></tr></table></figure><h4 id="1-5-函数运算符-operator"><a href="#1-5-函数运算符-operator" class="headerlink" title="1.5 函数运算符 operator()"></a>1.5 函数运算符 operator()</h4><p><strong>operator()</strong>让对象像函数，被称为函数运算符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义一个类 Display</span><br><span class="line">class Display &#123;</span><br><span class="line">public:</span><br><span class="line">    // 重载函数调用运算符 ()，用于输出传入的字符串</span><br><span class="line">    void operator () (string input) const &#123;//const: 这个关键字表示该运算符函数是一个常量成员函数，告诉编译器在函数内部不会修改对象的状态。</span><br><span class="line">        cout &lt;&lt; input &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    // 创建 Display 类的对象 displayFuncObj</span><br><span class="line">    Display displayFuncObj;</span><br><span class="line">    // 使用函数调用运算符 () 调用 displayFuncObj，传入字符串参数</span><br><span class="line">    displayFuncObj(&quot;Display this string! &quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Display this string!</span><br></pre></td></tr></table></figure><h3 id="2-类型转换运算符"><a href="#2-类型转换运算符" class="headerlink" title="2.类型转换运算符"></a>2.类型转换运算符</h3><h4 id="2-1-static-cast"><a href="#2-1-static-cast" class="headerlink" title="2.1 static_cast"></a>2.1 static_cast</h4><p><strong>static_cast:</strong>显式地将一种数据类型转换为另一种数据类型,在执行转换时会进行<strong>编译时</strong>类型检查，以确保类型转换是合法的。</p><p><strong>static_cast</strong>的语法如下：</p><p><code>new_type static_cast&lt;new_type&gt;(expression)</code></p><p>其中：</p><ul><li><code>new_type</code> 表示要进行的目标类型（目标数据类型）。</li><li><code>expression</code> 是要转换的表达式或值。</li></ul><p><strong>主要用途:</strong></p><ul><li><p><strong>基本数据类型之间的转换(主要用途）</strong>：如整数到浮点数，浮点数到整数，以及其他基本数据类型之间的转换。</p></li><li><p>指针类型之间的转换：在执行时<strong>不会进行运行时检查</strong>，因此应该谨慎使用</p></li><li><p>类之间的转换：可以用于父类和子类之间的转换，但它<strong>不执行运行时检查</strong>，因此应谨慎使用。</p></li><li><p>枚举类型的转换：可以用于枚举类型之间的转换。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123; /* ... */ &#125;;</span><br><span class="line">class Child : public Parent &#123; /* ... */ &#125;;</span><br><span class="line"></span><br><span class="line">Parent* parentPtr = new Child();</span><br><span class="line">Child* childPtr = static_cast&lt;Child*&gt;(parentPtr); // 将父类指针转换为子类指针</span><br></pre></td></tr></table></figure><h4 id="2-2-dynamic-cast"><a href="#2-2-dynamic-cast" class="headerlink" title="2.2 dynamic_cast"></a>2.2 dynamic_cast</h4><p><strong>dynamic_cast：</strong>主要用于在继承关系中进行安全的<strong>运行时</strong>类型识别和类型转换。</p><p><strong>dynamic_cast</strong> 的语法如下：</p><p><code>dynamic_cast&lt;new_type&gt;(expression)</code> </p><p>其中：</p><ul><li><code>new_type</code> 表示要进行的目标类型（目标数据类型）。</li><li><code>expression</code> 是要转换的指针或引用。</li></ul><p><strong>dynamic_cast</strong>的主要用途如下：</p><ul><li><strong>用于多态类型的安全类型转换</strong>：<code>dynamic_cast</code> 主要用于处理多态类的情况</li></ul><p><strong>*注：dynamic_cast</strong>会在运行时检查是否可以进行安全的类型转换。如果转换不合法（例如，试图将基类指针转换为未与之相关的派生类指针），则<strong>会返回空指针</strong>（对于指针）或引发 <strong>std::bad_cast</strong>异常（对于引用）。*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void speak() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Animal speaks&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Dog : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void speak() override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Dog barks&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Animal* animal = new Dog();</span><br><span class="line"></span><br><span class="line">    // 使用 dynamic_cast 将基类指针转换为派生类指针</span><br><span class="line">    Dog* dog = dynamic_cast&lt;Dog*&gt;(animal);</span><br><span class="line"></span><br><span class="line">    if (dog) &#123;</span><br><span class="line">        // 转换成功，现在可以安全地调用 Dog 类的函数</span><br><span class="line">        dog-&gt;speak();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 转换失败</span><br><span class="line">        std::cout &lt;&lt; &quot;Failed to cast to Dog&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete animal;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Dog barks</span><br></pre></td></tr></table></figure><h4 id="2-3-const-cast"><a href="#2-3-const-cast" class="headerlink" title="2.3 const_cast"></a>2.3 const_cast</h4><p><strong>const_cast:</strong>用于在一定情况下去除对象的常量性,可以添加或移除对象的 <code>const</code> 限定符，从而改变对象的常量属性。</p><p><strong>const_cast:</strong>的语法如下：</p><p><code>const_cast&lt;new_type&gt;(expression)</code> </p><p>其中：</p><ul><li><code>new_type</code> 表示要进行的目标类型（目标数据类型）。</li><li><code>expression</code> 是要转换的指针、引用或对象。</li></ul><p><strong>注：</strong></p><p><strong>1.const_cast:</strong>主要用于去除对象的 <code>const</code> 限定符，使其变为非常量对象，从而允许对其进行修改。</p><p><strong>2.const_cast:</strong>不会修改对象的实际值，只是修改了对象的类型属性。</p><p><strong>主要用途：</strong>用于解决某些兼容性问题，例如调用老式库函数，这些函数不将参数标记为常量，但实际上不会修改它们。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int value = 42;</span><br><span class="line">    int* nonConstPtr = const_cast&lt;int*&gt;(&amp;value);</span><br><span class="line">    *nonConstPtr = 100; // 合法，修改了原本是常量的对象</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-map和unordered-map-hash-map-的区别"><a href="#3-map和unordered-map-hash-map-的区别" class="headerlink" title="3.map和unordered_map(hash_map)的区别"></a>3.map和unordered_map(hash_map)的区别</h3><ul><li><strong>内部实现：</strong></li></ul><p>​    <strong>map:</strong>基于红黑树（二叉搜索树）实现，元素按照<strong>key</strong>的顺序进行排序存储（有序，增删改查log(n)的复杂度）</p><p>​    <strong>unordered_map:</strong>基于哈希表实现，根据键的哈希值分布(增删改查log(1)的复杂度)</p><p>​    <em>注：如果要对元素的key值排序使用map</em></p><h3 id="4-emplace-back和push-back的区别"><a href="#4-emplace-back和push-back的区别" class="headerlink" title="4.emplace_back和push_back的区别"></a>4.emplace_back和push_back的区别</h3><p><strong>emplace_back和push_back的用法:</strong>向vector末尾添加元素</p><p><strong>push_back：</strong></p><ul><li>在<strong>vector外</strong>构建对象</li><li><p>使用move或拷贝构造添加到vector的末尾</p></li><li><p>在vector外构建的对象析构了</p></li></ul><p><strong>emplace_back：</strong></p><ul><li>直接在<strong>vector内</strong>构造对象（接受构造该对象所需的参数，并在vector内部直接调用该对象的构造函数）</li></ul><p><strong>用法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Person&gt; vec;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>));</span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure><h3 id="5-stringstream"><a href="#5-stringstream" class="headerlink" title="5.stringstream"></a>5.stringstream</h3><p><strong>头文件：</strong><code>#include &lt;sstream&gt;</code></p><p><strong>作用1：</strong>格式化字符串（将各种类型的数据传入字符串中）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SStud</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> nNumb;</span><br><span class="line"><span class="type">char</span> sName[<span class="number">20</span>];</span><br><span class="line"><span class="type">float</span> fMath;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stringstream ostr;</span><br><span class="line">SStud d = &#123; <span class="number">1008</span>,<span class="string">&quot;学生1&quot;</span>,<span class="number">89.5</span> &#125;;</span><br><span class="line">ostr &lt;&lt; <span class="string">&quot;学号:&quot;</span> &lt;&lt; d.nNumb &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; d.sName &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; d.fMath &lt;&lt; endl;</span><br><span class="line">string str = ostr.<span class="built_in">str</span>();</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用2：</strong>截断字符串（按空格截断）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s1, s2, s3;</span><br><span class="line">ostr &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3;</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s3 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><strong>作用3:</strong>以指定字符<code>delim</code>分割字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">char</span> delim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    string item;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, item, delim))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; endl;</span><br><span class="line">        result.<span class="built_in">emplace_back</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swin-Transformer</title>
      <link href="/posts/4b223b72.html"/>
      <url>/posts/4b223b72.html</url>
      
        <content type="html"><![CDATA[<h2 id="Swin-Transformer"><a href="#Swin-Transformer" class="headerlink" title="Swin-Transformer"></a>Swin-Transformer</h2><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201409143.png" alt="1"></p><p><em>注：使用Transformer取代卷积操作是因为卷积操作在每个位置只关注输入图像的局部感受野，即一个固定大小的区域，而难以有效地捕捉全局信息，Transformer架构引入了自注意力机制，允许模型在一定范围内建立像素之间的关联，可以更好地处理全局信息</em>。</p><h3 id="2-W-MSA"><a href="#2-W-MSA" class="headerlink" title="2.W-MSA"></a>2.W-MSA</h3><p>使用窗口多头自注意力，将输入的图片划分成不重叠的窗口，在这样的局部的窗口中计算自注意力，减少计算量，其对于图像的大小具有<strong>线性的复杂度</strong></p><p>$Ω(MSA) = 4hwC^2 + 2(hw)^2C; (1)$<br>$Ω(W-MSA) = 4hwC^2 + 2M^2hwC; (2)$</p><p><strong>注：</strong></p><p>h,w:输入图像的高,宽</p><p>M:一个窗口中含有MxM个patch</p><p>C：超参数（linear embedding将patch的特征维度变成C)</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201409740.png" alt="6"></p><h3 id="3-SW-MSA"><a href="#3-SW-MSA" class="headerlink" title="3.SW-MSA"></a>3.SW-MSA</h3><p>虽然基于窗口计算自注意力能够很好的解决计算量大的问题，但是现在<strong>窗口与窗口之间没有联系</strong>，就达不到全局建模的能力，所以作者就提出了<strong>移动窗口</strong>的方式去解决</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201409940.png" alt="4" style="zoom: 80%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201409148.png" alt="7" style="zoom: 80%;"></p><p><strong>从Layer1移动到Layer1+1后存在的问题：</strong>每个窗口中的patch数量不同，窗口数增大了，会影响计算效率</p><p><strong>解决方法：cyclic shift+MSA-masked</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201410145.png" alt="5" style="zoom: 50%;"></p><p><strong>循环移位：</strong>将A、C先向下拼接，再将B、A向右拼接。通过循环移位将窗口的数目再一次地拼成4个，控制了计算复杂度，但产生了新的问题：同一个窗口中的patch来自于不同的区域，而来自于不同区域的patch之间不应该计算自注意力。</p><p><strong>MSA-masked：</strong>对于一个patch，得到这个patch的attention（Q、K、V），将这个patch的Q与其他patch的K点乘，如果这两个patch来自于不同的区域，那么将点乘的结果减100，那么结果将是一个负数，再经过softmax处理后映射得到的权值接近于0</p><h3 id="4-patch-merging"><a href="#4-patch-merging" class="headerlink" title="4.patch merging"></a>4.patch merging</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201410582.png" alt="8" style="zoom: 67%;"></p><p><strong>patch merging:</strong>进行下采样，用于缩小分辨率，调整通道数进而形成层次化的设计</p><h3 id="5-Relative-position-bias（相对位置偏置）"><a href="#5-Relative-position-bias（相对位置偏置）" class="headerlink" title="5.Relative position bias（相对位置偏置）"></a>5.Relative position bias（相对位置偏置）</h3><p><strong>偏置B:</strong>让attention map进一步有所偏重，在进行Attention计算时考虑到像素间的位置关系。</p><p>偏置B是由将像素与像素间的相对位置进行编码然后通过查找偏置表得到的。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310212045328.png" alt="9" style="zoom: 80%;"></p><h2 id="Swin-Unet"><a href="#Swin-Unet" class="headerlink" title="Swin-Unet"></a>Swin-Unet</h2><p><img src="https://typoraimg.wangak.cc/2023/img/202310201410888.png" alt="11"></p><p><strong>编码器:</strong>工作原理和 Swin-Transformer完全一样的。其中，Patch Merging模块的作用是在每个Swin-Transformer模块开头来降低图片分辨率。</p><p><strong>解码器：</strong>Patch Expanding将相邻维度的特征图重塑为更高分辨率的特征图(2×上采样)，并相应地将特征维数减半。</p><p><strong>Patch Expanding:</strong></p><p>​       在上采样之前，在输入特征上加一个线性层,将特征维数增加到原始维数的2倍,利用重排操作将输入特征的分辨率扩展为输入分辨率的2倍，将特征维数降低为输入维数的1/4。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class PatchExpand(nn.Module): </span><br><span class="line">    def __init__(self, input_resolution, dim, dim_scale=2, norm_layer=nn.LayerNorm):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.input_resolution = input_resolution</span><br><span class="line">        self.dim = dim</span><br><span class="line">        self.expand = nn.Linear(dim, 2*dim, bias=False) if dim_scale==2 else nn.Identity()#如果dim_scale是2则执行nn.Linear()，不是则执行直接映射</span><br><span class="line">        self.norm = norm_layer(dim // dim_scale)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line"></span><br><span class="line">        H, W = self.input_resolution</span><br><span class="line">        x = self.expand(x)</span><br><span class="line">        B, L, C = x.shape</span><br><span class="line">        assert L == H * W, &quot;input feature has wrong size&quot;</span><br><span class="line"></span><br><span class="line">        x = x.view(B, H, W, C)</span><br><span class="line">        x = rearrange(x, &#x27;b h w (p1 p2 c)-&gt; b (h p1) (w p2) c&#x27;, p1=2, p2=2, c=C//4)</span><br><span class="line">        x = x.view(B,-1,C//4)</span><br><span class="line">        x= self.norm(x.clone())</span><br><span class="line"></span><br><span class="line">        return x</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RNN</title>
      <link href="/posts/6fe72dd0.html"/>
      <url>/posts/6fe72dd0.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-RNN-递归神经网络"><a href="#1-RNN-递归神经网络" class="headerlink" title="1.RNN(递归神经网络)"></a>1.RNN(递归神经网络)</h3><p><strong>RNN:</strong>用于处理<strong>序列</strong>数据和<strong>时间</strong>序列数据。RNN具有循环连接，允许信息在网络内部传递。</p><h4 id="1-1-RNN的结构："><a href="#1-1-RNN的结构：" class="headerlink" title="1.1 RNN的结构："></a>1.1 RNN的结构：</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202310201406368.png" alt="1"></p><p>注：<strong>权重矩阵</strong> W就是<strong>隐藏层</strong>上一次的值作为这一次的输入的权重</p><h4 id="1-2-RNN的优劣"><a href="#1-2-RNN的优劣" class="headerlink" title="1.2  RNN的优劣"></a>1.2  RNN的优劣</h4><p><strong>RNN的主要优点包括：</strong></p><p><strong>1.处理序列数据：</strong>RNN能够有效地处理变长序列数据，因为它的隐藏状态可以捕获先前时间步的信息。</p><p><strong>2.上下文理解：</strong>RNN能够理解上下文信息。</p><p><strong>RNN的缺点：</strong></p><p><strong>1.长期依赖问题：</strong>由于梯度消失或梯度爆炸的问题，传统的RNN在处理长序列时可能会失去对远距离时间步的依赖性。</p><p><strong>2.计算效率：</strong>RNN的计算效率较低，难以处理大规模数据和长序列。</p><h3 id="2-LSTM-长短期记忆"><a href="#2-LSTM-长短期记忆" class="headerlink" title="2.LSTM(长短期记忆)"></a>2.LSTM(长短期记忆)</h3><p><strong>LSTM:</strong>为了解决RNN在长序列训练过程中的梯度消失和梯度爆炸问题。</p><h4 id="2-1-LSTM的结构原理："><a href="#2-1-LSTM的结构原理：" class="headerlink" title="2.1 LSTM的结构原理："></a>2.1 LSTM的结构原理：</h4><p>输入：Z、输入门$Z_i$、输出门 $Z_o$、遗忘门 $Z_f$</p><p>输出：a</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201406702.png" alt="2"></p><p>输入门$Z_i$:决定了哪些新信息要被存储到细胞状态中。它也考虑前一个时间步的隐藏状态和当前时间步的输入，以及一个候选值，用于更新细胞状态。</p><p>遗忘门 $Z_f$:决定了哪些信息要被遗忘或丢弃。输出一个介于0和1之间的值，表示要保留多少以前的信息。</p><p>输出门 $Z_o$:决定哪些将会被当成当前状态的输出。</p><p>细胞状态:在LSTM中负责存储和传递信息，以便于捕获长期依赖关系。</p><h4 id="2-2-LSTM的工作流程"><a href="#2-2-LSTM的工作流程" class="headerlink" title="2.2 LSTM的工作流程"></a>2.2 LSTM的工作流程</h4><p><strong>1.遗忘门的输出（$f_t$)</strong>:</p><script type="math/tex; mode=display">f_t=σ(W_{xf}x_t+W_{hf}h_{t−1}+b_f)</script><p><img src="https://typoraimg.wangak.cc/2023/img/202310201406010.png" alt="3"></p><p><strong>2.候选细胞状态（$\tilde{C}$）及输入门（$i_t$）</strong></p><script type="math/tex; mode=display">\tilde{C}=tanh(W_{xc}x_t+W_{hc}h_{t−1}+b_c)</script><script type="math/tex; mode=display">i_t=σ(W_{xi}x_t+W_{hi}h_{t−1}+b_i)</script><p><img src="https://typoraimg.wangak.cc/2023/img/202310201406785.png" alt="4"></p><p><strong>3.更新状态值($C_t$)</strong></p><script type="math/tex; mode=display">C_t=f_t⋅C_{t−1}+i_t⋅\tilde{C}</script><p><img src="https://typoraimg.wangak.cc/2023/img/202310201406751.png" alt="5"></p><p><strong>4.输出</strong></p><script type="math/tex; mode=display">o_t=σ(W_{xo}x_t+W_{ho}h_{t−1}+b_o)</script><script type="math/tex; mode=display">h_t=o_t⋅tanh(C_t)</script><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407980.png" alt="6"></p><p><strong>注：</strong></p><p>​      <strong>*利用tanh来映射细胞状态信息的原因</strong>：tanh函数其输出在-1-1之间，这与大多数场景下特征分布是0中心的吻合。tanh函数在输入为0附近相比 Sigmoid函数有更大的梯度，通常使模型收敛更快。*</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RNN </tag>
            
            <tag> LSTM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用损失函数</title>
      <link href="/posts/60adb68d.html"/>
      <url>/posts/60adb68d.html</url>
      
        <content type="html"><![CDATA[<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><h3 id="1-损失函数的概念及使用场景"><a href="#1-损失函数的概念及使用场景" class="headerlink" title="1.损失函数的概念及使用场景"></a>1.损失函数的概念及使用场景</h3><p><strong>损失函数：</strong>用于衡量模型预测结果与真实结果之间的差异或误差。</p><p><strong>损失函数的使用场景：</strong></p><ul><li><p><strong>模型训练：</strong>通过最小化损失函数，可以调整模型的参数，使其能够更好地拟合训练数据，提高模型的性能。</p></li><li><p><strong>模型评估：</strong>通过计算模型在验证集或测试集上的损失值，可以判断模型的泛化能力和预测准确度，较小的损失值通常表示模型更好地适应了新数据。</p></li><li><p><strong>优化算法：</strong>通过计算损失函数对模型参数的梯度，可以确定参数的更新方向和步长，以便优化模型。</p></li><li><p><strong>模型选择和比较：</strong>选择合适的损失函数可以帮助优化模型性能，并对不同模型进行比较和选择。</p></li></ul><h3 id="2-分类任务"><a href="#2-分类任务" class="headerlink" title="2.分类任务"></a>2.分类任务</h3><h4 id="2-1-交叉熵损失函数（Cross-Entropy-Loss）"><a href="#2-1-交叉熵损失函数（Cross-Entropy-Loss）" class="headerlink" title="2.1 交叉熵损失函数（Cross-Entropy Loss）"></a>2.1 交叉熵损失函数（Cross-Entropy Loss）</h4><p><strong>二分类问题：</strong>二元交叉熵损失函数（Binary Cross-Entropy Loss）</p><ul><li><p>计算公式：<script type="math/tex">\large L(y, p) = -[y * log(p) + (1 - y) * log(1 - p)]</script></p><p> <em>注：真实标签为 y（可以是0或1），模型的预测概率为 p（0 ≤ p ≤ 1）</em></p></li></ul><p><strong>多分类问题：</strong>多元交叉熵损失函数（Multiclass Cross-Entropy Loss）</p><p>​        在多元交叉熵损失函数中，假设有 C 个可能的类别，每个类别都有一个与之相关的标签（通常使用 one-hot 编码）。对于每个样本，模型会输出一个长度为 C 的概率分布向量，表示样本属于每个类别的概率。</p><ul><li>计算公式：$\large L(y, p) = -Σ(y_i * log(p_i))$</li></ul><p><em>注：其中，i 表示类别的索引，$y_i$ 表示真实标签的第 i 个元素，$p_i$ 表示模型的输出概率分布的第 i 个元素。</em></p><h4 id="2-2-Focal-Loss（聚焦损失）"><a href="#2-2-Focal-Loss（聚焦损失）" class="headerlink" title="2.2 Focal Loss（聚焦损失）"></a>2.2 Focal Loss（聚焦损失）</h4><p><strong>Focal Loss:</strong>用于处理类别不平衡问题的损失函数,旨在解决当某些类别的样本数量远远多于其他类别时，传统的交叉熵损失函数会受到类别不平衡的影响，导致模型难以有效地学习少数类别。</p><p><strong>focal loss的具体形式：</strong><script type="math/tex">\large-\alpha(1-y_{pred})^{\gamma}y_{true}log(y_{pred})-(1-\alpha)y_{pred}^{\gamma}(1-y_{true})log(1-y_{pred})</script></p><p><strong>注：</strong></p><p><em>1.$\large\gamma$通常设置为2，$\large(1-y_{pred})^{\gamma}$相当于样本的难易度权值,$\large\alpha$为正负样本的比例</em></p><p><em>2.为了防止难易样本的频繁变化，应当选取小的学习率。防止学习率过大，造成w变化较大从而引起 $\large y_{pred}$的巨大变化，造成难易样本的改变。</em></p><h3 id="3-回归任务"><a href="#3-回归任务" class="headerlink" title="3.回归任务"></a>3.回归任务</h3><h4 id="3-1-均方误差损失函数（Mean-Squared-Error-MSE）"><a href="#3-1-均方误差损失函数（Mean-Squared-Error-MSE）" class="headerlink" title="3.1 均方误差损失函数（Mean Squared Error, MSE）"></a>3.1 均方误差损失函数（Mean Squared Error, MSE）</h4><p><strong>计算公式：</strong>$\large MSE = (1/N) * Σ(y_i - ŷ_i)^2$</p><p>注：N 表示样本数量，$y_i$ 表示真实标签，$ŷ_i$ 表示模型的预测值。</p><h4 id="3-2-平均绝对误差损失函数（Mean-Absolute-Error-MAE"><a href="#3-2-平均绝对误差损失函数（Mean-Absolute-Error-MAE" class="headerlink" title="3.2 平均绝对误差损失函数（Mean Absolute Error, MAE)"></a>3.2 平均绝对误差损失函数（Mean Absolute Error, MAE)</h4><p><strong>计算公式：</strong>$\large MAE = (1/N) * Σ|y_i - ŷ_i|$</p><p>注：N 表示样本数量，$y_i$ 表示真实标签，$ŷ_i$ 表示模型的预测值。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 损失函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nnUnet</title>
      <link href="/posts/544635d8.html"/>
      <url>/posts/544635d8.html</url>
      
        <content type="html"><![CDATA[<h2 id="nnUnet"><a href="#nnUnet" class="headerlink" title="nnUnet"></a>nnUnet</h2><h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1.预处理"></a>1.预处理</h3><h4 id="1-1-Crop"><a href="#1-1-Crop" class="headerlink" title="1.1 Crop"></a>1.1 Crop</h4><p><strong>Crop:</strong>裁剪去除图片的0区域，使用非0区域作为训练数据，对MRI数据能够显著降低其大小。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405330.png" alt="1"></p><h4 id="1-2-Resample"><a href="#1-2-Resample" class="headerlink" title="1.2 Resample"></a>1.2 Resample</h4><p><strong>Resample:</strong>CNN无法理解体素间距的概念，重采样使得数据集体素间距一致（使像素间所对应的真实的物理距离一致）。</p><p><em>注：在医学图像中要关注图像的物理距离，这关系到器官的大小。</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405296.png" alt="2"></p><h3 id="2-训练"><a href="#2-训练" class="headerlink" title="2.训练"></a>2.训练</h3><h4 id="2-1-Patch-Sampling"><a href="#2-1-Patch-Sampling" class="headerlink" title="2.1 Patch-Sampling:"></a>2.1 Patch-Sampling:</h4><p><strong>Patch-Training:</strong>对不同的图像裁剪固定的大小，组成一个batch进行训练（用于解决在统一体素间距后，出现的数据分辨率不一致的问题）。</p><p><strong>Sampling：</strong>为了防止Patch中的数据全部是背景，保证batch中的数据有1/3包含前景。</p><h4 id="2-2-Cross-Validation"><a href="#2-2-Cross-Validation" class="headerlink" title="2.2 Cross-Validation"></a>2.2 Cross-Validation</h4><p><strong>nnUnet</strong>在训练集上使用<strong>五折交叉验证</strong>进行评估</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405943.png" alt="3"></p><h3 id="3-网络设计"><a href="#3-网络设计" class="headerlink" title="3.网络设计"></a>3.网络设计</h3><p>nnUnet与Unet的结构类似，但<strong>nnUnet</strong>会根据数据集<strong>自适应调整网络结构</strong>。</p><h4 id="3-1-Cascade-Unet"><a href="#3-1-Cascade-Unet" class="headerlink" title="3.1 Cascade-Unet"></a>3.1 Cascade-Unet</h4><p><strong>Cascade-Unet:</strong>使用patch-training，不完整的图片导致感受野受限，为了解决该问题，设计出Cascade-Unet。</p><p><strong>Cascade-Unet的两个阶段：</strong></p><p><strong>1.对输入图片下采样，使用下采样的图片得到粗糙的分割结果</strong></p><p><strong>2.将第一阶段的分割结果上采样，然后与原图concat，使用patch训练</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405010.png" alt="4"></p><h4 id="3-2-网络自适应调整"><a href="#3-2-网络自适应调整" class="headerlink" title="3.2 网络自适应调整"></a>3.2 网络自适应调整</h4><p><strong>nnUnet：</strong>先统一体素间距，然后根据数据集计算网络的输入分辨率并确定网络的结构及参数。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405038.png" alt="5"></p><h3 id="4-后处理"><a href="#4-后处理" class="headerlink" title="4.后处理"></a>4.后处理</h3><p><strong>保留最大连通区域</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405154.png" alt="6"></p><p>上图：<strong>蓝色（前景）、黄色（预测的结果）</strong></p><p><strong>出现的问题：</strong>第一次处理使的模型的性能下降，第二次处理使得模型的性能提高。</p><p><strong>解决方法：</strong>在训练过程中，分别对使用后处理和不使用后处理得到两个精度，然后通过对比结果，决定是否使用后处理。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405294.png" alt="7"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
            <tag> Unet系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（2）</title>
      <link href="/posts/679d2361.html"/>
      <url>/posts/679d2361.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-复制函数"><a href="#1-复制函数" class="headerlink" title="1.复制函数"></a>1.复制函数</h3><h4 id="1-1-浅复制"><a href="#1-1-浅复制" class="headerlink" title="1.1 浅复制"></a>1.1 浅复制</h4><p><strong>浅复制：</strong>仅复制对象的成员变量的值，而不复制对象中的指针所指向的内容。</p><p><em>注：如果原始对象中包含指针，浅复制将导致多个对象共享同一内存块，从而可能引发潜在的问题。当原始对象的析构函数被调用时，如果没有适当地管理共享资源，可能会导致重复释放内存或内存泄漏等问题。</em></p><h4 id="1-2-深复制"><a href="#1-2-深复制" class="headerlink" title="1.2 深复制"></a>1.2 深复制</h4><p><strong>深复制：</strong>不仅复制对象的成员变量的值，还要递归地复制对象中的指针所指向的内容，创建一个全新的数据拷贝。</p><p><em>注：新对象与原始对象彼此独立，<strong>不共享内存块</strong>，但需要更多的计算和内存开销。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt; </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std; </span><br><span class="line">class String&#123;</span><br><span class="line">  private:</span><br><span class="line">    char *data;</span><br><span class="line">  public:</span><br><span class="line">    String(const char *str)</span><br><span class="line">    &#123;</span><br><span class="line">      data=new char[strlen(str)]+1;</span><br><span class="line">      strcpy(data,str);</span><br><span class="line">    &#125;</span><br><span class="line">    // String(const String &amp;other)//浅复制</span><br><span class="line">    // &#123;</span><br><span class="line">    //   data=other.data;</span><br><span class="line">    // &#125;</span><br><span class="line">    String(const String &amp;other)//深复制</span><br><span class="line">    &#123;</span><br><span class="line">      data=new char[strlen(other.data)+1];</span><br><span class="line">      strcpy(data,other.data);</span><br><span class="line">    &#125;</span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">      delete []data;</span><br><span class="line">    &#125;</span><br><span class="line">    void printData()</span><br><span class="line">    &#123;</span><br><span class="line">      cout&lt;&lt;data&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  String Str0(&quot;Hello&quot;);</span><br><span class="line">  String Str1(Str0);</span><br><span class="line">  Str1.printData();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-复制构造函数-拷贝"><a href="#1-3-复制构造函数-拷贝" class="headerlink" title="1.3 复制构造函数(拷贝)"></a>1.3 复制构造函数(拷贝)</h4><p><strong>构造函数委托:</strong>允许一个构造函数调用同一类的另一个构造函数来完成对象的初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyString</span><br><span class="line">&#123;</span><br><span class="line">  private:</span><br><span class="line">    char * _data;</span><br><span class="line">  public:</span><br><span class="line">    MyString(const char* s=&quot;&quot;)</span><br><span class="line">    :_data(nullptr)//初始化_data成员变量为nullptr</span><br><span class="line">    &#123;</span><br><span class="line">      if(s)&#123;</span><br><span class="line">        size_t n=strlen(s)+1;</span><br><span class="line">        _data=new char[n];</span><br><span class="line">        memcpy(_data,s,n);</span><br><span class="line">      &#125;</span><br><span class="line">      cout&lt;&lt;&quot;create&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">  ~MyString()</span><br><span class="line">  &#123;</span><br><span class="line">    cout&lt;&lt;&quot;delete&quot;&lt;&lt;endl;</span><br><span class="line">    delete[] _data;</span><br><span class="line">  &#125;</span><br><span class="line">  MyString(const MyString &amp;other)//复制构造函数(使用构造函数委托来重用构造函数)</span><br><span class="line">  :MyString(other._data)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;copy constructor&quot;&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  MyString str(&quot;hello&quot;);</span><br><span class="line">  MyString str2(str);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">create</span><br><span class="line">create</span><br><span class="line">copy constructor</span><br><span class="line">delete</span><br><span class="line">delete</span><br></pre></td></tr></table></figure><h4 id="1-4-移动构造函数（移动）"><a href="#1-4-移动构造函数（移动）" class="headerlink" title="1.4 移动构造函数（移动）"></a>1.4 移动构造函数（移动）</h4><p><strong>移动构造函数:</strong>一个对象的资源从一个对象转移到另一个对象，而无需进行深层次的复制操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyString</span><br><span class="line">&#123;</span><br><span class="line">  private:</span><br><span class="line">    char * _data;</span><br><span class="line">  public:</span><br><span class="line">    MyString(const char* s=&quot;&quot;)</span><br><span class="line">    :_data(nullptr)//初始化_data成员变量为nullptr</span><br><span class="line">    &#123;</span><br><span class="line">      if(s)&#123;</span><br><span class="line">        size_t n=strlen(s)+1;</span><br><span class="line">        _data=new char[n];</span><br><span class="line">        memcpy(_data,s,n);</span><br><span class="line">      &#125;</span><br><span class="line">      cout&lt;&lt;&quot;create&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">  ~MyString()</span><br><span class="line">  &#123;</span><br><span class="line">    cout&lt;&lt;&quot;delete&quot;&lt;&lt;endl;</span><br><span class="line">    delete[] _data;</span><br><span class="line">  &#125;</span><br><span class="line">  MyString(MyString&amp;&amp; other)//移动构造函数</span><br><span class="line">  &#123;</span><br><span class="line">    this-&gt;_data=other._data;</span><br><span class="line">    other._data=nullptr;</span><br><span class="line">    cout&lt;&lt;&quot;move constructor&quot;&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  MyString str(&quot;hello&quot;);</span><br><span class="line">  MyString str2(move(str));</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">create</span><br><span class="line">move constructor</span><br><span class="line">delete</span><br><span class="line">delete</span><br></pre></td></tr></table></figure><h3 id="2-单例类"><a href="#2-单例类" class="headerlink" title="2.单例类"></a>2.单例类</h3><p><strong>单例类：</strong>使用私有构造函数、私有赋值运算符和静态实例成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class President &#123;</span><br><span class="line">private:</span><br><span class="line">    President() &#123;&#125;; // 私有的默认构造函数，防止直接创建对象</span><br><span class="line">    President(const President&amp;); // 私有的复制构造函数，阻止复制对象</span><br><span class="line">    const President&amp; operator=(const President&amp;); // 私有的赋值运算符重载，阻止赋值操作</span><br><span class="line"></span><br><span class="line">    string name; // 存储总统名字的私有成员变量</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static President&amp; GetInstance() // 获取唯一的总统实例的静态成员函数</span><br><span class="line">    &#123;</span><br><span class="line">        // 使用静态局部变量确保只有一个实例会被创建</span><br><span class="line">        static President onlyInstance;</span><br><span class="line">        return onlyInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string GetName() // 获取总统名字的公有成员函数</span><br><span class="line">    &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void SetName(string InputName) // 设置总统名字的公有成员函数</span><br><span class="line">    &#123;</span><br><span class="line">        name = InputName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    President&amp; onlyPresident = President::GetInstance(); // 获取唯一的总统实例并引用它</span><br><span class="line">    onlyPresident.SetName(&quot;Abraham Lincoln&quot;); // 设置总统的名字为 &quot;Abraham Lincoln&quot;</span><br><span class="line">    // 下面的注释代码演示了禁止创建多个总统实例的情况</span><br><span class="line">    // President second; // 不能访问构造函数</span><br><span class="line">    // President* third = new President(); // 不能访问构造函数</span><br><span class="line">    // President fourth = onlyPresident; // 不能访问复制构造函数</span><br><span class="line">    // onlyPresident = President::GetInstance(); // 不能访问赋值运算符重载</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;The name of the President is: &quot;;</span><br><span class="line">    cout &lt;&lt; President::GetInstance().GetName() &lt;&lt; endl; // 获取并输出总统的名字</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-关键字-explicit"><a href="#3-关键字-explicit" class="headerlink" title="3.关键字 explicit"></a>3.关键字 explicit</h3><p><strong>关键字 explicit：</strong>避免隐式转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义一个名为 Human 的类</span><br><span class="line">class Human &#123;</span><br><span class="line">private:</span><br><span class="line">    int age; // 私有成员变量，表示人的年龄</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 显式构造函数，阻止隐式类型转换</span><br><span class="line">    explicit Human(int humansAge) : age(humansAge) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 函数，接受一个 Human 类型的参数</span><br><span class="line">void DoSomething(Human person) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Human sent did something&quot; &lt;&lt; endl;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个 Human 对象 kid，设置年龄为 10</span><br><span class="line">    Human kid(10);</span><br><span class="line"></span><br><span class="line">    // 创建另一个 Human 对象 anotherKid，设置年龄为 11</span><br><span class="line">    Human anotherKid = Human(11);</span><br><span class="line"></span><br><span class="line">    // 调用函数，将 kid 对象作为参数传递给它</span><br><span class="line">    DoSomething(kid); // 这是有效的，因为参数的类型是明确的</span><br><span class="line"></span><br><span class="line">    // 下面两行是注释掉的代码，因为它们尝试执行隐式类型转换，会导致编译错误</span><br><span class="line">    // Human anotherKid2 = 11;</span><br><span class="line">    // DoSomething(10);</span><br><span class="line"></span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p><strong>隐式转换：</strong>将提供的整数作为参数发送给这个构造函数，从而创建一个Human 对象。</p><h3 id="4-友元"><a href="#4-友元" class="headerlink" title="4.友元"></a>4.友元</h3><p>使用关键字 <strong>friend</strong>声明友元类或友元函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义一个名为 Human 的类</span><br><span class="line">class Human &#123;</span><br><span class="line">private:</span><br><span class="line">    // 允许 Utility 类成员访问私有成员</span><br><span class="line">    friend class Utility;</span><br><span class="line"></span><br><span class="line">    string name; // 私有成员变量，表示人的姓名</span><br><span class="line">    int age;    // 私有成员变量，表示人的年龄</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 构造函数，接受人的姓名和年龄</span><br><span class="line">    Human(string humansName, int humansAge) &#123;</span><br><span class="line">        name = humansName;</span><br><span class="line">        age = humansAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义一个名为 Utility 的类</span><br><span class="line">class Utility &#123;</span><br><span class="line">public:</span><br><span class="line">    // 静态成员函数，用于显示人的年龄</span><br><span class="line">    static void DisplayAge(const Human&amp; person) &#123;</span><br><span class="line">        cout &lt;&lt; person.age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个 Human 对象 firstMan，初始化姓名为 &quot;Adam&quot; 年龄为 25</span><br><span class="line">    Human firstMan(&quot;Adam&quot;, 25);</span><br><span class="line"></span><br><span class="line">    // 使用友元类 Utility 来访问 private 成员 age</span><br><span class="line">    cout &lt;&lt; &quot;Accessing private member age via friend class: &quot;;</span><br><span class="line">    Utility::DisplayAge(firstMan);</span><br><span class="line"></span><br><span class="line">    return 0; // 程序正常退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-继承"><a href="#5-继承" class="headerlink" title="5.继承"></a>5.继承</h3><p><strong>调用基类中被覆盖的方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class base&#123;</span><br><span class="line">    private:</span><br><span class="line">    public:</span><br><span class="line">        void print()</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;base\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class son:public base&#123;</span><br><span class="line">    private:</span><br><span class="line">    public:</span><br><span class="line">        void print()</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;son\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    son a;</span><br><span class="line">    a.print();</span><br><span class="line">    a.base::print();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">son</span><br><span class="line">base</span><br></pre></td></tr></table></figure><h3 id="6-抽象基类和纯虚函数"><a href="#6-抽象基类和纯虚函数" class="headerlink" title="6.抽象基类和纯虚函数"></a>6.抽象基类和纯虚函数</h3><p><strong>抽象基类：</strong>计用来作为其他派生类的基础，但不能被实例化为对象</p><p><em>注：抽象基类至少包含一个纯虚函数，这些纯虚函数在派生类中必须被实现。</em></p><p><strong>纯虚函数：</strong>在抽象基类中声明的虚函数，但没有提供实际的函数体实现。</p><p><em>注：纯虚函数的声明使用 <code>virtual</code> 关键字，并在函数声明后加上 <code>= 0</code></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    // 纯虚函数，必须在派生类中实现</span><br><span class="line">    virtual double Area() const = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 派生类 Circle</span><br><span class="line">class Circle : public Shape &#123;</span><br><span class="line">private:</span><br><span class="line">    double radius;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Circle(double r) : radius(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 实现了抽象基类中的纯虚函数</span><br><span class="line">    double Area() &#123;</span><br><span class="line">        return 3.14 * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-虚继承"><a href="#7-虚继承" class="headerlink" title="7.虚继承"></a>7.虚继承</h3><p><strong>虚继承：</strong>解决了多继承中可能出现的菱形继承问题以及由此引发的二义性问题。</p><p><strong>菱形继承问题</strong>：菱形继承问题发生在一个派生类从两个不同的基类继承，而这两个基类都继承自同一个共同的基类。派生类会继承两份相同的数据，导致二义性和内存浪费。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class CommonBase &#123;</span><br><span class="line">public:</span><br><span class="line">    int data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Base1 : virtual public CommonBase &#123;</span><br><span class="line">public:</span><br><span class="line">    void setData(int d) &#123;</span><br><span class="line">        data = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Base2 : virtual public CommonBase &#123;</span><br><span class="line">public:</span><br><span class="line">    int getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base1, public Base2 &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    obj.setData(42);</span><br><span class="line">    int result = obj.getData();</span><br><span class="line">    cout &lt;&lt; &quot;Data: &quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-限定符-override"><a href="#8-限定符-override" class="headerlink" title="8.限定符 override"></a>8.限定符 override</h3><p><strong>限定符 override：</strong>用于显式指示派生类中的成员函数是对基类中的虚函数进行重写（覆盖）的，主要作用是提高代码的可读性和可维护性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void MyFunction() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base::MyFunction()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    // 使用 override 明确表示覆盖了基类的虚函数</span><br><span class="line">    void MyFunction() override &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derived::MyFunction()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    Base* ptr = &amp;obj;//一个派生类对象的地址赋给一个基类指针，可以使用该指针来访问基类中定义的成员函数和数据成员。</span><br><span class="line">    ptr-&gt;MyFunction(); // 输出 Derived::MyFunction()</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-final关键字"><a href="#9-final关键字" class="headerlink" title="9.final关键字"></a>9.final关键字</h3><p><strong>修饰类：</strong>表示该类不能被其他类继承。</p><p>示例：<code>class MyFinalClass final &#123; /* 类定义 */ &#125;;</code></p><p><strong>修饰成员函数</strong>：表示该成员函数不能在派生类中被重写。</p><p>示例：<code>virtual void MyFunction() final;</code></p><p><strong>修饰变量</strong>：数值一旦在初始化之后便不能更改。</p><p>示例：<code>final int j = 5;</code></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unet</title>
      <link href="/posts/d03cec61.html"/>
      <url>/posts/d03cec61.html</url>
      
        <content type="html"><![CDATA[<h2 id="Unet"><a href="#Unet" class="headerlink" title="Unet"></a>Unet</h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201410379.png" alt="1"></p><p>网络左边为contracting path(收缩路径)，右边为expansive path(扩张路径)。</p><p><strong><em>注：</em></strong></p><p><strong><em>1.Contracting path为常规的3×3卷积结构，与ReLU，还有2×2的max pooling。每次下采样，都将featuremap的channel变为之前的两倍。</em></strong></p><p><strong><em>2.Expansive path为上采样过程，每次都是22的上采样卷积过程，并且将相应的feature channel减少为之前的一半。</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FCN</title>
      <link href="/posts/c1665831.html"/>
      <url>/posts/c1665831.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-FCN网络"><a href="#1-FCN网络" class="headerlink" title="1.FCN网络"></a>1.FCN网络</h3><h4 id="1-1-核心思想"><a href="#1-1-核心思想" class="headerlink" title="1.1 核心思想"></a>1.1 核心思想</h4><ul><li>不含全连接层的全卷积网络，可适应任意尺寸输入；（可以为不同大小和分辨率的图像生成像素级别的预测）</li><li>反卷积层增大图像尺寸，输出精细结果；</li><li>结合不同深度层结果的跳级结构，确保鲁棒性和精确性。</li></ul><h4 id="1-2-网络结构"><a href="#1-2-网络结构" class="headerlink" title="1.2 网络结构"></a>1.2 网络结构</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202310201352229.png" alt="1"></p><p><strong><em>注：</em></strong></p><p><em>1.<strong>全卷积部分</strong>为一些经典的CNN网络（如VGG，ResNet等），用于提取特征</em>。</p><p><em>2.<strong>反卷积部分</strong>则是通过上采样得到原尺寸的语义分割图像。</em></p><p><em>3.FCN的<strong>输入</strong>可以为任意尺寸的彩色图像，<strong>输出</strong>与输入尺寸相同，通道数为n（目标类别数）+1（背景）。</em></p><h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h3><h4 id="2-1-创建一个全卷积网络"><a href="#2-1-创建一个全卷积网络" class="headerlink" title="2.1 创建一个全卷积网络"></a>2.1 创建一个全卷积网络</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">import torch</span><br><span class="line">import torchvision</span><br><span class="line">from torch import nn</span><br><span class="line">from torch.nn import functional as F</span><br><span class="line">from d2l import torch as d2l</span><br><span class="line"></span><br><span class="line">#加载预训练的ResNet-18模型来提取图像特征，并查看该模型的最后三个子模块的结构和参数</span><br><span class="line">pretrained_net = torchvision.models.resnet18(pretrained=True)</span><br><span class="line">list(pretrained_net.children())[-3:]</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[Sequential(</span><br><span class="line">   (0): BasicBlock(</span><br><span class="line">     (conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)</span><br><span class="line">     (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">     (relu): ReLU(inplace=True)</span><br><span class="line">     (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">     (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">     (downsample): Sequential(</span><br><span class="line">       (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False)</span><br><span class="line">       (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">     )</span><br><span class="line">   )</span><br><span class="line">   (1): BasicBlock(</span><br><span class="line">     (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">     (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">     (relu): ReLU(inplace=True)</span><br><span class="line">     (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">     (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">   )</span><br><span class="line"> ),</span><br><span class="line"> AdaptiveAvgPool2d(output_size=(1, 1)),</span><br><span class="line"> Linear(in_features=512, out_features=1000, bias=True)]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#利用ResNet-18模型创建一个全卷积网络实例net(去除ResNet-18模型的池化层和全连接层)</span><br><span class="line">net = nn.Sequential(*list(pretrained_net.children())[:-2])</span><br><span class="line"></span><br><span class="line">X = torch.rand(size=(1, 3, 320, 480))</span><br><span class="line">net(X).shape #对张量X进行前向传播</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">torch.Size([1, 512, 10, 15])</span><br></pre></td></tr></table></figure><h4 id="2-2-添加1x1的卷积层和转置卷积层"><a href="#2-2-添加1x1的卷积层和转置卷积层" class="headerlink" title="2.2 添加1x1的卷积层和转置卷积层"></a>2.2 添加1x1的卷积层和转置卷积层</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#向网络net中添加final_conv和transpose_conv两个层，特征图的分辨率还原回输入图像的大小</span><br><span class="line">num_classes = 21</span><br><span class="line">net.add_module(&#x27;final_conv&#x27;, nn.Conv2d(512, num_classes, kernel_size=1))</span><br><span class="line">net.add_module(</span><br><span class="line">    &#x27;transpose_conv&#x27;,</span><br><span class="line">    nn.ConvTranspose2d(num_classes, num_classes, kernel_size=64, padding=16,</span><br><span class="line">                       stride=32))#kernel_size取stride的两倍，padding取kernel_size的1/4</span><br><span class="line">net(X).shape</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">torch.Size([1, 21, 320, 480])</span><br></pre></td></tr></table></figure><h4 id="2-3-初始化卷积核"><a href="#2-3-初始化卷积核" class="headerlink" title="2.3 初始化卷积核"></a>2.3 初始化卷积核</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#初始化转置卷积层</span><br><span class="line">def bilinear_kernel(in_channels, out_channels, kernel_size):</span><br><span class="line">    #找到卷积核的中心位置</span><br><span class="line">    factor = (kernel_size + 1) // 2    </span><br><span class="line">    if kernel_size % 2 == 1:</span><br><span class="line">        center = factor - 1</span><br><span class="line">    else:</span><br><span class="line">        center = factor - 0.5</span><br><span class="line">    og = (torch.arange(kernel_size).reshape(-1, 1),</span><br><span class="line">          torch.arange(kernel_size).reshape(1, -1))</span><br><span class="line">    #权重矩阵 filt,通过将偏移与 factor 相除并从1中减去得到的,确保了中心位置附近的权重最大</span><br><span class="line">    filt = (1 - torch.abs(og[0] - center) / factor) *\</span><br><span class="line">           (1 - torch.abs(og[1] - center) / factor)</span><br><span class="line">    weight = torch.zeros(</span><br><span class="line">        (in_channels, out_channels, kernel_size, kernel_size))</span><br><span class="line">    weight[range(in_channels), range(out_channels), :, :] = filt</span><br><span class="line">    return weight</span><br></pre></td></tr></table></figure><h4 id="2-4-双线性插值的上采样的实验"><a href="#2-4-双线性插值的上采样的实验" class="headerlink" title="2.4 双线性插值的上采样的实验"></a>2.4 双线性插值的上采样的实验</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">conv_trans = nn.ConvTranspose2d(3, 3, kernel_size=4, padding=1, stride=2,</span><br><span class="line">                                bias=False)#kernel_size取stride的两倍，padding取kernel_size的1/4</span><br><span class="line">conv_trans.weight.data.copy_(bilinear_kernel(3, 3, 4));</span><br><span class="line"></span><br><span class="line">img = torchvision.transforms.ToTensor()(d2l.Image.open(&#x27;../data/cat.jpg&#x27;))#加载一张图像并将其转换为 PyTorch 张量格式。</span><br><span class="line">X = img.unsqueeze(0)#unsqueeze(0)的作用是在索引0的位置插入一个新的维度，将原始的三维图像张量变成了四维</span><br><span class="line">Y = conv_trans(X)#对X进行转置卷积</span><br><span class="line">out_img = Y[0].permute(1, 2, 0).detach()#删除一个维度，并将其他的三个维度调整为高度（Height）、宽度（Width）和通道数（Channels）的顺序</span><br><span class="line">d2l.set_figsize()</span><br><span class="line">print(&#x27;input image shape:&#x27;, img.permute(1, 2, 0).shape)</span><br><span class="line">d2l.plt.imshow(img.permute(1, 2, 0))</span><br><span class="line">print(&#x27;output image shape:&#x27;, out_img.shape)</span><br><span class="line">d2l.plt.imshow(out_img);</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201353461.png" alt="2"></p><h4 id="2-5-初始化转置卷积层"><a href="#2-5-初始化转置卷积层" class="headerlink" title="2.5 初始化转置卷积层"></a>2.5 初始化转置卷积层</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">W = bilinear_kernel(num_classes, num_classes, 64)</span><br><span class="line">net.transpose_conv.weight.data.copy_(W);</span><br></pre></td></tr></table></figure><h4 id="2-6-读取数据集"><a href="#2-6-读取数据集" class="headerlink" title="2.6 读取数据集"></a>2.6 读取数据集</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size, crop_size = 32, (320, 480)</span><br><span class="line">train_iter, test_iter = d2l.load_data_voc(batch_size, crop_size)</span><br></pre></td></tr></table></figure><h4 id="2-7-训练"><a href="#2-7-训练" class="headerlink" title="2.7 训练"></a>2.7 训练</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def loss(inputs, targets):</span><br><span class="line">    return F.cross_entropy(inputs, targets, reduction=&#x27;none&#x27;).mean(1).mean(1)</span><br><span class="line"></span><br><span class="line">num_epochs, lr, wd, devices = 5, 0.001, 1e-3, d2l.try_all_gpus()</span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=lr, weight_decay=wd)</span><br><span class="line">d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201353655.png" alt="3"></p><h4 id="2-8-可视化预测的类别"><a href="#2-8-可视化预测的类别" class="headerlink" title="2.8 可视化预测的类别"></a>2.8 可视化预测的类别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def predict(img):</span><br><span class="line">    X = test_iter.dataset.normalize_image(img).unsqueeze(0)</span><br><span class="line">    pred = net(X.to(devices[0])).argmax(dim=1)</span><br><span class="line">    return pred.reshape(pred.shape[1], pred.shape[2])</span><br><span class="line">    </span><br><span class="line">def label2image(pred):</span><br><span class="line">    colormap = torch.tensor(d2l.VOC_COLORMAP, device=devices[0])</span><br><span class="line">    X = pred.long()</span><br><span class="line">    return colormap[X, :]</span><br><span class="line"></span><br><span class="line">voc_dir = d2l.download_extract(&#x27;voc2012&#x27;, &#x27;VOCdevkit/VOC2012&#x27;)</span><br><span class="line">test_images, test_labels = d2l.read_voc_images(voc_dir, False)</span><br><span class="line">n, imgs = 4, []</span><br><span class="line">for i in range(n):</span><br><span class="line">    crop_rect = (0, 0, 320, 480)</span><br><span class="line">    X = torchvision.transforms.functional.crop(test_images[i], *crop_rect)</span><br><span class="line">    pred = label2image(predict(X))</span><br><span class="line">    imgs += [</span><br><span class="line">        X.permute(1, 2, 0),</span><br><span class="line">        pred.cpu(),</span><br><span class="line">        torchvision.transforms.functional.crop(test_labels[i],</span><br><span class="line">                                               *crop_rect).permute(1, 2, 0)]</span><br><span class="line">d2l.show_images(imgs[::3] + imgs[1::3] + imgs[2::3], 3, n, scale=2);</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201353581.png" alt="4"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像分割基础</title>
      <link href="/posts/f46e289b.html"/>
      <url>/posts/f46e289b.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-图像分割"><a href="#1-图像分割" class="headerlink" title="1.图像分割"></a>1.图像分割</h3><p><strong>语义分割：</strong>为每个像素都打上标签，只区分类别，但不区分类别中的具体单位。</p><p><strong>实例分割：</strong>不光要区别类别，还要区分类别中的每一个个体。</p><h3 id="2-Focal-loss"><a href="#2-Focal-loss" class="headerlink" title="2.Focal loss"></a>2.Focal loss</h3><p><strong>focal loss从样本难易分类角度出发，解决样本非平衡带来的模型训练问题。</strong></p><p><strong>focal loss的具体形式：</strong><script type="math/tex">\large-\alpha(1-y_{pred})^{\gamma}y_{true}log(y_{pred})-(1-\alpha)y_{pred}^{\gamma}(1-y_{true})log(1-y_{pred})</script></p><p><strong>注：</strong></p><p><em>1.$\large\gamma$通常设置为2，$\large(1-y_{pred})^{\gamma}$相当于样本的难易度权值,$\large\alpha$为正负样本的比例</em></p><p><em>2.为了防止难易样本的频繁变化，应当选取小的学习率。防止学习率过大，造成w变化较大从而引起 $\large y_{pred}$的巨大变化，造成难易样本的改变。</em></p><h3 id="3-转置卷积"><a href="#3-转置卷积" class="headerlink" title="3.转置卷积"></a>3.转置卷积</h3><p><strong>转置卷积：</strong>用来增大输入的高宽</p><h4 id="3-1-转置卷积的计算方式"><a href="#3-1-转置卷积的计算方式" class="headerlink" title="3.1 转置卷积的计算方式"></a>3.1 转置卷积的计算方式</h4><p><strong>计算方式一：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201414993.png" alt="1"></p><p><strong>计算方式二（填充为0，步幅为1)：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201414494.png" alt="2"></p><p><strong>一般情况：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201414965.png" alt="3"></p><p><strong>基本的转置卷积运算：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def trans_conv(X, K):</span><br><span class="line">    h, w = K.shape</span><br><span class="line">    Y = torch.zeros((X.shape[0] + h - 1, X.shape[1] + w - 1))</span><br><span class="line">    for i in range(X.shape[0]):</span><br><span class="line">        for j in range(X.shape[1]):</span><br><span class="line">            Y[i:i + h, j:j + w] += X[i, j] * K</span><br><span class="line">    return Y</span><br></pre></td></tr></table></figure><p><strong>高级API:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">X = torch.tensor([[0.0, 1.0], [2.0, 3.0]])</span><br><span class="line">K = torch.tensor([[0.0, 1.0], [2.0, 3.0]])</span><br><span class="line">X, K = X.reshape(1, 1, 2, 2), K.reshape(1, 1, 2, 2)</span><br><span class="line">tconv = nn.ConvTranspose2d(1, 1, kernel_size=2, bias=False)</span><br><span class="line">tconv.weight.data = K</span><br><span class="line">tconv(X)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">tensor([[[[ 0.,  0.,  1.],</span><br><span class="line">          [ 0.,  4.,  6.],</span><br><span class="line">          [ 4., 12.,  9.]]]], grad_fn=&lt;ConvolutionBackward0&gt;)</span><br></pre></td></tr></table></figure><p><strong>填充：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tconv = nn.ConvTranspose2d(1, 1, kernel_size=2, padding=1, bias=False)#padding=1将输出的行列减小1</span><br><span class="line">tconv.weight.data = K</span><br><span class="line">tconv(X)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">tensor([[[[4.]]]], grad_fn=&lt;ConvolutionBackward0&gt;)</span><br></pre></td></tr></table></figure><p><strong>步幅:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tconv = nn.ConvTranspose2d(1, 1, kernel_size=2, stride=2, bias=False)#增大stride会将输出变大</span><br><span class="line">tconv.weight.data = K</span><br><span class="line">tconv(X)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">tensor([[[[0., 0., 0., 1.],</span><br><span class="line">          [0., 0., 2., 3.],</span><br><span class="line">          [0., 2., 0., 3.],</span><br><span class="line">          [4., 6., 6., 9.]]]], grad_fn=&lt;ConvolutionBackward0&gt;)</span><br></pre></td></tr></table></figure><p><strong>多通道:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand(size=(1, 10, 16, 16))</span><br><span class="line">conv = nn.Conv2d(10, 20, kernel_size=5, padding=2, stride=3)</span><br><span class="line">tconv = nn.ConvTranspose2d(20, 10, kernel_size=5, padding=2, stride=3)</span><br><span class="line">tconv(conv(X)).shape == X.shape</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h4 id="3-2-转置卷积的棋盘效应"><a href="#3-2-转置卷积的棋盘效应" class="headerlink" title="3.2 转置卷积的棋盘效应"></a>3.2 转置卷积的棋盘效应</h4><p><strong>棋盘效应：</strong>在转置卷积操作中，生成的输出特征图中出现的不规则、重叠和错位的图案，类似于棋盘格子</p><p><strong>棋盘效应的主要原因：</strong>kernel size不能够被stride整除（<strong>不均匀重叠</strong>）</p><p><strong>解决方法：</strong></p><p><strong>方法一：</strong>使kernel size能够被stride整除（无法完全避免该问题）</p><p><strong>方法二：</strong>插值法+卷积</p><h3 id="4-双线性插值"><a href="#4-双线性插值" class="headerlink" title="4.双线性插值"></a>4.双线性插值</h3><p><strong>双线性插值：</strong>通过待求像素点在源图像中4个最近邻像素值的加权和计算得到</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201414401.png" alt="4"></p><p><strong>优势：</strong>没有灰度不连续的缺点，结果基本令人满意</p><p><strong>劣势：</strong>双线性内插法的计算比最邻近点法复杂，计算量较大。它具有低通滤波性质，使高频分量受损，图像轮廓可能会有一点模糊。</p><h3 id="5-Batch-Normalization"><a href="#5-Batch-Normalization" class="headerlink" title="5.Batch Normalization"></a>5.Batch Normalization</h3><p><strong>优点：</strong><br>1.可以用更大学习率，加速模型收敛<br>2.可以不用精心设计权值初始化<br>3.可以不用dropout或较小的dropout<br>4.可以不用L2或者较小的weight decay<br>5.可以不用LRN(local response normalization)</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201414040.png" alt="5"></p><p><strong><em>注：</em></strong></p><p><strong><em>1.由于归一化后的xi基本会被限制在正态分布下，使得网络的表达能力下降。为解决该问题，我们引入两个新的参数：γ,β。 γ和β是在训练时网络自己学习得到的。</em></strong></p><p><em>2.Batch Normalization将数据移到激活函数中心区域，对于大多数的激活函数而言，这个区域的梯度都是最大的或者是有梯度的，因而这种方法是一种对抗梯度消失的有效手段。</em></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（1）</title>
      <link href="/posts/75288c8f.html"/>
      <url>/posts/75288c8f.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-常量"><a href="#1-常量" class="headerlink" title="1.常量"></a>1.常量</h3><h4 id="1-1-使用-const-将变量声明为常量"><a href="#1-1-使用-const-将变量声明为常量" class="headerlink" title="1.1 使用 const 将变量声明为常量"></a>1.1 使用 const 将变量声明为常量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const double pi = 3.14;</span><br></pre></td></tr></table></figure><h4 id="1-2-使用-constexpr-定义常量表达式"><a href="#1-2-使用-constexpr-定义常量表达式" class="headerlink" title="1.2 使用 constexpr 定义常量表达式"></a>1.2 使用 constexpr 定义常量表达式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constexpr double GetPi() &#123;return 3.14;&#125;</span><br><span class="line">constexpr double TwicePi()&#123;return 2* GetPi();&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-使用关键字-enum-声明的枚举常量"><a href="#1-3-使用关键字-enum-声明的枚举常量" class="headerlink" title="1.3 使用关键字 enum 声明的枚举常量"></a>1.3 使用关键字 enum 声明的枚举常量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">enum direct&#123;</span><br><span class="line">        North=5,</span><br><span class="line">        South,</span><br><span class="line">        East,</span><br><span class="line">        West</span><br><span class="line">    &#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    direct f=North;</span><br><span class="line">    cout&lt;&lt;f&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;South&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;East&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;West&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p><em>1.使用枚举来指定变量的类型，这样声明的变量只能取指定的值</em>。</p><p><em>2.North的值设置为5，这自动将随后的常量分别设置为 6、7 和8。</em></p><h4 id="1-4-使用-define-定义常量"><a href="#1-4-使用-define-定义常量" class="headerlink" title="1.4 使用#define 定义常量"></a>1.4 使用#define 定义常量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define pi 3.14</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p><em>1.#define 是一个预处理器宏，让预处理器将随后出现的所有 pi 都替换为 3.14。</em></p><p><em>2.使用#define 定义常量的做法已被摒弃，因此不应采用这种做法。</em></p><h3 id="2-动态数组"><a href="#2-动态数组" class="headerlink" title="2.动态数组"></a>2.动态数组</h3><p><strong>std::vector:</strong>支持在运行阶段根据需要增大动态数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; a(3);</span><br><span class="line">    a[0]=1,a[1]=2,a[2]=3;</span><br><span class="line">    printf(&quot;%d\n&quot;,a.size());</span><br><span class="line">    a.push_back(4);</span><br><span class="line">    printf(&quot;%d&quot;,a.size());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="3-Lambda-表达式"><a href="#3-Lambda-表达式" class="headerlink" title="3.Lambda 表达式"></a>3.Lambda 表达式</h3><p><strong>[capture](parameters) -&gt; return_type { body }</strong></p><ul><li><code>capture</code>：捕获列表，用于指定在 lambda 表达式中可见的外部变量。可以通过值捕获或引用捕获来捕获变量。</li><li><code>parameters</code>：参数列表，与普通函数的参数列表一样，用于传递参数给 lambda 表达式。</li><li><code>return_type</code>：返回类型，指定 lambda 表达式的返回类型。可以省略，编译器会自动推断返回类型。</li><li><code>body</code>：函数体，包含 lambda 表达式的实际操作。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">#lambda表达式接受两个整数参数x和y，然后返回它们的和</span><br><span class="line">    auto add=[](int x,int y)-&gt;int&#123;</span><br><span class="line">        return x+y;</span><br><span class="line">    &#125;;</span><br><span class="line">    int ans=add(2,3);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    int x=2,y=3;</span><br><span class="line">    #这个lambda表达式没有参数，并且在捕获列表中捕获了变量x和y，返回x*y的结果</span><br><span class="line">    auto mul=[x,y]()-&gt;int&#123;</span><br><span class="line">        return x*y;</span><br><span class="line">    &#125;;</span><br><span class="line">    int res=mul();</span><br><span class="line">    printf(&quot;%d&quot;,res);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-动态内存分配"><a href="#4-动态内存分配" class="headerlink" title="4.动态内存分配"></a>4.动态内存分配</h3><p><strong>使用 new  动态地分配内存</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type* Pointer = new Type;</span><br><span class="line">Type* Pointer = new Type[numElements];</span><br></pre></td></tr></table></figure><p><strong>最终都需使用对应的 delete 进行释放:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete Pointer;</span><br><span class="line">delete[] Pointer;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int *x=new int;</span><br><span class="line">    scanf(&quot;%d&quot;,x);</span><br><span class="line">    printf(&quot;%d&quot;,*x);</span><br><span class="line">    delete x;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-将关键字-const-用于指针"><a href="#5-将关键字-const-用于指针" class="headerlink" title="5.将关键字 const 用于指针"></a>5.将关键字 const 用于指针</h3><h4 id="5-1-地址不能修改-数据可修改"><a href="#5-1-地址不能修改-数据可修改" class="headerlink" title="5.1 地址不能修改,数据可修改"></a>5.1 地址不能修改,数据可修改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int* const pDaysInMonth = &amp;daysInMonth;</span><br></pre></td></tr></table></figure><h4 id="5-2-地址可修改-数据不能修改"><a href="#5-2-地址可修改-数据不能修改" class="headerlink" title="5.2 地址可修改,数据不能修改"></a>5.2 地址可修改,数据不能修改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int* pointsToInt = &amp;hoursInDay;</span><br></pre></td></tr></table></figure><h4 id="5-3-地址和数据均不能修改"><a href="#5-3-地址和数据均不能修改" class="headerlink" title="5.3 地址和数据均不能修改"></a>5.3 地址和数据均不能修改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int* const pHoursInDay = &amp;hoursInDay;</span><br></pre></td></tr></table></figure><h3 id="6-共用体"><a href="#6-共用体" class="headerlink" title="6.共用体"></a>6.共用体</h3><p><strong>共用体：</strong>可包含多个数据成员，但是只能使用其中的一个。</p><p><strong>sizeof()</strong>用于共用体时，结果总是为共用体最大成员的长度，即便该成员并不处于活动状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">union Type</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    char p;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Type a;</span><br><span class="line">    a.num=1;</span><br><span class="line">    printf(&quot;num:%d\n&quot;,a.num);</span><br><span class="line">    a.p=&#x27;x&#x27;;</span><br><span class="line">    printf(&quot;p:%c\n&quot;,a.num,a.p);</span><br><span class="line">    printf(&quot;size:%d&quot;,sizeof(a));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">num:1</span><br><span class="line">p:x</span><br><span class="line">size:4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>torchvision.transforms使用详解</title>
      <link href="/posts/cc5fd5b2.html"/>
      <url>/posts/cc5fd5b2.html</url>
      
        <content type="html"><![CDATA[<h2 id="torchvision-transforms"><a href="#torchvision-transforms" class="headerlink" title="torchvision.transforms"></a>torchvision.transforms</h2><h3 id="1-torchvision-transforms-Compose"><a href="#1-torchvision-transforms-Compose" class="headerlink" title="1. torchvision.transforms.Compose"></a>1. torchvision.transforms.Compose</h3><p><strong>torchvision.transforms.Compose：</strong>是一个用于组合多个图像预处理操作的类，将多个预处理操作串联在一起，以便在数据加载时对图像进行连续的处理。</p><p><strong>torchvision.transforms.Compose(transforms)</strong> 的参数是一个列表，其中包含要进行的图像预处理操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import torchvision.transforms as transforms</span><br><span class="line"></span><br><span class="line"># 定义图像预处理操作</span><br><span class="line">transformations = transforms.Compose([</span><br><span class="line">    transforms.Resize(256),              # 调整图像大小为256x256</span><br><span class="line">    transforms.RandomCrop(224),          # 随机裁剪为224x224</span><br><span class="line">    transforms.RandomHorizontalFlip(),   # 随机水平翻转</span><br><span class="line">    transforms.ToTensor(),               # 将图像转换为Tensor格式</span><br><span class="line">    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])  # 归一化</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"># 使用组合的预处理操作对图像进行处理</span><br><span class="line">img = Image.open(&#x27;example.jpg&#x27;)  # 假设有一张名为 &#x27;example.jpg&#x27; 的图像</span><br><span class="line">processed_img = transformations(img)</span><br></pre></td></tr></table></figure><h3 id="2-torchvision-transforms-RandomResizedCrop"><a href="#2-torchvision-transforms-RandomResizedCrop" class="headerlink" title="2.torchvision.transforms.RandomResizedCrop"></a>2.torchvision.transforms.RandomResizedCrop</h3><p><strong>torchvision.transforms.RandomResizedCrop：</strong>用于<strong>数据增广</strong>，以增加数据集的<strong>多样性</strong>和提高模型的<strong>泛化能力</strong>（随机裁剪图像，并将裁剪后的图像调整为指定的大小）</p><p><code>torchvision.transforms.RandomResizedCrop(size, scale=(0.08, 1.0), ratio=(3.0/4.0, 4.0/3.0), interpolation=2)</code> 的参数包括：</p><ul><li><p><code>size</code>：输出的裁剪后图像的大小，可以是一个整数或一个元组 (height, width)。</p></li><li><p><code>scale</code>：控制裁剪区域相对于原始图像大小的尺度范围，它是一个长度为2的元组 (min_scale, max_scale)。裁剪区域的大小在 [min_scale <em> 图像大小, max_scale </em> 图像大小] 之间随机选择。</p></li><li><p><code>ratio</code>：控制裁剪区域的宽高比范围，它是一个长度为2的元组 (min_ratio, max_ratio)。裁剪区域的宽高比在 [min_ratio, max_ratio] 之间随机选择。</p></li><li><p><code>interpolation</code>：插值方法，用于调整裁剪后图像的大小。默认值为2，表示使用双线性插值。</p><p><em>注：在图像处理中，将图像从一个尺寸调整为另一个尺寸时，通常需要使用插值方法来计算新尺寸的像素值。</em></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import torchvision.transforms as transforms</span><br><span class="line">from PIL import Image</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"># 定义随机裁剪操作</span><br><span class="line">transformations = transforms.RandomResizedCrop(size=224, scale=(0.08, 1.0), ratio=(3.0/4.0, 4.0/3.0))</span><br><span class="line"></span><br><span class="line"># 使用随机裁剪操作对图像进行处理</span><br><span class="line">img = Image.open(&#x27;example.jpg&#x27;)  # 假设有一张名为 &#x27;example.jpg&#x27; 的图像</span><br><span class="line">processed_img = transformations(img)</span><br><span class="line">plt.imshow(processed_img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="3-torchvision-transforms-RandomHorizontalFlip"><a href="#3-torchvision-transforms-RandomHorizontalFlip" class="headerlink" title="3.torchvision.transforms.RandomHorizontalFlip()"></a>3.torchvision.transforms.RandomHorizontalFlip()</h3><p><strong>torchvision.transforms.RandomHorizontalFlip():</strong>对图像进行随机水平翻转，增加数据集的多样性和提高模型的鲁棒性。</p><p><code>torchvision.transforms.RandomHorizontalFlip(p=0.5)</code> 的参数 <code>p</code> （默认为0.5）控制水平翻转的概率。</p><p>当 <code>p=0.5</code> 时，有50%的概率对图像进行水平翻转。当 <code>p=0</code> 时，不进行翻转；当 <code>p=1</code> 时，100%进行翻转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import torchvision.transforms as transforms</span><br><span class="line"></span><br><span class="line"># 定义随机水平翻转操作</span><br><span class="line">transformations = transforms.RandomHorizontalFlip(p=0.5)</span><br><span class="line"></span><br><span class="line"># 使用随机水平翻转操作对图像进行处理</span><br><span class="line">img = Image.open(&#x27;example.jpg&#x27;)  # 假设有一张名为 &#x27;example.jpg&#x27; 的图像</span><br><span class="line">processed_img = transformations(img)</span><br></pre></td></tr></table></figure><h3 id="4-torchvision-transforms-ToTensor"><a href="#4-torchvision-transforms-ToTensor" class="headerlink" title="4.torchvision.transforms.ToTensor()"></a>4.torchvision.transforms.ToTensor()</h3><p><strong>torchvision.transforms.ToTensor():</strong>用于将 PIL 图像或 NumPy 数组转换为 PyTorch 张量（Tensor）格式，以便在深度学习模型中使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import torchvision.transforms as transforms</span><br><span class="line"></span><br><span class="line"># 定义 ToTensor 操作</span><br><span class="line">transformations = transforms.ToTensor()</span><br><span class="line"></span><br><span class="line"># 使用 ToTensor 操作将 PIL 图像转换为张量</span><br><span class="line">img = Image.open(&#x27;example.jpg&#x27;)  # 假设有一张名为 &#x27;example.jpg&#x27; 的图像</span><br><span class="line">tensor_img = transformations(img)</span><br></pre></td></tr></table></figure><h3 id="5-torchvision-transforms-Normalize"><a href="#5-torchvision-transforms-Normalize" class="headerlink" title="5.torchvision.transforms.Normalize"></a>5.torchvision.transforms.Normalize</h3><p><strong>torchvision.transforms.Normalize:</strong>对图像进行归一化处理，以便模型在训练和推断过程中更好地处理数据</p><h4 id="5-1-计算数据集的均值和标准差"><a href="#5-1-计算数据集的均值和标准差" class="headerlink" title="5.1 计算数据集的均值和标准差"></a>5.1 计算数据集的均值和标准差</h4><p><strong>os.walk(dataset_path)：</strong>用于遍历文件夹的一个函数，它生成一个三元组的迭代器，每次迭代返回一个包含当前<strong>目录路径</strong>、当前目录下所有<strong>子目录名</strong>、当前目录下所有<strong>文件名</strong>的元组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from PIL import Image</span><br><span class="line">import os</span><br><span class="line">import torchvision.transforms as transforms</span><br><span class="line">import torch</span><br><span class="line"></span><br><span class="line">def compute_mean_and_std(dataset_path):</span><br><span class="line">    # 初始化均值和标准差</span><br><span class="line">    mean = torch.zeros(3)</span><br><span class="line">    std = torch.zeros(3)</span><br><span class="line">    num_images = 0</span><br><span class="line"></span><br><span class="line">    # 遍历数据集</span><br><span class="line">    for root, _, files in os.walk(dataset_path):</span><br><span class="line">        for file in files:</span><br><span class="line">            if file.endswith(&quot;.jpg&quot;) or file.endswith(&quot;.png&quot;) or file.endswith(&quot;.jpeg&quot;):</span><br><span class="line">                img_path = os.path.join(root, file)</span><br><span class="line">                img = Image.open(img_path).convert(&quot;RGB&quot;)</span><br><span class="line">                transformations = transforms.ToTensor()</span><br><span class="line">                img = transformations(img)</span><br><span class="line"></span><br><span class="line">                # 计算当前图像的均值和标准差</span><br><span class="line">                mean += torch.mean(img, dim=(1, 2))</span><br><span class="line">                std += torch.std(img, dim=(1, 2))</span><br><span class="line">                num_images += 1</span><br><span class="line"></span><br><span class="line">    # 计算整个数据集的均值和标准差</span><br><span class="line">    mean /= num_images</span><br><span class="line">    std /= num_images</span><br><span class="line"></span><br><span class="line">    return mean.tolist(), std.tolist()</span><br><span class="line"></span><br><span class="line"># 数据集路径</span><br><span class="line">dataset_path = &quot;.\train&quot;</span><br><span class="line"></span><br><span class="line"># 计算均值和标准差</span><br><span class="line">mean, std = compute_mean_and_std(dataset_path)</span><br><span class="line">print(&quot;Mean:&quot;, mean)</span><br><span class="line">print(&quot;Std:&quot;, std)</span><br></pre></td></tr></table></figure><p><em>注：</em></p><p><em>1.表示图像的 Tensor，其维度为 (C, H, W)，其中 C 表示通道数，H 表示图像的高度，W 表示图像的宽度。<strong>dim=(1, 2)</strong> 表示在第 1 和第 2 维度上进行求均值的操作，<strong>torch.mean(img, dim=(1, 2))</strong>将对每个通道的高度和宽度上的所有像素值进行求均值。</em></p><p><em>2.<strong>PIL 图像（NumPy 数组表示）：</strong>在将图像转换为 NumPy 数组时，通常图像中的像素值被映射到 [0, 255] 范围内，方便对图像进行基本的像素级操作，如颜色调整、滤波等。</em></p><p><em>3.<strong>PyTorch 张量</strong>：PyTorch 张量在处理图像时，通常会进行数据归一化处理，图像的像素值会被映射到 [0, 1] 范围内，这可以有效地缩小不同通道之间数值的差异，避免数据在训练过程中产生较大的梯度，导致训练不稳定。（归一化方式是将像素值除以 255）</em></p><h4 id="5-2-torchvision-transforms-Normalize"><a href="#5-2-torchvision-transforms-Normalize" class="headerlink" title="5.2 torchvision.transforms.Normalize"></a>5.2 torchvision.transforms.Normalize</h4><p><code>torchvision.transforms.Normalize(mean, std)</code> 的参数包括：</p><ul><li><code>mean</code>：一个包含三个元素的列表或元组，表示每个通道的均值。对于 RGB 图像，通常是 [R 均值, G 均值, B 均值]。</li><li><code>std</code>：一个包含三个元素的列表或元组，表示每个通道的标准差。对于 RGB 图像，通常是 [R 标准差, G 标准差, B 标准差]</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import torchvision.transforms as transforms</span><br><span class="line"></span><br><span class="line"># 定义归一化操作</span><br><span class="line">mean = [0.4914, 0.4822, 0.4465]</span><br><span class="line">std = [0.2023, 0.1994, 0.2010]</span><br><span class="line">transformations = transforms.Normalize(mean=mean, std=std)</span><br><span class="line"></span><br><span class="line"># 假设 tensor_img 是一个张量，表示一张图像</span><br><span class="line">normalized_img = transformations(tensor_img)</span><br></pre></td></tr></table></figure><h3 id="6-torchvision-transforms-functional-crop"><a href="#6-torchvision-transforms-functional-crop" class="headerlink" title="6.torchvision.transforms.functional.crop"></a>6.torchvision.transforms.functional.crop</h3><p><strong>torchvision.transforms.functional.crop：</strong>从输入图像中裁剪出指定区域的子图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.functional.crop(img, top, left, height, width)</span><br></pre></td></tr></table></figure><ul><li><code>img</code>：输入的图像，通常是一个 PIL 图像或一个张量。</li><li><code>top</code>：裁剪区域的顶部边界（以像素为单位）。</li><li><code>left</code>：裁剪区域的左边界（以像素为单位）。</li><li><code>height</code>：裁剪区域的高度（以像素为单位）。</li><li><code>width</code>：裁剪区域的宽度（以像素为单位）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crop_rect = (0, 0, 320, 480)</span><br><span class="line">X = torchvision.transforms.functional.crop(test_images, *crop_rect)</span><br><span class="line">#crop_rect 是一个包含四个值的元组 (top, left, height, width)，它定义了要从图像中裁剪的区域的位置和大小</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> torchvision </tag>
            
            <tag> 图像预处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性回归</title>
      <link href="/posts/40997091.html"/>
      <url>/posts/40997091.html</url>
      
        <content type="html"><![CDATA[<h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><h3 id="1-线性回归的从零开始实现"><a href="#1-线性回归的从零开始实现" class="headerlink" title="1.线性回归的从零开始实现"></a>1.线性回归的从零开始实现</h3><h4 id="1-1-构造数据集"><a href="#1-1-构造数据集" class="headerlink" title="1.1 构造数据集"></a>1.1 构造数据集</h4><p>以参数w=[2,−3.4]⊤、b=4.2和噪声项ϵ生成数据集。</p><p>标签：y=Xw+b+ϵ</p><p><strong>torch.normal()：</strong>生成一个服从正态分布的随机张量。</p><p><strong>torch.matmul：</strong>计算两个张量矩阵相乘（可以用利用广播机制进行不同维度的相乘操作）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def synthetic_data(w, b, num_examples):  </span><br><span class="line">    &quot;&quot;&quot;生成 y = Xw + b + 噪声。&quot;&quot;&quot;</span><br><span class="line">    X = torch.normal(0, 1, (num_examples, len(w)))</span><br><span class="line">    #torch.normal()生成一个服从正态分布（均值为0，标准差为1）的随机张量X，大小为(num_examples, len(w))</span><br><span class="line">    #其中num_examples是样本数量，len(w)是特征数量。</span><br><span class="line">    y = torch.matmul(X, w) + b</span><br><span class="line">    #函数通过矩阵乘法计算目标变量y。y是由X和w之间的线性关系构造的，并且加上了偏差项b。</span><br><span class="line">    y += torch.normal(0, 0.01, y.shape)</span><br><span class="line">    #函数为目标变量y添加了一个服从正态分布（均值为0，标准差为0.01）的随机噪声，以模拟真实数据中的噪声。</span><br><span class="line">    return X, y.reshape((-1, 1))</span><br><span class="line"></span><br><span class="line">true_w = torch.tensor([2, -3.4])</span><br><span class="line">true_b = 4.2</span><br><span class="line">features, labels = synthetic_data(true_w, true_b, 1000)</span><br></pre></td></tr></table></figure><h4 id="1-2-观察特征的相关性"><a href="#1-2-观察特征的相关性" class="headerlink" title="1.2 观察特征的相关性"></a>1.2 观察特征的相关性</h4><p>将features张量中第二列的数据作为x轴，labels张量的数据作为y轴，绘制出散点图，散点图的每个点的大小为1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d2l.plt.scatter(features[:,1].detach().numpy(),</span><br><span class="line">                labels.detach().numpy(), 1);#detach()函数用于从计算图中分离出这部分数据，以防止在绘制图形时产生梯度计算</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201638283.png" alt="img"></p><h4 id="1-3-构造一个PyTorch数据迭代器"><a href="#1-3-构造一个PyTorch数据迭代器" class="headerlink" title="1.3 构造一个PyTorch数据迭代器"></a>1.3 构造一个PyTorch数据迭代器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">def data_iter(batch_size, features, labels):#接收批量大小、特征矩阵和标签向量作为输入</span><br><span class="line">    num_examples = len(features)#计算了特征数据的样本数量。</span><br><span class="line">    indices = list(range(num_examples))#创建一个索引列表。</span><br><span class="line">    random.shuffle(indices)# 将样本索引列表打乱，目的是随机化样本的顺序，这样在每个迭代周期中会使用不同的样本顺序，有助于训练模型的泛化能力。</span><br><span class="line">    for i in range(0, num_examples, batch_size):#循环开始，每次增加batch_size个步长进行迭代，直到遍历完所有样本。</span><br><span class="line">        batch_indices = torch.tensor(indices[i:min(i +</span><br><span class="line">                                                   batch_size, num_examples)])</span><br><span class="line">                #从打乱后的索引列表中选择一个批次的索引。</span><br><span class="line">                #注意，最后一个批次可能不足batch_size，因此使用min(i + batch_size, num_examples)来确保不超出数据集的边界。</span><br><span class="line">        yield features[batch_indices], labels[batch_indices]</span><br><span class="line">  </span><br><span class="line">batch_size = 10</span><br><span class="line">for X, y in data_iter(batch_size, features, labels):</span><br><span class="line">    print(X, &#x27;\n&#x27;, y)</span><br><span class="line">    break</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">tensor([[ 0.9374, -0.1930],</span><br><span class="line">        [ 0.1325, -1.0253],</span><br><span class="line">        [ 0.9573,  0.4727],</span><br><span class="line">        [-0.3795,  0.4407],</span><br><span class="line">        [-0.4063,  1.0375],</span><br><span class="line">        [ 0.7656, -1.9743],</span><br><span class="line">        [ 1.4891,  1.4386],</span><br><span class="line">        [-0.9692, -0.4879],</span><br><span class="line">        [ 2.5848,  1.3103],</span><br><span class="line">        [-0.5822,  0.5608]]) </span><br><span class="line"> tensor([[ 6.7309],</span><br><span class="line">        [ 7.9584],</span><br><span class="line">        [ 4.4986],</span><br><span class="line">        [ 1.9576],</span><br><span class="line">        [-0.1413],</span><br><span class="line">        [12.4321],</span><br><span class="line">        [ 2.2723],</span><br><span class="line">        [ 3.9170],</span><br><span class="line">        [ 4.9298],</span><br><span class="line">        [ 1.1197]])</span><br></pre></td></tr></table></figure><h4 id="1-4-初始化模型参数"><a href="#1-4-初始化模型参数" class="headerlink" title="1.4 初始化模型参数"></a>1.4 初始化模型参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w = torch.normal(0, 0.01, size=(2, 1), requires_grad=True)</span><br><span class="line">b = torch.zeros(1, requires_grad=True)</span><br><span class="line">#requires_grad=True:表示这个张量是可训练的，当执行反向传播时，PyTorch会自动计算关于w的梯度，并在优化算法中更新这个张量。</span><br></pre></td></tr></table></figure><h4 id="1-5-定义模型"><a href="#1-5-定义模型" class="headerlink" title="1.5 定义模型"></a>1.5 定义模型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def linreg(X, w, b):  </span><br><span class="line">    &quot;&quot;&quot;线性回归模型。&quot;&quot;&quot;</span><br><span class="line">    return torch.matmul(X, w) + b</span><br></pre></td></tr></table></figure><h4 id="1-6-定义损失函数"><a href="#1-6-定义损失函数" class="headerlink" title="1.6 定义损失函数"></a>1.6 定义损失函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def squared_loss(y_hat, y):  #y_hat：预测值</span><br><span class="line">    &quot;&quot;&quot;均方损失。&quot;&quot;&quot;</span><br><span class="line">    return (y_hat - y.reshape(y_hat.shape))**2 / 2</span><br></pre></td></tr></table></figure><h4 id="1-7-定义优化算法"><a href="#1-7-定义优化算法" class="headerlink" title="1.7 定义优化算法"></a>1.7 定义优化算法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def sgd(params, lr, batch_size):  #params（模型的可训练参数）、lr（学习率）和batch_size（批大小）</span><br><span class="line">    &quot;&quot;&quot;小批量随机梯度下降。&quot;&quot;&quot;</span><br><span class="line">    with torch.no_grad():#上下文管理器，用于包裹在其内部的操作，告诉PyTorch在这个上下文中不要计算梯度</span><br><span class="line">        for param in params:</span><br><span class="line">            param -= lr * param.grad / batch_size#梯度乘以学习率，再除以批大小来更新参数</span><br><span class="line">            param.grad.zero_()#将参数的梯度清零，在PyTorch中，梯度是累积的，需要手动将梯度置零</span><br></pre></td></tr></table></figure><h4 id="1-8-训练过程"><a href="#1-8-训练过程" class="headerlink" title="1.8 训练过程"></a>1.8 训练过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lr = 0.03</span><br><span class="line">num_epochs = 3</span><br><span class="line">net = linreg</span><br><span class="line">loss = squared_loss</span><br><span class="line"></span><br><span class="line">for epoch in range(num_epochs):</span><br><span class="line">    for X, y in data_iter(batch_size, features, labels):</span><br><span class="line">        l = loss(net(X, w, b), y)</span><br><span class="line">        l.sum().backward()# l是向量，用sum转换成标量，再对损失进行反向传播，计算模型参数 w 和 b 的梯度。</span><br><span class="line">        sgd([w, b], lr, batch_size)</span><br><span class="line">    with torch.no_grad():</span><br><span class="line">        train_l = loss(net(features, w, b), labels)</span><br><span class="line">        print(f&#x27;epoch &#123;epoch + 1&#125;, loss &#123;float(train_l.mean()):f&#125;&#x27;)</span><br></pre></td></tr></table></figure><h4 id="1-9-评估训练效果"><a href="#1-9-评估训练效果" class="headerlink" title="1.9 评估训练效果"></a>1.9 评估训练效果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(f&#x27;w的估计误差: &#123;true_w - w.reshape(true_w.shape)&#125;&#x27;)</span><br><span class="line">print(f&#x27;b的估计误差: &#123;true_b - b&#125;&#x27;)</span><br></pre></td></tr></table></figure><h3 id="2-线性回归的简洁实现"><a href="#2-线性回归的简洁实现" class="headerlink" title="2.线性回归的简洁实现"></a>2.线性回归的简洁实现</h3><h4 id="2-1-构造数据集"><a href="#2-1-构造数据集" class="headerlink" title="2.1 构造数据集"></a>2.1 构造数据集</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import torch</span><br><span class="line">from torch.utils import data</span><br><span class="line">from d2l import torch as d2l</span><br><span class="line"></span><br><span class="line">true_w = torch.tensor([2, -3.4])</span><br><span class="line">true_b = 4.2</span><br><span class="line">features, labels = d2l.synthetic_data(true_w, true_b, 1000)</span><br></pre></td></tr></table></figure><h4 id="2-2-构造一个PyTorch数据迭代器"><a href="#2-2-构造一个PyTorch数据迭代器" class="headerlink" title="2.2 构造一个PyTorch数据迭代器"></a>2.2 构造一个PyTorch数据迭代器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def load_array(data_arrays, batch_size, is_train=True):  </span><br><span class="line">    &quot;&quot;&quot;构造一个PyTorch数据迭代器。&quot;&quot;&quot;</span><br><span class="line">    dataset = data.TensorDataset(*data_arrays)#用于将特征数据和标签数据打包成一个数据集对象</span><br><span class="line">    return data.DataLoader(dataset, batch_size, shuffle=is_train)#从数据集中按照批大小 batch_size 加载数据</span><br><span class="line">#shuffle=is_train 表示在训练模式下（is_train=True）将数据打乱顺序</span><br><span class="line"></span><br><span class="line">batch_size = 10</span><br><span class="line">data_iter = load_array((features, labels), batch_size)</span><br><span class="line"></span><br><span class="line">next(iter(data_iter))</span><br></pre></td></tr></table></figure><h4 id="2-3-构建模型"><a href="#2-3-构建模型" class="headerlink" title="2.3 构建模型"></a>2.3 构建模型</h4><p><strong>nn.Sequential：</strong>PyTorch中的一个容器类，它按照顺序组合各种神经网络的层。</p><p><strong>nn.Linear(2, 1)：</strong><code>nn.Linear</code>是一个全连接层（线性层），它接收两个参数：输入特征的数量（输入维度）和输出特征的数量（输出维度）。因此该层将实现一个将输入维度为2的数据映射为输出维度为1的线性变换（线性回归模型）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from torch import nn</span><br><span class="line"></span><br><span class="line">net = nn.Sequential(nn.Linear(2, 1))</span><br><span class="line">#初始化模型参数</span><br><span class="line">net[0].weight.data.normal_(0, 0.01)#net[0]表示模型中的第一个层</span><br><span class="line">net[0].bias.data.fill_(0)</span><br><span class="line"></span><br><span class="line">loss = nn.MSELoss()#定义损失函数</span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=0.03)#实例化SGD实例</span><br></pre></td></tr></table></figure><h4 id="2-4-训练过程"><a href="#2-4-训练过程" class="headerlink" title="2.4 训练过程"></a>2.4 训练过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num_epochs = 3</span><br><span class="line">for epoch in range(num_epochs):</span><br><span class="line">    for X, y in data_iter:</span><br><span class="line">        l = loss(net(X), y)</span><br><span class="line">        trainer.zero_grad()</span><br><span class="line">        l.backward() #pytorch自动对l求sum，无需再求sum</span><br><span class="line">        trainer.step()</span><br><span class="line">    l = loss(net(features), labels)</span><br><span class="line">    print(f&#x27;epoch &#123;epoch + 1&#125;, loss &#123;l:f&#125;&#x27;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 线性回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据预处理</title>
      <link href="/posts/e92b12e5.html"/>
      <url>/posts/e92b12e5.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><h3 id="1-创建csv文件"><a href="#1-创建csv文件" class="headerlink" title="1.创建csv文件"></a>1.创建csv文件</h3><h4 id="1-1-创建目录"><a href="#1-1-创建目录" class="headerlink" title="1.1 创建目录"></a>1.1 创建目录</h4><p><strong>os.makedirs():</strong> 这是一个用于递归创建目录的函数。它接受一个路径作为输入，并创建路径中所有缺失的目录</p><p><strong>exist_ok=True:</strong> 这是os.makedirs()函数的一个可选参数。当设置为True时，如果目标目录已经存在，函数不会引发错误，而是默默地继续执行。</p><p><strong>os.path.join()：</strong>函数来连接两个路径部分：”..”(表示父目录) 和 “data”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">os.makedirs(os.path.join(&#x27;..&#x27;, &#x27;data&#x27;), exist_ok=True)</span><br><span class="line">#创建一个名为&quot;data&quot;的目录，该目录位于当前工作目录的父目录中</span><br><span class="line">data_file = os.path.join(&#x27;..&#x27;, &#x27;data&#x27;, &#x27;house_tiny.csv&#x27;)</span><br><span class="line">#创建一个名为data_file的变量，指向当前工作目录的上一级目录中的&quot;data&quot;目录下的&quot;house_tiny.csv&quot;文件</span><br></pre></td></tr></table></figure><p><em>注：如果目录不存在，它将被创建。这样，代码在运行时，如果”data”目录已经存在，它不会抛出异常，而是继续执行。</em></p><h4 id="1-2-创建新文件"><a href="#1-2-创建新文件" class="headerlink" title="1.2 创建新文件"></a>1.2 创建新文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">with open(data_file, &#x27;w&#x27;) as f:#打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</span><br><span class="line">    f.write(&#x27;NumRooms,Alley,Price\n&#x27;)</span><br><span class="line">    f.write(&#x27;NA,Pave,127500\n&#x27;)</span><br><span class="line">    f.write(&#x27;2,NA,106000\n&#x27;)</span><br><span class="line">    f.write(&#x27;4,NA,178100\n&#x27;)</span><br><span class="line">    f.write(&#x27;NA,NA,140000\n&#x27;)</span><br></pre></td></tr></table></figure><h3 id="2-数据预处理"><a href="#2-数据预处理" class="headerlink" title="2.数据预处理"></a>2.数据预处理</h3><h4 id="2-1-读取文件"><a href="#2-1-读取文件" class="headerlink" title="2.1 读取文件"></a>2.1 读取文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">data = pd.read_csv(data_file)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><h4 id="2-2-数据切片"><a href="#2-2-数据切片" class="headerlink" title="2.2 数据切片"></a>2.2 数据切片</h4><p><strong>iloc方法</strong>用于基于整数位置对数据进行索引和切片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">inputs, outputs = data.iloc[:,0:2], data.iloc[:,2]#iloc方法用于基于整数位置对数据进行索引和切片</span><br><span class="line">print(inputs)</span><br><span class="line">print(outputs)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"> NumRooms Alley</span><br><span class="line">0 NaN Pave</span><br><span class="line">1 2.0 NaN</span><br><span class="line">2 4.0 NaN</span><br><span class="line">3 NaN NaN</span><br><span class="line"></span><br><span class="line">0    127500</span><br><span class="line">1    106000</span><br><span class="line">2    178100</span><br><span class="line">3    140000</span><br><span class="line">Name: Price, dtype: int64</span><br></pre></td></tr></table></figure><h4 id="2-3-缺失值填充"><a href="#2-3-缺失值填充" class="headerlink" title="2.3 缺失值填充"></a>2.3 缺失值填充</h4><p><strong>fillna() 方法</strong>用指定的值（在这里是 inputs.mean() 即每列的均值）替换DataFrame中的缺失值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#对筛选出的数值类型列使用 mean() 方法计算各自列的均值进行填充</span><br><span class="line">inputs = inputs.fillna(inputs.select_dtypes(include=&#x27;number&#x27;).mean())</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">   NumRooms Alley</span><br><span class="line">0       3.0  Pave</span><br><span class="line">1       2.0   NaN</span><br><span class="line">2       4.0   NaN</span><br><span class="line">3       3.0   NaN</span><br></pre></td></tr></table></figure><p><strong>pd.get_dummies()函数</strong>对inputs DataFrame 进行独热编码（One-Hot Encoding）处理。</p><p><strong>dummy_na=True:</strong> 这是pd.get_dummies()函数的一个可选参数。当设置为True时，它会为原始数据中的缺失值创建一个额外的二进制列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inputs = pd.get_dummies(inputs, dummy_na=True)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">   NumRooms  Alley_Pave  Alley_nan</span><br><span class="line">0       3.0        True      False</span><br><span class="line">1       2.0       False       True</span><br><span class="line">2       4.0       False       True</span><br><span class="line">3       3.0       False       True</span><br></pre></td></tr></table></figure><p><em>注：独热编码的过程会将inputs DataFrame  中的分类变量转换成二进制的向量表示。对于每个分类变量，它会为每个类别创建一个新的列，其中类别出现的位置为1，其余位置为0。如果某一行数据的分类变量具有某个类别，则该类别对应的列为1，其他类别对应的列都为0。如果原始数据中有缺失值，独热编码会在对应的缺失值列中标记为1。</em></p><h4 id="2-4-类型转换"><a href="#2-4-类型转换" class="headerlink" title="2.4 类型转换"></a>2.4 类型转换</h4><p>inputs和outputs中的所有条目都是数值类型，可以转换为张量格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">inputs = inputs.astype(&#x27;float64&#x27;)</span><br><span class="line">x, y = torch.tensor(inputs.values), torch.tensor(outputs.values)</span><br><span class="line">x, y</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">(tensor([[3., 1., 0.],</span><br><span class="line">         [2., 0., 1.],</span><br><span class="line">         [4., 0., 1.],</span><br><span class="line">         [3., 0., 1.]], dtype=torch.float64),</span><br><span class="line"> tensor([127500, 106000, 178100, 140000]))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据预处理 </tag>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络(1)</title>
      <link href="/posts/409718da.html"/>
      <url>/posts/409718da.html</url>
      
        <content type="html"><![CDATA[<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><h3 id="1-激活函数"><a href="#1-激活函数" class="headerlink" title="1. 激活函数"></a>1. 激活函数</h3><p>激活函数：作用在于决定如何来激活输入信号的总和。</p><p>如，感知机的数学形式：<img src="https://typoraimg.wangak.cc/2023/img/202310201413373.png" alt="img2"></p><p>其亦可表达为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201413123.png" alt="img3"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201413687.png" alt="img4"></p><p>h(x)函数会将输入信号的总和转换为输出信号，即为激活函数。</p><h4 id="1-1-阶跃函数"><a href="#1-1-阶跃函数" class="headerlink" title="1.1 阶跃函数"></a>1.1 阶跃函数</h4><p><strong>激活函数：</strong>以阈值为界，一旦输入超过阈值，就切换输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#当输入超过0时，输出1，否则输出0的阶跃函数</span><br><span class="line">def step_function(x):</span><br><span class="line">  y = x &gt; 0</span><br><span class="line">  return y.astype(np.int)</span><br><span class="line">  #用astype()方法转换NumPy数组的类型</span><br></pre></td></tr></table></figure><p><strong>阶跃函数的图形</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pylab as plt</span><br><span class="line">def step_function(x):</span><br><span class="line"> return np.array(x &gt; 0, dtype=np.int)</span><br><span class="line">x = np.arange(-5.0, 5.0, 0.1)</span><br><span class="line">y = step_function(x)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.ylim(-0.1, 1.1) # 指定y轴的范围</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201413101.png" alt="img5" style="zoom:50%;"></p><h4 id="1-2-sigmoid函数"><a href="#1-2-sigmoid函数" class="headerlink" title="1.2 sigmoid函数"></a>1.2 sigmoid函数</h4><p><strong>sigmoid函数:</strong> $h(x)={1 \over 1+e^{-x} }$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def sigmoid(x):</span><br><span class="line"> return 1 / (1 + np.exp(-x))</span><br></pre></td></tr></table></figure><p><strong>sigmoid函数的图形</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(-5.0, 5.0, 0.1)</span><br><span class="line">y = sigmoid(x)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.ylim(-0.1, 1.1) # 指定y轴的范围</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>​                                                                <img src="https://typoraimg.wangak.cc/2023/img/202310201413595.png" alt="img6" style="zoom: 50%;"></p><p><em>注：神经网络的激活函数必须使用非线性函数。使用线性函数时，加深神经网络的层数就没有意义了，因为不管如何加深层数，总是存在与之等效的“无隐藏层的神经网络”。</em></p><h4 id="1-3-tanh函数"><a href="#1-3-tanh函数" class="headerlink" title="1.3 tanh函数"></a>1.3 tanh函数</h4><p><strong>tanh函数：</strong>$\LARGE {e^{x}-e^{-x}\over e^{x}+e^{-x} }$</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201413700.png" alt="img11" style="zoom: 50%;"></p><h4 id="1-4-ReLU函数"><a href="#1-4-ReLU函数" class="headerlink" title="1.4 ReLU函数"></a>1.4 ReLU函数</h4><p><strong>ReLU函数</strong>：<img src="https://typoraimg.wangak.cc/2023/img/202310201413423.png" alt="img7"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def relu(x):</span><br><span class="line"> return np.maximum(0, x)</span><br></pre></td></tr></table></figure><p><strong>ReLU函数的图形</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201413022.png" alt="img8" style="zoom: 67%;"></p><p><strong>Leaky ReLU函数:</strong>max(0.1x,x)</p><h3 id="2-恒等函数和-softmax函数"><a href="#2-恒等函数和-softmax函数" class="headerlink" title="2 恒等函数和 softmax函数"></a>2 恒等函数和 softmax函数</h3><p><strong>恒等函数：</strong>将输入按原样输出，对于输入的信息，不加以任何改动地直接输出。</p><p><strong>softmax函数：</strong><script type="math/tex">\large y_k={e^{a_k} \over \sum\limits_{i=1}^ne^{a_i}}</script></p><p>为了防止溢出，可对softmax函数进行如下改进：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201413575.png" alt="img10"></p><p><em>注：其中，$C^{，}$通常使用输入信号中的最大值，来防止溢出。</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201413580.png" alt="img9"></p><p><strong><em>注：</em></strong></p><p><em>1.softmax函数的输出通过箭头与所有的输入信号相连，输出层的各个神经元都受到所有输入信号的影响。</em></p><p><em>2.softmax函数将输出的给类别的得分转换成了概率</em></p><h3 id="3-交叉熵损失"><a href="#3-交叉熵损失" class="headerlink" title="3. 交叉熵损失"></a>3. 交叉熵损失</h3><p><strong>交叉熵损失：</strong>用于比较分类器预测分布与真实分布的距离。</p><p><strong>熵：</strong>H(p)=$-\sum p(x)log(p(x))$</p><p><strong>交叉熵：</strong>H(p,q)=$-\sum p(x)log(q(x))$</p><p><strong>相对熵(KL散度)：</strong>KL(p||q)=$-\sum p(x)log({q(x)\over p(x)})$</p><p><strong>三者之间的关系：</strong>H(p,q)=KL(p||q)+H(p)</p><p>p(x):真实分布概率        q(x):分类器预测分布概率</p><p><strong>注：</strong></p><p><strong>1.相对熵(KL散度)用于度量两个分布间的不相似性。</strong></p><p><strong>2.真实分布为one-hot形式时，H(p)=0,用H(p,q)代替KL(p||q),且交叉熵损失可化简为L=$-log(q_j)$,其中j为真实的类别。</strong></p><h3 id="3-参数优化"><a href="#3-参数优化" class="headerlink" title="3. 参数优化"></a>3. 参数优化</h3><p>参数优化：利用损失函数的输出值作为反馈信号来调整分类器的参数。</p><h4 id="3-1-梯度下降算法"><a href="#3-1-梯度下降算法" class="headerlink" title="3.1 梯度下降算法"></a>3.1 梯度下降算法</h4><p>原理：对于最小化优化问题，只需要将参数沿着梯度相反的方向前进一个步长，就可以实现目标函数的下降。</p><p>方向：负梯度方向</p><p>移动：步长(学习率)</p><p><strong>随机梯度下降算法：</strong>每次随机选择一个样本，计算损失并更新梯度。</p><p>缺点：单个样本的训练易受噪声的影响，不是每次迭代都向着整体最优化的方向。</p><p><strong>小批量随机梯度下降：</strong>每次选择m个样本，计算损失并更新梯度。</p><h4 id="3-2-梯度消失与梯度爆炸"><a href="#3-2-梯度消失与梯度爆炸" class="headerlink" title="3.2 梯度消失与梯度爆炸"></a>3.2 梯度消失与梯度爆炸</h4><p><strong>梯度消失：</strong>由于链式法则的乘法性质导致梯度趋向于0。</p><p>注：tanh,sigmoid局部梯度特性不利于网络梯度流的反向传播，尽量选择RelU或Leaky RelU。</p><p><strong>梯度爆炸：</strong>断崖处梯度乘以学习率后是一个非常大得值，从而“飞”出了合理区域，最终导致算法不收敛;</p><p>注：通过限制步长的大小(梯度裁剪)可以避免梯度爆炸。</p><h4 id="3-3-梯度下降算法的问题及改进"><a href="#3-3-梯度下降算法的问题及改进" class="headerlink" title="3.3 梯度下降算法的问题及改进"></a>3.3 梯度下降算法的问题及改进</h4><p><strong>梯度下降算法的问题：</strong>在一个方向上变化迅速而在另一个方向上的变化缓慢，并且通过增大步长不能提高算法的收敛速度。</p><p><strong>动量法：</strong>利用累加历史梯度信息更新梯度。</p><p>步骤：</p><p>1.采样</p><p>2.计算梯度：g</p><p>3.速度更新：v=uv+g(u:动量系数，u=0时为梯度下降算法)</p><p>4.更新权值：w=w-$\varepsilon$v($\varepsilon$:学习率）</p><p><em>注：梯度下降算法在局部最小点与鞍点处的梯度为0，无法通过，而动量法由于动量的存在可以通过，可以找到更优的解）</em></p><p><strong>自适应梯度算法(AdaGrad)：</strong>减小震荡方向的步长，增大平坦方向的步长。</p><p>步骤：</p><p>1.采样</p><p>2.计算梯度：g</p><p>3.累计平方梯度：r=r+g*g (r : 累计变量)</p><p>4.更新权值：w=w-${\large \varepsilon \over \sqrt{r}+\delta}*g$($\delta$:小常数，通常取$10^{-5}$,用于防止除0出错）</p><p><em>注：AdaGrad的一个限制是，随着累计变量的不断增大，导致每个参数的步长(学习率)非常小，这可能会大大减慢搜索进度，并且可能意味着无法找到最优值。</em></p><p><strong>RMSProp：</strong>累计平方梯度：r=$\rho$r+(1-$\rho$)g*g ($\rho$:衰减系数，通常取0.999)</p><p><strong>ADAM:</strong>同时使用动量与自适应梯度的思想</p><p>步骤：</p><p>1.采样</p><p>2.计算梯度：g</p><p>3.累计梯度：v=uv+(1-u)*g(u:动量系数,通常取0.9)</p><p>4.累计平方梯度：r=$\rho$r+(1-$\rho$)g*g </p><p>5.修正偏差：$\large \tilde{v}={v\over 1-u^t}$  ,$\large \tilde{r}={r\over 1-\rho^t}$ (t:迭代系数，该步骤极大缓解了算法初期的冷启动的问题)</p><p>6.更新权值：w=w-${\large \varepsilon \over \sqrt{\tilde{r}}+\delta}*\tilde{v}$</p><p><em>注：动量法等同于修改学习的“方向”，自适应梯度等同于修改“步长”，ADAM等同于修改“步长”和“方向”。</em></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> 激活函数 </tag>
            
            <tag> 交叉熵 </tag>
            
            <tag> 参数优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib</title>
      <link href="/posts/9ebec7b8.html"/>
      <url>/posts/9ebec7b8.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-plot-函数"><a href="#1-plot-函数" class="headerlink" title="1.plot()函数"></a>1.plot()函数</h3><p><strong>plot()函数会根据列表中的数据尝试绘制出有意义的图形</strong></p><p>参数：<img src="https://typoraimg.wangak.cc/2023/img/202310201403789.png" alt="img1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(-6,6,0.1)</span><br><span class="line">#起点：-6，终点：6，步长：0.1</span><br><span class="line">y1 = np.sin(x)</span><br><span class="line">y2 = np.cos(x)</span><br><span class="line">plt.plot(x,y1)</span><br><span class="line">plt.plot(x,y2)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201403827.png" alt="img2"></p><p><strong>plt的title()方法：</strong>添加图标标题</p><p><strong>xlabel()、ylabel()方法：</strong>为每条轴设置标题、大小等参数</p><p><strong>tick_params()方法：</strong>指定刻度标记的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(-6,6,0.1)#起点：-6，终点：6，步长：0.1</span><br><span class="line">y1 = np.sin(x)</span><br><span class="line">y2 = np.cos(x)</span><br><span class="line">plt.plot(x,y1)</span><br><span class="line">plt.plot(x,y2)</span><br><span class="line">plt.title(&quot;Figure 1&quot;,fontsize = 18,color = &quot;red&quot;)</span><br><span class="line">plt.xlabel(&quot;x value&quot;,fontsize = 14)</span><br><span class="line">plt.ylabel(&quot;y value&quot;,fontsize = 14)</span><br><span class="line">plt.tick_params(axis=&quot;both&quot;,labelsize=10)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201403269.png" alt="img3"></p><h3 id="2-图像的显示和读取"><a href="#2-图像的显示和读取" class="headerlink" title="2.图像的显示和读取"></a>2.图像的显示和读取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = plt.imread(&#x27;lena.png&#x27;)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201403862.png" alt="img4"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> matplotlib </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感知机</title>
      <link href="/posts/18592060.html"/>
      <url>/posts/18592060.html</url>
      
        <content type="html"><![CDATA[<h2 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h2><h3 id="感知机的概念"><a href="#感知机的概念" class="headerlink" title="感知机的概念"></a>感知机的概念</h3><p>​        感知机是一种线性分类模型，属于<strong>判别模型</strong>，其使用一个线性方程所对应的超平面，将特征空间分成两部分。</p><p><strong>例：有两个输入的感知机：</strong></p><p>x1、x2是输入信号，y是输出信号，w1、w2是权重。图中的○称为“神经元”或者“节点”。输入信号被送往神经元时，会被分别乘以固定的权重（w1x1、w2x2）。神经元会计算传送过来的信号的总和，当这个总和超过了某个界限值时，才会输出1，否则输出0（二分类）。这也称为“神经元被激活”。这里将这个界限值称为阈值，用符号θ表示。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411985.png" alt="img1"></p><p>用<strong>数学公式</strong>表示为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411463.png" alt="img2"></p><p><em>注：感知机的多个输入信号都有各自固有的权重，权重越大，对应该权重的信号的重要性就越高</em></p><p><strong>单层感知机的局限性：</strong>单层感知机的局限性就在于它只能表示由一条直线分割的空间。（单层感知机无法分离非线性空间）</p><p><strong>多层感知机：</strong>多层感知机可以表示非线性空间<img src="https://typoraimg.wangak.cc/2023/img/202310201412935.png" alt="img3"></p><h3 id="感知机的损失函数"><a href="#感知机的损失函数" class="headerlink" title="感知机的损失函数"></a>感知机的损失函数</h3><p>感知机的损失函数：误分类点到超平面的距离，即$-{1 \over {||w||}}\sum \limits_{x_i\in M} y_i(w*x_i+b)$,其中M为误分类点的集合</p><p><em>注：对于误分类点，$y_i(wx_i+b)$&lt;0</em></p><h3 id="感知机学习算法的原始形式"><a href="#感知机学习算法的原始形式" class="headerlink" title="感知机学习算法的原始形式"></a>感知机学习算法的原始形式</h3><p>感知机学习算法是误分类驱动的，采用随机梯度下降法，不断地极小化目标函数。</p><p><strong>训练过程：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412894.png" alt="感知机算法学习步骤"></p><p><strong><em>注：</em></strong></p><p><em>1.当一个实例点被误分类时，调整w,b，使分离超平面向误分类点的一侧移动，以减少误分类点距离超平面的距离。</em></p><p><em>2.其训练过程等价于使用批量大小为1的梯度下降，并使用L(y,x,w)=max(0,-y(w,x))的损失函数。</em></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 感知机 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则化</title>
      <link href="/posts/ce0afb50.html"/>
      <url>/posts/ce0afb50.html</url>
      
        <content type="html"><![CDATA[<h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><h4 id="1-基本公式"><a href="#1-基本公式" class="headerlink" title="1.基本公式"></a>1.基本公式</h4><p><strong>经验风险最小化：</strong>$min{1\over N}\sum\limits_{i=1}^NL(y_i,f(x_i))$<br><strong>正则化项：</strong>$\lambda J(f)$</p><p><strong>L1正则化项：</strong>$||w_1||=|w1|+|w2|+…..+|w_n|$<br><strong>L2正则化项：</strong>$||w_2||=\sqrt [2]{w_1^2+w_2^2+…..+w_n^2}$</p><p><strong>结构风险最小化：</strong>$min{1\over N}\sum_{i=1}^{N}L(y_i,f(x_i)+\lambda J(f)$</p><p>注：其中λ 是正则化参数，用来控制正则化项在整体损失函数中的重要程度。较大的 λ 值会增加对模型复杂度的惩罚，从而更强调正则化的效果。</p><h4 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h4><p><strong>过拟合：</strong>模型过于复杂或过度拟合了训练数据的细节和噪声，导致对新数据的泛化能力不佳。</p><p><strong>欠拟合：</strong>无法在训练数据上达到较好的拟合效果，也不能很好地泛化到新数据。</p><p><strong>正则化：</strong>在经验风险的基础上增添了一个正则化项，用来控制模型的复杂度，可以防止过拟合。通过正则化可以选择出经验风险和模型复杂度同时较小的模型。</p><h4 id="3-常见问题："><a href="#3-常见问题：" class="headerlink" title="3.常见问题："></a>3.常见问题：</h4><h5 id="3-1为什么正则化可以防止过拟合？"><a href="#3-1为什么正则化可以防止过拟合？" class="headerlink" title="3.1为什么正则化可以防止过拟合？"></a>3.1为什么正则化可以防止过拟合？</h5><p>答：正则化等价于对模型的复杂度添加约束条件，其具有相同的解空间。</p><h5 id="3-2为什么L1正则化具有稀疏性？"><a href="#3-2为什么L1正则化具有稀疏性？" class="headerlink" title="3.2为什么L1正则化具有稀疏性？"></a>3.2为什么L1正则化具有稀疏性？</h5><p>答：在最小化损失函数时，L1正则化项会与损失函数一起构成优化问题。从解空间形状的角度分析，，另外，L1正则化在参数空间中形成了一个尖锐的角，使得优化算法更有可能选择参数为零的解（即L1正则化图像与损失函数的等值线的交点更可能位于坐标轴上）。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201415392.png" alt="image-20230710170542545"></p><p>从贝叶斯的观点，所有的正则化都是来自于对参数分布的先验，Laplace先验会导出L1正则化，Gauss先验会导出L2正则化，而Laplace分布取零值的概率较大，所以参数取零值的概率较大，因而L1正则化具有稀疏性。</p><h5 id="3-3推导L1先验分布是Laplace分布"><a href="#3-3推导L1先验分布是Laplace分布" class="headerlink" title="3.3推导L1先验分布是Laplace分布"></a>3.3推导L1先验分布是Laplace分布</h5><p>后验概率：$P(\theta|D)={P(D|\theta)*P(\theta)} \over P(D) $</p><p>要使后验概率最大，即使$P(D|\theta)*P(\theta)$最大</p><p>取log加负号后求其最小值：</p><script type="math/tex; mode=display">-log(P(D|\theta))-log(P(\theta))</script><p>其等价于求$-\sum\limits_{i=1}^NlogP(x_i|\theta)-log(P(\theta))$的最小值</p><p>假设$P(\theta)$满足拉普拉斯分布：</p><script type="math/tex; mode=display">P(\theta)={1 \over {2\lambda}}e^{-|\theta|\over \lambda}</script><p>代入$P(\theta)$后，即求$-\sum\limits_{i=1}^NlogP(x_i|\theta)-log({1 \over {2\lambda}})+{1 \over \lambda}|\theta|$</p><p>其相当于L1正则</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 正则化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy基础</title>
      <link href="/posts/90d07c36.html"/>
      <url>/posts/90d07c36.html</url>
      
        <content type="html"><![CDATA[<h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h3><h4 id="1-np-random-randn函数"><a href="#1-np-random-randn函数" class="headerlink" title="1.np.random.randn函数"></a>1.np.random.randn函数</h4><p>numpy中rand与randn的区别:</p><p>(1).rand是随机生成值在0-1之间的函数。</p><p>(2).randn是随机生成均值为0，方差为1的正态分布上的数值。</p><p><strong>np.random.randn函数不同个数参数的输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">in: x = np.random.randn(3)</span><br><span class="line">    print(x)#输出1行3列的一维数组</span><br><span class="line">out:array([0.87154087, 0.78316833, 0.97669061])</span><br><span class="line"></span><br><span class="line">in: x = np.random.randn(4,3)</span><br><span class="line">    print(x)#输出4行3列的二维数组</span><br><span class="line">out:[[ 0.81536654 -0.06119516  0.23273782]</span><br><span class="line">     [-1.3096832   0.11305955 -0.43735283]</span><br><span class="line">     [-1.68680386 -0.08597495 -1.20287298]</span><br><span class="line">     [-0.30945828 -0.50162275  0.41018841]]</span><br><span class="line">     </span><br><span class="line">in: x = np.random.randn(4,3,2)</span><br><span class="line">    print(x)#输出4个小矩阵，每个小矩阵都是3行2列</span><br><span class="line">out:[[[-0.24571791 -0.51039714]</span><br><span class="line">      [ 0.88810165 -0.94045245]</span><br><span class="line">      [-0.37231775  1.33880112]]</span><br><span class="line"></span><br><span class="line">     [[ 0.09029384 -0.76451493]</span><br><span class="line">      [ 1.25793366  1.04770133]</span><br><span class="line">      [ 0.92711157  1.07891784]]</span><br><span class="line"></span><br><span class="line">     [[ 1.10773856 -0.0084584 ]</span><br><span class="line">      [-0.31300087 -0.80121054]</span><br><span class="line">      [ 0.15738774 -1.12602141]]</span><br><span class="line"></span><br><span class="line">     [[ 0.54273696  1.2454806 ]</span><br><span class="line">      [-0.80644804 -1.00282505]</span><br><span class="line">      [ 0.70669598 -0.45169629]]]</span><br><span class="line">   </span><br><span class="line">#其他情况以此类推</span><br></pre></td></tr></table></figure><h4 id="2-ndarray的创建"><a href="#2-ndarray的创建" class="headerlink" title="2.ndarray的创建"></a>2.ndarray的创建</h4><p>ndarray是一个通用的同构数据多维容器，其中的所有元素必须是相同类型的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">in :data1 = [6, 7.5, 8, 0, 1]</span><br><span class="line">    arr1 = np.array(data1)</span><br><span class="line">    print(arr1)</span><br><span class="line">out:array([6. , 7.5, 8. , 0. , 1. ])#np.array会尝试为新建的这个数组推断出一个较为合适的数据类型。</span><br><span class="line"></span><br><span class="line">in :data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]</span><br><span class="line">    arr2 = np.array(data2)</span><br><span class="line">    print(arr2)</span><br><span class="line">out:[[1 2 3 4]</span><br><span class="line">     [5 6 7 8]]</span><br><span class="line">in :arr1 = np.array([1, 2, 3], dtype=np.float64)#指定创建的array的元素类型</span><br><span class="line">    print(arr1)</span><br><span class="line">out:[1. 2. 3.]</span><br><span class="line"></span><br><span class="line">in :arr2.ndim  #维度大小</span><br><span class="line">out:2</span><br><span class="line"></span><br><span class="line">in :arr2.shape #数组大小</span><br><span class="line">out:(2, 4)</span><br><span class="line"></span><br><span class="line">in :arr2.dtype #元素类型</span><br><span class="line">out:dtype(&#x27;int32&#x27;) </span><br></pre></td></tr></table></figure><p>zeros和ones分别可以创建指定长度或形状的全0或全1数组。</p><p>empty可以创建一个没有任何具体值的数组，通常它返回的都是一些未初始化的垃圾值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in : np.zeros(10)</span><br><span class="line">out: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])</span><br></pre></td></tr></table></figure><p>通过ndarray的astype方法可以明确地将一个数组从一个dtype转换成另一个dtype：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in :arr = np.array([1, 2, 3, 4, 5])</span><br><span class="line">    float_arr = arr.astype(np.float64)</span><br><span class="line">    float_arr.dtype</span><br><span class="line">out:dtype(&#x27;float64&#x27;)</span><br></pre></td></tr></table></figure><h4 id="3-numpy数组的运算"><a href="#3-numpy数组的运算" class="headerlink" title="3.numpy数组的运算"></a>3.numpy数组的运算</h4><p>大小相等的数组之间的任何算术运算及数组与标量的算术运算都会将运算应用到元素级。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In :arr = np.array([[1., 2., 3.], [4., 5., 6.]])</span><br><span class="line">    arr</span><br><span class="line">Out: </span><br><span class="line">array([[ 1.,  2.,  3.],</span><br><span class="line">       [ 4.,  5.,  6.]])</span><br><span class="line"></span><br><span class="line">In : arr * arr</span><br><span class="line">Out: </span><br><span class="line">array([[  1.,   4.,   9.],</span><br><span class="line">       [ 16.,  25.,  36.]])</span><br></pre></td></tr></table></figure><p><strong>矩阵的乘法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in: A = np.array([[1,2], [3,4]])</span><br><span class="line">    B = np.array([[5,6], [7,8]])</span><br><span class="line">    np.dot(A, B)#进行矩阵A与矩阵B的乘法运算</span><br><span class="line">out:</span><br><span class="line">array([[19, 22],</span><br><span class="line">       [43, 50]])</span><br></pre></td></tr></table></figure><h4 id="4-ndarray的切片"><a href="#4-ndarray的切片" class="headerlink" title="4.ndarray的切片"></a>4.ndarray的切片</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">in :arr2d</span><br><span class="line">out:</span><br><span class="line">array([[1, 2, 3],</span><br><span class="line">       [4, 5, 6],</span><br><span class="line">       [7, 8, 9]])</span><br><span class="line">in :arr2d[:2, 1:]</span><br><span class="line">out:</span><br><span class="line">array([[2, 3],</span><br><span class="line">       [5, 6]])</span><br></pre></td></tr></table></figure><h4 id="5-广播"><a href="#5-广播" class="headerlink" title="5.广播"></a>5.广播</h4><p>NumPy中，形状不同的数组之间也可以进行运算。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405108.png" alt="img1"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201406185.png" alt="img2"></p><h4 id="6-np-arange-用法"><a href="#6-np-arange-用法" class="headerlink" title="6.np.arange()用法"></a>6.np.arange()用法</h4><p><strong>一个参数时：</strong></p><h5 id="（1）参数值为终点"><a href="#（1）参数值为终点" class="headerlink" title="（1）参数值为终点"></a>（1）参数值为终点</h5><h5 id="（2）起点取默认值0"><a href="#（2）起点取默认值0" class="headerlink" title="（2）起点取默认值0"></a>（2）起点取默认值0</h5><h5 id="（3）步长取默认值1"><a href="#（3）步长取默认值1" class="headerlink" title="（3）步长取默认值1"></a>（3）步长取默认值1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in ：</span><br><span class="line">import numpy </span><br><span class="line">print(numpy.arange(6)) #从0到5,不包括6</span><br><span class="line">out:</span><br><span class="line">[0 1 2 3 4 5]</span><br></pre></td></tr></table></figure><p><strong>两个参数时：</strong></p><h5 id="（1）第一个参数为起点"><a href="#（1）第一个参数为起点" class="headerlink" title="（1）第一个参数为起点"></a>（1）第一个参数为起点</h5><h5 id="（2）第二个参数为终点（不包括）"><a href="#（2）第二个参数为终点（不包括）" class="headerlink" title="（2）第二个参数为终点（不包括）"></a>（2）第二个参数为终点（不包括）</h5><h5 id="（3）步长取默认值1-1"><a href="#（3）步长取默认值1-1" class="headerlink" title="（3）步长取默认值1"></a>（3）步长取默认值1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in: print(numpy.arange(6, 10)) #[6,9)</span><br><span class="line">out:[6 7 8 9]</span><br></pre></td></tr></table></figure><p><strong>三个参数时：</strong></p><h5 id="（1）第一个参数为起点-1"><a href="#（1）第一个参数为起点-1" class="headerlink" title="（1）第一个参数为起点"></a>（1）第一个参数为起点</h5><h5 id="（2）第二个参数为终点（不包括）-1"><a href="#（2）第二个参数为终点（不包括）-1" class="headerlink" title="（2）第二个参数为终点（不包括）"></a>（2）第二个参数为终点（不包括）</h5><h5 id="（3）第三个参数为步长"><a href="#（3）第三个参数为步长" class="headerlink" title="（3）第三个参数为步长"></a>（3）第三个参数为步长</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in: print(np.arange(6,20,1.5))  #步长支持小数</span><br><span class="line">out:</span><br><span class="line">[ 6.   7.5  9.  10.5 12.  13.5 15.  16.5 18.  19.5]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础（2）</title>
      <link href="/posts/c74eb236.html"/>
      <url>/posts/c74eb236.html</url>
      
        <content type="html"><![CDATA[<h2 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h2><h3 id="1-enumerate函数"><a href="#1-enumerate函数" class="headerlink" title="1.enumerate函数"></a>1.enumerate函数</h3><p>用于返回<code>(i, value)</code>元组序列，可以跟踪当前项的序号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (i,value) in enumerate(tup):</span><br><span class="line">    print(str(i)+&quot;:&quot;+value)</span><br></pre></td></tr></table></figure><h3 id="2-sorted函数"><a href="#2-sorted函数" class="headerlink" title="2.sorted函数"></a>2.sorted函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In : sorted([7, 1, 2, 6, 0, 3, 2])</span><br><span class="line">Out: [0, 1, 2, 2, 3, 6, 7]</span><br><span class="line"></span><br><span class="line">In : sorted(&#x27;horse race&#x27;)#对字符串进行排序</span><br><span class="line">Out: [&#x27; &#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;e&#x27;, &#x27;h&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;r&#x27;, &#x27;s&#x27;]</span><br></pre></td></tr></table></figure><p>sorted()函数与sort()函数不同，会返回一个排序列表，而不改变原有序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">in :tup1=[2,6,8,1]</span><br><span class="line">    tup1.sort()</span><br><span class="line">    print(tup1)</span><br><span class="line">out:[1, 2, 6, 8]</span><br><span class="line"></span><br><span class="line">in :tup1=[2,6,8,1]</span><br><span class="line">    tup2=sorted(tup1)</span><br><span class="line">    print(tup2)</span><br><span class="line">    print(tup1)</span><br><span class="line">out:[1, 2, 6, 8]</span><br><span class="line">    [2, 6, 8, 1]</span><br></pre></td></tr></table></figure><p><strong>sort（）可以接受两个参数sort（key,reverse）</strong></p><p>key接受的函数返回值，表示此元素的权值，sort将按照权值大小进行排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in: x=[8,9,0,7,4,5,1,2,3,6]</span><br><span class="line">    def size(a):</span><br><span class="line">        x=10-int(a)</span><br><span class="line">        return x</span><br><span class="line">    x.sort(key=size)</span><br><span class="line">    print(x)</span><br><span class="line">out:[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br></pre></td></tr></table></figure><p>reverse接受的是一个bool类型的值 (Ture or False),表示是否颠倒排列顺序,一般默认的是False</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in :x=[8,9,0,7,4,5,1,2,3,6]</span><br><span class="line">    x.sort(reverse=True)</span><br><span class="line">    print(x)</span><br><span class="line">out:[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br></pre></td></tr></table></figure><p><strong>sort根据关键字排序</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in :l = [[1,2,3],[2,2,1],[2,1,3]]</span><br><span class="line">    l.sort(key = lambda x: (x[0],-x[1]))</span><br><span class="line">    print(l)</span><br><span class="line">out:[[1, 2, 3], [2, 2, 1], [2, 1, 3]]</span><br></pre></td></tr></table></figure><p><u>注：其中key表示按第几个关键字排序，lambda x:后()中的元素表示了关键字的优先级（由高至低），x[0]表示按第一个关键词的升序排列，-x[1]表示按第二个关键词的降序排列</u></p><h3 id="3-zip函数"><a href="#3-zip函数" class="headerlink" title="3.zip函数"></a>3.zip函数</h3><p><code>zip</code>可以将多个列表、元组或其它序列成对组合成一个元组列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In :tup1=1,2,3</span><br><span class="line">    tup2=&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;</span><br><span class="line">    ziped=zip(tup1,tup2)</span><br><span class="line">    list(ziped)</span><br><span class="line">out:[(1, &#x27;a&#x27;), (2, &#x27;b&#x27;), (3, &#x27;c&#x27;)]</span><br></pre></td></tr></table></figure><p>处理任意多的序列，元素的个数取决于最短的序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In :tup1=1,2,3</span><br><span class="line">    tup2=&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;</span><br><span class="line">    tup3=False,True</span><br><span class="line">    ziped=zip(tup1,tup2,tup3)</span><br><span class="line">    list(ziped)</span><br><span class="line">out:[(1, &#x27;a&#x27;, False), (2, &#x27;b&#x27;, True)]</span><br></pre></td></tr></table></figure><p><strong>（1）zip函数的常见用法：同时迭代多个序列</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in :tup1=1,2,3</span><br><span class="line">    tup2=&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;</span><br><span class="line">    for i,(value1,value2) in enumerate(zip(tup1,tup2)):</span><br><span class="line">         print(&#x27;&#123;0&#125;:&#123;1&#125;,&#123;2&#125;&#x27;.format(i,value1,value2))</span><br><span class="line">out:0:1,a</span><br><span class="line">    1:2,b</span><br><span class="line">    2:3,c</span><br></pre></td></tr></table></figure><p><strong>（2）zip函数的常见用法:解压序列</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in :pitchers = [(&#x27;Nolan&#x27;, &#x27;Ryan&#x27;), (&#x27;Roger&#x27;, &#x27;Clemens&#x27;),(&#x27;Schilling&#x27;, &#x27;Curt&#x27;)]</span><br><span class="line">    first_names, last_names = zip(*pitchers)</span><br><span class="line">    print(first_names)</span><br><span class="line">    print(last_names)</span><br><span class="line">out:(&#x27;Nolan&#x27;, &#x27;Roger&#x27;, &#x27;Schilling&#x27;)</span><br><span class="line">    (&#x27;Ryan&#x27;, &#x27;Clemens&#x27;, &#x27;Curt&#x27;)</span><br></pre></td></tr></table></figure><h3 id="4-reversed函数"><a href="#4-reversed函数" class="headerlink" title="4.reversed函数"></a>4.reversed函数</h3><p>用于从后向前迭代序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in :tup = tuple(&#x27;string&#x27;)</span><br><span class="line">    for (i,value) in enumerate(reversed(tup)):#从后向前迭代元组</span><br><span class="line">        print(str(i)+&quot;:&quot;+value,end=&#x27; &#x27;)</span><br><span class="line">out:0:g 1:n 2:i 3:r 4:t 5:s </span><br></pre></td></tr></table></figure><h3 id="5-匿名（lambda）函数"><a href="#5-匿名（lambda）函数" class="headerlink" title="5.匿名（lambda）函数"></a>5.匿名（lambda）函数</h3><p>由单条语句组成，该语句的结果就是返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">in :def apply_to_list(some_list, f):</span><br><span class="line">        return [f(x) for x in some_list]</span><br><span class="line"></span><br><span class="line">    ints = [4, 0, 1, 5, 6]</span><br><span class="line">    apply_to_list(ints, lambda x: x * 2)#&#x27;:&#x27;前为参数,&#x27;:&#x27;后为运算表达式</span><br><span class="line">out:[8, 0, 2, 10, 12]</span><br><span class="line"></span><br><span class="line">in :strings = [&#x27;foo&#x27;, &#x27;card&#x27;, &#x27;bar&#x27;, &#x27;aaaa&#x27;, &#x27;abab&#x27;]</span><br><span class="line">    strings.sort(key=lambda x: len(set(list(x))))#根据不同字母的数量，对strings排序</span><br><span class="line">    print(strings)</span><br><span class="line">out:[&#x27;aaaa&#x27;, &#x27;foo&#x27;, &#x27;abab&#x27;, &#x27;bar&#x27;, &#x27;card&#x27;]</span><br></pre></td></tr></table></figure><h3 id="6-迭代器"><a href="#6-迭代器" class="headerlink" title="6.迭代器"></a>6.迭代器</h3><p><strong>可迭代对象</strong>:可迭代的对象要有_iter_()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#常见的可迭代对象</span><br><span class="line">iterables=[</span><br><span class="line">    &quot;123&quot;,#字符串</span><br><span class="line">    [1,2,3],#列表</span><br><span class="line">    (1,2,3),#元组</span><br><span class="line">    &#123;1:&#x27;a&#x27;,2:&#x27;b&#x27;&#125;,#字典</span><br><span class="line">    &#123;1,2,3&#125;,#集合</span><br><span class="line">]</span><br><span class="line">for iterable in iterables:</span><br><span class="line">    print(type(iterable))</span><br><span class="line">    for x in iterable:</span><br><span class="line">        print(x,end=&#x27;,&#x27;)</span><br><span class="line">    print(&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line">1,2,3,</span><br><span class="line">&lt;class &#x27;list&#x27;&gt;</span><br><span class="line">1,2,3,</span><br><span class="line">&lt;class &#x27;tuple&#x27;&gt;</span><br><span class="line">1,2,3,</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">1,2,</span><br><span class="line">&lt;class &#x27;set&#x27;&gt;</span><br><span class="line">1,2,3,</span><br></pre></td></tr></table></figure><p><strong>迭代器：</strong>有_next<em>()方法的可迭代对象，即迭代器既有_iter\</em>()方法，又有_next_()方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#列表不是迭代器</span><br><span class="line">from collections.abc import Iterator</span><br><span class="line">lst=[1,2,3]</span><br><span class="line">isinstance(lst,Iterator)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">False</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#iter(lst)是迭代器</span><br><span class="line">x=iter(lst)</span><br><span class="line">isinstance(x,Iterator)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">True</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">in: x.__next__()</span><br><span class="line">out:1</span><br><span class="line"></span><br><span class="line">in: x.__next__()</span><br><span class="line">out:2</span><br><span class="line"></span><br><span class="line">in: next(x)</span><br><span class="line">out:3</span><br></pre></td></tr></table></figure><p><strong>自定义迭代器：</strong>为类添加_iter_()方法和_next_()方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#定义一个将字符串反序输出的迭代器</span><br><span class="line">class ReverseIterator:</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = len(data)</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.index &lt;= 0:</span><br><span class="line">            raise StopIteration</span><br><span class="line">        self.index -= 1</span><br><span class="line">        return self.data[self.index]</span><br><span class="line"></span><br><span class="line">r=ReverseIterator(&#x27;abc&#x27;)</span><br><span class="line">for i in r:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">c</span><br><span class="line">b</span><br><span class="line">a</span><br></pre></td></tr></table></figure><h3 id="7-生成器"><a href="#7-生成器" class="headerlink" title="7.生成器"></a>7.生成器</h3><p><strong>生成器</strong>：一种特殊的迭代器,通过函数的方式来定义，使用关键字<strong>yield</strong>来返回值，而不是使用<strong>return</strong>。当生成器函数被调用时，它并不会立即执行函数体，而是返回一个生成器对象，该对象可以用于逐步迭代产生值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def countdown(n):</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        yield n</span><br><span class="line">        n -= 1</span><br><span class="line"></span><br><span class="line"># 使用生成器进行迭代</span><br><span class="line">for num in countdown(5):</span><br><span class="line">    print(num, end=&quot; &quot;)</span><br><span class="line">   </span><br><span class="line">out:</span><br><span class="line">5 4 3 2 1 </span><br></pre></td></tr></table></figure><p><em>注：<strong>yield</strong>语句右边的对象作为next()的返回值，生成器在yield所在的位置暂停，当再次使用next()时继续从该位置继续运行。</em></p><h3 id="8-collections-Counter"><a href="#8-collections-Counter" class="headerlink" title="8.collections.Counter"></a>8.collections.Counter</h3><p><strong>collections.Counter:</strong>是Python标准库中的一个类，用于计数可哈希对象（通常是元素或元素组成的集合）的出现次数。</p><p><strong>collections.Counter是一个字典的子类，提供了方便的计数功能，可以用于各种计数和统计场景</strong></p><h4 id="8-1-创建计数器"><a href="#8-1-创建计数器" class="headerlink" title="8.1 创建计数器"></a>8.1 创建计数器</h4><p>可以通过传入可迭代对象（如列表、元组、字符串等）或字典来创建计数器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line"># 通过列表创建计数器</span><br><span class="line">a= Counter([&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;apple&#x27;])</span><br><span class="line"></span><br><span class="line"># 通过字符串创建计数器</span><br><span class="line">b = Counter(&#x27;hello&#x27;)</span><br><span class="line"></span><br><span class="line"># 通过字典创建计数器</span><br><span class="line">c = Counter(&#123;&#x27;apple&#x27;: 3, &#x27;orange&#x27;: 2, &#x27;banana&#x27;: 1&#125;)</span><br><span class="line">a,b,c</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">(Counter(&#123;&#x27;apple&#x27;: 3, &#x27;orange&#x27;: 1, &#x27;banana&#x27;: 1&#125;),</span><br><span class="line"> Counter(&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 1, &#x27;l&#x27;: 2, &#x27;o&#x27;: 1&#125;),</span><br><span class="line"> Counter(&#123;&#x27;apple&#x27;: 3, &#x27;orange&#x27;: 2, &#x27;banana&#x27;: 1&#125;))</span><br></pre></td></tr></table></figure><h4 id="8-2-计数元素的出现次数"><a href="#8-2-计数元素的出现次数" class="headerlink" title="8.2 计数元素的出现次数"></a>8.2 计数元素的出现次数</h4><p>可以使用<code>elements()</code>方法获取计数器中所有元素的迭代器，也可以使用普通的字典语法或<code>get()</code>方法获取指定元素的出现次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c = Counter(&#x27;abracadabra&#x27;)</span><br><span class="line">print(c)  # Counter(&#123;&#x27;a&#x27;: 5, &#x27;b&#x27;: 2, &#x27;r&#x27;: 2, &#x27;c&#x27;: 1, &#x27;d&#x27;: 1&#125;)</span><br><span class="line"></span><br><span class="line">print(c[&#x27;a&#x27;])  # 5</span><br><span class="line">print(c.get(&#x27;b&#x27;))  # 2</span><br><span class="line"></span><br><span class="line">elements = list(c.elements())  # [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;r&#x27;, &#x27;r&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br></pre></td></tr></table></figure><h4 id="8-3-获取最常见的元素"><a href="#8-3-获取最常见的元素" class="headerlink" title="8.3 获取最常见的元素"></a>8.3 获取最常见的元素</h4><p>可以使用<code>most_common()</code>方法获取计数器中出现频率最高的元素。该方法返回一个列表，其中每个元素是一个元组，包含元素和对应的计数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c = Counter(&#x27;abracadabra&#x27;)</span><br><span class="line">print(c.most_common(2))</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[(&#x27;a&#x27;, 5), (&#x27;b&#x27;, 2)]</span><br></pre></td></tr></table></figure><h4 id="8-4-更新计数器"><a href="#8-4-更新计数器" class="headerlink" title="8.4 更新计数器"></a>8.4 更新计数器</h4><p>可以使用<code>update()</code>方法将另一个计数器、可迭代对象或字典的元素合并到当前计数器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c1 = Counter(&#x27;abracadabra&#x27;)</span><br><span class="line">c2 = Counter(&#x27;alakazam&#x27;)</span><br><span class="line"></span><br><span class="line">c1.update(c2)  # 合并c2中的计数到c1中</span><br><span class="line">print(c1)  # Counter(&#123;&#x27;a&#x27;: 8, &#x27;b&#x27;: 2, &#x27;r&#x27;: 2, &#x27;l&#x27;: 1, &#x27;k&#x27;: 1, &#x27;z&#x27;: 1, &#x27;m&#x27;: 1&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> 生成器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础（1）</title>
      <link href="/posts/d5fb1dd8.html"/>
      <url>/posts/d5fb1dd8.html</url>
      
        <content type="html"><![CDATA[<h3 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h3><h4 id="1-字符串输入：使用input-函数"><a href="#1-字符串输入：使用input-函数" class="headerlink" title="1.字符串输入：使用input()函数"></a>1.字符串输入：使用input()函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x=input()</span><br><span class="line">y=input()</span><br><span class="line">print(x+y)</span><br><span class="line">#输入：5 4</span><br><span class="line"> 输出：54(&quot;+&quot;对于字符串进行拼接)</span><br><span class="line"></span><br><span class="line">name=input(&quot;请输入姓名：&quot;)#input()中添加文本对所要输入的信息进行提示</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure><h4 id="2-列表（list"><a href="#2-列表（list" class="headerlink" title="2.列表（list)"></a>2.列表（list)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span><br><span class="line">print(List)</span><br><span class="line">print(len(List))#获取列表的长度</span><br><span class="line">print(List[-1])#获取列表表尾的元素</span><br><span class="line">print(List[-2])#获取列表倒数第二个元素</span><br><span class="line"></span><br><span class="line">#列表的插入</span><br><span class="line">List.append(&#x27;D&#x27;)#列表尾部插入</span><br><span class="line">List.insert(2,&#x27;F&#x27;)#列表指定位置插入</span><br><span class="line">List.pop()#列表尾部元素删除</span><br><span class="line">List.pop(2)#删除列表指定索引处的元素</span><br><span class="line">print(List)</span><br><span class="line">List.remove(&#x27;A&#x27;)#一次remove()只删除一个，若有多个，要多次使用remove()函数</span><br><span class="line">print(List)</span><br></pre></td></tr></table></figure><h4 id="3-元组-tuple"><a href="#3-元组-tuple" class="headerlink" title="3.元组(tuple)"></a>3.元组(tuple)</h4><p>tuple一旦初始化就不能修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tuple=(2,3,4)#定义元组并初始化</span><br><span class="line">print(tuple)</span><br><span class="line">tuple2=(2,)#定义单元组</span><br><span class="line">tuple3=(2)#由于出现歧义，tuple3为2这个数</span><br><span class="line">print(tuple2,tuple3)</span><br></pre></td></tr></table></figure><h4 id="4-for-…-in…-循环：可以用于遍历元组或列表"><a href="#4-for-…-in…-循环：可以用于遍历元组或列表" class="headerlink" title="4.for ….in….循环：可以用于遍历元组或列表"></a>4.for ….in….循环：可以用于遍历元组或列表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span><br><span class="line">for i in List:#遍历列表</span><br><span class="line">    print(i)</span><br><span class="line">print(list(range(5)))#range(5)生成一个从0开始小于5的整数序列</span><br><span class="line">                     #list()将这个整数序列转换成列表</span><br><span class="line">sum=0</span><br><span class="line">for i in range(101):#计算从0加到100的值</span><br><span class="line">    sum+=i</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><h4 id="5-字典-dict"><a href="#5-字典-dict" class="headerlink" title="5.字典(dict)"></a>5.字典(dict)</h4><p>使用键-值（key-value）存储，具有极快的查找速度</p><h5 id="字典的创建"><a href="#字典的创建" class="headerlink" title="字典的创建"></a>字典的创建</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dict=&#123;&#x27;A&#x27;:1,&#x27;B&#x27;:2,&#x27;C&#x27;:3&#125;#创建字典</span><br><span class="line">Dict[&#x27;A&#x27;]=4#修改key对应的值</span><br><span class="line">print(&#x27;D&#x27; in Dict)#判断字典key是否存在</span><br><span class="line">Dict.pop(&#x27;A&#x27;)#按key删除 或可用：del Dict[&#x27;A&#x27;]</span><br><span class="line">print(Dict)#注：字典中的key是不可变的对象</span><br><span class="line">Dict[&#x27;D&#x27;]=4#向字典中添加键值对</span><br></pre></td></tr></table></figure><h5 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for key,val in Dict.items():#以键值对的形式遍历字典</span><br><span class="line">    print(key,val)</span><br><span class="line">for key in Dict.keys():#遍历字典的键，其中.keys()可省略</span><br><span class="line">    print(key)</span><br><span class="line">for val in Dict.values():#遍历字典中的值</span><br><span class="line">    print(val)</span><br><span class="line">for key in sorted(Dict.keys()):#在遍历前对字典的键的列表排序</span><br><span class="line">    print(key)</span><br><span class="line">for val in set(Dict.values()):#在遍历前对字典的值的列表去重</span><br><span class="line">    print(val)</span><br></pre></td></tr></table></figure><p><strong>dictionary.get(key, default)</strong></p><ul><li><code>dictionary</code> 是要获取值的字典对象。</li><li><code>key</code> 是要查找的键。</li><li><code>default</code> 是一个可选参数，表示如果键在字典中不存在时，返回的默认值。如果不提供 <code>default</code> 参数，默认值为 <code>None</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fruits = &#123;&#x27;apple&#x27;: 3, &#x27;banana&#x27;: 2, &#x27;orange&#x27;: 5&#125;</span><br><span class="line"></span><br><span class="line"># 获取键 &#x27;apple&#x27; 对应的值</span><br><span class="line">print(fruits.get(&#x27;apple&#x27;))  # 输出: 3</span><br><span class="line"></span><br><span class="line"># 获取键 &#x27;grape&#x27; 对应的值，由于 &#x27;grape&#x27; 不在字典中，返回默认值 0</span><br><span class="line">print(fruits.get(&#x27;grape&#x27;, 0))  # 输出: 0</span><br><span class="line"></span><br><span class="line"># 不提供默认值，&#x27;grape&#x27; 不在字典中，返回 None</span><br><span class="line">print(fruits.get(&#x27;grape&#x27;))  # 输出: None</span><br><span class="line"></span><br><span class="line"># 可以省略默认值参数，将返回 None</span><br><span class="line">print(fruits.get(&#x27;kiwi&#x27;))  # 输出: None</span><br></pre></td></tr></table></figure><h4 id="6-集合-set"><a href="#6-集合-set" class="headerlink" title="6.集合(set)"></a>6.集合(set)</h4><p>重复的元素在set中会被自动过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s=set([1,2,2,3,3])#创建一个set，使用list作为输入集合</span><br><span class="line">print(s)#输出&#123;1, 2, 3&#125;，相同的元素被过滤</span><br><span class="line">s.add(4)#向集合中添加元素</span><br><span class="line">s.remove(1)</span><br><span class="line">print(s)#输出&#123;2，3，4&#125;</span><br><span class="line">s2=set([1,2,3])</span><br><span class="line">print(s&amp;s2)#集合取交集</span><br><span class="line">print(s|s2)#集合取并集</span><br></pre></td></tr></table></figure><h4 id="7-字符串（str"><a href="#7-字符串（str" class="headerlink" title="7.字符串（str)"></a>7.字符串（str)</h4><p>str是不可变对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=&#x27;abc&#x27;</span><br><span class="line">print(a.replace(&#x27;a&#x27;,&#x27;A&#x27;))#输出Abc</span><br><span class="line">print(a)#输出abc,不可变对象本身永远是不可变的</span><br></pre></td></tr></table></figure><h4 id="8-函数的默认参数"><a href="#8-函数的默认参数" class="headerlink" title="8.函数的默认参数"></a>8.函数的默认参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def enroll(name, gender, age=6, city=&#x27;Beijing&#x27;):#把年龄和城市设为默认参数</span><br><span class="line">    print(&#x27;name:&#x27;, name)</span><br><span class="line">    print(&#x27;gender:&#x27;, gender)</span><br><span class="line">    print(&#x27;age:&#x27;, age)</span><br><span class="line">    print(&#x27;city:&#x27;, city)</span><br><span class="line"></span><br><span class="line">#只有与默认参数不符的学生才需要提供额外的信息</span><br><span class="line">enroll(&#x27;Bob&#x27;, &#x27;M&#x27;, 7)</span><br><span class="line">enroll(&#x27;Adam&#x27;, &#x27;M&#x27;, city=&#x27;Tianjin&#x27;)#不按顺序提供部分默认参数时，需要把参数名写上</span><br></pre></td></tr></table></figure><h4 id="9-函数的可变参数"><a href="#9-函数的可变参数" class="headerlink" title="9.函数的可变参数"></a>9.函数的可变参数</h4><p>可变参数就是函数传入的参数个数是可变的</p><p><u>注：可变参数通过创建一个元组将传入的参数封装到元组中，即使函数只收到一个值也是如此。</u></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def calc(*numbers):#计算：a*a+b*b+c*c+……</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers:#numbers是元组</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum</span><br><span class="line"></span><br><span class="line">print(calc(1, 2))</span><br><span class="line">nums = [1, 2, 3]</span><br><span class="line">print(calc(*nums))#在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去</span><br></pre></td></tr></table></figure><h4 id="10-函数upper-、title-、lower"><a href="#10-函数upper-、title-、lower" class="headerlink" title="10.函数upper()、title()、lower()"></a>10.函数upper()、title()、lower()</h4><p>upper():全字母大写</p><p>title():首字母大写</p><p>lower():全字母小写</p><p><u>注：以上方法是非永久性改变，不会改变变量的值</u></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cars=[&#x27;audi&#x27;,&#x27;bmw&#x27;,&#x27;subaru&#x27;,&#x27;toyota&#x27;]</span><br><span class="line">for car in cars:</span><br><span class="line">    if car==&#x27;bmw&#x27;:</span><br><span class="line">        print(car.upper())#car为bmw时以大写输出</span><br><span class="line">    else:</span><br><span class="line">        print(car.title())</span><br></pre></td></tr></table></figure><h4 id="11-函数的列表参数"><a href="#11-函数的列表参数" class="headerlink" title="11.函数的列表参数"></a>11.函数的列表参数</h4><p>列表作为参数传给函数，函数可以对列表做出永久性修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def fun(List):</span><br><span class="line">    i=0</span><br><span class="line">    for x in List:</span><br><span class="line">        List[i]=x.lower()</span><br><span class="line">        i+=1</span><br><span class="line">List=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span><br><span class="line">fun(List)</span><br><span class="line">print(List)#输出[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure><p>传入列表的副本，原始列表不做修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def fun(List):</span><br><span class="line">    i=0</span><br><span class="line">    for x in List:</span><br><span class="line">        List[i]=x.lower()</span><br><span class="line">        i+=1</span><br><span class="line">List=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span><br><span class="line">fun(List[:])#切片表示法创建副本</span><br><span class="line">print(List)#输出[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br></pre></td></tr></table></figure><h4 id="12-列表生成式"><a href="#12-列表生成式" class="headerlink" title="12.列表生成式"></a>12.列表生成式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print([x * x for x in range(1, 11) if x % 2 == 0]) #筛选出仅偶数的平方</span><br><span class="line"></span><br><span class="line">print([m + n for m in &#x27;ABC&#x27; for n in &#x27;XYZ&#x27;])#使用两层循环，可以生成全排列</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">print([d for d in os.listdir(&#x27;.&#x27;)])#列出当前目录下的所有文件和目录名</span><br><span class="line"></span><br><span class="line">print([x if x % 2 == 0 else -x for x in range(1, 5)])#生成表达式的if……else……，输出[-1, 2, -3, 4]</span><br></pre></td></tr></table></figure><h4 id="13-split-函数"><a href="#13-split-函数" class="headerlink" title="13.split()函数"></a>13.split()函数</h4><p><strong>split():</strong>通过指定分隔符对字符串进行切片，将字符串切片后的结果存放在列表中。</p><p><strong>str.split(str=””, num=string.count(str))</strong></p><ul><li>str — 分隔符，默认为空白格。</li><li>num — 分割次数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;Line1-abcdef,\nLine2-abc,\nLine4-abcd&quot;</span><br><span class="line">str.split(&#x27;,&#x27;)</span><br><span class="line">out:</span><br><span class="line">[&#x27;Line1-abcdef&#x27;, &#x27;\nLine2-abc&#x27;, &#x27;\nLine4-abcd&#x27;]</span><br><span class="line"></span><br><span class="line">str = &quot;Line1-abcdef \nLine2-abc \nLine4-abcd&quot;</span><br><span class="line">str.split( )</span><br><span class="line">str.split(&#x27; &#x27;, 1 )#分割次数为1次</span><br><span class="line">out:</span><br><span class="line">[&#x27;Line1-abcdef&#x27;, &#x27;Line2-abc&#x27;, &#x27;Line4-abcd&#x27;]#以空白格分割，自动去除回车</span><br><span class="line">[&#x27;Line1-abcdef&#x27;, &#x27;\nLine2-abc \nLine4-abcd&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>rstrip():</strong> 删除字符串末尾的指定字符,默认为空白符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#分割字符串列表</span><br><span class="line">str=[&#x27;1,a\n&#x27;,&#x27;2,b\n&#x27;,&#x27;3,c\n&#x27;]</span><br><span class="line">tokens=[l.rstrip().split(&#x27;,&#x27;) for l in str]</span><br><span class="line">tokens</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[&#x27;1&#x27;, &#x27;a&#x27;], [&#x27;2&#x27;, &#x27;b&#x27;], [&#x27;3&#x27;, &#x27;c&#x27;]]</span><br></pre></td></tr></table></figure><h4 id="14-文件操作函数"><a href="#14-文件操作函数" class="headerlink" title="14.文件操作函数"></a>14.文件操作函数</h4><p><strong>os.makedirs():</strong> 这是一个用于递归创建目录的函数。它接受一个路径作为输入，并创建路径中所有缺失的目录</p><p><strong>exist_ok=True:</strong> 这是os.makedirs()函数的一个可选参数。当设置为True时，如果目标目录已经存在，函数不会引发错误，而是默默地继续执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.makedirs(os.path.join(&#x27;..&#x27;, &#x27;data&#x27;), exist_ok=True)#创建一个名为&quot;data&quot;的目录，该目录位于当前工作目录的父目录中</span><br></pre></td></tr></table></figure><p><strong>shutil.copy():</strong>用于将源文件的内容复制到目标文件或目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutil.copy(filename, target_dir)#将filename文件复制到target_dir目录中。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>comments</title>
      <link href="/comments/index.html"/>
      <url>/comments/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
