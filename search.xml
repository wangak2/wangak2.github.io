<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>D-LKA Attention</title>
      <link href="/posts/bf4c3cab.html"/>
      <url>/posts/bf4c3cab.html</url>
      
        <content type="html"><![CDATA[<h1 id="D-LKA-Attention"><a href="#D-LKA-Attention" class="headerlink" title="D-LKA Attention"></a>D-LKA Attention</h1><p><strong>论文：《Beyond Self-Attention: Deformable Large Kernel Attention for Medical Image Segmentation》（WACV 2024)</strong></p><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><strong>网络结构：</strong><br>                                            <img src="https://typoraimg.wangak.cc/2023/img/202312252047820.png" alt="image-20231218151015722" style="zoom:67%;"></p><p><strong>LKA：</strong>将卷积分解为三个部分：深度卷积、深度空洞卷积和逐点卷积</p><p>LKA吸收了卷积和self-attention的优点，包括局部结构信息、长依赖性和适应性。</p><p><strong>DW-Conv:</strong>可以利用图像的局部上下文信息</p><p><strong>DW-D-Conv：</strong>捕获LKA中的长程依赖性方面起到了作用</p><p><strong>1×1 Conv：</strong>通道维度中的关系</p><p><strong>2d-LKA的参数量：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047832.png" alt="image-20231218150016851" style="zoom: 67%;"></p><p><em>注：普通卷积kernel大小为K，DW-Conv的kernel为K/d，DW-D-Conv的kernel为(2d-1)</em></p><p><strong>3d-LKA的参数量：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047618.png" alt="image-20231218150455218" style="zoom:67%;"></p><p>d（扩张率）是通过对参数量求导确定的，找使参数量导数为0，即参数量最小的扩张率</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047839.png" alt="image-20231218150728812" style="zoom:67%;"></p><p><strong>D-LKA：</strong>在LKA的基础上，使用可变形深度卷积代替深度卷积，用可变形深度空洞卷积代替空洞卷积</p><p><em>注：可变形卷积提高了捕获不规则形状和大小的物体的能力</em></p><p><strong>D-LKA模块结构：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047842.png" alt="image-20231218152019184" style="zoom: 50%;"></p><h3 id="2-实验"><a href="#2-实验" class="headerlink" title="2.实验"></a>2.实验</h3><p><strong>2d的D-LKA在多器官数据集上的表现：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047330.png" alt="image-20231218154533519" style="zoom:67%;"></p><p><strong>3d的D-LKA在多器官数据集上的表现：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252047355.png" alt="image-20231218154633563"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shader</title>
      <link href="/posts/fff39e28.html"/>
      <url>/posts/fff39e28.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-GLSL中向量的数据类型"><a href="#1-GLSL中向量的数据类型" class="headerlink" title="1.GLSL中向量的数据类型"></a>1.GLSL中向量的数据类型</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202312252046456.png" alt="image-20231215145202684"></p><h4 id="2-Uniform"><a href="#2-Uniform" class="headerlink" title="2.Uniform"></a>2.Uniform</h4><p><strong>uniform</strong>是一种在顶点着色器和片段着色器之间进行数据传递的机制，uniform变量是全局的，其值在每个渲染迭代中对所有顶点或片段是一致的。</p><p><strong>变量声明：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniform vec3 cameraPosition;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//返回自窗口初始化以来的秒数</span><br><span class="line">float timeValue = glfwGetTime();</span><br><span class="line">//将timeValue缩放到[0, 1]范围</span><br><span class="line">float greenValue = sin(timeValue) / 2.0f + 0.5f;</span><br><span class="line">//查询uniform ourColor的位置值</span><br><span class="line">int vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);</span><br><span class="line">//设置uniform值</span><br><span class="line">glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);</span><br></pre></td></tr></table></figure><h4 id="3-颜色插值"><a href="#3-颜色插值" class="headerlink" title="3.颜色插值"></a>3.颜色插值</h4><p>OpenGL会自动在顶点着色器和片段着色器之间进行插值</p><p><strong>定义顶点着色器和片段着色器：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">float vertices[] = &#123;</span><br><span class="line">// 位置              // 颜色</span><br><span class="line"> 0.8f, 0.2f, 0.0f,  1.0f, 0.0f, 0.0f,   // 右下</span><br><span class="line"> 0.3f, 0.4f, 0.0f,  0.0f, 1.0f, 0.0f,   // 左下</span><br><span class="line"> 0.0f,  0.1f, 0.0f,  0.0f, 0.0f, 1.0f,    // 顶部</span><br><span class="line"> 0.2f,  0.9f, 0.0f,  0.8f, 0.6f, 1.0f</span><br><span class="line">&#125;;</span><br><span class="line">unsigned int indices[] = &#123;</span><br><span class="line">0,1,2, // 第一个三角形</span><br><span class="line">2,1,3  // 第二个三角形</span><br><span class="line">&#125;;</span><br><span class="line">const char* vertexShaderSource = &quot;#version 330 core\n&quot;</span><br><span class="line">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span><br><span class="line">&quot;layout(location=1) in vec3 aColor;&quot;</span><br><span class="line">&quot;out vec4 vertexColor;\n&quot;</span><br><span class="line">&quot;void main()\n&quot;</span><br><span class="line">&quot;&#123;\n&quot;</span><br><span class="line">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span><br><span class="line">&quot;vertexColor=vec4(aColor.x,aColor.y,aColor.z,1.0f);\n&quot;</span><br><span class="line">&quot;&#125;\0&quot;;</span><br><span class="line"></span><br><span class="line">const char* fragmentShaderSource =</span><br><span class="line">&quot;#version 330 core\n&quot;</span><br><span class="line">&quot;out vec4 FragColor;\n&quot;</span><br><span class="line">&quot;uniform vec4 ourColor; &quot;</span><br><span class="line">&quot;in vec4 vertexColor;\n&quot;</span><br><span class="line">&quot;void main()&#123;\n&quot;</span><br><span class="line">&quot;FragColor = vertexColor;&#125;\n &quot;;</span><br></pre></td></tr></table></figure><p><strong>配置顶点属性指针：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 位置属性</span><br><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line">// 颜色属性</span><br><span class="line">glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));</span><br><span class="line">glEnableVertexAttribArray(1);</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312252046360.png" alt="image-20231215170557358" style="zoom:67%;"></p><p><em>注：片段着色器不会直接从 <code>VBO</code> 中读取数据，而是通过与顶点着色器的输出交互，通过插值的方式在片段上进行着色。</em></p><h4 id="4-文件流读取着色器内容"><a href="#4-文件流读取着色器内容" class="headerlink" title="4.文件流读取着色器内容"></a>4.文件流读取着色器内容</h4>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>窗口与三角形</title>
      <link href="/posts/aa216b4c.html"/>
      <url>/posts/aa216b4c.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-窗口"><a href="#1-窗口" class="headerlink" title="1.窗口"></a>1.窗口</h3><p><strong>创建GLFW窗口对象</strong></p><p><code>GLFWwindow* window = glfwCreateWindow(800, 600, &quot;opengl&quot;,NULL,NULL);</code></p><ul><li>800:width</li><li>600:height</li><li>“opengl”:title</li></ul><p><strong>初始化GLEW</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glewExperimental = true;//设置 GLEW 的实验性模式</span><br><span class="line">if (glewInit() != GLEW_OK)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Init GLEW failed&quot;);</span><br><span class="line">glfwTerminate();</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>窗口渲染框架：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#define GLEW_STATIC</span><br><span class="line">#include&lt;GL/glew.h&gt;</span><br><span class="line">#include&lt;GLFW/glfw3.h&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">void processInput(GLFWwindow* window)</span><br><span class="line">&#123;</span><br><span class="line">if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)//GLFW_KEY_ESCAPE:表示esc键，glfwGetKey：获取窗口中键的状态</span><br><span class="line">&#123;</span><br><span class="line">glfwSetWindowShouldClose(window, true);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">glfwInit();</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">//创建GLFW窗口对象</span><br><span class="line">GLFWwindow* window = glfwCreateWindow(800, 600, &quot;opengl&quot;,NULL,NULL);</span><br><span class="line">glfwMakeContextCurrent(window);//将当前需要渲染的窗口设置为window</span><br><span class="line">//初始化GLEW</span><br><span class="line">glewExperimental = true;//设置 GLEW 的实验性模式</span><br><span class="line">if (glewInit() != GLEW_OK)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Init GLEW failed&quot;);</span><br><span class="line">glfwTerminate();</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glViewport(0, 0, 800, 600);</span><br><span class="line">while (!glfwWindowShouldClose(window))//判断窗口是否被关闭，未关闭则一直循环</span><br><span class="line">&#123;</span><br><span class="line">processInput(window);</span><br><span class="line">glClearColor(0.5f, 0.2f, 0.3f, 1.0f);//定义一种颜色（rgba四通道），每个通道取值为0~1.</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT); </span><br><span class="line">//GL_COLOR_BUFFER_BIT:颜色缓冲,glClear:将颜色缓冲填充成glClearColor设置的颜色</span><br><span class="line">glfwSwapBuffers(window);//交换双缓冲，渲染先在后台缓冲区进行，之后再与前台缓冲区交换</span><br><span class="line">//使用双缓冲是为了避免用户看到不完整的、中间过程的渲染结果</span><br><span class="line">glfwPollEvents();//检查有没有触发什么事件（比如键盘输入、鼠标移动等）</span><br><span class="line">&#125;</span><br><span class="line">glfwTerminate();//释放 GLFW 库分配的资源和清理 GLFW 环境</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-三角形"><a href="#2-三角形" class="headerlink" title="2.三角形"></a>2.三角形</h3><p><strong>图形渲染管线：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312151450311.png" alt="image-20231215095323007" style="zoom:67%;"></p><h4 id="2-1-定义并绑定VAO"><a href="#2-1-定义并绑定VAO" class="headerlink" title="2.1 定义并绑定VAO"></a>2.1 定义并绑定VAO</h4><p><strong>VAO（Vertex Array Object）</strong>：**保存了一系列的VBO配置和顶点属性指针，它负责告诉GPU，VBO中的信息到底该以几个为一组，对VBO起到解释的作用。</p><p><em>注：一个VAO可以对应多个VBO</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312151450544.png" alt="image-20231215093925600" style="zoom:67%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned int VAO;//也可以是unsigned int VAO[n],n为VAO的个数</span><br><span class="line">glGenVertexArrays(1, &amp;VAO);</span><br><span class="line">glBindVertexArray(VAO);</span><br></pre></td></tr></table></figure><h4 id="2-2-定义并绑定VBO"><a href="#2-2-定义并绑定VBO" class="headerlink" title="2.2 定义并绑定VBO"></a>2.2 定义并绑定VBO</h4><p><strong>VBO（Vertex Buffer Object）:</strong>用于存储实际的顶点数据，可以包含顶点坐标、法线、颜色等信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned int VBO;</span><br><span class="line">glGenBuffers(1, &amp;VBO);</span><br><span class="line">//绑定VBO</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">//数据传输到缓冲区，GL_STATIC_DRAW：静态绘制，顶点数据不会被修改</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><h4 id="2-3-创建顶点着色器"><a href="#2-3-创建顶点着色器" class="headerlink" title="2.3 创建顶点着色器"></a>2.3 创建顶点着色器</h4><p><strong>顶点着色器：</strong>对每个输入顶点的坐标进行计算和变换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//vertexShaderSource</span><br><span class="line">const char* vertexShaderSource = &quot;#version 330 core\n&quot;</span><br><span class="line">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span><br><span class="line">&quot;void main()\n&quot;</span><br><span class="line">&quot;&#123;\n&quot;</span><br><span class="line">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span><br><span class="line">&quot;&#125;\0&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建顶点着色器对象</span><br><span class="line">unsigned int vertexShader;</span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">//设置顶点着色器源代码并编译</span><br><span class="line">glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);</span><br><span class="line">glCompileShader(vertexShader);</span><br></pre></td></tr></table></figure><h4 id="2-4-创建片段着色器"><a href="#2-4-创建片段着色器" class="headerlink" title="2.4 创建片段着色器"></a>2.4 创建片段着色器</h4><p><strong>片段着色器：</strong>用于对每个屏幕上的像素（片段）进行处理，决定最终的颜色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//fragmentShaderSource</span><br><span class="line">const char* fragmentShaderSource =</span><br><span class="line">&quot;#version 330 core\n&quot;</span><br><span class="line">&quot;out vec4 FragColor;\n&quot;</span><br><span class="line">&quot;void main()&#123;\n&quot;</span><br><span class="line">&quot;FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);&#125;\n &quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建片段着色器对象</span><br><span class="line">unsigned int fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">//设置源代码并编译</span><br><span class="line">glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);</span><br><span class="line">glCompileShader(fragmentShader);</span><br></pre></td></tr></table></figure><h4 id="2-5-创建着色器程序"><a href="#2-5-创建着色器程序" class="headerlink" title="2.5 创建着色器程序"></a>2.5 创建着色器程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned int shaderProgram;</span><br><span class="line">shaderProgram = glCreateProgram();</span><br><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">//将附加到着色器程序的各个着色器连接在一起，以形成一个完整的着色器程序。</span><br><span class="line">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure><h4 id="2-6-配置顶点属性指针"><a href="#2-6-配置顶点属性指针" class="headerlink" title="2.6 配置顶点属性指针"></a>2.6 配置顶点属性指针</h4><p><strong><code>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 \* sizeof(float), (void\*)0);</code></strong></p><ul><li><code>0</code>: 指定顶点着色器中的顶点属性位置（location）。在顶点着色器代码中，使用 <code>layout(location = 0)</code> 来定义的。</li><li><code>3</code>: 指定每个顶点属性包含的分量数量，这里是3，表示三维坐标x、y、z。</li><li><code>GL_FLOAT</code>: 指定顶点属性的数据类型，这里是浮点数。</li><li><code>GL_FALSE</code>: 指定是否要归一化数据，对于浮点数数据，通常设置为GL_FALSE。</li><li><code>3 * sizeof(float)</code>: 指定相邻顶点属性之间的偏移量（以字节为单位）。这里表示每个顶点的大小为3个浮点数，所以偏移量为3 * sizeof(float)。</li><li><code>(void*)0</code>: void*无类型指针，指定第一个顶点属性在缓冲区中的偏移量。这里表示从缓冲区的开头开始使用。</li></ul><p><strong><code>glEnableVertexAttribArray(0);</code></strong>:启用顶点属性数组，OpenGL会按照之前配置的顶点属性指针从缓冲区中读取数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br></pre></td></tr></table></figure><h4 id="2-7-绘制三角形"><a href="#2-7-绘制三角形" class="headerlink" title="2.7 绘制三角形"></a>2.7 绘制三角形</h4><p><strong><code>glDrawArrays(GL_TRIANGLES, 0, 3);</code></strong>:</p><ul><li><code>GL_TRIANGLES</code> 表示渲染的图元类型，这里是三角形。</li><li><code>0</code> 是起始顶点的索引，表示从顶点数组的第一个顶点开始渲染。</li><li><code>3</code> 是顶点的数量，表示渲染三个顶点。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, 0, 3);</span><br></pre></td></tr></table></figure><h4 id="2-8-绘制多边形"><a href="#2-8-绘制多边形" class="headerlink" title="2.8 绘制多边形"></a>2.8 绘制多边形</h4><p>注意：opengl的绘制顺序是逆时针（右手系），当启用背面剔除时，背面将不可见。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_CULL_FACE);</span><br><span class="line">glCullFace(GL_BACK);</span><br></pre></td></tr></table></figure><p><strong>EBO（索引缓冲对象）：</strong>用于优化和节省内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unsigned int indices[] = &#123;</span><br><span class="line">0, 1, 2, // 第一个三角形</span><br><span class="line">2, 1, 3  // 第二个三角形</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义并绑定EBO</span><br><span class="line">unsigned int EBO;</span><br><span class="line">glGenBuffers(1, &amp;EBO);</span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p><strong>绘制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">/*glDrawArrays(GL_TRIANGLES, 0,3);*/</span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span><br></pre></td></tr></table></figure><h4 id="2-9-线框模式"><a href="#2-9-线框模式" class="headerlink" title="2.9 线框模式"></a>2.9 线框模式</h4><p><strong>启用线框模式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span><br></pre></td></tr></table></figure><p><strong>取消线框模式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<p>ViT模型检测局部纹理和边缘信息的能力较弱</p><p>Laplacian- former，通过自适应地重新校准Laplacian金字塔中的频率信息来增强自注意图</p><p>ViT模型很难捕捉图像的高频成分（？），CNN与其相比在局部特征提取方面有优越性能</p><p>传统的自注意机制易丢失高频信息，如纹理和边缘细节</p><p>自注意机制具有二次型的计算复杂度，可能产生冗余特征</p><p><img src="/posts/0.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20231214143832330.png" alt="image-20231214143832330" style="zoom: 67%;"></p><p>efficient enhancement Transformer block</p><p>LN</p><p>EF-ATT捕获上下文信息，选择性地包含各种类型的频率信息，使用拉普拉斯金字塔来平衡形状和纹理特征的重要性</p><p>transformer越深，其特征变化越少，这限制了transformer的表示能力</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>games作业4</title>
      <link href="/posts/db707014.html"/>
      <url>/posts/db707014.html</url>
      
        <content type="html"><![CDATA[<h3 id="递归绘制贝塞尔曲线"><a href="#递归绘制贝塞尔曲线" class="headerlink" title="递归绘制贝塞尔曲线"></a>递归绘制贝塞尔曲线</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cv::Point2f recursive_bezier(const std::vector&lt;cv::Point2f&gt; &amp;control_points, float t) </span><br><span class="line">&#123;</span><br><span class="line">    if (control_points.size() == 1) </span><br><span class="line">    &#123;</span><br><span class="line">        return control_points[0];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        std::vector&lt;cv::Point2f&gt; points;</span><br><span class="line">        for (int i = 0; i &lt; control_points.size()-1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cv::Point2f p;</span><br><span class="line">            p.x = (1-t) * control_points[i].x + t * control_points[i + 1].x;</span><br><span class="line">            p.y = (1-t) * control_points[i].y + t * control_points[i + 1].y;</span><br><span class="line">            points.push_back(p);</span><br><span class="line">        &#125;</span><br><span class="line">        return recursive_bezier(points, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bezier(const std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window) </span><br><span class="line">&#123;</span><br><span class="line">    for (float t = 0; t &lt;= 1; t += 0.0001)</span><br><span class="line">    &#123;</span><br><span class="line">        //调用递归贝塞尔曲线计算函数，计算曲线上的点坐标</span><br><span class="line">        cv::Point2f point=recursive_bezier(control_points,t);</span><br><span class="line">        window.at&lt;cv::Vec3b&gt;(point.y, point.x)[1] = 255;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光线追踪</title>
      <link href="/posts/426f6fb6.html"/>
      <url>/posts/426f6fb6.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Shadow-Mapping"><a href="#1-Shadow-Mapping" class="headerlink" title="1.Shadow Mapping"></a>1.<strong>Shadow Mapping</strong></h3><p><strong>光栅化的问题：</strong>不能很好地表示全局的效果</p><p><strong>Shadow Mapping：</strong> 主要是为了解决点光源的硬阴影的问题</p><p>阴影区域：点对相机可见，而对光源不可见</p><p>Shadow Map记录每个pixel是否在阴影区域， 其生成步骤如下：</p><ul><li><p>1.从光源位置出发找出可见点，记录光源可见点的深度，得到光源深度图。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910765.png" alt="image-20231210115113668" style="zoom:50%;"></p></li><li><p>2.从相机出发，找可见点，如果点可见，坐标变换求此点到光源的距离。如果此距离与光源深度图中此位置的深度一致，说明此点可以被光源照到，是为光源、相机能同时看到点；如果不一致，说明是阴影点。</p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910506.png" alt="image-20231210115203873" style="zoom:50%;"></p><p><strong>硬阴影与软阴影：</strong></p><p>软阴影的形成在于全影和半影的渐变，点光源不存在软阴影问题，出现软阴影一定是光源有大小、不同照射位置有全影和半影这种渐变。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910061.png" alt="image-20231210120318890" style="zoom:50%;"></p><h3 id="2-Whitted-Styled-Ray-Tracing"><a href="#2-Whitted-Styled-Ray-Tracing" class="headerlink" title="2.Whitted-Styled Ray Tracing"></a>2.Whitted-Styled Ray Tracing</h3><p><strong>光线追踪利用的就是光的可逆性</strong></p><p>利用递归的方法进行光线追踪，对每条光线，递归计算其多个弹射点，当前光线所对应的像素值是由全部弹射点共同决定的：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910583.png" alt="image-20231210124837928" style="zoom:50%;"></p><p><strong>光源的定义：起点+方向</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910866.png" alt="image-20231210124958832" style="zoom:50%;"></p><p>于是，光线上的点可表示为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910939.png" alt="image-20231210125038746" style="zoom:50%;"></p><h3 id="3-光线求交点"><a href="#3-光线求交点" class="headerlink" title="3.光线求交点"></a>3.光线求交点</h3><h4 id="3-1-隐式表面"><a href="#3-1-隐式表面" class="headerlink" title="3.1 隐式表面"></a>3.1 隐式表面</h4><p>隐式表面求交点：将光线上的一点代入隐式方程中求解</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910802.png" alt="image-20231210125547229" style="zoom:50%;"></p><h4 id="3-2-显式表面"><a href="#3-2-显式表面" class="headerlink" title="3.2 显式表面"></a>3.2 显式表面</h4><p>显式表面求交点：用光线与三角形求交</p><p><strong>光线与三角形求交：</strong>光线与平面求交+判断交点是否在三角形内</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910771.png" alt="image-20231210130304291" style="zoom:50%;"></p><p>平面的定义：平面上一点+平面的法线</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910972.png" alt="image-20231210130407893" style="zoom:50%;"></p><p>求解交点的过程：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910503.png" alt="image-20231210130538694" style="zoom:50%;"></p><p><strong>Möller Trumbore Algorithm：</strong>三角形的一个点可以使用重心坐标表示</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910163.png" alt="image-20231210130920469" style="zoom:50%;"></p><p><em>注：解上图的方程，若$(1-b_1,b_2)、b_1、b_2$为正数，则交点在三角形内部</em></p><h3 id="4-计算的加速"><a href="#4-计算的加速" class="headerlink" title="4.计算的加速"></a>4.计算的加速</h3><p>每个光线与全部三角形都要进行求交点的计算，会导致计算开销过大，所以需要进行计算的加速。</p><p><strong>包围盒方法：</strong>在物体外面包一个包围盒，如果光线与盒子都没交点，那跟物体里的所有面更不会有交集。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910024.png" alt="image-20231210133306097" style="zoom:50%;"></p><p><strong>一般使用轴对齐包围盒（Axis-Aligned Bounding Box、AABB)</strong></p><p><strong>判断光线和包围盒是否有交点：</strong>通过计算光线进入/离开长方体的三个对面的时间可以判断出，光线和包围盒是否有交点</p><p>立方体有三个对面：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910471.png" alt="image-20231210133558734" style="zoom:50%;"></p><p>进入/离开对面的时间：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910723.png" alt="image-20231210133643427" style="zoom:50%;"></p><p>进入盒、离开盒的时间为：<br><img src="https://typoraimg.wangak.cc/2023/img/202312101910186.png" alt="image-20231210133737225" style="zoom:50%;"></p><p><em>注：光线进入了三个对面则认为光线进入了盒子，而光线离开了任意一个对面，就认为光线离开了盒子。</em></p><p><strong>若$t<em>{enter}&lt;t</em>{exit}且t_{exit}&gt;=0$，则有交点</strong></p><p><em>注：$t_{exit}$&lt;0，表示盒在光源背后，没有交点</em></p><h3 id="5-加速结构"><a href="#5-加速结构" class="headerlink" title="5.加速结构"></a>5.加速结构</h3><h4 id="5-1-均匀空间划分-Uniform-Spatial-Partitions-Grids"><a href="#5-1-均匀空间划分-Uniform-Spatial-Partitions-Grids" class="headerlink" title="5.1 均匀空间划分 Uniform Spatial Partitions (Grids)"></a>5.1 均匀空间划分 Uniform Spatial Partitions (Grids)</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910051.png" alt="image-20231210140725279" style="zoom:50%;"></p><p>判断光线交到的是不是含有物体表面的格子，如果不是的话跳过，是的话和其中的物体求交</p><p><em>注：该方法适合物体分布较均匀的场景</em></p><h4 id="5-2-空间划分"><a href="#5-2-空间划分" class="headerlink" title="5.2 空间划分"></a>5.2 空间划分</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910649.png" alt="image-20231210141331964" style="zoom:50%;"></p><ul><li>Oct-Tree:八叉树</li><li>KD-Tree</li><li>BSP-Tree</li></ul><p><strong>KD-Tree</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910636.png" alt="image-20231210142240300" style="zoom:50%;"></p><p>注：</p><p>1.KD-Tree中一个物体可能存在多个格子中</p><p>2.KD-Tree要计算三角形与盒子的求交，这较为困难</p><h4 id="5-3-物体划分（BVH）"><a href="#5-3-物体划分（BVH）" class="headerlink" title="5.3 物体划分（BVH）"></a>5.3 物体划分（BVH）</h4><p><strong>步骤：</strong></p><p>1.找到一个包围盒</p><p>2.递归地将物体拆成两个部分</p><p>3.两个部分重新计算包围盒</p><p>4.在每个叶子节点中记录实际的物体</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312101910732.png" alt="image-20231210143955688" style="zoom: 67%;"></p><p><em>注：划分规则：选择最长轴划分，以中间位置的物体进行划分</em></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>辐射度量学</title>
      <link href="/posts/9c8d1a2b.html"/>
      <url>/posts/9c8d1a2b.html</url>
      
        <content type="html"><![CDATA[<h2 id="辐射度量学"><a href="#辐射度量学" class="headerlink" title="辐射度量学"></a>辐射度量学</h2><p><strong>Whitted-Styled Ray Tracing的缺陷：</strong></p><ul><li>Whitted-Styled Ray Tracing主要关注的是折射光线和反射光线，而没有对漫反射的光线进行追踪。</li><li>所使用的Blinn-Phong模型是一种简化的模型</li></ul><p>因而引入辐射幅度量学来解决此问题。</p><p><strong>辐射度量学</strong>对光照的一套测量系统和单位，它能够准确的描述光线的物理性质。</p><h3 id="1-物理量的定义"><a href="#1-物理量的定义" class="headerlink" title="1.物理量的定义"></a>1.物理量的定义</h3><h4 id="1-1-辐射能量-Radiant-energy-和辐射通量-Radiant-flux"><a href="#1-1-辐射能量-Radiant-energy-和辐射通量-Radiant-flux" class="headerlink" title="1.1. 辐射能量(Radiant energy)和辐射通量(Radiant flux)"></a>1.1. 辐射能量(Radiant energy)和辐射通量(Radiant flux)</h4><p><strong>辐射能量:</strong>描述在一定时间内，通过某个表面或在空间中传播的电磁辐射的总能量量,以焦耳(J)为单位</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619481.png" alt="image-20231211210954761" style="zoom: 67%;"></p><p><strong>辐射通量（Radiant Flux）：</strong>是指光源辐射出的总功率，是在所有方向上的辐射强度的总和，以瓦特(W)为单位</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619781.png" alt="image-20231211211004923" style="zoom:67%;"></p><h4 id="1-2-辐射强度-Radiant-intensity"><a href="#1-2-辐射强度-Radiant-intensity" class="headerlink" title="1.2 辐射强度(Radiant intensity)"></a>1.2 辐射强度(Radiant intensity)</h4><p><strong>立体角：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619827.png" alt="image-20231211211509949" style="zoom: 67%;"></p><p>注：整个球的立体角为4<script type="math/tex">\pi</script></p><p><strong>微分立体角<script type="math/tex">d\omega</script>与<script type="math/tex">d\theta</script>和<script type="math/tex">d\phi</script>的关系:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619950.png" alt="image-20231212140402409" style="zoom: 67%;"></p><p><strong>辐射强度(Radiant intensity)：</strong>光源向特定方向发射的单位立体角内的功率，反映了光源在特定方向上的亮度。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619264.png" alt="image-20231212141054230" style="zoom:50%;"></p><p><em>注：辐射强度等于辐射通量除以立体角（各向同性）</em></p><h4 id="1-3-irradiance"><a href="#1-3-irradiance" class="headerlink" title="1.3  irradiance"></a>1.3  irradiance</h4><p><strong>irradiance：</strong>每单位照射面积所接收到的光功率</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619651.png" alt="image-20231212141549887" style="zoom:50%;"></p><p>注：当光线斜着照射到平面时，<script type="math/tex">\theta</script>为光线与法线的夹角，该公式变为：<img src="https://typoraimg.wangak.cc/2023/img/202312121621359.png" alt="image-20231212141804496" style="zoom: 67%;"></p><p>当照射点离光源越远时，A（球的表面积）就越大，irradiance就越小：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619417.png" alt="image-20231212142046864" style="zoom:50%;"></p><h4 id="1-4-radiance"><a href="#1-4-radiance" class="headerlink" title="1.4 radiance"></a>1.4 radiance</h4><p><strong>Radiance：</strong>每单位立体角、每单位垂直面积的光功率。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619800.png" alt="image-20231212142754987" style="zoom:67%;"></p><p><em>注：与irradiance的单位照射面积不同，Radiance定义的是单位垂直面积，二者的关系为：dA⊥=dAcosθ</em></p><p><strong>radiance和irradiance的关系如下：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619856.png" alt="image-20231212143220911" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619776.png" alt="image-20231212143324793" style="zoom:67%;"></p><p><em>注:Irradiance是Radiance在整个半球面的立体角上的积累</em></p><h3 id="2-双向反射分布函数-BRDF"><a href="#2-双向反射分布函数-BRDF" class="headerlink" title="2.双向反射分布函数(BRDF)"></a>2.双向反射分布函数(BRDF)</h3><p>空间中的一点（面积微分），在接受到一定方向上的亮度<script type="math/tex">dE(\omega_i)</script>之后，再向不同方向把能量辐射出去<script type="math/tex">dL_r(\omega_r)</script></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619734.png" alt="image-20231212143746031" style="zoom:67%;"></p><p><em>注：能量辐射的过程（即产生<script type="math/tex">dL_r(\omega_r)</script>的过程）受物体表面材质的影响，如光滑表面会完全反射到镜面反射方向，而粗糙表面会反射到所有方向</em></p><p><strong>BRDF：</strong>从特定方向入射的光线经材料表面反射后，沿特定方向散射的相对强度，函数值为反射光的radiance与入射光的irradiance的比值，定义如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619943.png" alt="image-20231212145455775" style="zoom:67%;"></p><h3 id="3-反射方程与渲染方程"><a href="#3-反射方程与渲染方程" class="headerlink" title="3.反射方程与渲染方程"></a>3.反射方程与渲染方程</h3><p><strong>反射方程：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619468.png" alt="image-20231212145941600" style="zoom: 67%;"></p><p>注：</p><p>(1).反射光 <script type="math/tex">Lo(p,ω_r)</script>是由所有不同方向上的入射光线的辐照度 <script type="math/tex">Li(p,ω_i)</script>贡献得到的</p><p>(2).在相机位置不变的情况下，对于一个固定的表面点p，反射方向 <script type="math/tex">ω_r</script>是相对固定的</p><p><strong>渲染方程：</strong>在反射方程的基础上，增加了一个自发光项</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121621807.png" alt="image-20231212150332586" style="zoom:67%;"></p><p><strong>一个点光源和单个物体：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619946.png" alt="image-20231212150513332" style="zoom:50%;"></p><p><em>注：点光源对一个点来说自然只有一个方向有入射光</em></p><p><strong>多个点光源一个物体的情况：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619174.png" alt="image-20231212150612687" style="zoom:50%;"></p><p><em>注：对多个点光源产生的反射光求和即可</em></p><p><strong>面光源的情况：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619863.png" alt="image-20231212150741761" style="zoom:50%;"></p><p><em>注：对面光源所在的立体角的范围积分</em></p><p><strong>考虑场景中其他物体的反射造成的光线交互：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619374.png" alt="image-20231212151116699" style="zoom:50%;"></p><p><em>注：将其他物体当作面光源</em></p><p><strong>使用积分变换矩阵可将其写作：L=E+KL</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619557.png" alt="image-20231212151331626" style="zoom:50%;"></p><p>于是得到L:<br>                                                <img src="https://typoraimg.wangak.cc/2023/img/202312121619933.png" alt="image-20231212151431111" style="zoom: 67%;"></p><p>其中<script type="math/tex">I</script>为单位矩阵，再接着对<script type="math/tex">(I-K)^{-1}</script>使用广义二项式定理得到：<br>                                                <img src="https://typoraimg.wangak.cc/2023/img/202312121619858.png" alt="image-20231212151515813" style="zoom:67%;"></p><p>注：E为自发光项，E+KE为光栅化的结果，即直接光照。对于全局光照,<script type="math/tex">K^2E</script>，即一次弹射的间接照明，<script type="math/tex">K^3E</script>就是两次弹射的间接照明……</p><h3 id="4-蒙特卡洛路径追踪"><a href="#4-蒙特卡洛路径追踪" class="headerlink" title="4.蒙特卡洛路径追踪"></a>4.蒙特卡洛路径追踪</h3><h4 id="4-1-蒙特卡洛积分"><a href="#4-1-蒙特卡洛积分" class="headerlink" title="4.1 蒙特卡洛积分"></a>4.1 蒙特卡洛积分</h4><p><strong>蒙特卡洛积分：</strong>通过对函数进行随机采样来估计积分值的方法，定义如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619771.png" alt="image-20231212154356113" style="zoom:50%;"></p><p>蒙特卡洛的近似正是对积分值的一个无偏估计：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619445.png" alt="image-20231212154446422" style="zoom: 67%;"></p><p><em>注：蒙特卡洛是一种用来求困难积分的方法</em></p><h4 id="4-2-蒙特卡洛路径追踪"><a href="#4-2-蒙特卡洛路径追踪" class="headerlink" title="4.2 蒙特卡洛路径追踪"></a>4.2 蒙特卡洛路径追踪</h4><p>当不考虑自发光项时， 渲染方程：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619268.png" alt="image-20231212155049240" style="zoom:67%;"></p><p>使用蒙特卡洛积分后：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619695.png" alt="image-20231212155138653" style="zoom:67%;"></p><p><em>注：这里取了N个采样方向<script type="math/tex">\omega_i</script></em></p><p>只考虑直接光照时，伪代码如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619297.png" alt="image-20231212155412919" style="zoom:67%;"></p><p>加入间接光照后，使用递归的算法，伪代码如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121620829.png" alt="image-20231212155500528" style="zoom:67%;"></p><p><em>注：这时由于使用递归的算法，每次采样N，这会导致指数爆炸的问题</em></p><p>于是，修改N=1，每次只搜索一条路径，重复多次寻找到多条路径，将多条路径的结果求得平均：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619544.png" alt="image-20231212160230270" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619824.png" alt="image-20231212160403123" style="zoom: 67%;"></p><p><em>注：对经过像素的光线采样多次，而对反射的光线只采样一次</em></p><p>递归出口的设置：RR(俄罗斯轮盘赌)</p><p>设定一个概率P,即每次反射有概率P继续递归，递归的返回值为<script type="math/tex">L_0/P</script>，有（1-P)的概率停止</p><p>使用俄罗斯轮盘赌保证了所得到的Radiance的期望不变：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619719.png" alt="image-20231212160801671" style="zoom:67%;"></p><p>shade函数的伪代码如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619418.png" alt="image-20231212160916559" style="zoom:67%;"></p><p>这样的采样，路径追踪效率非常的低下:</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121619630.png" alt="image-20231212161351867" style="zoom:67%;"></p><p>所以，为提高采样的效率，直接对光源进行采样，假设光源的面积为A，dA与<script type="math/tex">d\omega_i</script>的关系如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121620938.png" alt="image-20231212161554373" style="zoom:67%;"></p><p>于是渲染方程可改写为：<br>                                       <img src="https://typoraimg.wangak.cc/2023/img/202312121620560.png" alt="image-20231212161621658" style="zoom:67%;"></p><p>最终伪代码如下，分直接光照和间接光照两部分计算：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312121620823.png" alt="image-20231212161812935" style="zoom:67%;"></p><p><em>注：在计算直接光照时，要判断光源与着色点之间是否有物体遮挡</em></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学几何</title>
      <link href="/posts/e4365916.html"/>
      <url>/posts/e4365916.html</url>
      
        <content type="html"><![CDATA[<h2 id="图形学几何"><a href="#图形学几何" class="headerlink" title="图形学几何"></a>图形学几何</h2><h3 id="1-几何的分类"><a href="#1-几何的分类" class="headerlink" title="1.几何的分类"></a>1.几何的分类</h3><p><strong>隐式几何:</strong> 无明确表示，如用函数表示曲面，如点（x, y, z) 满足一定函数f(x, y)关系就在一个曲面上。判断点的位置关系很方便，遍历绘制图形比较困难。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536222.png" alt="image-20231209124852632" style="zoom:67%;"></p><p><strong>显式几何:</strong> 有明确表示方法，直接给出，或通过参数映射给出几何信息，比如一般的点云或网格。遍历绘制图形比较方便， 但判断点的位置关系，如内外、是否在表面上比较困难。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535257.png" alt="image-20231209124540218" style="zoom: 67%;"></p><p><em>注：显式几何的点被直接给出或可通过映射关系得到。</em></p><p><strong>区别：</strong>区别隐式曲面与显示曲面的关键就在于是否可以直接表示出所有的点</p><p><em>注：隐式曲面难以采样曲面上的点，但是可以轻易判断点与曲面的关系，对于显式曲面来可以很轻易的采样到所有的点，但是给予你任意一点却很难判断它与曲面的关系。</em></p><h4 id="1-1-隐式几何的例子"><a href="#1-1-隐式几何的例子" class="headerlink" title="1.1 隐式几何的例子"></a>1.1 隐式几何的例子</h4><ul><li><strong>代数曲面</strong></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535303.png" alt="image-20231209125119599" style="zoom:67%;"></p><ul><li><strong>Constructive Solid Geometry(CSG):</strong>对各种不同的几何做布尔运算，如并，交，差</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535351.png" alt="image-20231209125221199" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535535.png" alt="image-20231209125238367" style="zoom:67%;"></p><ul><li><strong>距离函数:</strong>得到几何体的混合效果</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535344.png" alt="image-20231209125458243" style="zoom:67%;"></p><ul><li><strong>水平集：</strong>找出函数值为0的地方作为曲线</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535748.png" alt="image-20231209125824432" style="zoom:67%;"></p><ul><li><strong>分型几何：</strong>通过迭代、自相似性和尺度不变性来描述复杂的几何形状。</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535549.png" alt="image-20231209125952472" style="zoom: 50%;"></p><h4 id="1-2-显式几何的例子"><a href="#1-2-显式几何的例子" class="headerlink" title="1.2 显式几何的例子"></a>1.2 显式几何的例子</h4><ul><li><p><strong>点云：</strong>（x,y,z）的列表，用点代替面，可用于表示任何空间中的几何</p></li><li><p><strong>多边形面/三角形</strong>（使用的最广泛）</p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535443.png" alt="image-20231209130844203" style="zoom: 33%;"></p><p>用.obj格式的文件保存模型：顶点、法线、纹理坐标</p><p>如下，文件描述了一个立方体：8个顶点、6个法线（右图vn有8个是因为存在冗余）、纹理坐标（vt）</p><p>f:顶点/纹理坐标/法线,定义了哪三个顶点构成三角形</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535311.png" alt="image-20231209131213798" style="zoom:67%;"></p><h3 id="2-曲线"><a href="#2-曲线" class="headerlink" title="2.曲线"></a>2.曲线</h3><h4 id="2-1-贝塞尔曲线"><a href="#2-1-贝塞尔曲线" class="headerlink" title="2.1 贝塞尔曲线"></a>2.1 贝塞尔曲线</h4><p>贝塞尔曲线：用控制点去定义曲线</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535440.png" alt="image-20231209132251079" style="zoom: 33%;"></p><p><strong>de Casteljau Algorithm：</strong>画贝塞尔曲线</p><p>将问题转化为：t点该如何画</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535451.png" alt="image-20231209132632421" style="zoom:50%;"></p><p>由$b_0、b_1$得到$b_0^1$,$b_1、b_2$得到$b_1^1$,由$b_0^1$,$b_1^1$得到$b_0^2$,即为t点</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535890.png" alt="image-20231209132826273" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312100940592.png" alt="image-20231210094017798" style="zoom:50%;"></p><p>四个点的情况：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535312.png" alt="image-20231209133247407" style="zoom: 33%;"></p><p>给出n个控制点可以得到一个n阶的贝塞尔曲线：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091535895.png" alt="image-20231209133842896" style="zoom: 50%;"></p><p><strong>伯恩斯坦多项式：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536748.png" alt="image-20231209134013528" style="zoom:50%;"></p><p><em>注：(n,i)是组合数</em></p><p>贝塞尔曲线的性质：</p><p>(1).必定经过起始与终止控制点<br>(2).必定经与起始与终止线段相切<br>(3).具有仿射变换性质，可以通过移动控制点移动整条曲线<br>(4).凸包性质，曲线一定不会超出所有控制点构成的多边形范围</p><p><em>注：将t从0到1进行迭代即可得到完整的贝塞尔曲线</em></p><p><strong>逐段定义贝塞尔曲线：</strong>更易使用控制点去控制曲线（常用四个控制点定义一段贝塞尔曲线）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536926.png" alt="image-20231209135657494" style="zoom:50%;"></p><h4 id="2-2-B样条"><a href="#2-2-B样条" class="headerlink" title="2.2 B样条"></a>2.2 B样条</h4><p>pass</p><h4 id="2-3-NURBS"><a href="#2-3-NURBS" class="headerlink" title="2.3 NURBS"></a>2.3 NURBS</h4><p>pass</p><h3 id="3-曲面"><a href="#3-曲面" class="headerlink" title="3.曲面"></a>3.曲面</h3><p><strong>贝塞尔曲面：</strong>需要有两个参数控制（时间u,v）,分别控制两次贝塞尔曲线的计算</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536201.png" alt="image-20231209142717655" style="zoom: 33%;"></p><h3 id="4-曲面细分"><a href="#4-曲面细分" class="headerlink" title="4.曲面细分"></a>4.曲面细分</h3><h4 id="4-1-Loop细分"><a href="#4-1-Loop细分" class="headerlink" title="4.1 Loop细分"></a>4.1 Loop细分</h4><p><strong>步骤：</strong></p><p><strong>1.生成更多三角形或顶点</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536280.png" alt="image-20231209144613202" style="zoom: 50%;"></p><p><strong>2.调整这些三角形的位置（顶点的位置）</strong></p><p>顶点分为两类，一类是新生成的顶点，一类是老的原来就有的顶点</p><p>对于新生成的顶点：其位置为周围顶点的权重之和</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536826.png" alt="image-20231209145401431" style="zoom:33%;"></p><p>对于旧的顶点：自身以及邻接顶点的权重和，权重的设置与旧的顶点的度有关</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536368.png" alt="image-20231209145809889" style="zoom:50%;"></p><h4 id="4-2-Catmull-Clark细分"><a href="#4-2-Catmull-Clark细分" class="headerlink" title="4.2 Catmull-Clark细分"></a>4.2 Catmull-Clark细分</h4><p>用于处理四边形面和三角面的混合的细分</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536889.png" alt="image-20231209150626897" style="zoom:50%;"></p><p><strong>Non-quad face:</strong>非四边形面</p><p><strong>奇异点:</strong>所有度不为4的顶点</p><p><strong>第一次细分所有面都会变成四边形，增加的奇异点个数为非四边形面的个数，之后再进行细分，奇异点个数不再增加</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536250.png" alt="image-20231209150826085" style="zoom:50%;"></p><p>点位置的调整：所有点分为：边上的点、面上的点、原来的点</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536387.png" alt="image-20231209151144071" style="zoom:50%;"></p><h3 id="5-曲面简化-Mesh-Smplication"><a href="#5-曲面简化-Mesh-Smplication" class="headerlink" title="5.曲面简化(Mesh Smplication)"></a>5.曲面简化(Mesh Smplication)</h3><p><strong>边坍缩：</strong>将一条边的两个顶点合成为一个顶点</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536794.png" alt="image-20231209152028718" style="zoom:50%;"></p><p>如何坍缩：使二次误差度量最小</p><p>二次误差度量：坍缩之后蓝色新顶点所在的位置与原来各个平面的垂直距离之和</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312091536192.png" alt="image-20231209152333304"></p><p><strong>步骤：</strong>（使用堆结构）</p><p><strong>1 为模型每条边赋值，其值为坍缩这条边之后，代替两个老顶点的新顶点所能得到的最小二次误差度量</strong><br> <strong>2 选取权值最小的边做坍缩，新顶点位置为原来计算得出使得二次误差最小的位置</strong><br> <strong>3 坍缩完之后，与之相连其他的边的位置会改动，更新这些边的权值</strong><br> <strong>4 重复上述步骤，直到到达终止条件</strong></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>games作业3</title>
      <link href="/posts/4514e5b7.html"/>
      <url>/posts/4514e5b7.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-透视投影变换"><a href="#1-透视投影变换" class="headerlink" title="1.透视投影变换"></a>1.透视投影变换</h4><p>投影接口的参数是张角fov，横纵比为aspect时，透视投影的变换矩阵如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090851755.png" alt="image-20231203092505302" style="zoom:50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar)</span><br><span class="line">&#123;</span><br><span class="line">    Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();</span><br><span class="line">    projection(0, 0) = -(1 / (aspect_ratio * tan(eye_fov / 180.0 * MY_PI)));</span><br><span class="line">    projection(1, 1) = -(1 / (tan(eye_fov / 180.0 * MY_PI)));</span><br><span class="line">    projection(2, 2) = (zNear + zFar) / (zNear - zFar);</span><br><span class="line">    projection(2, 3) = (2 * zFar * zNear) / (zNear - zFar);</span><br><span class="line">    projection(3, 2) = 1;</span><br><span class="line">    projection(3, 3) = 0;</span><br><span class="line">    return projection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-判断点是否在三角形内"><a href="#2-判断点是否在三角形内" class="headerlink" title="2.判断点是否在三角形内"></a>2.判断点是否在三角形内</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static bool insideTriangle(int x, int y, const Vector4f* _v)&#123;</span><br><span class="line">    Eigen::Vector2f AB, BC, CA, AP, BP, CP, p;</span><br><span class="line">    float a, b, c;//用于保存叉乘的结果(是正还是负）</span><br><span class="line">    p &lt;&lt; x ,y;</span><br><span class="line">    AB = _v[1].head(2) - _v[0].head(2);</span><br><span class="line">    AP = p - _v[0].head(2);</span><br><span class="line">    BC = _v[2].head(2) - _v[1].head(2);</span><br><span class="line">    BP = p - _v[1].head(2);</span><br><span class="line">    CA = _v[0].head(2) - _v[2].head(2);</span><br><span class="line">    CP = p - _v[2].head(2);</span><br><span class="line">    //分别计算叉乘，x,y方向为0，故只计算z方向的结果</span><br><span class="line">    a = AB[0] * AP[1] - AB[1] * AP[0];</span><br><span class="line">    b = BC[0] * BP[1] - BC[1] * BP[0];</span><br><span class="line">    c = CA[0] * CP[1] - CA[1] * CP[0];</span><br><span class="line">    if (a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; c &gt; 0)</span><br><span class="line">        return true;</span><br><span class="line">    else if (a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; c &lt; 0)</span><br><span class="line">        return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-光栅化"><a href="#3-光栅化" class="headerlink" title="3.光栅化"></a>3.光栅化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//屏幕空间光栅化</span><br><span class="line">//view_pos：顶点在屏幕空间的坐标</span><br><span class="line">void rst::rasterizer::rasterize_triangle(const Triangle&amp; t, const std::array&lt;Eigen::Vector3f, 3&gt;&amp; view_pos)</span><br><span class="line">&#123;</span><br><span class="line">    auto v = t.toVector4();</span><br><span class="line">    float x_max = std::max(std::max(v[0].x(), v[1].x()), v[2].x());</span><br><span class="line">    float x_min = std::min(std::min(v[0].x(), v[1].x()), v[2].x());</span><br><span class="line">    float y_min = std::min(std::min(v[0].y(), v[1].y()), v[2].y());</span><br><span class="line">    float y_max = std::max(std::max(v[0].y(), v[1].y()), v[2].y());</span><br><span class="line">    for (int i = x_min; i &lt; x_max+1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = y_min; j &lt; y_max+1; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (insideTriangle(i, j, t.v))</span><br><span class="line">            &#123;</span><br><span class="line">                //计算当前像素在三角形内的重心坐标</span><br><span class="line">                auto [alpha, beta, gamma] = computeBarycentric2D(i, j, t.v);</span><br><span class="line"></span><br><span class="line">                //通过重心插值得到深度值z_interpolated</span><br><span class="line">                //w_reciprocal为透视修正系数</span><br><span class="line">                float w_reciprocal = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());</span><br><span class="line">                float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();</span><br><span class="line">                z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">                //Z-Buffer</span><br><span class="line">                if (depth_buf[get_index(i, j)] &gt; z_interpolated)</span><br><span class="line">                &#123;</span><br><span class="line">                    //利用重心坐标插值颜色、法线、纹理、shadingcoords（像素位置）</span><br><span class="line">                    auto interpolated_color = interpolate(alpha, beta, gamma, t.color[0], t.color[1], t.color[2], 1);</span><br><span class="line">                    auto interpolated_normal = interpolate(alpha, beta, gamma, t.normal[0], t.normal[1], t.normal[2], 1);</span><br><span class="line">                    auto interpolated_texcoords = interpolate(alpha, beta, gamma, t.tex_coords[0], t.tex_coords[1], t.tex_coords[2], 1);</span><br><span class="line">                    auto interpolated_shadingcoords = interpolate(alpha, beta, gamma, view_pos[0], view_pos[1], view_pos[2], 1);</span><br><span class="line">                    // 初始化 payload，用于传递给片段着色器</span><br><span class="line">                    fragment_shader_payload payload(interpolated_color, interpolated_normal.normalized(), interpolated_texcoords, texture ? &amp;*texture : nullptr);</span><br><span class="line">                    payload.view_pos = interpolated_shadingcoords;</span><br><span class="line"></span><br><span class="line">                    // 更新深度缓存</span><br><span class="line">                    depth_buf[get_index(i, j)] = z_interpolated;</span><br><span class="line"></span><br><span class="line">                    // 设置像素颜色，调用片段着色器</span><br><span class="line">                    Vector2i temp(i, j);</span><br><span class="line">                    set_pixel(temp, fragment_shader(payload));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Blinn-Phong反射模型"><a href="#4-Blinn-Phong反射模型" class="headerlink" title="4.Blinn-Phong反射模型"></a>4.Blinn-Phong反射模型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector3f phong_fragment_shader(const fragment_shader_payload&amp; payload)</span><br><span class="line">&#123;</span><br><span class="line">    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);//环境光反射率</span><br><span class="line">    Eigen::Vector3f kd = payload.color;//漫反射项系数</span><br><span class="line">    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);//高光项</span><br><span class="line">    //定义了两个光源</span><br><span class="line">    auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line">    auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;;//环境光</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;;//观察点的位置</span><br><span class="line">    float p = 150;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f color = payload.color;</span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f result_color = &#123;0, 0, 0&#125;;</span><br><span class="line">    for (auto&amp; light : lights)</span><br><span class="line">    &#123;</span><br><span class="line">        //计算光源到物体距离的平方r2</span><br><span class="line">        float r2 = (light.position - point).dot((light.position - point));//a.dot(a)=|a|^2</span><br><span class="line"></span><br><span class="line">        Eigen::Vector3f l = (light.position - point).normalized();//光线方向</span><br><span class="line">        Eigen::Vector3f v = (eye_pos - point).normalized();//观察方向</span><br><span class="line">        Eigen::Vector3f h = (l + v).normalized();//半程向量</span><br><span class="line"></span><br><span class="line">        //.cwiseProduct()用于向量对应位置的点相乘</span><br><span class="line">        //漫反射</span><br><span class="line">        Eigen::Vector3f diffuse = kd.cwiseProduct(light.intensity / r2) * std::max(0.0f, normal.normalized().dot(l));</span><br><span class="line">        //环境光</span><br><span class="line">        Eigen::Vector3f ambient = ka.cwiseProduct(amb_light_intensity);</span><br><span class="line">        //高光</span><br><span class="line">        Eigen::Vector3f specular = ks.cwiseProduct(light.intensity / r2) * pow(std::max(0.0f, normal.normalized().dot(h)), p);</span><br><span class="line"></span><br><span class="line">        result_color += ambient + diffuse + specular; </span><br><span class="line">    &#125;</span><br><span class="line">    return result_color * 255.f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-纹理映射"><a href="#5-纹理映射" class="headerlink" title="5.纹理映射"></a>5.纹理映射</h4><p>修改漫反射系数 <code>kd</code>即可，<code>kd</code> 是一个颜色向量，它表示了表面对漫反射光的反应程度，环境光和镜面反射成分通常是不受纹理映射直接影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector3f texture_fragment_shader(const fragment_shader_payload&amp; payload)</span><br><span class="line">&#123;</span><br><span class="line">    Eigen::Vector3f return_color = &#123;0, 0, 0&#125;;</span><br><span class="line">    if (payload.texture)</span><br><span class="line">    &#123;</span><br><span class="line">        //获取纹理坐标处的颜色</span><br><span class="line">        return_color = payload.texture-&gt;getColor(payload.tex_coords.x(), payload.tex_coords.y());</span><br><span class="line">    &#125;</span><br><span class="line">    Eigen::Vector3f texture_color;</span><br><span class="line">    texture_color &lt;&lt; return_color.x(), return_color.y(), return_color.z();</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);</span><br><span class="line">    Eigen::Vector3f kd = texture_color / 255.f;</span><br><span class="line">    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);</span><br><span class="line"></span><br><span class="line">    auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line">    auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;;</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;;</span><br><span class="line"></span><br><span class="line">    float p = 150;</span><br><span class="line">    Eigen::Vector3f color = texture_color;</span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f result_color = &#123;0, 0, 0&#125;;</span><br><span class="line"></span><br><span class="line">    for (auto&amp; light : lights)</span><br><span class="line">    &#123;</span><br><span class="line">        //计算光源到物体距离的平方r2</span><br><span class="line">        float r2 = (light.position - point).dot((light.position - point));//a.dot(a)=|a|^2</span><br><span class="line"></span><br><span class="line">        Eigen::Vector3f l = (light.position - point).normalized();//光线方向</span><br><span class="line">        Eigen::Vector3f v = (eye_pos - point).normalized();//观察方向</span><br><span class="line">        Eigen::Vector3f h = (l + v).normalized();//半程向量</span><br><span class="line"></span><br><span class="line">        //.cwiseProduct()用于向量对应位置的点相乘</span><br><span class="line">        //漫反射</span><br><span class="line">        Eigen::Vector3f diffuse = kd.cwiseProduct(light.intensity / r2) * std::max(0.0f, normal.normalized().dot(l));</span><br><span class="line">        //环境光</span><br><span class="line">        Eigen::Vector3f ambient = ka.cwiseProduct(amb_light_intensity);</span><br><span class="line">        //高光</span><br><span class="line">        Eigen::Vector3f specular = ks.cwiseProduct(light.intensity / r2) * pow(std::max(0.0f, normal.normalized().dot(h)), p);</span><br><span class="line"></span><br><span class="line">        result_color += ambient + diffuse + specular;</span><br><span class="line">    &#125;</span><br><span class="line">    return result_color * 255.f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-凹凸贴图"><a href="#6-凹凸贴图" class="headerlink" title="6.凹凸贴图"></a>6.凹凸贴图</h4><p>pass</p><h4 id="7-位移贴图"><a href="#7-位移贴图" class="headerlink" title="7.位移贴图"></a>7.位移贴图</h4><p>pass</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纹理映射</title>
      <link href="/posts/df375b66.html"/>
      <url>/posts/df375b66.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-纹理映射"><a href="#1-纹理映射" class="headerlink" title="1.纹理映射"></a>1.纹理映射</h3><p><strong>纹理映射：</strong>用于增强渲染的真实感和细节，允许在三维模型表面上贴附二维图像，以模拟材质、颜色、光照等细节。</p><p>纹理坐标的伪代码表示：<br><img src="https://typoraimg.wangak.cc/2023/img/202312090856218.png" alt="image-20231201125433593" style="zoom:50%;"></p><p>​        即通过对每个光栅化的屏幕坐标算出它的纹理坐标（u,v)(利用三角形顶点重心坐标插值),再利用这个u,v坐标去查询texture上的颜色，把这个颜色信息当作漫反射系数Kd。</p><h4 id="1-1-纹理过小的问题"><a href="#1-1-纹理过小的问题" class="headerlink" title="1.1 纹理过小的问题"></a>1.1 纹理过小的问题</h4><p><strong>问题：</strong>例如，有一张大小为100x100像素的纹理贴图，然后将这个贴图应用到一个500x500像素的屏幕上，这样多个像素点可能会映射到纹理贴图的相同区域，这使得纹理像素的信息被多个屏幕像素所共享。</p><p>​        如果只是简单地使用最近的纹理坐标点，即离目标点最近的(u, v)坐标，取样不足以准确反映屏幕上多个像素的信息，会导致渲染结果出现严重的走样问题。</p><p><strong>解决方法：</strong>使用更复杂的纹理过滤技术，如双线性插值，考虑周围像素的颜色信息，从而在渲染过程中更加平滑地处理纹理映射，减少走样的影响。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090856478.png" alt="image-20231201130205648" style="zoom:50%;"></p><p><em>注：Bicubic：双三次插值是利用三次方程来进行两次插值，但是计算开销过</em>大</p><h4 id="1-2-纹理过大的问题"><a href="#1-2-纹理过大的问题" class="headerlink" title="1.2 纹理过大的问题"></a>1.2 纹理过大的问题</h4><p><strong>现象：</strong><br><img src="https://typoraimg.wangak.cc/2023/img/202312090855369.png" alt="image-20231201130738219" style="zoom: 67%;"></p><p><strong>近处出现锯齿，远处出现摩尔纹</strong></p><p><strong>原因：</strong>根据近大远小，远处的一张完整的贴图可能在屏幕空间中仅仅是几个像素的大小，屏幕空间的一个像素对应了纹理贴图上的一片范围的点，而用一个点采样的结果代替纹理空间一片范围的颜色信息，必然会导致严重失真</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090855975.png" alt="image-20231201131153194" style="zoom:50%;"></p><p>如上图，一个屏幕空间的蓝色像素点离相机越远，对应在texture空间的范围也就越大</p><p><strong>解决方法：</strong>超采样（计算开销过大，不好）、MipMap</p><p><strong>纹理足迹（Texture Footprint）：</strong> 当纹理贴图映射到几何体表面时，每个像素在纹理空间中的足迹描述了纹理在几何体上的分布。</p><h4 id="1-3-MipMap"><a href="#1-3-MipMap" class="headerlink" title="1.3 MipMap"></a>1.3 MipMap</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202312090856328.png" alt="image-20231201132206220" style="zoom:50%;"></p><p>level 0代表的是原始texture，也是精度最高的纹理，随着level的提升，每提升一级将4个相邻像素点求均值合为一个像素点，因此越高的level也就代表了更大的footprint的区域查询。接下来要做的就是根据屏幕像素的footprint大小选定不同level的texture，再进行点查询即可，而这其实就相当于在原始texture上进行了区域查询。</p><p><em>注：通过MipMap将区域查询的问题，再次转换为点查询。使用MipMap仅将纹理map的大小扩大了1/3</em></p><p><strong>确定level：</strong>利用屏幕像素的相邻像素点估算footprint大小再确定level</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090856671.png" alt="image-20231201132617242" style="zoom: 67%;"></p><p>在屏幕空间中取当前像素点的右方和上方的两个相邻像素点(4个全取也可以)，分别查询得到这3个点对应在Texture space的坐标，计算出当前像素点与右方像素点和上方像素点在Texture space的距离，二者取最大值得到L,再通过L得到D。</p><p><strong>D算出的是一个连续值而不是整数的解决办法：</strong><br>（1）四舍五入取得最近的那个level D（纹理之间可能存在突变，不连续，故不好）</p><p>（2）利用D值在向下和向上取整的两个不同level进行三线性插值（即将level连续化），如下图。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090856929.png" alt="image-20231201133041710" style="zoom:50%;"></p><p>三线性插值的MipMap的效果：远处出现了过曝的现象<br><img src="https://typoraimg.wangak.cc/2023/img/202312090856355.png" alt="image-20231201133122841" style="zoom: 50%;"></p><p><em>出现该问题的原因是屏幕空间中的正方形的像素，在纹理空间中的形状可能是不规则的矩形</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312090856608.png" alt="image-20231201133312851" style="zoom:50%;"></p><h4 id="1-4-各向异性过滤Mipmap"><a href="#1-4-各向异性过滤Mipmap" class="headerlink" title="1.4 各向异性过滤Mipmap"></a>1.4 各向异性过滤Mipmap</h4><p>各向异性的过滤：<img src="https://typoraimg.wangak.cc/2023/img/202312090856102.png" alt="image-20231201133512182" style="zoom:50%;"></p><p>将纹理分为水平方向上的level和竖直方向的level</p><h3 id="2-凹凸贴图"><a href="#2-凹凸贴图" class="headerlink" title="2.凹凸贴图"></a>2.凹凸贴图</h3><p><strong>凹凸贴图的原理:</strong>  利用凹凸贴图来改变原本光滑的平面的法线, 使原本光滑的平面产生凹凸感。</p><p> pass</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>games作业框架</title>
      <link href="/posts/b46ced9d.html"/>
      <url>/posts/b46ced9d.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Triangle类"><a href="#1-Triangle类" class="headerlink" title="1.Triangle类"></a>1.Triangle类</h3><h4 id="1-1-Triangle-hpp：类的声明"><a href="#1-1-Triangle-hpp：类的声明" class="headerlink" title="1.1 Triangle.hpp：类的声明"></a>1.1 Triangle.hpp：类的声明</h4><p><strong>定义了一个名为 <code>Triangle</code> 的类</strong></p><ul><li>三角形顶点的齐次坐标：（x,y,z,w)</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202312090858570.png" alt="image-20231203094213284"></p><p><em>注：w=0时表示该点在无穷远处</em></p><ul><li><strong>ifndef</strong>：防止头文件的重复包含，确保在编译时，同一个头文件不会被多次包含，从而避免因重复包含导致的重定义报错。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TEST_H</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">...... #内容</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line">头文件结尾写上一行：</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><em>注：__TEST_H为标识符，通常是大写形式</em></p><ul><li><strong>void setNormals(const std::array<Vector3f, 3>&amp; normals)</Vector3f,></strong>：利用normals设置三角形顶点的法向量normal[3]<ul><li>std::array：标准库中的容器</li><li>Vector3f（元素类型）、3（数组大小）</li><li>const:保证normals不会被修改,&amp;:传递引用类型，避免对象的拷贝，提高执行效率</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#ifndef RASTERIZER_TRIANGLE_H</span><br><span class="line">#define RASTERIZER_TRIANGLE_H</span><br><span class="line"></span><br><span class="line">#include&lt;eigen3/Eigen/Eigen&gt;</span><br><span class="line">#include&quot;Texture.hpp&quot;//项目内的头文件用&quot;&quot;</span><br><span class="line">using namespace Eigen;</span><br><span class="line">class Triangle&#123;</span><br><span class="line">Vector4f v[3];//三角形三个顶点的其次坐标（x,y,z,w)</span><br><span class="line">Vector3f color[3];//顶点的颜色</span><br><span class="line">Vector2f tex_coords[3];//顶点的纹理坐标</span><br><span class="line">Vector3f normal[3];//顶点的法向量</span><br><span class="line"></span><br><span class="line">Texture* tex = nullptr;//指向其纹理信息的指针</span><br><span class="line"></span><br><span class="line">Triangle();//默认构造函数</span><br><span class="line"></span><br><span class="line">//获取三个顶点的坐标</span><br><span class="line">Eigen::Vector4f a() const &#123; return v[0]; &#125;</span><br><span class="line">Eigen::Vector4f b() const &#123; return v[1]; &#125;</span><br><span class="line">Eigen::Vector4f c() const &#123; return v[2]; &#125;</span><br><span class="line"></span><br><span class="line">//设置第i个顶点的坐标</span><br><span class="line">void setVertex(int ind,Vector4f ver);//将第i个顶点的坐标设置为ver</span><br><span class="line">//设置法向量</span><br><span class="line">void setNormal(int ind, Vector3f ver);</span><br><span class="line">//设置颜色</span><br><span class="line">void setColor(int ind, float r, float g, float b);</span><br><span class="line">//设置所有顶点的法向量</span><br><span class="line">void setNormals(const std::array&lt;Vector3f, 3&gt;&amp; normals);</span><br><span class="line">//设置所有顶点的颜色</span><br><span class="line">void setColors(const std::array&lt;Vector3f, 3&gt;&amp; colors);</span><br><span class="line">//设置第i个顶点的纹理</span><br><span class="line">void setTexCoord(int ind, Vector2f uv);</span><br><span class="line"></span><br><span class="line">std::array&lt;Vector4f, 3&gt; toVector4() const;//定义toVector4()函数，将齐次坐标（x,y,z,w)转换为（x/w,y/w,z/w,1)的形式</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">#endif // !RASTERIZER_TRIANGLE_H</span><br></pre></td></tr></table></figure><h4 id="1-2-Triangle-cpp：类的实现"><a href="#1-2-Triangle-cpp：类的实现" class="headerlink" title="1.2 Triangle.cpp：类的实现"></a>1.2 Triangle.cpp：类的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;Triangle.hpp&quot;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;array&gt;</span><br><span class="line"></span><br><span class="line">//构造函数的实现</span><br><span class="line">Triangle::Triangle() &#123;</span><br><span class="line">v[0] &lt;&lt; 0, 0, 0, 1;</span><br><span class="line">v[1] &lt;&lt; 0, 0, 0, 1;</span><br><span class="line">v[2] &lt;&lt; 0, 0, 0, 1;</span><br><span class="line">color[0] &lt;&lt; 0.0, 0.0, 0.0;</span><br><span class="line">color[1] &lt;&lt; 0.0, 0.0, 0.0;</span><br><span class="line">color[2] &lt;&lt; 0.0, 0.0, 0.0;</span><br><span class="line">tex_coords[0] &lt;&lt; 0.0, 0.0;</span><br><span class="line">tex_coords[1] &lt;&lt; 0.0, 0.0;</span><br><span class="line">tex_coords[2] &lt;&lt; 0.0, 0.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置指定索引的纹理</span><br><span class="line">void Triangle::setTexCoord(int ind, Vector2f uv) &#123;</span><br><span class="line">tex_coords[ind] = uv;</span><br><span class="line">&#125;</span><br><span class="line">//设置顶点</span><br><span class="line">void Triangle::setVertex(int ind, Vector4f ver) &#123;</span><br><span class="line">v[ind] = ver;</span><br><span class="line">&#125;</span><br><span class="line">//设置法线</span><br><span class="line">void Triangle::setNormal(int ind, Vector3f n) &#123;</span><br><span class="line">normal[ind] = n;</span><br><span class="line">&#125;</span><br><span class="line">//设置颜色</span><br><span class="line">void Triangle::setColor(int ind, float r, float g, float b) &#123;</span><br><span class="line">if ((r &lt; 0.0) || (r &gt; 255.) ||</span><br><span class="line">(g &lt; 0.0) || (g &gt; 255.) ||</span><br><span class="line">(b &lt; 0.0) || (b &gt; 255.)) &#123;</span><br><span class="line">fprintf(stderr, &quot;ERROR! Invalid color values&quot;);</span><br><span class="line">fflush(stderr);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">color[ind] = Vector3f((float)r / 255., (float)g / 255., (float)b / 255.);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//将顶点坐标转换为标准的四维齐次坐标</span><br><span class="line">std::array&lt;Vector4f, 3&gt; Triangle::toVector4() const</span><br><span class="line">&#123;</span><br><span class="line">std::array&lt;Vector4f, 3&gt; res;</span><br><span class="line">std::transform(std::begin(v), std::end(v), res.begin(), [](auto&amp; vec) &#123; return Vector4f(vec.x(), vec.y(), vec.z(), 1.f); &#125;);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">void Triangle::setNormals(const std::array&lt;Vector3f, 3&gt;&amp; normals)</span><br><span class="line">&#123;</span><br><span class="line">// 设置法向量</span><br><span class="line">normal[0] = normals[0];</span><br><span class="line">normal[1] = normals[1];</span><br><span class="line">normal[2] = normals[2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Triangle::setColors(const std::array&lt;Vector3f, 3&gt;&amp; colors)</span><br><span class="line">&#123;</span><br><span class="line">// 设置颜色</span><br><span class="line">auto first_color = colors[0];</span><br><span class="line">setColor(0, colors[0][0], colors[0][1], colors[0][2]);</span><br><span class="line">setColor(1, colors[1][0], colors[1][1], colors[1][2]);</span><br><span class="line">setColor(2, colors[2][0], colors[2][1], colors[2][2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>局部光照模型及着色方法</title>
      <link href="/posts/af9d8c8.html"/>
      <url>/posts/af9d8c8.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-局部光照模型"><a href="#1-局部光照模型" class="headerlink" title="1.局部光照模型"></a>1.局部光照模型</h3><p><strong>光线的简单分类：</strong></p><ul><li><p><strong>镜面反射</strong></p></li><li><p><strong>漫反射</strong></p></li></ul><ul><li><strong>环境光</strong></li></ul><h4 id="1-1-泛光模型"><a href="#1-1-泛光模型" class="headerlink" title="1.1 泛光模型"></a>1.1 泛光模型</h4><p>泛光模型即<strong>只考虑环境光</strong>，这是最简单的<strong>经验</strong>模型，只会去考虑环境光的影响，并且不会去精确的描述，而只是用一个简单的式子表示：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952046.png" alt="image-20231130091038413" style="zoom:50%;"></p><script type="math/tex; mode=display">注：K_a表示物体表面对环境光的反射率，I_a代表入射环境光的亮度，I_{env}存储结果，即人眼所能看到从物体表面反射的环境光的亮度。</script><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952312.png" alt="image-20231130091806017" style="zoom: 67%;"></p><h4 id="1-2-Lambert漫反射模型"><a href="#1-2-Lambert漫反射模型" class="headerlink" title="1.2 Lambert漫反射模型"></a>1.2 Lambert漫反射模型</h4><ul><li><p>在泛光模型的基础之上增加了<strong>漫反射项</strong></p><ul><li>每个不同方向反射的光的强度相等</li><li>产生漫反射的原因是物体表面的粗糙</li></ul></li><li><p><strong>漫反射光照强度与光线照射方向和表面法线之间的夹角余弦成正比</strong></p><p><em>注：漫反射与观察方向无关，光线照射方向和表面法线之间的夹角反应了对于光照的接受率</em></p></li><li><p><strong>公式表示：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952975.png" alt="image-20231130091906700" style="zoom:50%;"></p></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952973.png" alt="image-20231130091824267"></p><h4 id="1-3-Blinn-Phong反射模型"><a href="#1-3-Blinn-Phong反射模型" class="headerlink" title="1.3 Blinn-Phong反射模型"></a>1.3 Blinn-Phong反射模型</h4><p>Blinn-Phong反射模型是Phong光照模型的一种改进，在模拟高光方面表现更为自然。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952864.png" alt="image-20231130092346846" style="zoom: 50%;"></p><p>注：$k_s$为镜面反射系数， I为入射光强， r为光源到入射点距离,指数p加速衰减(用于减小可以看到高光的角度）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952037.png" alt="image-20231130092850361" style="zoom:50%;"></p><p>注：使用半程向量简化了反射向量与人眼观察夹角的计算（Phong光照模型，即下图中R与v的夹角的计算）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952906.png" alt="image-20231130092457821" style="zoom:50%;"></p><p><strong>整体计算公式：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300952426.png" alt="image-20231130092944573" style="zoom:50%;"></p><p><em>注：L=泛光（环境光）+漫反射项+高光</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953544.png" alt="image-20231130093045061" style="zoom:50%;"></p><h3 id="2-着色方法-频率"><a href="#2-着色方法-频率" class="headerlink" title="2.着色方法(频率)"></a>2.着色方法(频率)</h3><h4 id="2-1-Flat-Shading（面着色）"><a href="#2-1-Flat-Shading（面着色）" class="headerlink" title="2.1 Flat Shading（面着色）"></a>2.1 Flat Shading（面着色）</h4><p>模型数据大多以很多个三角面进行存储，因此也就记录了每个面的法线向量，利用每个面的法线向量进行一次Blinn-Phong反射光照模型的计算，将该颜色赋予整个面。</p><p>效果如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953328.png" alt="image-20231130093503703" style="zoom:50%;"></p><h4 id="2-2-Gouraud-Shading（顶点着色）"><a href="#2-2-Gouraud-Shading（顶点着色）" class="headerlink" title="2.2 Gouraud Shading（顶点着色）"></a>2.2 Gouraud Shading（顶点着色）</h4><p>Gouraud Shading会对每个三角形的顶点进行一次着色</p><p><strong>点法线：将所有共享这个点的面的法线向量加起来求均值，最后再标准化</strong></p><p><strong>三角形内部的每一个点：</strong>利用<strong>重心坐标来插值</strong></p><p>重心坐标：给定的三角形ABC和其中的一个点P，其重心坐标$(w_a,w_b,w_c)$满足以下条件：</p><ul><li>$w_a+w_b+w_c=1$</li><li>$P=w_a⋅A+w_b⋅B+w_c⋅C$</li></ul><p>重心坐标可以通过面积的比值求出：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312010916393.png" alt="image-20231130134307989" style="zoom:50%;"></p><p>注：三角形的重心为（1/3，1/3，1/3），其将三角形分为了面积相等的三份。</p><p>重心坐标一般的表达式：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312010916494.png" alt="image-20231130134715691" style="zoom:50%;"></p><p>重心插值公式如下:</p><p>$P_{interpolated}=w_a⋅P_A+w_b⋅P_B+w_c⋅P_C$</p><p><em>注：$P_A、P_B、P_C$分别是三个顶点上的属性值</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953992.png" alt="image-20231130094402265" style="zoom:50%;"></p><p><em>注：重心坐标经过投影之后可能会改变，在三维空间中插值一些属性时，要计算三维空间中重心的坐标。</em></p><h4 id="2-3-Phong-Shading-像素着色"><a href="#2-3-Phong-Shading-像素着色" class="headerlink" title="2.3 Phong Shading(像素着色)"></a>2.3 Phong Shading(像素着色)</h4><p>要对每个点都进行光照计算，三角形内部的每一个点的法线向量如插值颜色一样得到：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953798.png" alt="image-20231130094638524" style="zoom:50%;"></p><p><em>注：$n_0,n_1,n_2$分别是三角形三个顶点的法线向量,α,β,γ为三角形面内点的重心坐标</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311300953475.png" alt="image-20231130094743068" style="zoom:50%;"></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SG-Former</title>
      <link href="/posts/c53f4cce.html"/>
      <url>/posts/c53f4cce.html</url>
      
        <content type="html"><![CDATA[<h2 id="SG-Former"><a href="#SG-Former" class="headerlink" title="SG-Former"></a>SG-Former</h2><p><strong>论文：《SG-Former: Self-guided Transformer with Evolving Token Reallocation》（ICCV 2023)</strong></p><h4 id="1-探究动机"><a href="#1-探究动机" class="headerlink" title="1.探究动机"></a>1.探究动机</h4><p>ViT使用全局的自注意力机制，但带来了较高的计算成本。</p><p>Swin Transformer设计了窗口注意力，而牺牲了建模全局信息的能力。</p><p><strong>提出SG-Fomer（Self-guided Transformer):</strong>利用<strong>显著性</strong>图，根据每个区域的显著性来分配token，将更多的token分配给显著性区域以获取细粒度的注意力，而将更少的token分配给次要的区域以换取计算效率和全局的感受野。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145871.png" alt="image-20231130202913356"></p><p><em>注：在显著性区域（狗脸）分配更多的token</em></p><h4 id="2-网络设计"><a href="#2-网络设计" class="headerlink" title="2.网络设计"></a>2.网络设计</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145135.png" alt="image-20231130203138889" style="zoom:80%;"></p><p><strong>Hybrid-Scale Transformer blocks:</strong>提取多尺度的信息并为Self-Guided Transformer Block提供显著性图</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145630.png" alt="image-20231129153810548" style="zoom: 67%;"></p><p>把H个注意力头分成h组，在第j组的注意力头有一个尺度因子<script type="math/tex">S_j</script>,即对于K,V的每<script type="math/tex">S_j*S_j</script>个token合并为一个token，把K、V的窗口大小设为M,Q的窗口大小设为<script type="math/tex">S_jM*S_jM</script>(使Q中token与K、V中的token对齐）</p><p><em>注：</em></p><p><em>（1）K,V的窗口大小在所有组中都是固定的，均为M,而Q的窗口大小还和$S_j$有关</em>，每一组的输出均为N*M,N为token序列的长度</p><p><em>（2）token的合并是通过卷积实现的</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145504.png" alt="image-20231130205331048" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145396.png" alt="image-20231130205438728" style="zoom: 67%;"></p><p>Token 的重要性被视为所有 Token 和当前 Token 的乘积之和：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145068.png" alt="image-20231129153230302" style="zoom: 67%;"></p><p><em>注：S是对所有的$S_i$求和的结果，即为最终的注意力图，用于混合尺度引导</em></p><p><strong>Self-Guided Transformer Block：</strong></p><p>为了降低计算成本，同时保持计算后特征映射的大小不变，固定Q的大小，使用IAM（importance guided aggregation module)对K和V的token进行聚合</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145350.png" alt="image-20231130211007377" style="zoom: 80%;"></p><p><em>注：S为显著性图，r为合并比率</em></p><p>将S平均分为n个子区域S1，S2,……Sn,每个区域设置不同的合并比率r1,r2,……，rn,子区域越重要，合并比率越小，输入特征X按X1,X2,……,Xn分组，每组有不同的合并比率</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311302145872.png" alt="image-20231130212526902" style="zoom: 67%;"></p><p><em>注：token的合并通过全连接层实现</em></p><h4 id="3-实验"><a href="#3-实验" class="headerlink" title="3.实验"></a>3.实验</h4><p>与其他结构在语义分割任务中的对比：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312010859765.png" alt="image-20231130215028355" style="zoom: 50%;"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/posts/38a918c7.html"/>
      <url>/posts/38a918c7.html</url>
      
        <content type="html"><![CDATA[<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>C++中的指针：</p><ul><li>原始指针</li><li>智能指针</li></ul><p>智能指针是原始指针的封装，其优点是会自动分配内存，不用担心潜在的内存泄露</p><p><em>注：智能指针只解决了独占/共享所有权指针的释放、传输，没有从根本上解决C++内存安全问题，不加以注意依然会造成内存安全问题</em></p><h3 id="2-独占指针：unique-ptr"><a href="#2-独占指针：unique-ptr" class="headerlink" title="2.独占指针：unique_ptr"></a>2.独占指针：unique_ptr</h3><p><strong>unique_ptr:</strong>在任何给定的时刻，只能有一个指针管理内存，当指针超出作用域时，内存将自动释放</p><p><em>注:该类型的指针不可Copy,只可以Move</em></p><p><strong>unique_ptr的三种创建方式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &quot;cat.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    // 1.栈</span><br><span class="line">    // 对象是在栈上创建的(而不是使用 new 操作符在堆上分配对象）,那么在对象的作用域结束时，其析构函数会被自动调用。</span><br><span class="line">    Cat c1(&quot;OK&quot;);</span><br><span class="line">    c1.cat_info();</span><br><span class="line">    &#123;</span><br><span class="line">        Cat c2(&quot;OK&quot;);</span><br><span class="line">        c2.cat_info();</span><br><span class="line">    &#125; // 在这个代码块结束时，c2 对象将被销毁，调用析构函数</span><br><span class="line"> </span><br><span class="line">    // 2.堆</span><br><span class="line">    //2.1 原始指针（不安全）</span><br><span class="line">    Cat *c_p1=new Cat(&quot;yy&quot;);</span><br><span class="line">    c_p1-&gt;cat_info();</span><br><span class="line">    &#123;</span><br><span class="line">        Cat *c_p1=new Cat(&quot;yy&quot;);</span><br><span class="line">        c_p1-&gt;cat_info();</span><br><span class="line">        delete c_p1;//原始指针不会自动调用析构函数，要使用delete方法</span><br><span class="line">    &#125;</span><br><span class="line">    delete c_p1;</span><br><span class="line">    // 2.2 智能指针</span><br><span class="line">    // 2.2.3 unique_pointer的三种创建方式</span><br><span class="line">    // 2.2.3.1 第一种方式</span><br><span class="line">    Cat *c_p2=new Cat(&quot;ok&quot;);</span><br><span class="line">    unique_ptr&lt;Cat&gt; u_c_p2&#123;c_p2&#125;;</span><br><span class="line">    c_p2=nullptr;//原始指针一般需要置空，否则其还能使用</span><br><span class="line">    u_c_p2-&gt;cat_info();</span><br><span class="line">    // 2.2.3.2 第二种方式</span><br><span class="line">    unique_ptr&lt;Cat&gt; u_c_p3&#123;new Cat(&quot;dd&quot;)&#125;;</span><br><span class="line">    u_c_p3-&gt;cat_info();</span><br><span class="line">    // 2.2.3.2 第三种方式（推荐）</span><br><span class="line">    unique_ptr&lt;Cat&gt; u_c_p4=make_unique&lt;Cat&gt;(&quot;ook&quot;);</span><br><span class="line">    u_c_p4-&gt;cat_info();</span><br><span class="line">    std::cout &lt;&lt; &quot;-----yz ------&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transformation</title>
      <link href="/posts/ac17f787.html"/>
      <url>/posts/ac17f787.html</url>
      
        <content type="html"><![CDATA[<h2 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h2><h3 id="1-2D变换"><a href="#1-2D变换" class="headerlink" title="1. 2D变换"></a>1. 2D变换</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207409.png" alt="image-20231126190707151" style="zoom:50%;"></p><h4 id="1-1-缩放-scaling"><a href="#1-1-缩放-scaling" class="headerlink" title="1.1 缩放(scaling)"></a>1.1 缩放(scaling)</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207653.png" alt="image-20231126190747793" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207767.png" alt="image-20231126190853847" style="zoom: 50%;"></p><h4 id="1-2-镜像变换"><a href="#1-2-镜像变换" class="headerlink" title="1.2 镜像变换"></a>1.2 镜像变换</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207557.png" alt="image-20231126191121990" style="zoom:50%;"></p><h4 id="1-3-切变（Shear-Matrix）"><a href="#1-3-切变（Shear-Matrix）" class="headerlink" title="1.3 切变（Shear Matrix）"></a>1.3 切变（Shear Matrix）</h4><p>如下图，变换过程中y坐标始终不变</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271207966.png" alt="image-20231126192230389" style="zoom:50%;"></p><h4 id="1-4-旋转-Rotate"><a href="#1-4-旋转-Rotate" class="headerlink" title="1.4 旋转(Rotate)"></a>1.4 旋转(Rotate)</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208542.png" alt="image-20231126192327264" style="zoom:50%;"></p><h4 id="1-5-齐次坐标"><a href="#1-5-齐次坐标" class="headerlink" title="1.5 齐次坐标"></a>1.5 齐次坐标</h4><p><strong>平移：</strong><br><img src="https://typoraimg.wangak.cc/2023/img/202311271208287.png" alt="image-20231126193641073" style="zoom:50%;"></p><p><strong>为了表示平移操作引入了第三维坐标：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208639.png" alt="image-20231126193653818" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208486.png" alt="image-20231126193714639" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208369.png" alt="image-20231126193731535" style="zoom:50%;"></p><p><em>注：<strong>point+point</strong>的结果为两个点的中点</em></p><p><strong>仿射变换的两种形式：</strong><br><img src="https://typoraimg.wangak.cc/2023/img/202311271208436.png" alt="image-20231126194003729" style="zoom:50%;"></p><p><em>注：齐次坐标变换矩阵中的a,b,c,d与线性变换中的变换矩阵是对应的</em></p><h4 id="1-6-逆变换"><a href="#1-6-逆变换" class="headerlink" title="1.6 逆变换"></a>1.6 逆变换</h4><p><strong>逆变换：</strong>变换矩阵为原变换的逆矩阵</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208337.png" alt="image-20231126194715152" style="zoom:50%;"></p><h3 id="2-3D变换"><a href="#2-3D变换" class="headerlink" title="2. 3D变换"></a>2. 3D变换</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208498.png" alt="image-20231126195736702" style="zoom:50%;"></p><h4 id="2-1-仿射变换"><a href="#2-1-仿射变换" class="headerlink" title="2.1 仿射变换"></a>2.1 仿射变换</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202311271208171.png" alt="image-20231126195828157" style="zoom:50%;"></p><p><em>注：该表示方法是先做线性变换，然后再平移</em></p><h4 id="2-2-旋转"><a href="#2-2-旋转" class="headerlink" title="2.2 旋转"></a>2.2 旋转</h4><ul><li><strong>在轴上</strong></li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033304.png" alt="image-20231127122527405" style="zoom:50%;"></p><ul><li><p><strong>一般的旋转</strong>：可以将任意的旋转分为在三个轴上的旋转，其中在三个轴上的旋转角度称为欧拉角</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033703.png" alt="image-20231127122758750" style="zoom:50%;"></p></li></ul><p>​    <strong>罗德里格斯公式(Rodrigues’ Rotation Formula):</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033828.png" alt="image-20231127123545604"></p><p>注：四元数的应用</p><h3 id="2-3-视图-相机变换（View-Camera-Transformation）"><a href="#2-3-视图-相机变换（View-Camera-Transformation）" class="headerlink" title="2.3 视图/相机变换（View / Camera Transformation）"></a>2.3 视图/相机变换（View / Camera Transformation）</h3><p><strong>相机的参数：</strong>初始位置、观看角度（向量）、竖直角度（向量）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033677.png" alt="image-20231127125538822"></p><p><strong>标准化：</strong>观看位置为原点、观看角度为-Z、向上方向为Y</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033142.png" alt="image-20231127125835234" style="zoom:50%;"></p><p>变换的方法：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033832.png" alt="image-20231127125907343" style="zoom:50%;"></p><p>由于正向变换比较复杂，考虑<strong>通过其逆矩阵来实现</strong>：R为旋转变换矩阵、T为平移变换矩阵、M为整个过程的变换矩阵</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033482.png" alt="image-20231127130030303" style="zoom:50%;"></p><p><em>注：旋转矩阵为正交矩阵，逆矩阵即是其转置</em></p><p><em>注：视图变换变换的是相机，其他的物体随着相机一起变换</em></p><h3 id="3-投影变换"><a href="#3-投影变换" class="headerlink" title="3 投影变换"></a>3 投影变换</h3><h4 id="3-1-正交投影变换"><a href="#3-1-正交投影变换" class="headerlink" title="3.1 正交投影变换"></a>3.1 正交投影变换</h4><p><strong>正交投影变换：</strong>平移+压缩</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033623.png" alt="image-20231127131958838" style="zoom:50%;"></p><p><em>注：l,r为x轴上的距离，b,t为y轴上的距离</em></p><h4 id="3-2-透视投影变换"><a href="#3-2-透视投影变换" class="headerlink" title="3.2 透视投影变换"></a>3.2 透视投影变换</h4><p>透视投影类似人眼所看东西的方式，遵循近大远小,平行线也会变得不平行</p><p><strong>用正交变换表示透视投影变换：</strong><script type="math/tex">M_{ortho}M_{persp->ortho}</script></p><p>将透视变换压成投影<script type="math/tex">M_{persp->ortho}</script></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033023.png" alt="image-20231127212210693" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033371.png" alt="image-20231127212333846" style="zoom:50%;"></p><p><em>注：其中n是近平面，f是远平面，在公式推导的过程中是<strong>默认n、f</strong>均为负数</em></p><p>因而透视投影矩阵为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311301248538.png" alt="image-20231130123159569" style="zoom: 67%;"></p><p>又当投影接口的参数是张角fov，横纵比为aspect，近平面到原点的距离为near,远平面到原点的距离为far</p><p>由于长方体视窗体是轴对称，故有l=−r,b=−t,从原点看向−z方向看去，有n=−near,f=−far<br>                                                                    <img src="https://typoraimg.wangak.cc/2023/img/202311301247698.png" alt="image-20231130124140613" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311301248703.png" alt="image-20231130124220304" style="zoom:67%;"></p><p>所以透视投影矩阵可化简为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311301248469.png" alt="image-20231130124301880" style="zoom: 67%;"></p><h3 id="4-视口变换"><a href="#4-视口变换" class="headerlink" title="4.视口变换"></a>4.视口变换</h3><p><strong>视口变换</strong>用于将标准平面映射到屏幕的分辨率范围之内（缩放+平移），变换矩阵如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033944.png" alt="image-20231128150643474" style="zoom:50%;"></p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>将虚拟世界中以(x,y,z)为坐标的物体变换到以一个个像素位置(x,y) 来表示的屏幕坐标系之中(2维)的步骤：</p><ul><li><strong>模型变换(modeling tranformation)：</strong>这一步的目的是将虚拟世界中或者更具体点，游戏场景中的物体调整至他们应该在的位置</li><li><strong>摄像机变换(camera tranformation)：</strong>在游戏中我们真正在乎的是摄像机(或者说眼睛)所看到的东西，也就是需要得到物体与摄像机的相对位置</li><li><strong>投影变换(projection tranformation)：</strong>根据摄像机变换得到了所有可视范围内的物体对于摄像机的相对位置坐标(x,y,z)之后，便是根据是平行投影还是透视投影，将三维空间投影至标准二维平面([-1,1]^2)之上 （tips：这里的z并没有丢掉，为了之后的遮挡关系检测）</li><li><strong>视口变换(viewport transformation)：</strong>将处于标准平面映射到屏幕分辨率范围之内，即[-1,1]^2→[0,width]*[0,height], 其中width和height指屏幕分辨率大小</li></ul>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光栅化及深度测试</title>
      <link href="/posts/499d8707.html"/>
      <url>/posts/499d8707.html</url>
      
        <content type="html"><![CDATA[<h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p><strong>光栅化（Rasterization）</strong>是图形学中一种常用的渲染技术，用于将三维场景中的图形对象转换为二维像素表示，以便在计算机屏幕上显示，即将图形对象（通常是三角形）映射到屏幕上的像素格子，并确定每个像素的颜色值。</p><p><strong>选择三角形作为渲染的基本图元的原因：</strong></p><ul><li>因为三角形是最简单的几何形状之一，任意三个点可以确定一个平面上的三角形</li><li><p>任意多边形都可以被分解为若干个三角形，这种分解使得处理复杂的多边形图形变得更加容易。</p></li><li><p>三角形在仿射变换下保持平面性，对三角形的变换相对简单，而不会引入复杂的扭曲。</p></li></ul><h3 id="1-直线光栅化算法"><a href="#1-直线光栅化算法" class="headerlink" title="1.直线光栅化算法"></a>1.直线光栅化算法</h3><h4 id="1-1-DDA数值微分算法"><a href="#1-1-DDA数值微分算法" class="headerlink" title="1.1 DDA数值微分算法"></a>1.1 DDA数值微分算法</h4><p>通过两点确定一条直线的斜率（k)，若|k|&lt;=1,选择x方向作为步长（选择变换快的方向），若|k|&gt;1,选择y方向作为步长。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282033642.png" alt="image-20231128195221236" style="zoom:50%;"></p><p>注：在所选的步长方向上，从起始点 <code>(x0, y0)</code> 开始，计算每个下一个点的坐标 <code>(xi, yi)</code>。对于x方向的步长，使用 <code>xi+1 = xi + 1</code>；对于 y 方向的步长，使用 <code>yi+1 = yi + m</code>。(y的结果要四舍五入)</p><h4 id="1-2-Bresenham直线绘制算法"><a href="#1-2-Bresenham直线绘制算法" class="headerlink" title="1.2 Bresenham直线绘制算法"></a>1.2 Bresenham直线绘制算法</h4><p>Bresenham直线绘制算法通过在每个步骤中选择最接近理想路径上的点来逐步绘制线段，从而避免了使用浮点数运算，提高了计算效率。</p><p><strong>pass</strong></p><h3 id="2-三角形光栅化算法"><a href="#2-三角形光栅化算法" class="headerlink" title="2.三角形光栅化算法"></a>2.三角形光栅化算法</h3><p><strong>每一个像素进行采样:</strong>判断像素中心是否在三角形内部</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034020.png" alt="image-20231128200407428" style="zoom: 50%;"></p><p><strong>判断一个点在三角形内部的方法：</strong>利用叉乘的性质</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034363.png" alt="image-20231128200536862" style="zoom:50%;"></p><p>​        分别计算 $P_0P_1×P_0Q、 P_1P_2×P_1Q、P_2P_0×P_2Q$，如果三者同号则代表点P在三条线段的同一边，那么必然处于三角形内部，如果不同号则代表该点一定在三角形外部<br><strong>利用bouding box减少点的计算：</strong>三角形通常只占屏幕很小的一部分，只对该bounding box内的点进行采样测试</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034364.png" alt="image-20231128201223186" style="zoom:50%;"></p><p><strong>锯齿现象：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034128.png" alt="image-20231128201443202" style="zoom:50%;"></p><p>产生的原因：只用了有限的采样点去逼近连续的三角形</p><h3 id="3-解决走样的方法"><a href="#3-解决走样的方法" class="headerlink" title="3.解决走样的方法"></a>3.解决走样的方法</h3><h4 id="3-1超采样反走样-Super-Sampling-AA"><a href="#3-1超采样反走样-Super-Sampling-AA" class="headerlink" title="3.1超采样反走样(Super Sampling AA)"></a>3.1超采样反走样(Super Sampling AA)</h4><p>用更多的采样点去逼近连续的三角形</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034872.png" alt="image-20231128201847832" style="zoom:50%;"></p><p>对着四个采样点分别计算颜色值，将这四个点的采样点的颜色值取均值，如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034448.png" alt="image-20231128202001340" style="zoom:50%;"></p><p><em>注：超采样的缺点是对计算资源的更高要求</em></p><h4 id="3-2多采样反走样-Multi-Sampling-AA"><a href="#3-2多采样反走样-Multi-Sampling-AA" class="headerlink" title="3.2多采样反走样(Multi-Sampling AA)"></a>3.2多采样反走样(Multi-Sampling AA)</h4><p>MSAA是对SSAA的改进，不再为每个采样点都计算颜色值，而只计算像素中采样点被覆盖的比例，而后在中心点处计算颜色值。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034470.png" alt="image-20231128202605057" style="zoom:50%;"></p><h4 id="3-3-先模糊（滤波），再采样"><a href="#3-3-先模糊（滤波），再采样" class="headerlink" title="3.3 先模糊（滤波），再采样"></a>3.3 先模糊（滤波），再采样</h4><p>通过在采样前进行滤波，可以去除信号中的高频分量，从而在采样时避免混叠效应，减少走样。</p><p>在频域中限制高频成分的影响，有助于避免走样问题</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311282034171.png" alt="image-20231128203246227" style="zoom:50%;"></p><h3 id="4-深度测试"><a href="#4-深度测试" class="headerlink" title="4.深度测试"></a>4.深度测试</h3><p>深度测试是指在渲染图像时确定像素的深度值（或称为Z值）以确定哪些像素应该显示在屏幕上。</p><p><em>注：深度测试是一种解决图形学中遮挡关系的技术，确保在屏幕上只显示最前面的像素，而将被遮挡的像素隐藏起来，从而呈现出正确的三维场景。</em></p><h4 id="Z-Buffer（深度缓冲）算法"><a href="#Z-Buffer（深度缓冲）算法" class="headerlink" title="Z-Buffer（深度缓冲）算法"></a>Z-Buffer（深度缓冲）算法</h4><p><strong>算法的基本思想：</strong>每个采样点（像素）存储当前的最小深度值，假设深度值（z值）始终为正值。如果一个像素的深度值较小，表示它离观察者更近；反之，如果深度值较大，则表示它离观察者更远。<strong>帧缓冲用于存储屏幕上每个像素的颜色信息，深度缓冲专门用于存储每个像素的深度值</strong>，如果当前像素的深度值较小（即更接近观察者），则更新深度缓冲和帧缓冲中的值；否则，将其视为被遮挡，不进行更新。</p><p>伪代码如下:</p><p><img src="https://typoraimg.wangak.cc/2023/img/202312011217448.png" alt="image-20231130085326419" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202312011217183.png" alt="image-20231130085351796" style="zoom:50%;"></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPM</title>
      <link href="/posts/236d2982.html"/>
      <url>/posts/236d2982.html</url>
      
        <content type="html"><![CDATA[<h2 id="SPM"><a href="#SPM" class="headerlink" title="SPM"></a>SPM</h2><p><strong>论文：《Learning with Explicit Shape Priors for Medical Image Segmentation》（TMI 2023)</strong></p><p><strong>探索形状先验(shape priors)对分割性能的影响</strong></p><p>基于unet的医学图像分割模型的局限性:cnn的感受野有限，无法利用器官或组织之间的远距离和全局空间关系，无法实现精细的形状表示。（注意力模块扩大模型的感受野，隐式地捕获形状信息）</p><p><em>注：通过设计特定的损失函数，而不是Dice损失或交叉熵损失，将明确的形状先验集成到分割框架中。但这些损失函数是特定于任务的，不能很容易地扩展到不同的数据集</em></p><p>提出了显式形状模型（SPM），以形状先验作为额外的输入来增强模型的形状表示能力。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436431.png" alt="image-20231120152537182" style="zoom:67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436712.png" alt="image-20231120163304452" style="zoom:67%;"></p><p>其中F代表模型的前向传播，S代表构造图像I和标签L之间映射的形状先验。</p><p><strong>注意力图：</strong>生成的形状先验在推断阶段充当了注意力图，用于定位感兴趣的区域，并抑制背景区域</p><p><strong>SPM模块：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436670.png" alt="image-20231120153357914" style="zoom:67%;"></p><p>SPM模块由the self-update block (SUB)、cross-update block (CUB)</p><p><strong>the self-update block (SUB)：</strong>以形状先验作为输入，用于生成全局形状先验</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436041.png" alt="image-20231120154358605" style="zoom:50%;"></p><p>SUB的结构缺乏对局部视觉结构的建模，全局形状先验不具有精确的形状和轮廓信息。</p><p><strong>cross-update block (CUB)：</strong>建模局部形状先验</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436616.png" alt="image-20231120160130787" style="zoom: 50%;"></p><p><script type="math/tex">C_{map}</script>:一个C × N矩阵,用于评估C通道特征映射Fo和N通道形状先验之间的关系。</p><p>下采样<script type="math/tex">F_e</script>生成局部形状先验<script type="math/tex">S_L</script>:</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436429.png" alt="image-20231120160808202" style="zoom:50%;"></p><p>增强的形状先验融合了SUB生成全局形状先验及CUB生成的局部形状先验</p><h3 id="实验部分："><a href="#实验部分：" class="headerlink" title="实验部分："></a>实验部分：</h3><p><strong>与其他方法的对比：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436022.png" alt="image-20231120202559717" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436614.png" alt="image-20231120202723390" style="zoom: 67%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436085.png" alt="image-20231120202732327" style="zoom: 67%;"></p><p><strong>消融实验：</strong>在BRATS 2020（脑肿瘤）、<strong>VerSe2019</strong>(脊柱)、ACDC（心脏）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311271436828.png" alt="image-20231120201045294" style="zoom: 80%;"></p><p>表明SPM有增强模型对相对规则的形状区域的表示能力</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MedNeXt</title>
      <link href="/posts/9ce6c01f.html"/>
      <url>/posts/9ce6c01f.html</url>
      
        <content type="html"><![CDATA[<h2 id="MedNeXt-Transformer-driven-Scaling-of-ConvNets-for-Medical-Image-Segmentation"><a href="#MedNeXt-Transformer-driven-Scaling-of-ConvNets-for-Medical-Image-Segmentation" class="headerlink" title="MedNeXt: Transformer-driven Scaling of ConvNets for Medical Image Segmentation"></a>MedNeXt: Transformer-driven Scaling of ConvNets for Medical Image Segmentation</h2><p><strong>论文：《MedNeXt: Transformer-driven Scaling of ConvNets for Medical Image Segmentation》(MICCAI 2023)</strong></p><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311130851990.png" alt="image-20231108195751803"></p><p><strong>MedNeXt Block:</strong></p><ul><li><p>深度卷积层（DW）：k × k × k的深度卷积，归一化使用channel-wise GroupNorm</p></li><li><p>Expansion Layer:较大的 R 值允许网络在宽度方向上扩展，而 1×1×1 核限制了计算量</p></li><li><p>Compression Layer:1×1×1卷积层对输出通道进行压缩</p></li></ul><p><strong>MedNeXt Down Block和MedNeXt Up Block：</strong></p><ul><li>添加了一个残差连接1×1×1卷积或转置卷积，步幅为2</li></ul><p>​    解码器层使用<strong>深度监督</strong>，在较低分辨率下具有较低的损失权值（深度监督：在网络的中间部分添加了额外的loss，不同位置的loss按系数求和。深度监督的目的是为了浅层能够得到更加充分的训练，解决深度神经网络训练梯度消失和收敛速度过慢等问题。）</p><p><strong>UpKern 初始化：</strong></p><p>大卷积核的缺陷：大卷积核性能可能更容易达到一个瓶颈，无法再进一步提高。(大卷积核模型有更多的参数，因此更容易过拟合训练数据)</p><p>医学图像分割任务的数据少之又少，性能更容易饱和。</p><p>为了帮助大卷积核网络在医学图像分割等任务中更好地利用有限数据，从而改善性能。</p><p>对预训练小核网络进行三线性上采样来初始化大核网络，从而<strong>迭代地增加核大小</strong>。其他的大小相同的层（包括归一化层）都通过直接复制预训练层的权重来初始化。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311130851317.png" alt="image-20231108204926791" style="zoom:67%;"></p><p><strong>MedNeXt四种配置及消融实验：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311130851800.png" alt="image-20231108211021855"></p><p>通道数（C)均设置为32</p><ul><li>在重采样时保留了特征映射中的语义丰富性</li><li>没有UpKern的大内核和小内核的性能是没有区别的</li><li>大卷积核中的性能提升是由于UpKern与大卷积核的结合，而不仅仅是更长的训练</li></ul><h3 id="2-实验结果"><a href="#2-实验结果" class="headerlink" title="2.实验结果"></a>2.实验结果</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311130851293.png" alt="image-20231108214400563"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++编程出现的错误及解决</title>
      <link href="/posts/f3261b08.html"/>
      <url>/posts/f3261b08.html</url>
      
        <content type="html"><![CDATA[<h2 id="C-编程出现的错误及解决"><a href="#C-编程出现的错误及解决" class="headerlink" title="C++编程出现的错误及解决"></a>C++编程出现的错误及解决</h2><h3 id="1-Undefined-reference"><a href="#1-Undefined-reference" class="headerlink" title="1.Undefined reference"></a>1.Undefined reference</h3><p><strong>1.1目标文件未正确链接:</strong></p><p><strong>原因：</strong>有多个源文件，会独立编译它们,会导致对象没有正确链</p><p><strong>解决方法：同时编译这两个文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ cat.cpp test.cpp -o test//同时编译cat.cpp和test.cpp，并生成可执行文件test</span><br><span class="line">./test  //运行test.exe</span><br></pre></td></tr></table></figure><p>注：有多个源文件时使用如下指令进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ *.cpp -o main</span><br><span class="line">./main</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3D UX-NET</title>
      <link href="/posts/eabf9f8.html"/>
      <url>/posts/eabf9f8.html</url>
      
        <content type="html"><![CDATA[<h2 id="3D-UX-NET"><a href="#3D-UX-NET" class="headerlink" title="3D UX-NET"></a>3D UX-NET</h2><p><strong>论文：《3D UX-NET: A LARGE KERNEL VOLUMETRIC CONVNET MODERNIZING HIERARCHICAL TRANSFORMER</strong><br><strong>FOR MEDICAL IMAGE SEGMENTATION》（ICLR 2023）</strong></p><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115336.png" alt="image-20231106201433865"></p><p>采用具备大卷积核的投影层来提取 patch-wise 特征作为编码器的输入</p><p><strong>对Swin transformer的transformer block做了替换：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115856.png" alt="image-20231106202256333" style="zoom:67%;"></p><p>使用大卷积核(7 × 7 × 7)的深度卷积来模仿Swin Transformer的局部自注意力和窗口移动。</p><p>使用2 × 2 × 2、步幅为2的标准卷积块来实现下采样</p><p>在Swin Transformer中MLP隐藏层维度比输入维度宽四倍，引入了具有 1 × 1 × 1 卷积核大小的深度卷积缩放(DCS)，以独立地线性缩放每个通道特征，减少跨通道上下文产生的冗余信息</p><p>DCS：1x1x1的深度卷积+1x1x1的分组卷积</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115037.png" alt="image-20231106205655475" style="zoom:67%;"></p><p>从实验中发现：使用深度卷积缩放(DCS)参数量得到了减小，效果并没有下降</p><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115199.png" alt="image-20231106204002121"></p><p>编码器的输出特征由残差块作进一步的处理，以稳定提取的特征。（残差块由两个经过实例归一化的后归一化3 × 3 × 3卷积层组成）</p><p>转置卷积层实现上采样，其输出的特征与编码器的输出进行连接后，再次输入到残差块中。</p><h3 id="2-实验结果"><a href="#2-实验结果" class="headerlink" title="2.实验结果"></a>2.实验结果</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115341.png" alt="image-20231106210428239"></p><p>3D UX-Net 在这几个分割任务中均展示出最佳性能，并且 Dice 分数有了一定的提高</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nnUNet v2模型训练</title>
      <link href="/posts/4a35a285.html"/>
      <url>/posts/4a35a285.html</url>
      
        <content type="html"><![CDATA[<h2 id="nnUNet-v2模型训练"><a href="#nnUNet-v2模型训练" class="headerlink" title="nnUNet v2模型训练"></a>nnUNet v2模型训练</h2><h3 id="1-数据集处理"><a href="#1-数据集处理" class="headerlink" title="1.数据集处理"></a>1.数据集处理</h3><p><strong>nnUnet要求rgb-png格式的数据</strong>，故将原数据集由单通道堆叠成三通道的RGB图像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line">import os</span><br><span class="line">def gray_to_rgb(image_gray):</span><br><span class="line">    # 创建一个全零的三通道图像</span><br><span class="line">    height, width = image_gray.shape</span><br><span class="line">    image_rgb = np.zeros((height, width, 3), dtype=np.uint8)</span><br><span class="line">    # 将灰度图像的值复制到红通道</span><br><span class="line">    image_rgb[:, :, 2] = image_gray</span><br><span class="line">    image_rgb[:, :, 1] = image_gray</span><br><span class="line">    image_rgb[:, :, 0] = image_gray</span><br><span class="line">    return image_rgb</span><br><span class="line"># 设置目标文件夹路径</span><br><span class="line"> # 包含灰度PNG图像的文件夹路径</span><br><span class="line">output_folder = # 用于保存RGB图像的文件夹路径</span><br><span class="line">root_folder=</span><br><span class="line"># 创建输出文件夹（如果不存在）</span><br><span class="line">if not os.path.exists(output_folder):</span><br><span class="line">    os.makedirs(output_folder)</span><br><span class="line">for root, dirs, files in os.walk(root_folder):</span><br><span class="line">    # 遍历目标文件夹中的所有图像文件</span><br><span class="line">    if root == root_folder:</span><br><span class="line">        for dir_name in dirs:</span><br><span class="line">            input_folder = os.path.join(root, dir_name, dir_name + &quot;_label&quot;)</span><br><span class="line">            print(input_folder)</span><br><span class="line">            for filename in os.listdir(input_folder):</span><br><span class="line">                if filename.endswith(&#x27;.png&#x27;):</span><br><span class="line">                    # 构造图像文件的完整输入路径</span><br><span class="line">                    input_image_path = os.path.join(input_folder, filename)</span><br><span class="line">                    # 读取灰度图像</span><br><span class="line">                    image_gray = cv2.imread(input_image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">                    if image_gray is not None:</span><br><span class="line">                        # 转换为RGB图像</span><br><span class="line">                        image_rgb = gray_to_rgb(image_gray)</span><br><span class="line">                        # 构造保存的RGB图像文件名（输出路径）</span><br><span class="line">                        output_image_path = os.path.join(output_folder, filename.replace(&#x27;.png&#x27;, &#x27;_rgb.png&#x27;))</span><br><span class="line">                        # 保存RGB图像到指定输出路径</span><br><span class="line">                        cv2.imwrite(output_image_path, image_rgb)</span><br><span class="line">            print(&quot;Conversion completed.&quot;)</span><br></pre></td></tr></table></figure><p><strong>原先数据集的格式要求：</strong></p><ul><li><strong>train</strong><ul><li><strong>images</strong></li><li><strong>labels</strong></li></ul></li><li><strong>test</strong><ul><li><strong>images</strong></li><li><strong>labels</strong></li></ul></li></ul><p><strong>将数据集转化为nnUnet标准格式，改写nnUNet/nnunetv2/dataset_conversion/Dataset120_RoadSegmentation.py</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # extracted archive from https://www.kaggle.com/datasets/insaff/massachusetts-roads-dataset?resource=download</span><br><span class="line">    source = &#x27;/root/autodl-tmp/nnUNet/Coronary&#x27;</span><br><span class="line">    print(source)</span><br><span class="line">    dataset_name = &#x27;Dataset150_Segmentation&#x27;</span><br><span class="line">    nnUNet_raw = &#x27;/root/autodl-tmp/nnUNet/dataset/nnUNet_raw&#x27;</span><br><span class="line">    imagestr = join(nnUNet_raw, dataset_name, &#x27;imagesTr&#x27;)</span><br><span class="line">    imagests = join(nnUNet_raw, dataset_name, &#x27;imagesTs&#x27;)</span><br><span class="line">    labelstr = join(nnUNet_raw, dataset_name, &#x27;labelsTr&#x27;)</span><br><span class="line">    labelsts = join(nnUNet_raw, dataset_name, &#x27;labelsTs&#x27;)</span><br><span class="line">   </span><br><span class="line">    maybe_mkdir_p(imagestr)</span><br><span class="line">    maybe_mkdir_p(imagests)</span><br><span class="line">    maybe_mkdir_p(labelstr)</span><br><span class="line">    maybe_mkdir_p(labelsts)</span><br><span class="line"></span><br><span class="line">    train_source = join(source, &#x27;train&#x27;)</span><br><span class="line">    test_source = join(source, &#x27;test&#x27;)</span><br><span class="line"></span><br><span class="line">    with multiprocessing.get_context(&quot;spawn&quot;).Pool(8) as p:</span><br><span class="line"></span><br><span class="line">        # not all training images have a segmentation</span><br><span class="line">        valid_ids = subfiles(join(train_source, &#x27;labels&#x27;), join=False, suffix=&#x27;png&#x27;)</span><br><span class="line">        num_train = len(valid_ids)</span><br><span class="line">        r = []</span><br><span class="line">        for v in valid_ids:</span><br><span class="line">            r.append(</span><br><span class="line">                p.starmap_async(</span><br><span class="line">                    load_and_covnert_case,</span><br><span class="line">                    ((</span><br><span class="line">                         join(train_source, &#x27;images&#x27;, v),</span><br><span class="line">                         join(train_source, &#x27;labels&#x27;, v),</span><br><span class="line">                         join(imagestr, v[:-4] + &#x27;_0000.png&#x27;),</span><br><span class="line">                         join(labelstr, v),</span><br><span class="line">                         50</span><br><span class="line">                     ),)</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        # test set</span><br><span class="line">        valid_ids = subfiles(join(test_source, &#x27;labels&#x27;), join=False, suffix=&#x27;png&#x27;)</span><br><span class="line">        for v in valid_ids:</span><br><span class="line">            r.append(</span><br><span class="line">                p.starmap_async(</span><br><span class="line">                    load_and_covnert_case,</span><br><span class="line">                    ((</span><br><span class="line">                         join(test_source, &#x27;images&#x27;, v),</span><br><span class="line">                         join(test_source, &#x27;labels&#x27;, v),</span><br><span class="line">                         join(imagests, v[:-4] + &#x27;_0000.png&#x27;),</span><br><span class="line">                         join(labelsts, v),</span><br><span class="line">                         50</span><br><span class="line">                     ),)</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        _ = [i.get() for i in r]</span><br><span class="line"></span><br><span class="line">    generate_dataset_json(join(nnUNet_raw, dataset_name), &#123;0: &#x27;R&#x27;, 1: &#x27;G&#x27;, 2: &#x27;B&#x27;&#125;, &#123;&#x27;background&#x27;: 0, &#x27;coronary&#x27;: 1&#125;,</span><br><span class="line">                          num_train, &#x27;.png&#x27;, dataset_name=dataset_name)</span><br></pre></td></tr></table></figure><p><strong>生成的数据集：</strong></p><ul><li>数据集名称<ul><li>imagesTr</li><li>imagesTs</li><li>labelsTr</li><li>labelsTs</li><li>dataset.json</li></ul></li></ul><p><strong>添加环境变量：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export nnUNet_raw=&quot;/root/autodl-tmp/nnUNet/dataset/nnUNet_raw&quot;</span><br><span class="line">export nnUNet_preprocessed=&quot;/root/autodl-tmp/nnUNet/dataset/nnUNet_preprocessed&quot;</span><br><span class="line">export nnUNet_results=&quot;/root/autodl-tmp/nnUNet/dataset/nnUnet_results&quot;</span><br></pre></td></tr></table></figure><p><strong>预处理数据集：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNetv2_plan_and_preprocess -d 150 --verify_dataset_integrity #150为任务id</span><br></pre></td></tr></table></figure><h3 id="2-模型训练"><a href="#2-模型训练" class="headerlink" title="2.模型训练"></a>2.模型训练</h3><p><strong>开始训练：</strong></p><p><code>nnUNetv2_train CONFIGURATION TRAINER_CLASS_NAME TASK_NAME_OR_ID FOLD (additional options)</code></p><ul><li><code>CONFIGURATION：</code> 模型架构，三种Unet: 2D U-Net, 3D U-Net and a U-Net Cascade(U-Net级联)。</li><li><code>TASK_NAME_OR_ID：</code> 任务全名TaskXXX_MYTASK或者是ID号</li><li><code>FOLD：</code> 第几折交叉验证，可选 [0, 1, 2, 3, 4]，一共五折。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNetv2_train 666 2d 4</span><br></pre></td></tr></table></figure><p><strong>loss曲线：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202311062115385.png" alt="image-20231106164804089" style="zoom: 67%;"></p><h3 id="3-模型测试"><a href="#3-模型测试" class="headerlink" title="3.模型测试"></a>3.模型测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNetv2_predict -i “测试集路径” -o “输出路径” -chk checkpoint_best.pth -c 2d -f 4 -d 150 --save_probabilities</span><br></pre></td></tr></table></figure><p>将二值掩码转换为0或255</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def process_images_in_folder(input_folder, output_folder):</span><br><span class="line">    for root, dirs, files in os.walk(input_folder):</span><br><span class="line">        for file in files:</span><br><span class="line">            if file.endswith(&quot;.png&quot;):</span><br><span class="line">                input_image_path = os.path.join(root, file)</span><br><span class="line">                output_image_path = os.path.join(output_folder, file)</span><br><span class="line"></span><br><span class="line">                # 打开输入图像</span><br><span class="line">                image = Image.open(input_image_path)</span><br><span class="line"></span><br><span class="line">                # 将像素值为1的通道变为255</span><br><span class="line">                image = image.convert(&quot;RGB&quot;)</span><br><span class="line">                data = image.getdata()</span><br><span class="line">                new_data = [(r, g, b) if r != 1 and g != 1 and b != 1 else (255, 255, 255) for (r, g, b) in data]</span><br><span class="line">                image.putdata(new_data)</span><br><span class="line"></span><br><span class="line">                # 保存修改后的图像</span><br><span class="line">                image.save(output_image_path)</span><br><span class="line"></span><br><span class="line"># 指定输入文件夹和输出文件夹的路径</span><br><span class="line">input_folder_path = &quot;&quot;</span><br><span class="line">output_folder_path = &quot;&quot;</span><br><span class="line"></span><br><span class="line">if not os.path.exists(output_folder_path):</span><br><span class="line">    os.makedirs(output_folder_path)</span><br><span class="line"></span><br><span class="line">process_images_in_folder(input_folder_path, output_folder_path)</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202311062116900.png" alt="image-20231106200912078"></p><p><strong>评价指标：</strong></p><p><strong>HD95: 5.20</strong></p><p><strong>Average Dice: 0.8144</strong></p>]]></content>
      
      
      <categories>
          
          <category> 模型训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模型训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像分割常用指标</title>
      <link href="/posts/70fa35a7.html"/>
      <url>/posts/70fa35a7.html</url>
      
        <content type="html"><![CDATA[<h3 id="图像分割常用指标"><a href="#图像分割常用指标" class="headerlink" title="图像分割常用指标"></a>图像分割常用指标</h3><h4 id="1-DSC（Dice相似系数）"><a href="#1-DSC（Dice相似系数）" class="headerlink" title="1.DSC（Dice相似系数）"></a>1.DSC（Dice相似系数）</h4><p><strong>DSC：用于衡量区域的重合程度</strong></p><p><strong>计算公式：</strong></p><script type="math/tex; mode=display">DSC = (2 * |A ∩ B|) / (|A| + |B|)</script><p>其中，A为算法生成的分割结果的像素集合，B为参考分割结果的像素集合</p><ul><li><p>DSC值范围在0到1之间，其中0表示完全不相似，1表示完全相似。</p></li><li><p>DSC值越接近1，表示算法生成的分割结果与参考分割结果越相似</p></li></ul><p><em>注：Dice相似系数仅考虑了像素的重叠情况，而没有考虑像素之间的空间关系，在存在模糊边界的分割任务中,Dice系数可能无法准确评估模型的性能。</em></p><h4 id="2-HD-豪斯多夫距离"><a href="#2-HD-豪斯多夫距离" class="headerlink" title="2.HD(豪斯多夫距离)"></a>2.HD(豪斯多夫距离)</h4><p><strong>HD:表示预测分割区域边界与真实区域边界之间的最大距离，其值越小代表预测边界分割误差越小、质量越好。</strong></p><p><strong>计算公式：</strong></p><p><img src="/posts/70fa35a7.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20231102100120629.png" alt="image-20231102100120629" style="zoom:67%;"></p><p><img src="/posts/70fa35a7.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20231102100057838.png" alt="image-20231102100057838" style="zoom:67%;"></p><p><strong>计算步骤：</strong></p><p>​    (1)对点集X中的每一个点x计算其到点集Y中的每一个点y的距离，保留最短距离，然后找出保留的最短距离中的最大距离记为Dxy。</p><p>​    (2)对点集Y中的每一个点y计算其到点集X中的每一个点x的距离，保留最短距离，然后找出保留最短距离中的最大距离记为Dyx。</p><p>​    (3)取Dxy和Dyx最大值作为点集X和Y之间的豪斯多夫距离。</p><p><strong>HD95(95％ 豪斯多夫距离):</strong></p><p>为了排除一些离群点造成的不合理距离，保持整体数值稳定性，一般选择从小到大排名前 95%的距离作为实际豪斯多夫距离，称之为 95% 豪斯多夫距离。</p><p><strong>注：Dice相似系数主要关注分割结果的整体准确性，HD95则更侧重于考虑分割边界的精确性</strong></p><p><strong>注： 豪斯多夫距离目标是捕捉两个集合之间的最大不一致，对于孤立的离群点或噪声非常敏感，不适用于噪声较多的图像。</strong></p><h4 id="3-ASD（平均表面距离）"><a href="#3-ASD（平均表面距离）" class="headerlink" title="3.ASD（平均表面距离）"></a>3.ASD（平均表面距离）</h4><p>平均表面距离：用来测量分割结果中的边界与真实标签中的边界之间的距离。</p><p><strong>计算分割结果中的每个像素与真实标签中的最近像素之间的距离，然后取平均值。</strong></p><p><img src="/posts/70fa35a7.htm/Users\wangak\AppData\Roaming\Typora\typora-user-images\image-20231102102746435.png" alt="image-20231102102746435" style="zoom: 50%;"></p><p><strong>ASSD(平均对称表面距离):</strong></p><p>​                                                            <script type="math/tex">\large ASSD(X,Y)={ASD(X,Y)+ASD(Y,X)}/2</script></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nnFormer</title>
      <link href="/posts/9e11ec23.html"/>
      <url>/posts/9e11ec23.html</url>
      
        <content type="html"><![CDATA[<h2 id="nnFormer"><a href="#nnFormer" class="headerlink" title="nnFormer"></a>nnFormer</h2><p><strong>论文：《nnFormer: Volumetric Medical Image Segmentation via a 3D Transformer》（TMI2022）</strong></p><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310252011844.png" alt="image-20231025201100423" style="zoom: 80%;"></p><h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h4><p><strong>nnFormer的输入：</strong>对原始图像中随机裁剪（HxWxD)，数据增强技术，有助于模型更好地学习不同部分的特征。</p><p><strong>The embedding layer:</strong>（将输入数据转换成高维张量）</p><ul><li><strong>使用卷积的好处：</strong>对比transformer使用线性层对patch的向量进行映射，卷积层能够更细致地捕获图像中的像素级信息（减少了训练的参数数量，卷积核在处理特定区域时更加专注）</li><li><strong>在初始阶段使用小卷积核的连续卷积层，相对于大卷积核的好处：</strong>降低计算复杂度,同时保持相同大小的感受野(非线性激活函数多了，语义表达能力增强了)</li></ul><p><img src="https://typoraimg.wangak.cc/2023/img/202310252109346.png" alt="image-20231025210627610"></p><p><em>注：根据输入的patch大小卷积步长也会有相应的变化</em></p><p><strong>Local Volume-based Multi-head Self-attention (LV-MSA)：</strong>将不同尺度的信息和高分辨率的空间信息相互关联</p><p>不同尺度的特征由下采样层生成，高分辨率的空间信息则由嵌入层编码</p><p>使用的是一种基于局部三维图像块的self-attention计算方式（跟Swin-UNet类似)</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310252129451.png" alt="image-20231025212855680" style="zoom: 80%;"></p><p><strong>SLV-MSA:</strong>是LV-MSA的shifted版本（类似于Swin-UNet，目的是使局部的三维图像块之间产生联系）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310252130572.png" alt="image-20231025213050517" style="zoom: 67%;"></p><p><em>注：$S_H、S_W、S_D$代表每个图像块中的patch的数量</em></p><p>使用LV-MSA减少了计算的复杂度，计算复杂度和图像之间是线性的关系</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310252139215.png" alt="image-20231025213709821" style="zoom: 80%;"></p><p>使用相对位置偏置B来引入位置信息</p><p><strong>The down-sampling layer：</strong></p><p>与Swin-UNet使用patch merging不同，作者选择了使用简单的卷积来实现下采样，卷积下采样可以在不同空间维度上应用不同的步长，以根据问题的要求调整下采样率。（可以根据数据的特点来灵活设置，避免过度下采样，对于三维的图像在某些维度上数据切片数量有限，这时可以将该维度的步长设置为1）</p><h4 id="Bottleneck"><a href="#Bottleneck" class="headerlink" title="Bottleneck"></a>Bottleneck</h4><p>不同于编码器使用局部自注意力机制，Bottleneck中使用全局自注意力。</p><p>计算复杂度：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310271637998.png" alt="image-20231027153408838" style="zoom: 80%;"></p><p>编码器部分减小了h、w、d，这为GV-MSA的应用创造了条件，与LV-MSA相比，GV-MSA能够提供更大的感受野</p><h4 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h4><p><strong>上采样操作</strong>：使用转置卷积</p><p><strong>Skip Attention：</strong>（使不同层之间的信息交流变得更加灵活）</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310271636161.png" alt="image-20231027155805206" style="zoom: 67%;"></p><h3 id="2-实验部分"><a href="#2-实验部分" class="headerlink" title="2.实验部分"></a>2.实验部分</h3><h4 id="与基于Transformer的方法学的比较"><a href="#与基于Transformer的方法学的比较" class="headerlink" title="与基于Transformer的方法学的比较"></a>与基于Transformer的方法学的比较</h4><p><strong>脑肿瘤分割</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310271636932.png" alt="image-20231027162254249" style="zoom: 67%;"></p><p>列出了所有模型在脑瘤分割任务上的实验结果,nnFormer在所有类别中取得了最低的HD95和最高的DSC分数。</p><p><strong>多器官分割（Synapse）</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310302100261.png" alt="image-20231029163515666"></p><p>与以前基于Transformer的方法相比，nnFormer在分割胰腺(Pancreas)和胃(Stomach)方面更有优势</p><p><strong>与nnUNet的比较</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310302100944.png" alt="image-20231030203836841"></p><p>nnFormer的HD95似乎更有优势，其可以更好地划分对象边界。</p><p>nnAvg：对nnFormer和nnUNet的预测结果进行平均化，发现整体的性能得到了提高，表明nnFormer和nnUNet是可以互补的。</p><h4 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202310302100685.png" alt="image-20231030205355146"></p><ul><li><p>嵌入层使用小卷积核大小的连续卷积层</p></li><li><p>卷积下采样层替换掉了patch Merging层</p></li><li><p>GV-MSA替换了Bottleneck的LV-MSA</p></li><li><p>Skip Attention代替跳跃连接</p></li><li>SLV-MSA层与LV-MSA层级联，全局自注意力层的数量增加一倍</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File类</title>
      <link href="/posts/c8b66f0a.html"/>
      <url>/posts/c8b66f0a.html</url>
      
        <content type="html"><![CDATA[<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><h3 id="1-创建File类的对象"><a href="#1-创建File类的对象" class="headerlink" title="1.创建File类的对象"></a>1.创建File类的对象</h3><p><img src="https://typoraimg.wangak.cc/2023/img/1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//创建一个File对象，指向某个具体的文件</span><br><span class="line">      File f1=new File(&quot;./data/test.txt&quot;);</span><br><span class="line">      System.out.println(f1.length());//文件大小</span><br><span class="line"></span><br><span class="line">      File f2=new File(&quot;./data/aaa.txt&quot;);//File对象可以指向空路径</span><br><span class="line">      System.out.println(f2.length());//0</span><br><span class="line">      System.out.println(f2.exists());//false</span><br></pre></td></tr></table></figure><h3 id="2-判断文件类型、获取文件信息"><a href="#2-判断文件类型、获取文件信息" class="headerlink" title="2.判断文件类型、获取文件信息"></a>2.判断文件类型、获取文件信息</h3><p><img src="https://typoraimg.wangak.cc/2023/img/2.png" alt="img" style="zoom: 50%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//1.创建一个File对象，指向某个具体的文件</span><br><span class="line">      File f1=new File(&quot;./data/test.txt&quot;);</span><br><span class="line">      //2.判断文件路径是否存在</span><br><span class="line">      System.out.println(f1.exists());</span><br><span class="line">      //3.判断文件对象是否是文件</span><br><span class="line">      System.out.println(f1.isFile());</span><br><span class="line">      //4.判断文件对象是否是文件夹</span><br><span class="line">      System.out.println(f1.isDirectory());</span><br><span class="line">      //5.获取文件的名称</span><br><span class="line">      System.out.println(f1.getName());</span><br><span class="line">      //6.获取文件的大小，返回字节个数</span><br><span class="line">      System.out.println(f1.length());</span><br><span class="line">      //7.获取文件最后的修改时间</span><br><span class="line">      long time = f1.lastModified();</span><br><span class="line">      SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);</span><br><span class="line">      System.out.println(sdf.format(time));//2023/10/18</span><br><span class="line">      //8.获取创建文件对象时使用的路径</span><br><span class="line">      System.out.println(f1.getPath());</span><br><span class="line">      //9.获取文件对象的绝对路径</span><br><span class="line">      System.out.println(f1.getAbsolutePath());</span><br></pre></td></tr></table></figure><h3 id="3-创建、删除文件"><a href="#3-创建、删除文件" class="headerlink" title="3.创建、删除文件"></a>3.创建、删除文件</h3><p><strong>public boolean creatNewFile():</strong>创建一个新文件，创建成功返回true</p><p><strong>public boolean mkdir():</strong>创建文件夹（只能创建一级文件夹）</p><p><strong>public boolean mkdirs():</strong>创建文件夹,可以创建多级文件夹</p><p><strong>public boolean delete():</strong>删除文件或文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//1.创建一个新文件</span><br><span class="line">      File f1=new File(&quot;./data/test2.txt&quot;);</span><br><span class="line">      System.out.println(f1.createNewFile());</span><br><span class="line">      //2.创建文件夹</span><br><span class="line">      File f2=new File(&quot;./data/a&quot;);</span><br><span class="line">      System.out.println(f2.mkdir());</span><br><span class="line">      //3.创建多个文件夹</span><br><span class="line">      File f3=new File(&quot;./data/1/2&quot;);</span><br><span class="line">      System.out.println(f3.mkdirs());</span><br><span class="line">      //4.删除文件或文件夹</span><br><span class="line">      System.out.println(f1.delete());</span><br><span class="line">      System.out.println(f2.delete());</span><br><span class="line">      System.out.println(f3.delete());</span><br><span class="line">      //&quot;./data/1&quot;这个文件夹还存在</span><br></pre></td></tr></table></figure><h3 id="4-遍历文件夹"><a href="#4-遍历文件夹" class="headerlink" title="4.遍历文件夹"></a>4.遍历文件夹</h3><p><img src="https://typoraimg.wangak.cc/2023/img/3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">File f1=new File(&quot;./data&quot;);</span><br><span class="line">      //获取目录下文件的名称</span><br><span class="line">      String[] names=f1.list();</span><br><span class="line">      for(String x:names)&#123;</span><br><span class="line">          System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">      //获取当前目录下的文件对象</span><br><span class="line">      File[] files=f1.listFiles();</span><br><span class="line">      for (File file:files)&#123;</span><br><span class="line">          System.out.println(file.getPath());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷积编码位置信息</title>
      <link href="/posts/a8dea67.html"/>
      <url>/posts/a8dea67.html</url>
      
        <content type="html"><![CDATA[<p><strong>论文：《HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE?》（ICLR2020）</strong></p><h3 id="论文内容："><a href="#论文内容：" class="headerlink" title="论文内容："></a>论文内容：</h3><h4 id="初步实验："><a href="#初步实验：" class="headerlink" title="初步实验："></a>初步实验：</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412926.png" alt="1"></p><p>对原始图像和裁剪过的图像进行显著性检测。</p><p>显著的区域分析，对于相同的物体，在不同的边缘下，显著性区域始终靠近图像中心。</p><p>推测：<strong>位置信息在 CNN 网络提取的特征图中被隐式编码</strong></p><h4 id="Position-Encoding-Network："><a href="#Position-Encoding-Network：" class="headerlink" title="Position Encoding Network："></a>Position Encoding Network：</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412136.png" alt="2"></p><p><strong>a feed forward convolutional encoder network $f_{enc} $:</strong>使用预训练的VGG或者 ResNet，仅作为前馈网络，其参数不参与训练。为前馈网络的在五个卷积层产生的特征图，使用双线性插值缩放到统一尺寸进行拼接，之后输入到 Position Encoding Module 中。</p><p><strong>position encoding module：</strong>一般卷积网络，其卷积核未使用Padding。</p><p>作者使用该网络判断卷积层产生的特征图中是否包含位置信息。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412155.png" alt="3" style="zoom: 80%;"></p><p>垂直（H)和水平(V)方向的梯度掩码、应用高斯滤波器来设计另一种类型的真值图，高斯分布(G)、水平和垂直条纹（HS、VS)，使用这五种图像表示位置信息，作为Ground Truth，每次训练选择其中一种，<strong>所有样本的标签都是一样的</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412681.png" alt="4" style="zoom:80%;"></p><p>除了使用数据集中的原始图像，作者还分别将<strong>纯黑、纯白、高斯噪声图像作为输入</strong>，这是为了验证在没有语义信息的情况下，特征中是否包含绝对位置信息。</p><p><strong>评价指标：</strong> Spearmen Correlation (<strong>SPC</strong>) and Mean Absoute Error (<strong>MAE</strong>)，前者越高说明输出与目标图像的相关性越高，后者则相反。</p><p><strong>实验结果:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412217.png" alt="5"></p><p>单独使用PosENet得到的分数要低很多，这一结果表明，仅从输入图像中提取位置信息是非常困难的，<strong>PosENet要与编码器网络相结合才能更好地提取出位置信息</strong></p><p>发现基于ResNet的模型比基于VGG16的模型实现了更高的性能。</p><h4 id="探究卷积的参数对提取位置信息的影响"><a href="#探究卷积的参数对提取位置信息的影响" class="headerlink" title="探究卷积的参数对提取位置信息的影响"></a>探究卷积的参数对提取位置信息的影响</h4><p><strong>length of convolutional layers：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412853.png" alt="6" style="zoom: 67%;"></p><p><strong>kernel size:</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412339.png" alt="7" style="zoom: 80%;"></p><p>​                                                                <strong>更大的感受野可以更好地解析位置信息</strong></p><p><strong>zero-padding：</strong>作者认为卷积中zero-padding 是 CNN 中位置信息的来源</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412058.png" alt="8" style="zoom:80%;"></p><p>从结果中可以看出，未添加 zero-padding 的 VGG16 的性能比默认设置（padding =  1）低得多。PosENet（padding = 1）实现了比原始（padding = 0）更高的性能，而当 padding 设置为 2  时，位置信息的作用更加明显。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架</title>
      <link href="/posts/9753a2e.html"/>
      <url>/posts/9753a2e.html</url>
      
        <content type="html"><![CDATA[<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><h3 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1.泛型"></a>1.泛型</h3><p><strong>泛型：</strong>允许在编写类、接口和方法时使用类型参数，以在运行时确定具体的数据类型，用于增强类型安全性和代码的可重用性</p><h4 id="1-1-泛型类"><a href="#1-1-泛型类" class="headerlink" title="1.1 泛型类"></a>1.1 泛型类</h4><p><strong>泛型类：</strong><code>类名&lt;T,...&gt;</code>,T是类型占位符，表示一种引用类型，如果编写多个用逗号隔开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGeneric</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//1.创建变量</span></span><br><span class="line">    T t;</span><br><span class="line">    <span class="comment">//2.使用泛型作为方法的参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T y)</span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.使用泛型作为方法的返回值</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用泛型类创建对象</span></span><br><span class="line">        MyGeneric&lt;String&gt; myGeneric1=<span class="keyword">new</span> <span class="title class_">MyGeneric</span>&lt;&gt;();</span><br><span class="line">        myGeneric1.t=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        MyGeneric&lt;Integer&gt; myGeneric2=<span class="keyword">new</span> <span class="title class_">MyGeneric</span>&lt;&gt;();</span><br><span class="line">        myGeneric2.t=<span class="number">100</span>;</span><br><span class="line">        myGeneric1.show();</span><br><span class="line">        myGeneric2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p>1.泛型只能是引用类型</p><p>2.不同泛型类型的对象之间不能相互赋值</p><h4 id="1-2-泛型接口"><a href="#1-2-泛型接口" class="headerlink" title="1.2 泛型接口"></a>1.2 泛型接口</h4><p><strong>泛型接口：</strong><code>接口名&lt;T&gt;</code></p><p><strong><em>注：不能使用泛型创建静态常量</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">server</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口实现方式一：class确定泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyImpl1</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&lt;String&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">server</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口实现方式二：class不确定泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyImpl2</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">server</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyImpl1 myImpl1=<span class="keyword">new</span> <span class="title class_">MyImpl1</span>();</span><br><span class="line">        myImpl1.server(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        MyImpl2&lt;Integer&gt; myImpl2a=<span class="keyword">new</span> <span class="title class_">MyImpl2</span>&lt;&gt;();</span><br><span class="line">        myImpl2a.server(<span class="number">100</span>);</span><br><span class="line">        MyImpl2&lt;String&gt; myImpl2b=<span class="keyword">new</span> <span class="title class_">MyImpl2</span>&lt;&gt;();</span><br><span class="line">        myImpl2b.server(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">hello</span><br><span class="line"><span class="number">100</span></span><br><span class="line">world</span><br></pre></td></tr></table></figure><h4 id="1-3-泛型方法"><a href="#1-3-泛型方法" class="headerlink" title="1.3 泛型方法"></a>1.3 泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenernicMod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">show</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;泛型方法:&quot;</span>+t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test4</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GenernicMod genernicMod=<span class="keyword">new</span> <span class="title class_">GenernicMod</span>();</span><br><span class="line">        genernicMod.show(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        genernicMod.show(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">泛型方法:hello</span><br><span class="line">泛型方法:<span class="number">123</span></span><br></pre></td></tr></table></figure><h4 id="1-4-泛型集合"><a href="#1-4-泛型集合" class="headerlink" title="1.4 泛型集合"></a>1.4 泛型集合</h4><p><strong>泛型集合：</strong>参数化类型、类型安全的集合，强制集合元素的类型必须一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;yyy&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; iterator=arrayList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String string=iterator.next();</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Collection体系集合"><a href="#2-Collection体系集合" class="headerlink" title="2.Collection体系集合"></a>2.Collection体系集合</h3><p><strong>集合和数组的区别：</strong></p><p>(1).数组长度固定，集合长度不固定</p><p>(2).数组可以存储基本类型和引用类型，集合只能存储引用类型。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201402167.png" alt="1"></p><ul><li><p><strong>Collection</strong> 接口存储一组不唯一，无序的对象</p></li><li><p><strong>List</strong> 接口存储一组不唯一，有序的对象。</p></li><li><p><strong>Set</strong> 接口存储一组唯一，无序的对象</p></li><li><p><strong>Map</strong> 接口存储一组键值对象，提供key到value的映射</p><p><strong>Collection的使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">       <span class="comment">//1.添加元素</span></span><br><span class="line">        collection.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(collection);</span><br><span class="line">        <span class="comment">//*2.删除元素</span></span><br><span class="line"><span class="comment">//        collection.remove(&quot;a&quot;);//一次remove操作只删除一个元素，即使Collection中有相同元素</span></span><br><span class="line"><span class="comment">//        System.out.println(collection);</span></span><br><span class="line">        <span class="comment">//*3.1使用增强for遍历</span></span><br><span class="line"><span class="comment">//        for (Object object:collection) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(object);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//*3.2使用迭代器进行遍历</span></span><br><span class="line">        <span class="comment">//hasNext();判断有没有下一个元素</span></span><br><span class="line">        <span class="comment">//next();获取下一个元素</span></span><br><span class="line">        <span class="comment">//remove();删除当前元素</span></span><br><span class="line">        Iterator it= collection.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String s=(String)it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line"><span class="comment">//            it.remove();//删除当前元素</span></span><br><span class="line">        &#125;<span class="comment">//使用迭代器遍历时禁止使用Collection的其他的一些方法如remove()来改变集合的元素，可以使用迭代器的方法(it.remove())</span></span><br><span class="line"><span class="comment">//        System.out.println(collection);</span></span><br><span class="line">        <span class="comment">//*4.判断元素是否存在</span></span><br><span class="line">        System.out.println(collection.contains(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-1-List子接口"><a href="#2-1-List子接口" class="headerlink" title="2.1 List子接口"></a>2.1 List子接口</h4><p><strong>List：</strong>有序、有下标、元素可以重复</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201402726.png" alt="2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">List_test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//1.添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="number">0</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//2.删除元素</span></span><br><span class="line"><span class="comment">//        list.remove(&quot;c&quot;);//按元素删除</span></span><br><span class="line">        list.remove(<span class="number">0</span>);<span class="comment">//按下标删除</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//3.遍历</span></span><br><span class="line">        <span class="comment">//3.1使用for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.1使用for&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2使用增强for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.2使用增强for&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object object:list)&#123;</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.3使用迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.3使用迭代器&quot;</span>);</span><br><span class="line">        Iterator iterator=list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.4使用列表迭代器，ListIterator可以向前或向后遍历，可以添加、删除、修改元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.4使用列表迭代器向后遍历&quot;</span>);</span><br><span class="line">        ListIterator lit=list.listIterator();</span><br><span class="line">        <span class="keyword">while</span>(lit.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;3.4使用列表迭代器向前遍历&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(lit.hasPrevious())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.previous());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.获取元素的索引位置</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ArrayList存储结构：</strong>数组，查找速度快，增删速度慢，运行效率快，线程不安全</p><p><strong>Vector存储结构：</strong>数组，查找速度快，增删速度慢，运行效率慢，线程安全</p><p><strong>LinkedList存储结构:</strong>双向链表，增删速度快，查询速度慢</p><h4 id="2-2-set子接口"><a href="#2-2-set子接口" class="headerlink" title="2.2 set子接口"></a>2.2 set子接口</h4><h5 id="2-2-1-Set"><a href="#2-2-1-Set" class="headerlink" title="2.2.1 Set"></a>2.2.1 Set</h5><p><strong>Set:无序、无下标、元素不可重复</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set &lt;String&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[a, b, c]</span><br></pre></td></tr></table></figure><h5 id="2-2-2-HashSet"><a href="#2-2-2-HashSet" class="headerlink" title="2.2.2 HashSet"></a>2.2.2 HashSet</h5><p><strong>HashSet存储结构:</strong>哈希表（数组+链表+红黑树）</p><p><strong>存储过程：</strong></p><p>（1）根据hashcode计算保存的位置，如果此位置为空，则直接保存，如果不为空执行第二步。</p><p>（2）再执行equals方法，如果equals方法为true，则认为是重复，否则，形成链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet &lt;Person&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Person person1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;wang&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        Person person2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        set.add(person1);</span><br><span class="line">        set.add(person2);</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[Person@<span class="number">41629346</span>, Person@4eec7777, Person@3b07d329]</span><br></pre></td></tr></table></figure><p><strong>问题：相同name，age的对象于集合中重复添加</strong></p><p><strong>解决方法：重写hashcode、equals方法</strong></p><p><em>注：hashcode、equals方法定义了hashset的重复依据</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写hashCode和equals方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> n1=<span class="built_in">this</span>.name.hashCode();</span><br><span class="line">        <span class="type">int</span> n2=<span class="built_in">this</span>.age;</span><br><span class="line">        <span class="keyword">return</span> n1+n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>==obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Person)</span><br><span class="line">        &#123;</span><br><span class="line">            Person p=(Person) obj;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.name.equals(p.getName())&amp;&amp;<span class="built_in">this</span>.age==p.getAge())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet &lt;Person&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Person person1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;wang&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        Person person2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        set.add(person1);</span><br><span class="line">        set.add(person2);</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">2</span></span><br><span class="line">[Person<span class="meta">@f13</span>, Person@37921a]</span><br></pre></td></tr></table></figure><h5 id="2-2-3-TreeSet"><a href="#2-2-3-TreeSet" class="headerlink" title="2.2.3 TreeSet"></a>2.2.3 TreeSet</h5><p><strong>TreeSet:</strong></p><ul><li>基于排序顺序实现元素不重复</li><li>实现了SortedSet接口，对集合元素自动排序</li><li><strong>元素对象的类型必须实现Comparable接口，指定排序规则</strong></li><li>通过CompareTo方法确定是否为重复元素</li></ul><p><strong>TreeSet存储结构:</strong>红黑树</p><p><strong>TreeSet的使用一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt;&#123;<span class="comment">//TreeSet的元素类型必须实现Comparable接口</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;<span class="comment">//重写Comparable接口的compareTo方法，compareTo方法返回值为0认为是重复元素</span></span><br><span class="line">        <span class="type">int</span> n1=<span class="built_in">this</span>.name.compareTo(o.getName());</span><br><span class="line">        <span class="type">int</span> n2=<span class="built_in">this</span>.age-o.getAge();</span><br><span class="line">        <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        String str=<span class="built_in">this</span>.getName()+<span class="string">&quot;:&quot;</span>+<span class="built_in">this</span>.getAge();</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       TreeSet &lt;Person&gt; persons=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        Person person1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;wang&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        Person person2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        Person person3=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        persons.add(person1);</span><br><span class="line">        persons.add(person2);</span><br><span class="line">        persons.add(person3);</span><br><span class="line">        persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xu&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        System.out.println(persons.size());</span><br><span class="line">        System.out.println(persons.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[wang:<span class="number">23</span>, xu:<span class="number">22</span>, xu:<span class="number">24</span>]</span><br></pre></td></tr></table></figure><p><strong>TreeSet的使用二：Comparator实现比较器，无需实现Comparable接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TreeSet &lt;Person&gt; persons=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">               <span class="type">int</span> n1=o1.getName().compareTo(o2.getName());</span><br><span class="line">               <span class="type">int</span> n2=o1.getAge()-o2.getAge();</span><br><span class="line">               <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p><strong>利用TreeSet实现字符串排序：</strong>先按长度排，长度相同比大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;String&gt; treeSet=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">                <span class="type">int</span> n1=o1.length()-o2.length();</span><br><span class="line">                <span class="type">int</span> n2=o1.compareTo(o2);</span><br><span class="line">                <span class="keyword">return</span> n1==<span class="number">0</span>?n2:n1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeSet.add(<span class="string">&quot;peng&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;xu&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;an&quot;</span>);</span><br><span class="line">        System.out.println(treeSet.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-Map集合体系"><a href="#3-Map集合体系" class="headerlink" title="3.Map集合体系"></a>3.Map集合体系</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201402328.png" alt="3" style="zoom: 80%;"></p><p><strong>Map:</strong>存储一对数据（Key-Value),无序、无下标、键不可重复、值可重复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class demo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;String, String&gt; map=new HashMap&lt;&gt;();</span><br><span class="line">        //1.添加元素</span><br><span class="line">        map.put(&quot;a&quot;,&quot;1&quot;);</span><br><span class="line">        map.put(&quot;b&quot;,&quot;2&quot;);</span><br><span class="line">        map.put(&quot;c&quot;,&quot;3&quot;);</span><br><span class="line">        map.put(&quot;d&quot;,&quot;4&quot;);</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">        //2.删除元素</span><br><span class="line">        map.remove(&quot;b&quot;);</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">        //3.1 使用keySet()遍历</span><br><span class="line">        System.out.println(&quot;使用keySet()遍历&quot;);</span><br><span class="line">//        Set&lt;String&gt; keys=map.keySet();</span><br><span class="line">        for (String key:map.keySet())&#123;</span><br><span class="line">            System.out.println(key+&quot;:&quot;+map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        //3.2 使用entrySet()遍历(效率高于keySet())</span><br><span class="line">        System.out.println(&quot;使用entrySet()遍历&quot;);</span><br><span class="line">//        Set&lt;Map.Entry&lt;String,String&gt; &gt; entrySet=map.entrySet();</span><br><span class="line">        for (Map.Entry&lt;String,String&gt; entry:map.entrySet())&#123;</span><br><span class="line">            System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        //4.判断是否包含</span><br><span class="line">        System.out.println(map.containsKey(&quot;a&quot;));</span><br><span class="line">        System.out.println(map.containsValue(&quot;1&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HashMap的存储结构：哈希表（数组+链表+红黑树）</strong></p><p>注：HashMap使用key的hashcode和equals作为重复的依据</p><p><strong>TreeMap:</strong>实现了SortedMap接口，可以对key自动排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        String str=this.getName()+&quot;:&quot;+this.getAge();</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       TreeMap &lt;Person,String&gt; persons=new TreeMap&lt;&gt;(new Comparator&lt;Person&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public int compare(Person o1, Person o2) &#123;</span><br><span class="line">               int n1=o1.getName().compareTo(o2.getName());</span><br><span class="line">               int n2=o1.getAge()-o2.getAge();</span><br><span class="line">               return n1==0?n2:n1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">        Person person1=new Person(&quot;wang&quot;,23);</span><br><span class="line">        Person person2=new Person(&quot;xu&quot;,22);</span><br><span class="line">        Person person3=new Person(&quot;xu&quot;,24);</span><br><span class="line">        persons.put(person1,&quot;a&quot;);</span><br><span class="line">        persons.put(person2,&quot;b&quot;);</span><br><span class="line">        persons.put(person3,&quot;c&quot;);</span><br><span class="line">        persons.put(new Person(&quot;xu&quot;,22),&quot;d&quot;);</span><br><span class="line">        System.out.println(persons.size());</span><br><span class="line">        System.out.println(persons.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Collections工具类"><a href="#4-Collections工具类" class="headerlink" title="4.Collections工具类"></a>4.Collections工具类</h3><p>Collections工具类：集合工具类，定义了除存取以外的集合常用方法。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201402950.png" alt="4"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SegFormer</title>
      <link href="/posts/9e1703d2.html"/>
      <url>/posts/9e1703d2.html</url>
      
        <content type="html"><![CDATA[<h2 id="SegFormer"><a href="#SegFormer" class="headerlink" title="SegFormer"></a>SegFormer</h2><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407750.png" alt="1" style="zoom:75%;"></p><p><strong>编码器:</strong>通过在不同阶段进行下采样，生成多尺度特征。</p><p><strong>Efficient Self-Attention:</strong></p><p><strong>原始的自注意力计算：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407939.png" alt="2" style="zoom: 67%;"></p><p>计算复杂度为O($N^2$),其中N为w*h</p><p><strong>高效的自关注机制:</strong>通过一个压缩比R对K进行处理，改进的计算过程如下.0</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407713.png" alt="3" style="zoom:67%;"></p><p>复杂度从O($N^2$)将至O($N^2 \over R$),降低了计算复杂度</p><p><em>注：论文中的R分别取64, 16, 4, 1</em></p><p>通过将K进行reshape将空间维度N的信息转移到通道维度C上，可以得到$\widehat K$；然后通过线性变换层将通道为降到原始维度C上，得到K’，实现空间下采样。</p><p><strong>Mix-FFN:</strong>为了解决使用位置编码引入位置信息，但由于在测试时的分辨率发生变化时，<strong>会引起精度下降的问题</strong>。</p><p>注：训练时生成的位置编码长度小于预测时的需要时，一种处理方法是使用<strong>插值</strong>将训练时的位置编码扩展到预测时所需的长度。</p><p>位置信息在语义分割中不是必需的</p><p>Mix-FFN：直接使用<strong>3*3卷积</strong>捕获一定程度上的位置信息</p><p>计算过程如下：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407101.png" alt="4" style="zoom:67%;"></p><p>注：$x_{in}$为自注意力模块的输出</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408906.png" alt="8"></p><p><strong>Overlapped Patch Merging:保持patch周围的局部连续性</strong></p><p>patch尺寸K、步长S、填充尺寸P，在网络中设置参了2套参数：<em>K</em> = 7, <em>S</em> = 4, <em>P</em> = 3 ；<em>K</em> = 3, <em>S</em> = 2, <em>P</em> = 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class OverlapPatchEmbed(nn.Layer):</span><br><span class="line">    def __init__(self,</span><br><span class="line">                 img_size=224,</span><br><span class="line">                 patch_size=7,          # 卷积核大小</span><br><span class="line">                 stride=4,                 # 下采样倍数</span><br><span class="line">                 in_chans=3,            # 输入通道数</span><br><span class="line">                 embed_dim=768):  # 输出通道数</span><br><span class="line">        super().__init__()</span><br><span class="line">        img_size = to_2tuple(img_size)</span><br><span class="line">        patch_size = to_2tuple(patch_size)</span><br><span class="line"></span><br><span class="line">        self.img_size = img_size</span><br><span class="line">        self.patch_size = patch_size</span><br><span class="line">        self.H, self.W = img_size[0] // patch_size[0], img_size[</span><br><span class="line">            1] // patch_size[1]</span><br><span class="line">        self.num_patches = self.H * self.W</span><br><span class="line">        # 定义投影变换所用的卷积</span><br><span class="line">        self.proj = nn.Conv2D(</span><br><span class="line">            in_chans,</span><br><span class="line">            embed_dim,</span><br><span class="line">            kernel_size=patch_size,</span><br><span class="line">            stride=stride,</span><br><span class="line">            padding=(patch_size[0] // 2, patch_size[1] // 2))</span><br><span class="line">        # 定义layer norm层</span><br><span class="line">        self.norm = nn.LayerNorm(embed_dim)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        x = self.proj(x)    # 通过卷积进行特征重投影，实现下采样、通道变换</span><br><span class="line">        x_shape = paddle.shape(x)</span><br><span class="line">        H, W = x_shape[2], x_shape[3]</span><br><span class="line">        x = x.flatten(2).transpose([0, 2, 1])  # 将H*W维度压缩成1个维度</span><br><span class="line">        x = self.norm(x)          # 标准化</span><br><span class="line"></span><br><span class="line">        return x, H, W</span><br></pre></td></tr></table></figure><p><strong>解码器</strong></p><p><strong>Lightweight All-MLP Decoder</strong>：在解码器部分，SegFormer采用了简单的结构，仅由MLP组成</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310212052806.jpg" alt="6" style="zoom:50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408838.png" alt="5" style="zoom: 80%;"></p><p><strong>有效感受野分析</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408040.png" alt="7" style="zoom:80%;"></p><p>如图3的放大图所示，MLP头部(蓝框)的ERF与阶段4(红框)不同，除了非局部注意外，局部注意明显更强。</p><p>在上采样阶段，Head的感受野除了具有非局部关注外，还有较强的局部关注。</p><p>作者认为之所以这种简单的Decoder能够很好地工作，关键在于分层的Transformer Encoder比传统的基于CNN的Encoder具有更大的感受野。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408701.png" alt="9" style="zoom:80%;"></p><h3 id="2-实验结果"><a href="#2-实验结果" class="headerlink" title="2.实验结果"></a>2.实验结果</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201408211.png" alt="10" style="zoom: 67%;"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MISSFormer</title>
      <link href="/posts/d6b0e04e.html"/>
      <url>/posts/d6b0e04e.html</url>
      
        <content type="html"><![CDATA[<h2 id="MISSFormer"><a href="#MISSFormer" class="headerlink" title="MISSFormer"></a>MISSFormer</h2><p><strong>论文：《MISSFormer: An Effective Medical Image Segmentation Transformer》（TMI2022）</strong></p><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404731.png" alt="1"></p><p><strong>编码器</strong>由Overlap Patch Embedding、Overlap Patch Merging以及Transformer Block with ReMix-FFN组成。</p><p><strong>EMix-FFN:</strong>在Enhanced Mix块中引入递归跳跃连接，给定输入特征映射xin，应用深度卷积层捕获局部上下文，然后进行递归跳跃连接</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404884.png" alt="2"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404240.png" alt="5" style="zoom: 80%;"></p><p><strong>Enhanced Transformer Context Bridge来捕获不同尺度特征的局部和全局相关性</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404308.png" alt="3" style="zoom: 50%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404818.png" alt="4" style="zoom:50%;"></p><p>步骤：</p><p>1.将编码器生成的多尺度的特征的h、w，变成一个序列</p><p>2.将四个输出拼接到一起</p><p>3.对拼接后的结果进行注意力的计算</p><p>4.自注意力输出的结果和输出拼接的结果进行跳跃连接，然后进行层归一化</p><p>5.把归一化的结果再分成四个输出</p><p>6.将这四个输出再进行EMix-FFN</p><p>7.将四个输出的N（h*w)拼接到一起,再与归一化的结果进行跳跃连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class BridgeLayer_4(nn.Module):</span><br><span class="line">    def __init__(self, dims, head, reduction_ratios):</span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">        self.norm1 = nn.LayerNorm(dims)</span><br><span class="line">        self.attn = M_EfficientSelfAtten(dims, head, reduction_ratios)</span><br><span class="line">        self.norm2 = nn.LayerNorm(dims)</span><br><span class="line">        self.mixffn1 = MixFFN_skip(dims,dims*4)</span><br><span class="line">        self.mixffn2 = MixFFN_skip(dims*2,dims*8)</span><br><span class="line">        self.mixffn3 = MixFFN_skip(dims*5,dims*20)</span><br><span class="line">        self.mixffn4 = MixFFN_skip(dims*8,dims*32)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    def forward(self, inputs):</span><br><span class="line">        B = inputs[0].shape[0]</span><br><span class="line">        C = 64</span><br><span class="line">        if (type(inputs) == list):</span><br><span class="line">            # print(&quot;-----1-----&quot;)</span><br><span class="line">            c1, c2, c3, c4 = inputs</span><br><span class="line">            B, C, _, _= c1.shape</span><br><span class="line">            c1f = c1.permute(0, 2, 3, 1).reshape(B, -1, C)  # 3136*64</span><br><span class="line">            c2f = c2.permute(0, 2, 3, 1).reshape(B, -1, C)  # 1568*64</span><br><span class="line">            c3f = c3.permute(0, 2, 3, 1).reshape(B, -1, C)  # 980*64</span><br><span class="line">            c4f = c4.permute(0, 2, 3, 1).reshape(B, -1, C)  # 392*64</span><br><span class="line">            </span><br><span class="line">            # print(c1f.shape, c2f.shape, c3f.shape, c4f.shape)</span><br><span class="line">            inputs = torch.cat([c1f, c2f, c3f, c4f], -2)</span><br><span class="line">        else:</span><br><span class="line">            B,_,C = inputs.shape </span><br><span class="line"></span><br><span class="line">        tx1 = inputs + self.attn(self.norm1(inputs))</span><br><span class="line">        tx = self.norm2(tx1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        tem1 = tx[:,:3136,:].reshape(B, -1, C) </span><br><span class="line">        tem2 = tx[:,3136:4704,:].reshape(B, -1, C*2)</span><br><span class="line">        tem3 = tx[:,4704:5684,:].reshape(B, -1, C*5)</span><br><span class="line">        tem4 = tx[:,5684:6076,:].reshape(B, -1, C*8)</span><br><span class="line"></span><br><span class="line">        m1f = self.mixffn1(tem1, 56, 56).reshape(B, -1, C)</span><br><span class="line">        m2f = self.mixffn2(tem2, 28, 28).reshape(B, -1, C)</span><br><span class="line">        m3f = self.mixffn3(tem3, 14, 14).reshape(B, -1, C)</span><br><span class="line">        m4f = self.mixffn4(tem4, 7, 7).reshape(B, -1, C)</span><br><span class="line"></span><br><span class="line">        t1 = torch.cat([m1f, m2f, m3f, m4f], -2)</span><br><span class="line">        </span><br><span class="line">        tx2 = tx1 + t1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return tx2</span><br></pre></td></tr></table></figure><p><strong>上下文桥循环了四次：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class BridegeBlock_4(nn.Module):   #这是MISSFormer模型图中，上下文桥循环四次的代码</span><br><span class="line">    def __init__(self, dims, head, reduction_ratios):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.bridge_layer1 = BridgeLayer_4(dims, head, reduction_ratios) #定义上下文桥</span><br><span class="line">        self.bridge_layer2 = BridgeLayer_4(dims, head, reduction_ratios) </span><br><span class="line">        self.bridge_layer3 = BridgeLayer_4(dims, head, reduction_ratios) </span><br><span class="line">        self.bridge_layer4 = BridgeLayer_4(dims, head, reduction_ratios) </span><br><span class="line"></span><br><span class="line">    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:</span><br><span class="line">        bridge1 = self.bridge_layer1(x)    #输入数据至第一个上下文桥，得到第一个输出</span><br><span class="line">        bridge2 = self.bridge_layer2(bridge1)#将上一个输出输入至第二个上下文桥</span><br><span class="line">        bridge3 = self.bridge_layer3(bridge2)#将上一个输出输入至第三个上下文桥</span><br><span class="line">        bridge4 = self.bridge_layer4(bridge3)#将上一个输出输入至第四个上下文桥</span><br><span class="line"></span><br><span class="line">        B,_,C = bridge4.shape  #提取B和C大小</span><br><span class="line">        outs = []              #建立空列表，存储输出结果</span><br><span class="line"></span><br><span class="line">        sk1 = bridge4[:,:3136,:].reshape(B, 56, 56, C).permute(0,3,1,2)      #输出转换为二维形式</span><br><span class="line">        sk2 = bridge4[:,3136:4704,:].reshape(B, 28, 28, C*2).permute(0,3,1,2) </span><br><span class="line">        sk3 = bridge4[:,4704:5684,:].reshape(B, 14, 14, C*5).permute(0,3,1,2) </span><br><span class="line">        sk4 = bridge4[:,5684:6076,:].reshape(B, 7, 7, C*8).permute(0,3,1,2) </span><br><span class="line"></span><br><span class="line">        outs.append(sk1)  #将结果存储到列表中</span><br><span class="line">        outs.append(sk2)</span><br><span class="line">        outs.append(sk3)</span><br><span class="line">        outs.append(sk4)</span><br><span class="line"></span><br><span class="line">        return outs</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404365.png" alt="6"></p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201404746.png" alt="7"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用类</title>
      <link href="/posts/df13c63f.html"/>
      <url>/posts/df13c63f.html</url>
      
        <content type="html"><![CDATA[<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="1-Object类"><a href="#1-Object类" class="headerlink" title="1.Object类"></a>1.Object类</h3><h4 id="1-1-clone方法"><a href="#1-1-clone方法" class="headerlink" title="1.1 clone方法"></a>1.1 clone方法</h4><p><strong>clone方法：</strong>clone方法执行的是浅拷贝</p><p><em>注：<strong>clone方法</strong>创建了一个新对象，但这个新对象和原始对象的引用变量相同（浅拷贝）。</em></p><p><strong>验证clone方法是浅拷贝的：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 声明静态内部类 Body，实现 Cloneable 接口以支持克隆</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Body</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Head head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Body</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Body</span><span class="params">(Head head)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.head = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">            <span class="comment">// 调用父类的 clone 方法以执行浅拷贝</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明静态内部类 Head，这个类不需要克隆功能</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Head</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Head</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个 Body 对象，并将其关联的 Head 对象初始化</span></span><br><span class="line">        <span class="type">Body</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Body</span>(<span class="keyword">new</span> <span class="title class_">Head</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用克隆方法复制 Body 对象，得到一个新的 Body 对象 body1</span></span><br><span class="line">        <span class="type">Body</span> <span class="variable">body1</span> <span class="operator">=</span> (Body) body.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查两个对象是否相同</span></span><br><span class="line">        System.out.println(<span class="string">&quot;body == body1 : &quot;</span> + (body == body1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查两个对象的 head 属性是否相同（因为是浅拷贝，所以 head 属性相同）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;body.head == body1.head : &quot;</span> + (body.head == body1.head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">body == body1 : <span class="literal">false</span></span><br><span class="line">body.head == body1.head : <span class="literal">true</span><span class="comment">//新对象和原对象共享相同的引用对象,故clone方法执行的是浅拷贝</span></span><br></pre></td></tr></table></figure><h4 id="1-2-toString-方法"><a href="#1-2-toString-方法" class="headerlink" title="1.2 toString()方法"></a>1.2 toString()方法</h4><p>Object 类的 toString 方法返回一个字符串，该字符串由类名、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。</p><p><em>注：通常情况下，<strong>应重写 <code>toString()</code> 方法</strong>，以便返回一个更有意义的、描述对象状态的字符串。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;, age=&quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 toString() 方法输出对象的字符串表示形式</span></span><br><span class="line">        System.out.println(person.toString()); <span class="comment">// 输出：Person&#123;name=&#x27;Alice&#x27;, age=30&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Alice&#x27;</span>, age=<span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-getClass-方法"><a href="#1-3-getClass-方法" class="headerlink" title="1.3 getClass()方法"></a>1.3 getClass()方法</h4><p><strong>getClass()方法：</strong>返回对象的运行时类，所有 Java 类都继承了这个方法，不可重写，要调用的话，一般和getName()联合使用，如getClass().getName()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetClassExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        <span class="comment">// 使用 getClass() 方法获取对象的运行时类</span></span><br><span class="line">        Class&lt;?&gt; cls = vehicle.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出类的名称</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName()); <span class="comment">// 输出：Class name: Car</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Class name: Car</span><br></pre></td></tr></table></figure><h4 id="1-4-equals-方法"><a href="#1-4-equals-方法" class="headerlink" title="1.4 equals()方法"></a>1.4 equals()方法</h4><p> Object中的equals方法是直接判断this和obj本身的值是否相等,如果this和obj指向的是同一块内存对象，则返回true,如果</p><p>this和obj指向的不是同一块内存，则返回false。</p><p><em>注：即便是内容完全相等的两块不同的内存对象，也返回false。</em></p><p>String类已经重写了object中的equals方法（比较内容是否相等）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">// 输出：true，内容相同</span></span><br><span class="line">System.out.println(str1.equals(str3)); <span class="comment">// 输出：true，内容相同</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="1-5-wait-方法"><a href="#1-5-wait-方法" class="headerlink" title="1.5 wait()方法"></a>1.5 wait()方法</h4><p>pass</p><h4 id="1-6-notify-方法"><a href="#1-6-notify-方法" class="headerlink" title="1.6  notify()方法"></a>1.6  notify()方法</h4><p>pass</p><h3 id="2-包装类"><a href="#2-包装类" class="headerlink" title="2.包装类"></a>2.包装类</h3><p>基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用,故Java为每种基本数据类型分别设计了对应的类，称之为<strong>包装类</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201401558.png" alt="1" style="zoom: 67%;"></p><h4 id="自动拆箱和装箱"><a href="#自动拆箱和装箱" class="headerlink" title="自动拆箱和装箱"></a>自动拆箱和装箱</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">500</span>;            <span class="comment">// 创建一个基本数据类型变量 m 并赋值为 500</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> m;        <span class="comment">// 自动装箱：将基本数据类型 m 装箱为 Integer 对象 obj</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obj;            <span class="comment">// 自动拆箱：将 Integer 对象 obj 拆箱为基本数据类型 n</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n = &quot;</span> + n);  <span class="comment">// 输出 n 的值</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="number">500</span>;     <span class="comment">// 创建一个 Integer 对象 obj1 并初始化为 500</span></span><br><span class="line">        System.out.println(<span class="string">&quot;obj 等价于 obj1？&quot;</span> + obj.equals(obj1));  <span class="comment">// 比较 obj 和 obj1 是否相等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">n = <span class="number">500</span></span><br><span class="line">obj 等价于 obj1？<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><em>注：所有的包装类（Integer、Long、Byte、Double、Float、Short）都是<strong>抽象类 Number</strong> 的子类。</em></p><h3 id="3-String类"><a href="#3-String类" class="headerlink" title="3.String类"></a>3.String类</h3><h4 id="3-1-创建字符串对象方式"><a href="#3-1-创建字符串对象方式" class="headerlink" title="3.1 创建字符串对象方式"></a>3.1 创建字符串对象方式</h4><p><strong>String类对象一旦声明则不可以改变，而改变的只是地址，原来的字符串还是存在的，并且产生垃圾。</strong></p><p><strong>直接赋值方式：</strong>创建对象是在方法区的<strong>常量池</strong></p><p><code>String str=&quot;hello&quot;;//直接赋值的方式</code></p><p><strong>构造方法：</strong>通过构造方法创建字符串对象是在<strong>堆内存</strong></p><p><code>String str=new String(&quot;hello&quot;);//实例化的方式</code></p><p><strong>两种实例化方式的比较:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Lance&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Lance&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;Lance&quot;</span>;</span><br><span class="line"><span class="comment">//String类对象==比较，比较的是地址，而不是内容</span></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str1==str3);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3==str2);<span class="comment">//true</span></span><br><span class="line">System.out.println(str1==str4);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//str1和str4引用的是字符串常量池中的同一个对象，因此它们的引用相等</span></span><br></pre></td></tr></table></figure><h4 id="3-2-字符串常量池"><a href="#3-2-字符串常量池" class="headerlink" title="3.2 字符串常量池"></a>3.2 字符串常量池</h4><p>​       在字符串中，如果采用直接赋值的方式（String str=”Lance”）进行对象的实例化，则会将匿名对象“Lance”放入对象池，每当下一次对不同的对象进行直接赋值的时候会直接利用池中原有的匿名对象</p><p><strong>两种实例化方式的区别:</strong></p><p><strong>直接赋值（String str = “hello”）：</strong>只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。</p><p><strong>构造方法（String str= new String(“hello”)）:</strong>连续两次new一个String对象，会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过public String intern();方法进行手工入池。</p><p><em>注：在开发的过程中不会采用构造方法进行字符串的实例化</em></p><h4 id="3-3-空指向异常"><a href="#3-3-空指向异常" class="headerlink" title="3.3 空指向异常"></a>3.3 空指向异常</h4><p><strong>equals</strong>比较的是字符串内容，在开发的过程中，equals()通过接受参数，可以避免空指向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(str.equals(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//此时会出现空指向异常 ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;hello&quot;</span>.equals(str))</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//此时equals会处理null值，可以避免空指向异常 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-StringBuilder-和-StringBuffer"><a href="#4-StringBuilder-和-StringBuffer" class="headerlink" title="4.StringBuilder 和 StringBuffer"></a>4.StringBuilder 和 StringBuffer</h3><p>pass</p><h3 id="5-File类"><a href="#5-File类" class="headerlink" title="5.File类"></a>5.File类</h3><p>pass</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法</title>
      <link href="/posts/ea538f2a.html"/>
      <url>/posts/ea538f2a.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h2><h3 id="1-浮点型拓展"><a href="#1-浮点型拓展" class="headerlink" title="1.浮点型拓展"></a>1.浮点型拓展</h3><h4 id="1-1浮点类型的舍入误差"><a href="#1-1浮点类型的舍入误差" class="headerlink" title="1.1浮点类型的舍入误差"></a>1.1浮点类型的舍入误差</h4><p>浮点类型<strong>float, double</strong>的数据不适合在<strong>不容许舍入误差</strong>的领域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 定义一个float类型变量f并赋值为0.1</span><br><span class="line">        float f = 0.1f;</span><br><span class="line"></span><br><span class="line">        // 定义一个double类型变量d并赋值为1.0除以10，即0.1</span><br><span class="line">        double d = 1.0 / 10;</span><br><span class="line">        System.out.println(f == d); // 输出：false，由于精度差异，比较结果为false</span><br><span class="line">        float d1 = 2131231231f;</span><br><span class="line"></span><br><span class="line">        // 定义一个float类型变量d2，将d1加1后的结果赋值给d2</span><br><span class="line">        float d2 = d1 + 1;</span><br><span class="line">        System.out.println(&quot;d1=&quot;+d1);</span><br><span class="line">        System.out.println(&quot;d2=&quot;+d2);</span><br><span class="line">        // 检查d1是否等于d2</span><br><span class="line">        if (d1 == d2) &#123;</span><br><span class="line">            // 如果d1等于d2，输出&quot;d1==d2&quot;</span><br><span class="line">            System.out.println(&quot;d1==d2&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果d1不等于d2，输出&quot;d1!=d2&quot;</span><br><span class="line">            System.out.println(&quot;d1!=d2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">false</span><br><span class="line">d1=2.13123123E9</span><br><span class="line">d2=2.13123123E9</span><br><span class="line">d1==d2</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p><em>1.浮点数一般都存在舍入误差，很多数字无法精确表示，其结果只能是接近，但不等于。</em></p><p><strong><em>2.避免比较中使用浮点数</em></strong></p><p><em>3.需要进行不产生舍入误差的精确数字计算，需要使用<strong>BigDecimal</strong>类</em></p><h4 id="1-2-BigDecimal类"><a href="#1-2-BigDecimal类" class="headerlink" title="1.2 BigDecimal类"></a><strong>1.2 BigDecimal类</strong></h4><p><strong>BigDecimal类：</strong>用于高精度数值运算的类，它允许你精确地表示和执行各种数学运算，包括加法、减法、乘法、除法等，而不会丢失精度。</p><p><strong>常用方法：</strong></p><p>1.BigDecimal(String val)：构造方法，将String类型转换成BigDecimal类型数据。</p><p>2.BigDecimal(double val)：构造方法，将double类型转换成BigDecimal类型数据。</p><p>3.BigDecimal(int val)：构造方法，将int类型转换成BigDecimal类型数据。</p><p>4.BigDecimal add(BigDecimal value)：加法，求两个BigDecimal类型数据的和。</p><p>5.BigDecimal subtract(BigDecimal value)：减法，求两个BigDecimal类型数据的差。</p><p>6.BigDecimal multiply(BigDecimal  value)：乘法，求两个BigDecimal类型数据的积。</p><p>7.BigDecimal divide(BigDecimal divisor)：除法，求两个BigDecimal类型数据的商。</p><p>8.BigDecimal remainder(BigDecimal divisor)：求余数，求BigDecimal类型数据除以divisor的余数。</p><p>9.BigDecimal max(BigDecimal value)：最大数，求两个BigDecimal类型数据的最大值。</p><p>10.BigDecimal min(BigDecimal value)：最小数，求两个BigDecimal类型数据的最小值。</p><p>11.BigDecimal abs()：绝对值，求BigDecimal类型数据的绝对值。</p><p>12.BigDecimal negate()：相反数，求BigDecimal类型数据的相反数。</p><p>13.BigDecimal compareTo()：比较两个BigDecimal 对象的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.math.BigDecimal;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal num1 = new BigDecimal(&quot;0.1&quot;);//字符串带双引号被解释为确切的数值,若不加会存在一个微小的舍入误差</span><br><span class="line">        BigDecimal num2 = new BigDecimal(&quot;0.2&quot;);</span><br><span class="line">        BigDecimal num3=num1.multiply(new BigDecimal(&quot;2&quot;));</span><br><span class="line">        BigDecimal sum = num1.add(num2);</span><br><span class="line">        System.out.println(num3.compareTo(num2));</span><br><span class="line">        System.out.println(&quot;sum=&quot;+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">0</span><br><span class="line">sum=0.3</span><br></pre></td></tr></table></figure><h3 id="2-Scanner对象"><a href="#2-Scanner对象" class="headerlink" title="2.Scanner对象"></a>2.Scanner对象</h3><h4 id="2-1-创建-Scanner-对象的基本语法："><a href="#2-1-创建-Scanner-对象的基本语法：" class="headerlink" title="2.1 创建 Scanner 对象的基本语法："></a>2.1 创建 Scanner 对象的基本语法：</h4><p><code>Scanner s = new Scanner(System.in)</code></p><p>通过 Scanner 类的 <strong>next()</strong> 或<strong>nextLine()</strong> 方法获取输入的字符串</p><p>读取前一般需要使用 <strong>hasNext()</strong> 或<strong>hasNextLine()</strong> 判断是否还有输入的数据</p><h4 id="2-2-next-amp-nextLine"><a href="#2-2-next-amp-nextLine" class="headerlink" title="2.2 next &amp; nextLine"></a>2.2 next &amp; nextLine</h4><p>使用<strong>next方式</strong>接收一下输入的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext()) &#123;</span><br><span class="line">            String token = scanner.next();</span><br><span class="line">            System.out.println(&quot;Next Token: &quot; + token);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in: </span><br><span class="line">hello world</span><br><span class="line">out:</span><br><span class="line">Next Token: hello</span><br><span class="line">Next Token: world</span><br></pre></td></tr></table></figure><p>使用<strong>nextLine方式</strong>接收一下输入的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNextLine()) &#123;</span><br><span class="line">            String token = scanner.nextLine();</span><br><span class="line">            System.out.println(&quot;Next Token: &quot; + token);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in:</span><br><span class="line">hello world</span><br><span class="line">out：</span><br><span class="line">Next Token: hello world</span><br></pre></td></tr></table></figure><p><strong>两者区别：</strong></p><p>1.next() 不能得到带有空格的字符串，nextLine()可以获得空白。</p><p>2.nextLine()：以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</p><h4 id="2-3-其他数据类型"><a href="#2-3-其他数据类型" class="headerlink" title="2.3 其他数据类型"></a>2.3 其他数据类型</h4><p>如果要输入int、float等类型的数据，在 Scanner 类中也有支持，使用<strong>hasNextXxx() 方法、 nextXxx() 方法</strong>来读取</p><h3 id="3-可变参数"><a href="#3-可变参数" class="headerlink" title="3.可变参数"></a>3.可变参数</h3><p><strong>可变参数的声明:</strong></p><p><code>typeName... parameterName</code></p><p><strong>注：一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Main&#123;</span><br><span class="line">    public static void printMax(double... num)&#123;</span><br><span class="line">        if(num.length==0)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;wrong!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        double result=0;</span><br><span class="line">        for (int i = 1; i &lt; num.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (num[i] &gt; result)</span><br><span class="line">            &#123; result = num[i]; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num[num.length-1]);</span><br><span class="line">    &#125;;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        printMax(1,2.3,5.0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">5.0</span><br></pre></td></tr></table></figure><h3 id="4-Arrays-类"><a href="#4-Arrays-类" class="headerlink" title="4.Arrays 类"></a>4.Arrays 类</h3><p>数组的工具类<strong>java.util.Arrays</strong></p><p><strong>常用功能：</strong></p><h4 id="4-1-打印数组"><a href="#4-1-打印数组" class="headerlink" title="4.1 打印数组"></a>4.1 打印数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        int []num=new int[10];</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            num[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure><h4 id="4-2-数组排序"><a href="#4-2-数组排序" class="headerlink" title="4.2 数组排序"></a>4.2 数组排序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        int []num= &#123;5,8,9,4,2&#125;;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        System.out.println(Arrays.toString(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[2, 4, 5, 8, 9]</span><br></pre></td></tr></table></figure><h4 id="4-3-二分法查找"><a href="#4-3-二分法查找" class="headerlink" title="4.3 二分法查找"></a>4.3 二分法查找</h4><p><strong>在进行此调用之前对数组进行排序(通 过sort方法等)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        int []num= &#123;5,8,9,4,2&#125;;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        System.out.println(&quot;索引为：&quot;+Arrays.binarySearch(num,4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">索引为：1</span><br></pre></td></tr></table></figure><h4 id="4-4-将数组转换成List集合"><a href="#4-4-将数组转换成List集合" class="headerlink" title="4.4 将数组转换成List集合"></a>4.4 将数组转换成List集合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int []num= &#123;5,2,9,4,2,3,10&#125;;</span><br><span class="line">List&lt;int[]&gt; list= Arrays.asList(num);</span><br></pre></td></tr></table></figure><h3 id="5-内部类"><a href="#5-内部类" class="headerlink" title="5.内部类"></a>5.内部类</h3><h4 id="5-1-成员内部类"><a href="#5-1-成员内部类" class="headerlink" title="5.1 成员内部类"></a>5.1 成员内部类</h4><p><strong>实例化内部类，首先需要实例化外部类，通过外部类去调用内部类</strong></p><p><em>注：成员内部类中不能写静态属性和方法</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ppublic class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1.实例化外部类</span><br><span class="line">        Outer out=new Outer();</span><br><span class="line">        //2.通过外部类调用内部类</span><br><span class="line">        Outer.Inner inObject = out.new Inner();</span><br><span class="line">        inObject.In();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Outer&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    public void out()&#123;</span><br><span class="line">        System.out.println(&quot;外部类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Outer()</span><br><span class="line">    &#123;</span><br><span class="line">        id=10;</span><br><span class="line">    &#125;</span><br><span class="line">    class Inner&#123;</span><br><span class="line">        private int id;</span><br><span class="line">        public void In()&#123;</span><br><span class="line">            System.out.println(&quot;内部类&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Inner()&#123;</span><br><span class="line">            id=1;</span><br><span class="line">            System.out.println(&quot;外部：&quot;+Outer.this.id);//Outer.this.显式调用外部类的变量</span><br><span class="line">            System.out.println(&quot;内部：&quot;+id);//内部类中的变量会暂时将外部类的成员变量给隐藏</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out：</span><br><span class="line">外部：10</span><br><span class="line">内部：1</span><br><span class="line">内部类</span><br></pre></td></tr></table></figure><h4 id="5-2-静态内部类"><a href="#5-2-静态内部类" class="headerlink" title="5.2 静态内部类"></a>5.2 静态内部类</h4><p>静态内部类能够直接被外部类给实例化，不需要使用外部类对象</p><p><strong>静态内部类只能访问自己属性和方法及外部类的静态属性和方法</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private static int outerStaticField = 42;</span><br><span class="line"></span><br><span class="line">    // 静态内部类</span><br><span class="line">    public static class StaticInnerClass &#123;</span><br><span class="line">        private int innerField;</span><br><span class="line"></span><br><span class="line">        public StaticInnerClass(int innerField) &#123;</span><br><span class="line">            this.innerField = innerField;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void printValues() &#123;</span><br><span class="line">            System.out.println(&quot;Outer static field: &quot; + outerStaticField);</span><br><span class="line">            System.out.println(&quot;Inner field: &quot; + innerField);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建静态内部类的实例</span><br><span class="line">        StaticInnerClass innerObj = new StaticInnerClass(10);</span><br><span class="line">        // 调用静态内部类的方法</span><br><span class="line">        innerObj.printValues();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-局部内部类"><a href="#5-3-局部内部类" class="headerlink" title="5.3 局部内部类"></a>5.3 局部内部类</h4><p><strong>局部内部类是在一个方法内部声明的一个类</strong></p><p>在局部内部类中，如果要<strong>访问局部变量</strong>，那么该<strong>局部变量</strong>要用<strong>final修饰</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class LocalInnerClassTest &#123;</span><br><span class="line">    // 外部类的成员变量</span><br><span class="line">    private String name;</span><br><span class="line">    private static int age;</span><br><span class="line">    LocalInnerClassTest(String name,int age)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">        this.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 外部类的实例方法</span><br><span class="line">    public void run() &#123;&#125;</span><br><span class="line">    // 外部类的静态方法</span><br><span class="line">    public static void go() &#123;&#125;</span><br><span class="line">    // 外部类的实例方法，包含局部内部类的定义</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        // 定义一个 final 局部变量</span><br><span class="line">        final String myname = &quot;xxx&quot;;</span><br><span class="line">        // 定义局部内部类 LocalInnerClass</span><br><span class="line">        class LocalInnerClass &#123;</span><br><span class="line">            // 局部内部类的成员变量</span><br><span class="line">            private String name;</span><br><span class="line">            // 局部内部类的方法，接受一个参数 name</span><br><span class="line">            public void test(String name) &#123;</span><br><span class="line">                // 在方法中访问参数 name</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                // 在局部内部类的成员方法中，可以使用 this 关键字访问局部内部类的成员变量</span><br><span class="line">                System.out.println(this.name);</span><br><span class="line">                // 在局部内部类中访问外部方法中的 final 变量 myname</span><br><span class="line">                System.out.println(myname);</span><br><span class="line">                // 在局部内部类中访问外部类的成员变量 name</span><br><span class="line">                System.out.println(LocalInnerClassTest.this.name);</span><br><span class="line">                // 在局部内部类中调用外部类的实例方法 run()</span><br><span class="line">                LocalInnerClassTest.this.run();</span><br><span class="line">                // 在局部内部类中调用外部类的静态方法 go()</span><br><span class="line">                LocalInnerClassTest.go();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 创建局部内部类的实例</span><br><span class="line">        LocalInnerClass lic = new LocalInnerClass();</span><br><span class="line">        // 修改局部内部类的成员变量 name</span><br><span class="line">        lic.name = &quot;tom&quot;;</span><br><span class="line">        // 调用局部内部类的方法 test()，传入参数 &quot;test&quot;</span><br><span class="line">        lic.test(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalInnerClassTest inner=new LocalInnerClassTest(&quot;wang&quot;,22);</span><br><span class="line">        inner.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">test</span><br><span class="line">tom</span><br><span class="line">xxx</span><br><span class="line">wang</span><br></pre></td></tr></table></figure><p><em>注：局部内部类不能通过外部类对象直接实例化，而是在方法中实例化出自己来，然后通过内部类对象调用自己类中的方法。</em></p><h4 id="5-4-匿名内部类"><a href="#5-4-匿名内部类" class="headerlink" title="5.4 匿名内部类"></a>5.4 匿名内部类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个接口</span><br><span class="line">interface Greeting &#123;</span><br><span class="line">    void greet();</span><br><span class="line">&#125;</span><br><span class="line">public class AnonymousInnerClassExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 使用匿名内部类创建实现 Greeting 接口并调用greet方法</span><br><span class="line">        new Greeting() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void greet() &#123;</span><br><span class="line">                System.out.println(&quot;Hello, world!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.greet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟环境命令</title>
      <link href="/posts/37951873.html"/>
      <url>/posts/37951873.html</url>
      
        <content type="html"><![CDATA[<p><strong>1.查看虚拟环境</strong><br>conda info —envs<br><strong>2.查看虚拟环境的Python版本</strong><br>python —version<br><strong>3.创建虚拟环境</strong><br>conda create —name 环境名<br><strong>4.激活环境</strong><br>conda activate 环境名<br><strong>5.使用pip下载特定版本的Python包</strong><br>pip install package_name==version_number<br><strong>6.查看虚拟环境中有哪些包</strong><br>conda list -n <env_name><br><strong>7.创建虚拟环境并安装python所需要的版本</strong><br>conda create -n your_env_name python=x.x<br><strong>8.删除虚拟环境</strong><br>conda env remove -n pytorch_env<br><strong>9.pip指定环境安装包</strong><br>pip install —target=/Anaconda/envs/env_name/Lib/site-packages -r requirements.txt</env_name></p>]]></content>
      
      
      <categories>
          
          <category> 模型训练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模型训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNeXt</title>
      <link href="/posts/260cf31a.html"/>
      <url>/posts/260cf31a.html</url>
      
        <content type="html"><![CDATA[<h2 id="UNeXt"><a href="#UNeXt" class="headerlink" title="UNeXt"></a>UNeXt</h2><h3 id="1-网络设计"><a href="#1-网络设计" class="headerlink" title="1.网络设计"></a>1.网络设计</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411246.png" alt="1" style="zoom: 67%;"></p><p>分成卷积阶段、标记化MLP阶段</p><p>编码器：进行两倍的下采样（2×2的最大池化层）</p><p>解码器：进行两倍的上采样（双线性插值），使用双线性插值而不是转置卷积，因为转置卷积基本上是可学习的上采样，会增加更多可学习参数。</p><p>C为超参数，一般取C1=32、C2=64、C3=128、C4=160、C5=256(C的取值比UNet小，<strong>减少了参数和计算</strong>)</p><p><strong>注：充分考虑了模型维度对参数量和计算量的影响，采用了更少的参数设计</strong></p><p><strong>卷积阶段：</strong>每个卷积块配备了一个卷积层、一个批量归一化层和ReLU激活函数，使用3×3的卷积核大小，步幅为1，填充为1，用于保持特征图的空间分辨率不变，同时允许网络学习提取不同位置的特征信息。</p><p><strong>Tokenized MLP Stage：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411888.png" alt="2" style="zoom:67%;"></p><p>​    <strong>Conv:</strong>kernel_size=3，stride=2，padding=1,同时输出通道数(E)大于输入通道数(E为超参数，token数量)，把特征图大小缩小了一半，增加了通道数</p><p>​    <strong>Shifted MLP：</strong>让模型更加关注 local 的信息</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411232.png" alt="3"></p><p>先使用0填充特征图，填充过后在通道维度做切割，再做平移操作，然后将各个切片合并在一起，最后提取特征图中间部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">xn = x.transpose(1, 2).view(B, C, H, W).contiguous()</span><br><span class="line">xn = F.pad(xn, (self.pad, self.pad, self.pad, self.pad) , &quot;constant&quot;, 0)</span><br><span class="line">xs = torch.chunk(xn, self.shift_size, 1)</span><br><span class="line">x_shift = [torch.roll(x_c, shift, 3) for x_c, shift in zip(xs, range(-self.pad, self.pad+1))]</span><br><span class="line">x_cat = torch.cat(x_shift, 1)</span><br><span class="line">x_cat = torch.narrow(x_cat, 2, self.pad, H)</span><br><span class="line">x_s = torch.narrow(x_cat, 3, self.pad, W)</span><br><span class="line">x_s = x_s.reshape(B,C,H*W).contiguous()</span><br><span class="line">x_shift_c = x_s.transpose(1,2)</span><br><span class="line">x = self.fc2(x_shift_c)</span><br><span class="line">x = self.drop(x)</span><br><span class="line">return x</span><br></pre></td></tr></table></figure><p>  <strong>DWConv：</strong>编码MLP特征的位置信息、减少运算量的作用</p><h3 id="2-实验结果及消融实验"><a href="#2-实验结果及消融实验" class="headerlink" title="2.实验结果及消融实验"></a>2.实验结果及消融实验</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411020.png" alt="4"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411855.png" alt="5"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符及类型转换</title>
      <link href="/posts/3446eac5.html"/>
      <url>/posts/3446eac5.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1.运算符"></a>1.运算符</h3><h4 id="1-1-单目运算符重载"><a href="#1-1-单目运算符重载" class="headerlink" title="1.1 单目运算符重载"></a>1.1 单目运算符重载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyNumber&#123;</span><br><span class="line">    private:</span><br><span class="line">        int value;</span><br><span class="line">    public:</span><br><span class="line">        MyNumber(int v):value(v)&#123;&#125;;</span><br><span class="line">        MyNumber&amp; operator++()//重载前置递增运算符++,前置递增运算符返回引用(允许修改原始对象并立即访问修改后的对象)</span><br><span class="line">        &#123;</span><br><span class="line">            value++;</span><br><span class="line">            return *this;</span><br><span class="line">        &#125;</span><br><span class="line">        MyNumber operator++(int)//重载后置递增运算符++，返回原始对象的副本，int 参数只是为了区分前置和后置递增运算符</span><br><span class="line">        &#123;</span><br><span class="line">            MyNumber temp(*this);</span><br><span class="line">            value++;</span><br><span class="line">            return temp;</span><br><span class="line">        &#125;</span><br><span class="line">        void display()</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;value:&quot;&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    MyNumber num(5);</span><br><span class="line">    MyNumber num2=num++;</span><br><span class="line">    num2.display();</span><br><span class="line">    num.display();</span><br><span class="line">    ++num;</span><br><span class="line">    num.display();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">value:5</span><br><span class="line">value:6</span><br><span class="line">value:7</span><br></pre></td></tr></table></figure><p><em>注：如果只想执行递增运算，可使用++ object，也可使用 object ++，但应选择前者，这样避免创建一个未被使用的临时拷贝。</em></p><h4 id="1-2-转换运算符"><a href="#1-2-转换运算符" class="headerlink" title="1.2 转换运算符"></a>1.2 转换运算符</h4><p><strong>转换运算符 const char* ：</strong>对象的内容转换成 cout 能够接受的类型（const char*）</p><p><strong>ostringstream：</strong>属于 <code>&lt;sstream&gt;</code> 头文件，并提供了将各种数据类型（如整数、浮点数、字符串等）转换为字符串的能力</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt; // 用于 ostringstream</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 自定义日期类</span><br><span class="line">class Date &#123;</span><br><span class="line">private:</span><br><span class="line">    int day, month, year;</span><br><span class="line">    string dateInString;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 构造函数，用于初始化日期对象</span><br><span class="line">    Date(int inMonth, int inDay, int inYear) : month(inMonth), day(inDay), year(inYear) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 类型转换运算符，将日期对象转换为 const char* 类型的指针</span><br><span class="line">    operator const char*() &#123;</span><br><span class="line">        ostringstream formattedDate; // 辅助构建字符串</span><br><span class="line">        formattedDate &lt;&lt; month &lt;&lt; &quot; / &quot; &lt;&lt; day &lt;&lt; &quot; / &quot; &lt;&lt; year;</span><br><span class="line">        dateInString = formattedDate.str();</span><br><span class="line">        return dateInString.c_str();//dateInString.c_str(),返回一个 const char* 类型的指针</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建日期对象，表示圣诞节的日期</span><br><span class="line">    Date Holiday(12, 25, 2016);</span><br><span class="line"></span><br><span class="line">    // 直接输出日期对象，由于重载了类型转换运算符，它将自动转换为字符串并输出</span><br><span class="line">    cout &lt;&lt; &quot;Holiday is on: &quot; &lt;&lt; Holiday &lt;&lt; endl;</span><br><span class="line">    // 下面是其他使用示例的注释部分</span><br><span class="line">    // string strHoliday(Holiday); // 可行!</span><br><span class="line">    // strHoliday = Date(11, 11, 2016); // 也是可行的!</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-双目运算符重载"><a href="#1-3-双目运算符重载" class="headerlink" title="1.3 双目运算符重载"></a>1.3 双目运算符重载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Complex &#123;</span><br><span class="line">private:</span><br><span class="line">    double real;</span><br><span class="line">    double imaginary;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Complex(double r, double i) : real(r), imaginary(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 重载加法运算符 +</span><br><span class="line">    Complex operator+(const Complex&amp; other) &#123;</span><br><span class="line">        double newReal = real + other.real;</span><br><span class="line">        double newImaginary = imaginary + other.imaginary;</span><br><span class="line">        return Complex(newReal, newImaginary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打印复数的成员函数</span><br><span class="line">    void display() &#123;</span><br><span class="line">        std::cout &lt;&lt; real &lt;&lt; &quot; + &quot; &lt;&lt; imaginary &lt;&lt; &quot;i&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Complex num1(3.0, 4.0);</span><br><span class="line">    Complex num2(1.0, 2.0);</span><br><span class="line"></span><br><span class="line">    Complex sum = num1 + num2; // 使用重载的 + 运算符</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Sum: &quot;;</span><br><span class="line">    sum.display();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Sum: 4 + 6i</span><br></pre></td></tr></table></figure><h4 id="1-4-重载下标运算符"><a href="#1-4-重载下标运算符" class="headerlink" title="1.4 重载下标运算符"></a>1.4 重载下标运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyArray &#123;</span><br><span class="line">private:</span><br><span class="line">    int arr[10]; // 假设数组大小为 10</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 重载下标运算符 []</span><br><span class="line">    int&amp; operator[](int index) &#123;</span><br><span class="line">        if (index &lt; 0 || index &gt;= 10) &#123;</span><br><span class="line">            throw std::out_of_range(&quot;Index out of range&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyArray myArray;</span><br><span class="line"></span><br><span class="line">    // 初始化数组元素</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        myArray[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用下标运算符 [] 访问数组元素并输出</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;myArray[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; myArray[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">myArray[0] = 0</span><br><span class="line">myArray[1] = 1</span><br><span class="line">myArray[2] = 2</span><br><span class="line">myArray[3] = 3</span><br><span class="line">myArray[4] = 4</span><br><span class="line">myArray[5] = 5</span><br><span class="line">myArray[6] = 6</span><br><span class="line">myArray[7] = 7</span><br><span class="line">myArray[8] = 8</span><br><span class="line">myArray[9] = 9</span><br></pre></td></tr></table></figure><h4 id="1-5-函数运算符-operator"><a href="#1-5-函数运算符-operator" class="headerlink" title="1.5 函数运算符 operator()"></a>1.5 函数运算符 operator()</h4><p><strong>operator()</strong>让对象像函数，被称为函数运算符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义一个类 Display</span><br><span class="line">class Display &#123;</span><br><span class="line">public:</span><br><span class="line">    // 重载函数调用运算符 ()，用于输出传入的字符串</span><br><span class="line">    void operator () (string input) const &#123;//const: 这个关键字表示该运算符函数是一个常量成员函数，告诉编译器在函数内部不会修改对象的状态。</span><br><span class="line">        cout &lt;&lt; input &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    // 创建 Display 类的对象 displayFuncObj</span><br><span class="line">    Display displayFuncObj;</span><br><span class="line">    // 使用函数调用运算符 () 调用 displayFuncObj，传入字符串参数</span><br><span class="line">    displayFuncObj(&quot;Display this string! &quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Display this string!</span><br></pre></td></tr></table></figure><h3 id="2-类型转换运算符"><a href="#2-类型转换运算符" class="headerlink" title="2.类型转换运算符"></a>2.类型转换运算符</h3><h4 id="2-1-static-cast"><a href="#2-1-static-cast" class="headerlink" title="2.1 static_cast"></a>2.1 static_cast</h4><p><strong>static_cast:</strong>显式地将一种数据类型转换为另一种数据类型,在执行转换时会进行<strong>编译时</strong>类型检查，以确保类型转换是合法的。</p><p><strong>static_cast</strong>的语法如下：</p><p><code>new_type static_cast&lt;new_type&gt;(expression)</code></p><p>其中：</p><ul><li><code>new_type</code> 表示要进行的目标类型（目标数据类型）。</li><li><code>expression</code> 是要转换的表达式或值。</li></ul><p><strong>主要用途:</strong></p><ul><li><p><strong>基本数据类型之间的转换(主要用途）</strong>：如整数到浮点数，浮点数到整数，以及其他基本数据类型之间的转换。</p></li><li><p>指针类型之间的转换：在执行时<strong>不会进行运行时检查</strong>，因此应该谨慎使用</p></li><li><p>类之间的转换：可以用于父类和子类之间的转换，但它<strong>不执行运行时检查</strong>，因此应谨慎使用。</p></li><li><p>枚举类型的转换：可以用于枚举类型之间的转换。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123; /* ... */ &#125;;</span><br><span class="line">class Child : public Parent &#123; /* ... */ &#125;;</span><br><span class="line"></span><br><span class="line">Parent* parentPtr = new Child();</span><br><span class="line">Child* childPtr = static_cast&lt;Child*&gt;(parentPtr); // 将父类指针转换为子类指针</span><br></pre></td></tr></table></figure><h4 id="2-2-dynamic-cast"><a href="#2-2-dynamic-cast" class="headerlink" title="2.2 dynamic_cast"></a>2.2 dynamic_cast</h4><p><strong>dynamic_cast：</strong>主要用于在继承关系中进行安全的<strong>运行时</strong>类型识别和类型转换。</p><p><strong>dynamic_cast</strong> 的语法如下：</p><p><code>dynamic_cast&lt;new_type&gt;(expression)</code> </p><p>其中：</p><ul><li><code>new_type</code> 表示要进行的目标类型（目标数据类型）。</li><li><code>expression</code> 是要转换的指针或引用。</li></ul><p><strong>dynamic_cast</strong>的主要用途如下：</p><ul><li><strong>用于多态类型的安全类型转换</strong>：<code>dynamic_cast</code> 主要用于处理多态类的情况</li></ul><p><strong>*注：dynamic_cast</strong>会在运行时检查是否可以进行安全的类型转换。如果转换不合法（例如，试图将基类指针转换为未与之相关的派生类指针），则<strong>会返回空指针</strong>（对于指针）或引发 <strong>std::bad_cast</strong>异常（对于引用）。*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void speak() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Animal speaks&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Dog : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void speak() override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Dog barks&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Animal* animal = new Dog();</span><br><span class="line"></span><br><span class="line">    // 使用 dynamic_cast 将基类指针转换为派生类指针</span><br><span class="line">    Dog* dog = dynamic_cast&lt;Dog*&gt;(animal);</span><br><span class="line"></span><br><span class="line">    if (dog) &#123;</span><br><span class="line">        // 转换成功，现在可以安全地调用 Dog 类的函数</span><br><span class="line">        dog-&gt;speak();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 转换失败</span><br><span class="line">        std::cout &lt;&lt; &quot;Failed to cast to Dog&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete animal;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">Dog barks</span><br></pre></td></tr></table></figure><h4 id="2-3-const-cast"><a href="#2-3-const-cast" class="headerlink" title="2.3 const_cast"></a>2.3 const_cast</h4><p><strong>const_cast:</strong>用于在一定情况下去除对象的常量性,可以添加或移除对象的 <code>const</code> 限定符，从而改变对象的常量属性。</p><p><strong>const_cast:</strong>的语法如下：</p><p><code>const_cast&lt;new_type&gt;(expression)</code> </p><p>其中：</p><ul><li><code>new_type</code> 表示要进行的目标类型（目标数据类型）。</li><li><code>expression</code> 是要转换的指针、引用或对象。</li></ul><p><strong>注：</strong></p><p><strong>1.const_cast:</strong>主要用于去除对象的 <code>const</code> 限定符，使其变为非常量对象，从而允许对其进行修改。</p><p><strong>2.const_cast:</strong>不会修改对象的实际值，只是修改了对象的类型属性。</p><p><strong>主要用途：</strong>用于解决某些兼容性问题，例如调用老式库函数，这些函数不将参数标记为常量，但实际上不会修改它们。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int value = 42;</span><br><span class="line">    int* nonConstPtr = const_cast&lt;int*&gt;(&amp;value);</span><br><span class="line">    *nonConstPtr = 100; // 合法，修改了原本是常量的对象</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swin-Transformer</title>
      <link href="/posts/4b223b72.html"/>
      <url>/posts/4b223b72.html</url>
      
        <content type="html"><![CDATA[<h2 id="Swin-Transformer"><a href="#Swin-Transformer" class="headerlink" title="Swin-Transformer"></a>Swin-Transformer</h2><h3 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1.网络结构"></a>1.网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201409143.png" alt="1"></p><p><em>注：使用Transformer取代卷积操作是因为卷积操作在每个位置只关注输入图像的局部感受野，即一个固定大小的区域，而难以有效地捕捉全局信息，Transformer架构引入了自注意力机制，允许模型在一定范围内建立像素之间的关联，可以更好地处理全局信息</em>。</p><h3 id="2-W-MSA"><a href="#2-W-MSA" class="headerlink" title="2.W-MSA"></a>2.W-MSA</h3><p>使用窗口多头自注意力，将输入的图片划分成不重叠的窗口，在这样的局部的窗口中计算自注意力，减少计算量，其对于图像的大小具有<strong>线性的复杂度</strong></p><p>$Ω(MSA) = 4hwC^2 + 2(hw)^2C; (1)$<br>$Ω(W-MSA) = 4hwC^2 + 2M^2hwC; (2)$</p><p><strong>注：</strong></p><p>h,w:输入图像的高,宽</p><p>M:一个窗口中含有MxM个patch</p><p>C：超参数（linear embedding将patch的特征维度变成C)</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201409740.png" alt="6"></p><h3 id="3-SW-MSA"><a href="#3-SW-MSA" class="headerlink" title="3.SW-MSA"></a>3.SW-MSA</h3><p>虽然基于窗口计算自注意力能够很好的解决计算量大的问题，但是现在<strong>窗口与窗口之间没有联系</strong>，就达不到全局建模的能力，所以作者就提出了<strong>移动窗口</strong>的方式去解决</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201409940.png" alt="4" style="zoom: 80%;"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201409148.png" alt="7" style="zoom: 80%;"></p><p><strong>从Layer1移动到Layer1+1后存在的问题：</strong>每个窗口中的patch数量不同，窗口数增大了，会影响计算效率</p><p><strong>解决方法：cyclic shift+MSA-masked</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201410145.png" alt="5" style="zoom: 50%;"></p><p><strong>循环移位：</strong>将A、C先向下拼接，再将B、A向右拼接。通过循环移位将窗口的数目再一次地拼成4个，控制了计算复杂度，但产生了新的问题：同一个窗口中的patch来自于不同的区域，而来自于不同区域的patch之间不应该计算自注意力。</p><p><strong>MSA-masked：</strong>对于一个patch，得到这个patch的attention（Q、K、V），将这个patch的Q与其他patch的K点乘，如果这两个patch来自于不同的区域，那么将点乘的结果减100，那么结果将是一个负数，再经过softmax处理后映射得到的权值接近于0</p><h3 id="4-patch-merging"><a href="#4-patch-merging" class="headerlink" title="4.patch merging"></a>4.patch merging</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201410582.png" alt="8" style="zoom: 67%;"></p><p><strong>patch merging:</strong>进行下采样，用于缩小分辨率，调整通道数进而形成层次化的设计</p><h3 id="5-Relative-position-bias（相对位置偏置）"><a href="#5-Relative-position-bias（相对位置偏置）" class="headerlink" title="5.Relative position bias（相对位置偏置）"></a>5.Relative position bias（相对位置偏置）</h3><p><strong>偏置B:</strong>让attention map进一步有所偏重，在进行Attention计算时考虑到像素间的位置关系。</p><p>偏置B是由将像素与像素间的相对位置进行编码然后通过查找偏置表得到的。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310212045328.png" alt="9" style="zoom: 80%;"></p><h2 id="Swin-Unet"><a href="#Swin-Unet" class="headerlink" title="Swin-Unet"></a>Swin-Unet</h2><p><img src="https://typoraimg.wangak.cc/2023/img/202310201410888.png" alt="11"></p><p><strong>编码器:</strong>工作原理和 Swin-Transformer完全一样的。其中，Patch Merging模块的作用是在每个Swin-Transformer模块开头来降低图片分辨率。</p><p><strong>解码器：</strong>Patch Expanding将相邻维度的特征图重塑为更高分辨率的特征图(2×上采样)，并相应地将特征维数减半。</p><p><strong>Patch Expanding:</strong></p><p>​       在上采样之前，在输入特征上加一个线性层,将特征维数增加到原始维数的2倍,利用重排操作将输入特征的分辨率扩展为输入分辨率的2倍，将特征维数降低为输入维数的1/4。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class PatchExpand(nn.Module): </span><br><span class="line">    def __init__(self, input_resolution, dim, dim_scale=2, norm_layer=nn.LayerNorm):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.input_resolution = input_resolution</span><br><span class="line">        self.dim = dim</span><br><span class="line">        self.expand = nn.Linear(dim, 2*dim, bias=False) if dim_scale==2 else nn.Identity()#如果dim_scale是2则执行nn.Linear()，不是则执行直接映射</span><br><span class="line">        self.norm = norm_layer(dim // dim_scale)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line"></span><br><span class="line">        H, W = self.input_resolution</span><br><span class="line">        x = self.expand(x)</span><br><span class="line">        B, L, C = x.shape</span><br><span class="line">        assert L == H * W, &quot;input feature has wrong size&quot;</span><br><span class="line"></span><br><span class="line">        x = x.view(B, H, W, C)</span><br><span class="line">        x = rearrange(x, &#x27;b h w (p1 p2 c)-&gt; b (h p1) (w p2) c&#x27;, p1=2, p2=2, c=C//4)</span><br><span class="line">        x = x.view(B,-1,C//4)</span><br><span class="line">        x= self.norm(x.clone())</span><br><span class="line"></span><br><span class="line">        return x</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RNN</title>
      <link href="/posts/6fe72dd0.html"/>
      <url>/posts/6fe72dd0.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-RNN-递归神经网络"><a href="#1-RNN-递归神经网络" class="headerlink" title="1.RNN(递归神经网络)"></a>1.RNN(递归神经网络)</h3><p><strong>RNN:</strong>用于处理<strong>序列</strong>数据和<strong>时间</strong>序列数据。RNN具有循环连接，允许信息在网络内部传递。</p><h4 id="1-1-RNN的结构："><a href="#1-1-RNN的结构：" class="headerlink" title="1.1 RNN的结构："></a>1.1 RNN的结构：</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202310201406368.png" alt="1"></p><p>注：<strong>权重矩阵</strong> W就是<strong>隐藏层</strong>上一次的值作为这一次的输入的权重</p><h4 id="1-2-RNN的优劣"><a href="#1-2-RNN的优劣" class="headerlink" title="1.2  RNN的优劣"></a>1.2  RNN的优劣</h4><p><strong>RNN的主要优点包括：</strong></p><p><strong>1.处理序列数据：</strong>RNN能够有效地处理变长序列数据，因为它的隐藏状态可以捕获先前时间步的信息。</p><p><strong>2.上下文理解：</strong>RNN能够理解上下文信息。</p><p><strong>RNN的缺点：</strong></p><p><strong>1.长期依赖问题：</strong>由于梯度消失或梯度爆炸的问题，传统的RNN在处理长序列时可能会失去对远距离时间步的依赖性。</p><p><strong>2.计算效率：</strong>RNN的计算效率较低，难以处理大规模数据和长序列。</p><h3 id="2-LSTM-长短期记忆"><a href="#2-LSTM-长短期记忆" class="headerlink" title="2.LSTM(长短期记忆)"></a>2.LSTM(长短期记忆)</h3><p><strong>LSTM:</strong>为了解决RNN在长序列训练过程中的梯度消失和梯度爆炸问题。</p><h4 id="2-1-LSTM的结构原理："><a href="#2-1-LSTM的结构原理：" class="headerlink" title="2.1 LSTM的结构原理："></a>2.1 LSTM的结构原理：</h4><p>输入：Z、输入门$Z_i$、输出门 $Z_o$、遗忘门 $Z_f$</p><p>输出：a</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201406702.png" alt="2"></p><p>输入门$Z_i$:决定了哪些新信息要被存储到细胞状态中。它也考虑前一个时间步的隐藏状态和当前时间步的输入，以及一个候选值，用于更新细胞状态。</p><p>遗忘门 $Z_f$:决定了哪些信息要被遗忘或丢弃。输出一个介于0和1之间的值，表示要保留多少以前的信息。</p><p>输出门 $Z_o$:决定哪些将会被当成当前状态的输出。</p><p>细胞状态:在LSTM中负责存储和传递信息，以便于捕获长期依赖关系。</p><h4 id="2-2-LSTM的工作流程"><a href="#2-2-LSTM的工作流程" class="headerlink" title="2.2 LSTM的工作流程"></a>2.2 LSTM的工作流程</h4><p><strong>1.遗忘门的输出（$f_t$)</strong>:</p><script type="math/tex; mode=display">f_t=σ(W_{xf}x_t+W_{hf}h_{t−1}+b_f)</script><p><img src="https://typoraimg.wangak.cc/2023/img/202310201406010.png" alt="3"></p><p><strong>2.候选细胞状态（$\tilde{C}$）及输入门（$i_t$）</strong></p><script type="math/tex; mode=display">\tilde{C}=tanh(W_{xc}x_t+W_{hc}h_{t−1}+b_c)</script><script type="math/tex; mode=display">i_t=σ(W_{xi}x_t+W_{hi}h_{t−1}+b_i)</script><p><img src="https://typoraimg.wangak.cc/2023/img/202310201406785.png" alt="4"></p><p><strong>3.更新状态值($C_t$)</strong></p><script type="math/tex; mode=display">C_t=f_t⋅C_{t−1}+i_t⋅\tilde{C}</script><p><img src="https://typoraimg.wangak.cc/2023/img/202310201406751.png" alt="5"></p><p><strong>4.输出</strong></p><script type="math/tex; mode=display">o_t=σ(W_{xo}x_t+W_{ho}h_{t−1}+b_o)</script><script type="math/tex; mode=display">h_t=o_t⋅tanh(C_t)</script><p><img src="https://typoraimg.wangak.cc/2023/img/202310201407980.png" alt="6"></p><p><strong>注：</strong></p><p>​      <strong>*利用tanh来映射细胞状态信息的原因</strong>：tanh函数其输出在-1-1之间，这与大多数场景下特征分布是0中心的吻合。tanh函数在输入为0附近相比 Sigmoid函数有更大的梯度，通常使模型收敛更快。*</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RNN </tag>
            
            <tag> LSTM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用损失函数</title>
      <link href="/posts/60adb68d.html"/>
      <url>/posts/60adb68d.html</url>
      
        <content type="html"><![CDATA[<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><h3 id="1-损失函数的概念及使用场景"><a href="#1-损失函数的概念及使用场景" class="headerlink" title="1.损失函数的概念及使用场景"></a>1.损失函数的概念及使用场景</h3><p><strong>损失函数：</strong>用于衡量模型预测结果与真实结果之间的差异或误差。</p><p><strong>损失函数的使用场景：</strong></p><ul><li><p><strong>模型训练：</strong>通过最小化损失函数，可以调整模型的参数，使其能够更好地拟合训练数据，提高模型的性能。</p></li><li><p><strong>模型评估：</strong>通过计算模型在验证集或测试集上的损失值，可以判断模型的泛化能力和预测准确度，较小的损失值通常表示模型更好地适应了新数据。</p></li><li><p><strong>优化算法：</strong>通过计算损失函数对模型参数的梯度，可以确定参数的更新方向和步长，以便优化模型。</p></li><li><p><strong>模型选择和比较：</strong>选择合适的损失函数可以帮助优化模型性能，并对不同模型进行比较和选择。</p></li></ul><h3 id="2-分类任务"><a href="#2-分类任务" class="headerlink" title="2.分类任务"></a>2.分类任务</h3><h4 id="2-1-交叉熵损失函数（Cross-Entropy-Loss）"><a href="#2-1-交叉熵损失函数（Cross-Entropy-Loss）" class="headerlink" title="2.1 交叉熵损失函数（Cross-Entropy Loss）"></a>2.1 交叉熵损失函数（Cross-Entropy Loss）</h4><p><strong>二分类问题：</strong>二元交叉熵损失函数（Binary Cross-Entropy Loss）</p><ul><li><p>计算公式：<script type="math/tex">\large L(y, p) = -[y * log(p) + (1 - y) * log(1 - p)]</script></p><p> <em>注：真实标签为 y（可以是0或1），模型的预测概率为 p（0 ≤ p ≤ 1）</em></p></li></ul><p><strong>多分类问题：</strong>多元交叉熵损失函数（Multiclass Cross-Entropy Loss）</p><p>​        在多元交叉熵损失函数中，假设有 C 个可能的类别，每个类别都有一个与之相关的标签（通常使用 one-hot 编码）。对于每个样本，模型会输出一个长度为 C 的概率分布向量，表示样本属于每个类别的概率。</p><ul><li>计算公式：$\large L(y, p) = -Σ(y_i * log(p_i))$</li></ul><p><em>注：其中，i 表示类别的索引，$y_i$ 表示真实标签的第 i 个元素，$p_i$ 表示模型的输出概率分布的第 i 个元素。</em></p><h4 id="2-2-Focal-Loss（聚焦损失）"><a href="#2-2-Focal-Loss（聚焦损失）" class="headerlink" title="2.2 Focal Loss（聚焦损失）"></a>2.2 Focal Loss（聚焦损失）</h4><p><strong>Focal Loss:</strong>用于处理类别不平衡问题的损失函数,旨在解决当某些类别的样本数量远远多于其他类别时，传统的交叉熵损失函数会受到类别不平衡的影响，导致模型难以有效地学习少数类别。</p><p><strong>focal loss的具体形式：</strong><script type="math/tex">\large-\alpha(1-y_{pred})^{\gamma}y_{true}log(y_{pred})-(1-\alpha)y_{pred}^{\gamma}(1-y_{true})log(1-y_{pred})</script></p><p><strong>注：</strong></p><p><em>1.$\large\gamma$通常设置为2，$\large(1-y_{pred})^{\gamma}$相当于样本的难易度权值,$\large\alpha$为正负样本的比例</em></p><p><em>2.为了防止难易样本的频繁变化，应当选取小的学习率。防止学习率过大，造成w变化较大从而引起 $\large y_{pred}$的巨大变化，造成难易样本的改变。</em></p><h3 id="3-回归任务"><a href="#3-回归任务" class="headerlink" title="3.回归任务"></a>3.回归任务</h3><h4 id="3-1-均方误差损失函数（Mean-Squared-Error-MSE）"><a href="#3-1-均方误差损失函数（Mean-Squared-Error-MSE）" class="headerlink" title="3.1 均方误差损失函数（Mean Squared Error, MSE）"></a>3.1 均方误差损失函数（Mean Squared Error, MSE）</h4><p><strong>计算公式：</strong>$\large MSE = (1/N) * Σ(y_i - ŷ_i)^2$</p><p>注：N 表示样本数量，$y_i$ 表示真实标签，$ŷ_i$ 表示模型的预测值。</p><h4 id="3-2-平均绝对误差损失函数（Mean-Absolute-Error-MAE"><a href="#3-2-平均绝对误差损失函数（Mean-Absolute-Error-MAE" class="headerlink" title="3.2 平均绝对误差损失函数（Mean Absolute Error, MAE)"></a>3.2 平均绝对误差损失函数（Mean Absolute Error, MAE)</h4><p><strong>计算公式：</strong>$\large MAE = (1/N) * Σ|y_i - ŷ_i|$</p><p>注：N 表示样本数量，$y_i$ 表示真实标签，$ŷ_i$ 表示模型的预测值。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 损失函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nnUnet</title>
      <link href="/posts/544635d8.html"/>
      <url>/posts/544635d8.html</url>
      
        <content type="html"><![CDATA[<h2 id="nnUnet"><a href="#nnUnet" class="headerlink" title="nnUnet"></a>nnUnet</h2><h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1.预处理"></a>1.预处理</h3><h4 id="1-1-Crop"><a href="#1-1-Crop" class="headerlink" title="1.1 Crop"></a>1.1 Crop</h4><p><strong>Crop:</strong>裁剪去除图片的0区域，使用非0区域作为训练数据，对MRI数据能够显著降低其大小。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405330.png" alt="1"></p><h4 id="1-2-Resample"><a href="#1-2-Resample" class="headerlink" title="1.2 Resample"></a>1.2 Resample</h4><p><strong>Resample:</strong>CNN无法理解体素间距的概念，重采样使得数据集体素间距一致（使像素间所对应的真实的物理距离一致）。</p><p><em>注：在医学图像中要关注图像的物理距离，这关系到器官的大小。</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405296.png" alt="2"></p><h3 id="2-训练"><a href="#2-训练" class="headerlink" title="2.训练"></a>2.训练</h3><h4 id="2-1-Patch-Sampling"><a href="#2-1-Patch-Sampling" class="headerlink" title="2.1 Patch-Sampling:"></a>2.1 Patch-Sampling:</h4><p><strong>Patch-Training:</strong>对不同的图像裁剪固定的大小，组成一个batch进行训练（用于解决在统一体素间距后，出现的数据分辨率不一致的问题）。</p><p><strong>Sampling：</strong>为了防止Patch中的数据全部是背景，保证batch中的数据有1/3包含前景。</p><h4 id="2-2-Cross-Validation"><a href="#2-2-Cross-Validation" class="headerlink" title="2.2 Cross-Validation"></a>2.2 Cross-Validation</h4><p><strong>nnUnet</strong>在训练集上使用<strong>五折交叉验证</strong>进行评估</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405943.png" alt="3"></p><h3 id="3-网络设计"><a href="#3-网络设计" class="headerlink" title="3.网络设计"></a>3.网络设计</h3><p>nnUnet与Unet的结构类似，但<strong>nnUnet</strong>会根据数据集<strong>自适应调整网络结构</strong>。</p><h4 id="3-1-Cascade-Unet"><a href="#3-1-Cascade-Unet" class="headerlink" title="3.1 Cascade-Unet"></a>3.1 Cascade-Unet</h4><p><strong>Cascade-Unet:</strong>使用patch-training，不完整的图片导致感受野受限，为了解决该问题，设计出Cascade-Unet。</p><p><strong>Cascade-Unet的两个阶段：</strong></p><p><strong>1.对输入图片下采样，使用下采样的图片得到粗糙的分割结果</strong></p><p><strong>2.将第一阶段的分割结果上采样，然后与原图concat，使用patch训练</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405010.png" alt="4"></p><h4 id="3-2-网络自适应调整"><a href="#3-2-网络自适应调整" class="headerlink" title="3.2 网络自适应调整"></a>3.2 网络自适应调整</h4><p><strong>nnUnet：</strong>先统一体素间距，然后根据数据集计算网络的输入分辨率并确定网络的结构及参数。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405038.png" alt="5"></p><h3 id="4-后处理"><a href="#4-后处理" class="headerlink" title="4.后处理"></a>4.后处理</h3><p><strong>保留最大连通区域</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405154.png" alt="6"></p><p>上图：<strong>蓝色（前景）、黄色（预测的结果）</strong></p><p><strong>出现的问题：</strong>第一次处理使的模型的性能下降，第二次处理使得模型的性能提高。</p><p><strong>解决方法：</strong>在训练过程中，分别对使用后处理和不使用后处理得到两个精度，然后通过对比结果，决定是否使用后处理。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405294.png" alt="7"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
            <tag> Unet系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（2）</title>
      <link href="/posts/679d2361.html"/>
      <url>/posts/679d2361.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-复制函数"><a href="#1-复制函数" class="headerlink" title="1.复制函数"></a>1.复制函数</h3><h4 id="1-1-浅复制"><a href="#1-1-浅复制" class="headerlink" title="1.1 浅复制"></a>1.1 浅复制</h4><p><strong>浅复制：</strong>仅复制对象的成员变量的值，而不复制对象中的指针所指向的内容。</p><p><em>注：如果原始对象中包含指针，浅复制将导致多个对象共享同一内存块，从而可能引发潜在的问题。当原始对象的析构函数被调用时，如果没有适当地管理共享资源，可能会导致重复释放内存或内存泄漏等问题。</em></p><h4 id="1-2-深复制"><a href="#1-2-深复制" class="headerlink" title="1.2 深复制"></a>1.2 深复制</h4><p><strong>深复制：</strong>不仅复制对象的成员变量的值，还要递归地复制对象中的指针所指向的内容，创建一个全新的数据拷贝。</p><p><em>注：新对象与原始对象彼此独立，<strong>不共享内存块</strong>，但需要更多的计算和内存开销。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt; </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std; </span><br><span class="line">class String&#123;</span><br><span class="line">  private:</span><br><span class="line">    char *data;</span><br><span class="line">  public:</span><br><span class="line">    String(const char *str)</span><br><span class="line">    &#123;</span><br><span class="line">      data=new char[strlen(str)]+1;</span><br><span class="line">      strcpy(data,str);</span><br><span class="line">    &#125;</span><br><span class="line">    // String(const String &amp;other)//浅复制</span><br><span class="line">    // &#123;</span><br><span class="line">    //   data=other.data;</span><br><span class="line">    // &#125;</span><br><span class="line">    String(const String &amp;other)//深复制</span><br><span class="line">    &#123;</span><br><span class="line">      data=new char[strlen(other.data)+1];</span><br><span class="line">      strcpy(data,other.data);</span><br><span class="line">    &#125;</span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">      delete []data;</span><br><span class="line">    &#125;</span><br><span class="line">    void printData()</span><br><span class="line">    &#123;</span><br><span class="line">      cout&lt;&lt;data&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  String Str0(&quot;Hello&quot;);</span><br><span class="line">  String Str1(Str0);</span><br><span class="line">  Str1.printData();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-复制构造函数-拷贝"><a href="#1-3-复制构造函数-拷贝" class="headerlink" title="1.3 复制构造函数(拷贝)"></a>1.3 复制构造函数(拷贝)</h4><p><strong>构造函数委托:</strong>允许一个构造函数调用同一类的另一个构造函数来完成对象的初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyString</span><br><span class="line">&#123;</span><br><span class="line">  private:</span><br><span class="line">    char * _data;</span><br><span class="line">  public:</span><br><span class="line">    MyString(const char* s=&quot;&quot;)</span><br><span class="line">    :_data(nullptr)//初始化_data成员变量为nullptr</span><br><span class="line">    &#123;</span><br><span class="line">      if(s)&#123;</span><br><span class="line">        size_t n=strlen(s)+1;</span><br><span class="line">        _data=new char[n];</span><br><span class="line">        memcpy(_data,s,n);</span><br><span class="line">      &#125;</span><br><span class="line">      cout&lt;&lt;&quot;create&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">  ~MyString()</span><br><span class="line">  &#123;</span><br><span class="line">    cout&lt;&lt;&quot;delete&quot;&lt;&lt;endl;</span><br><span class="line">    delete[] _data;</span><br><span class="line">  &#125;</span><br><span class="line">  MyString(const MyString &amp;other)//复制构造函数(使用构造函数委托来重用构造函数)</span><br><span class="line">  :MyString(other._data)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;copy constructor&quot;&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  MyString str(&quot;hello&quot;);</span><br><span class="line">  MyString str2(str);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">create</span><br><span class="line">create</span><br><span class="line">copy constructor</span><br><span class="line">delete</span><br><span class="line">delete</span><br></pre></td></tr></table></figure><h4 id="1-4-移动构造函数（移动）"><a href="#1-4-移动构造函数（移动）" class="headerlink" title="1.4 移动构造函数（移动）"></a>1.4 移动构造函数（移动）</h4><p><strong>移动构造函数:</strong>一个对象的资源从一个对象转移到另一个对象，而无需进行深层次的复制操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyString</span><br><span class="line">&#123;</span><br><span class="line">  private:</span><br><span class="line">    char * _data;</span><br><span class="line">  public:</span><br><span class="line">    MyString(const char* s=&quot;&quot;)</span><br><span class="line">    :_data(nullptr)//初始化_data成员变量为nullptr</span><br><span class="line">    &#123;</span><br><span class="line">      if(s)&#123;</span><br><span class="line">        size_t n=strlen(s)+1;</span><br><span class="line">        _data=new char[n];</span><br><span class="line">        memcpy(_data,s,n);</span><br><span class="line">      &#125;</span><br><span class="line">      cout&lt;&lt;&quot;create&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">  ~MyString()</span><br><span class="line">  &#123;</span><br><span class="line">    cout&lt;&lt;&quot;delete&quot;&lt;&lt;endl;</span><br><span class="line">    delete[] _data;</span><br><span class="line">  &#125;</span><br><span class="line">  MyString(MyString&amp;&amp; other)//移动构造函数</span><br><span class="line">  &#123;</span><br><span class="line">    this-&gt;_data=other._data;</span><br><span class="line">    other._data=nullptr;</span><br><span class="line">    cout&lt;&lt;&quot;move constructor&quot;&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  MyString str(&quot;hello&quot;);</span><br><span class="line">  MyString str2(move(str));</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">create</span><br><span class="line">move constructor</span><br><span class="line">delete</span><br><span class="line">delete</span><br></pre></td></tr></table></figure><h3 id="2-单例类"><a href="#2-单例类" class="headerlink" title="2.单例类"></a>2.单例类</h3><p><strong>单例类：</strong>使用私有构造函数、私有赋值运算符和静态实例成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class President &#123;</span><br><span class="line">private:</span><br><span class="line">    President() &#123;&#125;; // 私有的默认构造函数，防止直接创建对象</span><br><span class="line">    President(const President&amp;); // 私有的复制构造函数，阻止复制对象</span><br><span class="line">    const President&amp; operator=(const President&amp;); // 私有的赋值运算符重载，阻止赋值操作</span><br><span class="line"></span><br><span class="line">    string name; // 存储总统名字的私有成员变量</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static President&amp; GetInstance() // 获取唯一的总统实例的静态成员函数</span><br><span class="line">    &#123;</span><br><span class="line">        // 使用静态局部变量确保只有一个实例会被创建</span><br><span class="line">        static President onlyInstance;</span><br><span class="line">        return onlyInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string GetName() // 获取总统名字的公有成员函数</span><br><span class="line">    &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void SetName(string InputName) // 设置总统名字的公有成员函数</span><br><span class="line">    &#123;</span><br><span class="line">        name = InputName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    President&amp; onlyPresident = President::GetInstance(); // 获取唯一的总统实例并引用它</span><br><span class="line">    onlyPresident.SetName(&quot;Abraham Lincoln&quot;); // 设置总统的名字为 &quot;Abraham Lincoln&quot;</span><br><span class="line">    // 下面的注释代码演示了禁止创建多个总统实例的情况</span><br><span class="line">    // President second; // 不能访问构造函数</span><br><span class="line">    // President* third = new President(); // 不能访问构造函数</span><br><span class="line">    // President fourth = onlyPresident; // 不能访问复制构造函数</span><br><span class="line">    // onlyPresident = President::GetInstance(); // 不能访问赋值运算符重载</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;The name of the President is: &quot;;</span><br><span class="line">    cout &lt;&lt; President::GetInstance().GetName() &lt;&lt; endl; // 获取并输出总统的名字</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-关键字-explicit"><a href="#3-关键字-explicit" class="headerlink" title="3.关键字 explicit"></a>3.关键字 explicit</h3><p><strong>关键字 explicit：</strong>避免隐式转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义一个名为 Human 的类</span><br><span class="line">class Human &#123;</span><br><span class="line">private:</span><br><span class="line">    int age; // 私有成员变量，表示人的年龄</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 显式构造函数，阻止隐式类型转换</span><br><span class="line">    explicit Human(int humansAge) : age(humansAge) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 函数，接受一个 Human 类型的参数</span><br><span class="line">void DoSomething(Human person) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Human sent did something&quot; &lt;&lt; endl;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个 Human 对象 kid，设置年龄为 10</span><br><span class="line">    Human kid(10);</span><br><span class="line"></span><br><span class="line">    // 创建另一个 Human 对象 anotherKid，设置年龄为 11</span><br><span class="line">    Human anotherKid = Human(11);</span><br><span class="line"></span><br><span class="line">    // 调用函数，将 kid 对象作为参数传递给它</span><br><span class="line">    DoSomething(kid); // 这是有效的，因为参数的类型是明确的</span><br><span class="line"></span><br><span class="line">    // 下面两行是注释掉的代码，因为它们尝试执行隐式类型转换，会导致编译错误</span><br><span class="line">    // Human anotherKid2 = 11;</span><br><span class="line">    // DoSomething(10);</span><br><span class="line"></span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p><strong>隐式转换：</strong>将提供的整数作为参数发送给这个构造函数，从而创建一个Human 对象。</p><h3 id="4-友元"><a href="#4-友元" class="headerlink" title="4.友元"></a>4.友元</h3><p>使用关键字 <strong>friend</strong>声明友元类或友元函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义一个名为 Human 的类</span><br><span class="line">class Human &#123;</span><br><span class="line">private:</span><br><span class="line">    // 允许 Utility 类成员访问私有成员</span><br><span class="line">    friend class Utility;</span><br><span class="line"></span><br><span class="line">    string name; // 私有成员变量，表示人的姓名</span><br><span class="line">    int age;    // 私有成员变量，表示人的年龄</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 构造函数，接受人的姓名和年龄</span><br><span class="line">    Human(string humansName, int humansAge) &#123;</span><br><span class="line">        name = humansName;</span><br><span class="line">        age = humansAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义一个名为 Utility 的类</span><br><span class="line">class Utility &#123;</span><br><span class="line">public:</span><br><span class="line">    // 静态成员函数，用于显示人的年龄</span><br><span class="line">    static void DisplayAge(const Human&amp; person) &#123;</span><br><span class="line">        cout &lt;&lt; person.age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个 Human 对象 firstMan，初始化姓名为 &quot;Adam&quot; 年龄为 25</span><br><span class="line">    Human firstMan(&quot;Adam&quot;, 25);</span><br><span class="line"></span><br><span class="line">    // 使用友元类 Utility 来访问 private 成员 age</span><br><span class="line">    cout &lt;&lt; &quot;Accessing private member age via friend class: &quot;;</span><br><span class="line">    Utility::DisplayAge(firstMan);</span><br><span class="line"></span><br><span class="line">    return 0; // 程序正常退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-继承"><a href="#5-继承" class="headerlink" title="5.继承"></a>5.继承</h3><p><strong>调用基类中被覆盖的方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class base&#123;</span><br><span class="line">    private:</span><br><span class="line">    public:</span><br><span class="line">        void print()</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;base\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class son:public base&#123;</span><br><span class="line">    private:</span><br><span class="line">    public:</span><br><span class="line">        void print()</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;son\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    son a;</span><br><span class="line">    a.print();</span><br><span class="line">    a.base::print();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">son</span><br><span class="line">base</span><br></pre></td></tr></table></figure><h3 id="6-抽象基类和纯虚函数"><a href="#6-抽象基类和纯虚函数" class="headerlink" title="6.抽象基类和纯虚函数"></a>6.抽象基类和纯虚函数</h3><p><strong>抽象基类：</strong>计用来作为其他派生类的基础，但不能被实例化为对象</p><p><em>注：抽象基类至少包含一个纯虚函数，这些纯虚函数在派生类中必须被实现。</em></p><p><strong>纯虚函数：</strong>在抽象基类中声明的虚函数，但没有提供实际的函数体实现。</p><p><em>注：纯虚函数的声明使用 <code>virtual</code> 关键字，并在函数声明后加上 <code>= 0</code></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    // 纯虚函数，必须在派生类中实现</span><br><span class="line">    virtual double Area() const = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 派生类 Circle</span><br><span class="line">class Circle : public Shape &#123;</span><br><span class="line">private:</span><br><span class="line">    double radius;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Circle(double r) : radius(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 实现了抽象基类中的纯虚函数</span><br><span class="line">    double Area() &#123;</span><br><span class="line">        return 3.14 * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-虚继承"><a href="#7-虚继承" class="headerlink" title="7.虚继承"></a>7.虚继承</h3><p><strong>虚继承：</strong>解决了多继承中可能出现的菱形继承问题以及由此引发的二义性问题。</p><p><strong>菱形继承问题</strong>：菱形继承问题发生在一个派生类从两个不同的基类继承，而这两个基类都继承自同一个共同的基类。派生类会继承两份相同的数据，导致二义性和内存浪费。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class CommonBase &#123;</span><br><span class="line">public:</span><br><span class="line">    int data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Base1 : virtual public CommonBase &#123;</span><br><span class="line">public:</span><br><span class="line">    void setData(int d) &#123;</span><br><span class="line">        data = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Base2 : virtual public CommonBase &#123;</span><br><span class="line">public:</span><br><span class="line">    int getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base1, public Base2 &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    obj.setData(42);</span><br><span class="line">    int result = obj.getData();</span><br><span class="line">    cout &lt;&lt; &quot;Data: &quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-限定符-override"><a href="#8-限定符-override" class="headerlink" title="8.限定符 override"></a>8.限定符 override</h3><p><strong>限定符 override：</strong>用于显式指示派生类中的成员函数是对基类中的虚函数进行重写（覆盖）的，主要作用是提高代码的可读性和可维护性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void MyFunction() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base::MyFunction()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    // 使用 override 明确表示覆盖了基类的虚函数</span><br><span class="line">    void MyFunction() override &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derived::MyFunction()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    Base* ptr = &amp;obj;//一个派生类对象的地址赋给一个基类指针，可以使用该指针来访问基类中定义的成员函数和数据成员。</span><br><span class="line">    ptr-&gt;MyFunction(); // 输出 Derived::MyFunction()</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-final关键字"><a href="#9-final关键字" class="headerlink" title="9.final关键字"></a>9.final关键字</h3><p><strong>修饰类：</strong>表示该类不能被其他类继承。</p><p>示例：<code>class MyFinalClass final &#123; /* 类定义 */ &#125;;</code></p><p><strong>修饰成员函数</strong>：表示该成员函数不能在派生类中被重写。</p><p>示例：<code>virtual void MyFunction() final;</code></p><p><strong>修饰变量</strong>：数值一旦在初始化之后便不能更改。</p><p>示例：<code>final int j = 5;</code></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unet</title>
      <link href="/posts/d03cec61.html"/>
      <url>/posts/d03cec61.html</url>
      
        <content type="html"><![CDATA[<h2 id="Unet"><a href="#Unet" class="headerlink" title="Unet"></a>Unet</h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="https://typoraimg.wangak.cc/2023/img/202310201410379.png" alt="1"></p><p>网络左边为contracting path(收缩路径)，右边为expansive path(扩张路径)。</p><p><strong><em>注：</em></strong></p><p><strong><em>1.Contracting path为常规的3×3卷积结构，与ReLU，还有2×2的max pooling。每次下采样，都将featuremap的channel变为之前的两倍。</em></strong></p><p><strong><em>2.Expansive path为上采样过程，每次都是22的上采样卷积过程，并且将相应的feature channel减少为之前的一半。</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FCN</title>
      <link href="/posts/c1665831.html"/>
      <url>/posts/c1665831.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-FCN网络"><a href="#1-FCN网络" class="headerlink" title="1.FCN网络"></a>1.FCN网络</h3><h4 id="1-1-核心思想"><a href="#1-1-核心思想" class="headerlink" title="1.1 核心思想"></a>1.1 核心思想</h4><ul><li>不含全连接层的全卷积网络，可适应任意尺寸输入；（可以为不同大小和分辨率的图像生成像素级别的预测）</li><li>反卷积层增大图像尺寸，输出精细结果；</li><li>结合不同深度层结果的跳级结构，确保鲁棒性和精确性。</li></ul><h4 id="1-2-网络结构"><a href="#1-2-网络结构" class="headerlink" title="1.2 网络结构"></a>1.2 网络结构</h4><p><img src="https://typoraimg.wangak.cc/2023/img/202310201352229.png" alt="1"></p><p><strong><em>注：</em></strong></p><p><em>1.<strong>全卷积部分</strong>为一些经典的CNN网络（如VGG，ResNet等），用于提取特征</em>。</p><p><em>2.<strong>反卷积部分</strong>则是通过上采样得到原尺寸的语义分割图像。</em></p><p><em>3.FCN的<strong>输入</strong>可以为任意尺寸的彩色图像，<strong>输出</strong>与输入尺寸相同，通道数为n（目标类别数）+1（背景）。</em></p><h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h3><h4 id="2-1-创建一个全卷积网络"><a href="#2-1-创建一个全卷积网络" class="headerlink" title="2.1 创建一个全卷积网络"></a>2.1 创建一个全卷积网络</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">import torch</span><br><span class="line">import torchvision</span><br><span class="line">from torch import nn</span><br><span class="line">from torch.nn import functional as F</span><br><span class="line">from d2l import torch as d2l</span><br><span class="line"></span><br><span class="line">#加载预训练的ResNet-18模型来提取图像特征，并查看该模型的最后三个子模块的结构和参数</span><br><span class="line">pretrained_net = torchvision.models.resnet18(pretrained=True)</span><br><span class="line">list(pretrained_net.children())[-3:]</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[Sequential(</span><br><span class="line">   (0): BasicBlock(</span><br><span class="line">     (conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)</span><br><span class="line">     (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">     (relu): ReLU(inplace=True)</span><br><span class="line">     (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">     (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">     (downsample): Sequential(</span><br><span class="line">       (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False)</span><br><span class="line">       (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">     )</span><br><span class="line">   )</span><br><span class="line">   (1): BasicBlock(</span><br><span class="line">     (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">     (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">     (relu): ReLU(inplace=True)</span><br><span class="line">     (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">     (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">   )</span><br><span class="line"> ),</span><br><span class="line"> AdaptiveAvgPool2d(output_size=(1, 1)),</span><br><span class="line"> Linear(in_features=512, out_features=1000, bias=True)]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#利用ResNet-18模型创建一个全卷积网络实例net(去除ResNet-18模型的池化层和全连接层)</span><br><span class="line">net = nn.Sequential(*list(pretrained_net.children())[:-2])</span><br><span class="line"></span><br><span class="line">X = torch.rand(size=(1, 3, 320, 480))</span><br><span class="line">net(X).shape #对张量X进行前向传播</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">torch.Size([1, 512, 10, 15])</span><br></pre></td></tr></table></figure><h4 id="2-2-添加1x1的卷积层和转置卷积层"><a href="#2-2-添加1x1的卷积层和转置卷积层" class="headerlink" title="2.2 添加1x1的卷积层和转置卷积层"></a>2.2 添加1x1的卷积层和转置卷积层</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#向网络net中添加final_conv和transpose_conv两个层，特征图的分辨率还原回输入图像的大小</span><br><span class="line">num_classes = 21</span><br><span class="line">net.add_module(&#x27;final_conv&#x27;, nn.Conv2d(512, num_classes, kernel_size=1))</span><br><span class="line">net.add_module(</span><br><span class="line">    &#x27;transpose_conv&#x27;,</span><br><span class="line">    nn.ConvTranspose2d(num_classes, num_classes, kernel_size=64, padding=16,</span><br><span class="line">                       stride=32))#kernel_size取stride的两倍，padding取kernel_size的1/4</span><br><span class="line">net(X).shape</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">torch.Size([1, 21, 320, 480])</span><br></pre></td></tr></table></figure><h4 id="2-3-初始化卷积核"><a href="#2-3-初始化卷积核" class="headerlink" title="2.3 初始化卷积核"></a>2.3 初始化卷积核</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#初始化转置卷积层</span><br><span class="line">def bilinear_kernel(in_channels, out_channels, kernel_size):</span><br><span class="line">    #找到卷积核的中心位置</span><br><span class="line">    factor = (kernel_size + 1) // 2    </span><br><span class="line">    if kernel_size % 2 == 1:</span><br><span class="line">        center = factor - 1</span><br><span class="line">    else:</span><br><span class="line">        center = factor - 0.5</span><br><span class="line">    og = (torch.arange(kernel_size).reshape(-1, 1),</span><br><span class="line">          torch.arange(kernel_size).reshape(1, -1))</span><br><span class="line">    #权重矩阵 filt,通过将偏移与 factor 相除并从1中减去得到的,确保了中心位置附近的权重最大</span><br><span class="line">    filt = (1 - torch.abs(og[0] - center) / factor) *\</span><br><span class="line">           (1 - torch.abs(og[1] - center) / factor)</span><br><span class="line">    weight = torch.zeros(</span><br><span class="line">        (in_channels, out_channels, kernel_size, kernel_size))</span><br><span class="line">    weight[range(in_channels), range(out_channels), :, :] = filt</span><br><span class="line">    return weight</span><br></pre></td></tr></table></figure><h4 id="2-4-双线性插值的上采样的实验"><a href="#2-4-双线性插值的上采样的实验" class="headerlink" title="2.4 双线性插值的上采样的实验"></a>2.4 双线性插值的上采样的实验</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">conv_trans = nn.ConvTranspose2d(3, 3, kernel_size=4, padding=1, stride=2,</span><br><span class="line">                                bias=False)#kernel_size取stride的两倍，padding取kernel_size的1/4</span><br><span class="line">conv_trans.weight.data.copy_(bilinear_kernel(3, 3, 4));</span><br><span class="line"></span><br><span class="line">img = torchvision.transforms.ToTensor()(d2l.Image.open(&#x27;../data/cat.jpg&#x27;))#加载一张图像并将其转换为 PyTorch 张量格式。</span><br><span class="line">X = img.unsqueeze(0)#unsqueeze(0)的作用是在索引0的位置插入一个新的维度，将原始的三维图像张量变成了四维</span><br><span class="line">Y = conv_trans(X)#对X进行转置卷积</span><br><span class="line">out_img = Y[0].permute(1, 2, 0).detach()#删除一个维度，并将其他的三个维度调整为高度（Height）、宽度（Width）和通道数（Channels）的顺序</span><br><span class="line">d2l.set_figsize()</span><br><span class="line">print(&#x27;input image shape:&#x27;, img.permute(1, 2, 0).shape)</span><br><span class="line">d2l.plt.imshow(img.permute(1, 2, 0))</span><br><span class="line">print(&#x27;output image shape:&#x27;, out_img.shape)</span><br><span class="line">d2l.plt.imshow(out_img);</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201353461.png" alt="2"></p><h4 id="2-5-初始化转置卷积层"><a href="#2-5-初始化转置卷积层" class="headerlink" title="2.5 初始化转置卷积层"></a>2.5 初始化转置卷积层</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">W = bilinear_kernel(num_classes, num_classes, 64)</span><br><span class="line">net.transpose_conv.weight.data.copy_(W);</span><br></pre></td></tr></table></figure><h4 id="2-6-读取数据集"><a href="#2-6-读取数据集" class="headerlink" title="2.6 读取数据集"></a>2.6 读取数据集</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size, crop_size = 32, (320, 480)</span><br><span class="line">train_iter, test_iter = d2l.load_data_voc(batch_size, crop_size)</span><br></pre></td></tr></table></figure><h4 id="2-7-训练"><a href="#2-7-训练" class="headerlink" title="2.7 训练"></a>2.7 训练</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def loss(inputs, targets):</span><br><span class="line">    return F.cross_entropy(inputs, targets, reduction=&#x27;none&#x27;).mean(1).mean(1)</span><br><span class="line"></span><br><span class="line">num_epochs, lr, wd, devices = 5, 0.001, 1e-3, d2l.try_all_gpus()</span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=lr, weight_decay=wd)</span><br><span class="line">d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201353655.png" alt="3"></p><h4 id="2-8-可视化预测的类别"><a href="#2-8-可视化预测的类别" class="headerlink" title="2.8 可视化预测的类别"></a>2.8 可视化预测的类别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def predict(img):</span><br><span class="line">    X = test_iter.dataset.normalize_image(img).unsqueeze(0)</span><br><span class="line">    pred = net(X.to(devices[0])).argmax(dim=1)</span><br><span class="line">    return pred.reshape(pred.shape[1], pred.shape[2])</span><br><span class="line">    </span><br><span class="line">def label2image(pred):</span><br><span class="line">    colormap = torch.tensor(d2l.VOC_COLORMAP, device=devices[0])</span><br><span class="line">    X = pred.long()</span><br><span class="line">    return colormap[X, :]</span><br><span class="line"></span><br><span class="line">voc_dir = d2l.download_extract(&#x27;voc2012&#x27;, &#x27;VOCdevkit/VOC2012&#x27;)</span><br><span class="line">test_images, test_labels = d2l.read_voc_images(voc_dir, False)</span><br><span class="line">n, imgs = 4, []</span><br><span class="line">for i in range(n):</span><br><span class="line">    crop_rect = (0, 0, 320, 480)</span><br><span class="line">    X = torchvision.transforms.functional.crop(test_images[i], *crop_rect)</span><br><span class="line">    pred = label2image(predict(X))</span><br><span class="line">    imgs += [</span><br><span class="line">        X.permute(1, 2, 0),</span><br><span class="line">        pred.cpu(),</span><br><span class="line">        torchvision.transforms.functional.crop(test_labels[i],</span><br><span class="line">                                               *crop_rect).permute(1, 2, 0)]</span><br><span class="line">d2l.show_images(imgs[::3] + imgs[1::3] + imgs[2::3], 3, n, scale=2);</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201353581.png" alt="4"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像分割基础</title>
      <link href="/posts/f46e289b.html"/>
      <url>/posts/f46e289b.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-图像分割"><a href="#1-图像分割" class="headerlink" title="1.图像分割"></a>1.图像分割</h3><p><strong>语义分割：</strong>为每个像素都打上标签，只区分类别，但不区分类别中的具体单位。</p><p><strong>实例分割：</strong>不光要区别类别，还要区分类别中的每一个个体。</p><h3 id="2-Focal-loss"><a href="#2-Focal-loss" class="headerlink" title="2.Focal loss"></a>2.Focal loss</h3><p><strong>focal loss从样本难易分类角度出发，解决样本非平衡带来的模型训练问题。</strong></p><p><strong>focal loss的具体形式：</strong><script type="math/tex">\large-\alpha(1-y_{pred})^{\gamma}y_{true}log(y_{pred})-(1-\alpha)y_{pred}^{\gamma}(1-y_{true})log(1-y_{pred})</script></p><p><strong>注：</strong></p><p><em>1.$\large\gamma$通常设置为2，$\large(1-y_{pred})^{\gamma}$相当于样本的难易度权值,$\large\alpha$为正负样本的比例</em></p><p><em>2.为了防止难易样本的频繁变化，应当选取小的学习率。防止学习率过大，造成w变化较大从而引起 $\large y_{pred}$的巨大变化，造成难易样本的改变。</em></p><h3 id="3-转置卷积"><a href="#3-转置卷积" class="headerlink" title="3.转置卷积"></a>3.转置卷积</h3><p><strong>转置卷积：</strong>用来增大输入的高宽</p><h4 id="3-1-转置卷积的计算方式"><a href="#3-1-转置卷积的计算方式" class="headerlink" title="3.1 转置卷积的计算方式"></a>3.1 转置卷积的计算方式</h4><p><strong>计算方式一：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201414993.png" alt="1"></p><p><strong>计算方式二（填充为0，步幅为1)：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201414494.png" alt="2"></p><p><strong>一般情况：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201414965.png" alt="3"></p><p><strong>基本的转置卷积运算：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def trans_conv(X, K):</span><br><span class="line">    h, w = K.shape</span><br><span class="line">    Y = torch.zeros((X.shape[0] + h - 1, X.shape[1] + w - 1))</span><br><span class="line">    for i in range(X.shape[0]):</span><br><span class="line">        for j in range(X.shape[1]):</span><br><span class="line">            Y[i:i + h, j:j + w] += X[i, j] * K</span><br><span class="line">    return Y</span><br></pre></td></tr></table></figure><p><strong>高级API:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">X = torch.tensor([[0.0, 1.0], [2.0, 3.0]])</span><br><span class="line">K = torch.tensor([[0.0, 1.0], [2.0, 3.0]])</span><br><span class="line">X, K = X.reshape(1, 1, 2, 2), K.reshape(1, 1, 2, 2)</span><br><span class="line">tconv = nn.ConvTranspose2d(1, 1, kernel_size=2, bias=False)</span><br><span class="line">tconv.weight.data = K</span><br><span class="line">tconv(X)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">tensor([[[[ 0.,  0.,  1.],</span><br><span class="line">          [ 0.,  4.,  6.],</span><br><span class="line">          [ 4., 12.,  9.]]]], grad_fn=&lt;ConvolutionBackward0&gt;)</span><br></pre></td></tr></table></figure><p><strong>填充：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tconv = nn.ConvTranspose2d(1, 1, kernel_size=2, padding=1, bias=False)#padding=1将输出的行列减小1</span><br><span class="line">tconv.weight.data = K</span><br><span class="line">tconv(X)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">tensor([[[[4.]]]], grad_fn=&lt;ConvolutionBackward0&gt;)</span><br></pre></td></tr></table></figure><p><strong>步幅:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tconv = nn.ConvTranspose2d(1, 1, kernel_size=2, stride=2, bias=False)#增大stride会将输出变大</span><br><span class="line">tconv.weight.data = K</span><br><span class="line">tconv(X)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">tensor([[[[0., 0., 0., 1.],</span><br><span class="line">          [0., 0., 2., 3.],</span><br><span class="line">          [0., 2., 0., 3.],</span><br><span class="line">          [4., 6., 6., 9.]]]], grad_fn=&lt;ConvolutionBackward0&gt;)</span><br></pre></td></tr></table></figure><p><strong>多通道:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand(size=(1, 10, 16, 16))</span><br><span class="line">conv = nn.Conv2d(10, 20, kernel_size=5, padding=2, stride=3)</span><br><span class="line">tconv = nn.ConvTranspose2d(20, 10, kernel_size=5, padding=2, stride=3)</span><br><span class="line">tconv(conv(X)).shape == X.shape</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h4 id="3-2-转置卷积的棋盘效应"><a href="#3-2-转置卷积的棋盘效应" class="headerlink" title="3.2 转置卷积的棋盘效应"></a>3.2 转置卷积的棋盘效应</h4><p><strong>棋盘效应：</strong>在转置卷积操作中，生成的输出特征图中出现的不规则、重叠和错位的图案，类似于棋盘格子</p><p><strong>棋盘效应的主要原因：</strong>kernel size不能够被stride整除（<strong>不均匀重叠</strong>）</p><p><strong>解决方法：</strong></p><p><strong>方法一：</strong>使kernel size能够被stride整除（无法完全避免该问题）</p><p><strong>方法二：</strong>插值法+卷积</p><h3 id="4-双线性插值"><a href="#4-双线性插值" class="headerlink" title="4.双线性插值"></a>4.双线性插值</h3><p><strong>双线性插值：</strong>通过待求像素点在源图像中4个最近邻像素值的加权和计算得到</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201414401.png" alt="4"></p><p><strong>优势：</strong>没有灰度不连续的缺点，结果基本令人满意</p><p><strong>劣势：</strong>双线性内插法的计算比最邻近点法复杂，计算量较大。它具有低通滤波性质，使高频分量受损，图像轮廓可能会有一点模糊。</p><h3 id="5-Batch-Normalization"><a href="#5-Batch-Normalization" class="headerlink" title="5.Batch Normalization"></a>5.Batch Normalization</h3><p><strong>优点：</strong><br>1.可以用更大学习率，加速模型收敛<br>2.可以不用精心设计权值初始化<br>3.可以不用dropout或较小的dropout<br>4.可以不用L2或者较小的weight decay<br>5.可以不用LRN(local response normalization)</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201414040.png" alt="5"></p><p><strong><em>注：</em></strong></p><p><strong><em>1.由于归一化后的xi基本会被限制在正态分布下，使得网络的表达能力下降。为解决该问题，我们引入两个新的参数：γ,β。 γ和β是在训练时网络自己学习得到的。</em></strong></p><p><em>2.Batch Normalization将数据移到激活函数中心区域，对于大多数的激活函数而言，这个区域的梯度都是最大的或者是有梯度的，因而这种方法是一种对抗梯度消失的有效手段。</em></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础（1）</title>
      <link href="/posts/75288c8f.html"/>
      <url>/posts/75288c8f.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-常量"><a href="#1-常量" class="headerlink" title="1.常量"></a>1.常量</h3><h4 id="1-1-使用-const-将变量声明为常量"><a href="#1-1-使用-const-将变量声明为常量" class="headerlink" title="1.1 使用 const 将变量声明为常量"></a>1.1 使用 const 将变量声明为常量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const double pi = 3.14;</span><br></pre></td></tr></table></figure><h4 id="1-2-使用-constexpr-定义常量表达式"><a href="#1-2-使用-constexpr-定义常量表达式" class="headerlink" title="1.2 使用 constexpr 定义常量表达式"></a>1.2 使用 constexpr 定义常量表达式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constexpr double GetPi() &#123;return 3.14;&#125;</span><br><span class="line">constexpr double TwicePi()&#123;return 2* GetPi();&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-使用关键字-enum-声明的枚举常量"><a href="#1-3-使用关键字-enum-声明的枚举常量" class="headerlink" title="1.3 使用关键字 enum 声明的枚举常量"></a>1.3 使用关键字 enum 声明的枚举常量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">enum direct&#123;</span><br><span class="line">        North=5,</span><br><span class="line">        South,</span><br><span class="line">        East,</span><br><span class="line">        West</span><br><span class="line">    &#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    direct f=North;</span><br><span class="line">    cout&lt;&lt;f&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;South&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;East&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;West&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p><em>1.使用枚举来指定变量的类型，这样声明的变量只能取指定的值</em>。</p><p><em>2.North的值设置为5，这自动将随后的常量分别设置为 6、7 和8。</em></p><h4 id="1-4-使用-define-定义常量"><a href="#1-4-使用-define-定义常量" class="headerlink" title="1.4 使用#define 定义常量"></a>1.4 使用#define 定义常量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define pi 3.14</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><p><em>1.#define 是一个预处理器宏，让预处理器将随后出现的所有 pi 都替换为 3.14。</em></p><p><em>2.使用#define 定义常量的做法已被摒弃，因此不应采用这种做法。</em></p><h3 id="2-动态数组"><a href="#2-动态数组" class="headerlink" title="2.动态数组"></a>2.动态数组</h3><p><strong>std::vector:</strong>支持在运行阶段根据需要增大动态数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; a(3);</span><br><span class="line">    a[0]=1,a[1]=2,a[2]=3;</span><br><span class="line">    printf(&quot;%d\n&quot;,a.size());</span><br><span class="line">    a.push_back(4);</span><br><span class="line">    printf(&quot;%d&quot;,a.size());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="3-Lambda-表达式"><a href="#3-Lambda-表达式" class="headerlink" title="3.Lambda 表达式"></a>3.Lambda 表达式</h3><p><strong>[capture](parameters) -&gt; return_type { body }</strong></p><ul><li><code>capture</code>：捕获列表，用于指定在 lambda 表达式中可见的外部变量。可以通过值捕获或引用捕获来捕获变量。</li><li><code>parameters</code>：参数列表，与普通函数的参数列表一样，用于传递参数给 lambda 表达式。</li><li><code>return_type</code>：返回类型，指定 lambda 表达式的返回类型。可以省略，编译器会自动推断返回类型。</li><li><code>body</code>：函数体，包含 lambda 表达式的实际操作。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">#lambda表达式接受两个整数参数x和y，然后返回它们的和</span><br><span class="line">    auto add=[](int x,int y)-&gt;int&#123;</span><br><span class="line">        return x+y;</span><br><span class="line">    &#125;;</span><br><span class="line">    int ans=add(2,3);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    int x=2,y=3;</span><br><span class="line">    #这个lambda表达式没有参数，并且在捕获列表中捕获了变量x和y，返回x*y的结果</span><br><span class="line">    auto mul=[x,y]()-&gt;int&#123;</span><br><span class="line">        return x*y;</span><br><span class="line">    &#125;;</span><br><span class="line">    int res=mul();</span><br><span class="line">    printf(&quot;%d&quot;,res);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-动态内存分配"><a href="#4-动态内存分配" class="headerlink" title="4.动态内存分配"></a>4.动态内存分配</h3><p><strong>使用 new  动态地分配内存</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type* Pointer = new Type;</span><br><span class="line">Type* Pointer = new Type[numElements];</span><br></pre></td></tr></table></figure><p><strong>最终都需使用对应的 delete 进行释放:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete Pointer;</span><br><span class="line">delete[] Pointer;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int *x=new int;</span><br><span class="line">    scanf(&quot;%d&quot;,x);</span><br><span class="line">    printf(&quot;%d&quot;,*x);</span><br><span class="line">    delete x;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-将关键字-const-用于指针"><a href="#5-将关键字-const-用于指针" class="headerlink" title="5.将关键字 const 用于指针"></a>5.将关键字 const 用于指针</h3><h4 id="5-1-地址不能修改-数据可修改"><a href="#5-1-地址不能修改-数据可修改" class="headerlink" title="5.1 地址不能修改,数据可修改"></a>5.1 地址不能修改,数据可修改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int* const pDaysInMonth = &amp;daysInMonth;</span><br></pre></td></tr></table></figure><h4 id="5-2-地址可修改-数据不能修改"><a href="#5-2-地址可修改-数据不能修改" class="headerlink" title="5.2 地址可修改,数据不能修改"></a>5.2 地址可修改,数据不能修改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int* pointsToInt = &amp;hoursInDay;</span><br></pre></td></tr></table></figure><h4 id="5-3-地址和数据均不能修改"><a href="#5-3-地址和数据均不能修改" class="headerlink" title="5.3 地址和数据均不能修改"></a>5.3 地址和数据均不能修改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int* const pHoursInDay = &amp;hoursInDay;</span><br></pre></td></tr></table></figure><h3 id="6-共用体"><a href="#6-共用体" class="headerlink" title="6.共用体"></a>6.共用体</h3><p><strong>共用体：</strong>可包含多个数据成员，但是只能使用其中的一个。</p><p><strong>sizeof()</strong>用于共用体时，结果总是为共用体最大成员的长度，即便该成员并不处于活动状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">union Type</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    char p;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Type a;</span><br><span class="line">    a.num=1;</span><br><span class="line">    printf(&quot;num:%d\n&quot;,a.num);</span><br><span class="line">    a.p=&#x27;x&#x27;;</span><br><span class="line">    printf(&quot;p:%c\n&quot;,a.num,a.p);</span><br><span class="line">    printf(&quot;size:%d&quot;,sizeof(a));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">num:1</span><br><span class="line">p:x</span><br><span class="line">size:4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>torchvision.transforms使用详解</title>
      <link href="/posts/cc5fd5b2.html"/>
      <url>/posts/cc5fd5b2.html</url>
      
        <content type="html"><![CDATA[<h2 id="torchvision-transforms"><a href="#torchvision-transforms" class="headerlink" title="torchvision.transforms"></a>torchvision.transforms</h2><h3 id="1-torchvision-transforms-Compose"><a href="#1-torchvision-transforms-Compose" class="headerlink" title="1. torchvision.transforms.Compose"></a>1. torchvision.transforms.Compose</h3><p><strong>torchvision.transforms.Compose：</strong>是一个用于组合多个图像预处理操作的类，将多个预处理操作串联在一起，以便在数据加载时对图像进行连续的处理。</p><p><strong>torchvision.transforms.Compose(transforms)</strong> 的参数是一个列表，其中包含要进行的图像预处理操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import torchvision.transforms as transforms</span><br><span class="line"></span><br><span class="line"># 定义图像预处理操作</span><br><span class="line">transformations = transforms.Compose([</span><br><span class="line">    transforms.Resize(256),              # 调整图像大小为256x256</span><br><span class="line">    transforms.RandomCrop(224),          # 随机裁剪为224x224</span><br><span class="line">    transforms.RandomHorizontalFlip(),   # 随机水平翻转</span><br><span class="line">    transforms.ToTensor(),               # 将图像转换为Tensor格式</span><br><span class="line">    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])  # 归一化</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"># 使用组合的预处理操作对图像进行处理</span><br><span class="line">img = Image.open(&#x27;example.jpg&#x27;)  # 假设有一张名为 &#x27;example.jpg&#x27; 的图像</span><br><span class="line">processed_img = transformations(img)</span><br></pre></td></tr></table></figure><h3 id="2-torchvision-transforms-RandomResizedCrop"><a href="#2-torchvision-transforms-RandomResizedCrop" class="headerlink" title="2.torchvision.transforms.RandomResizedCrop"></a>2.torchvision.transforms.RandomResizedCrop</h3><p><strong>torchvision.transforms.RandomResizedCrop：</strong>用于<strong>数据增广</strong>，以增加数据集的<strong>多样性</strong>和提高模型的<strong>泛化能力</strong>（随机裁剪图像，并将裁剪后的图像调整为指定的大小）</p><p><code>torchvision.transforms.RandomResizedCrop(size, scale=(0.08, 1.0), ratio=(3.0/4.0, 4.0/3.0), interpolation=2)</code> 的参数包括：</p><ul><li><p><code>size</code>：输出的裁剪后图像的大小，可以是一个整数或一个元组 (height, width)。</p></li><li><p><code>scale</code>：控制裁剪区域相对于原始图像大小的尺度范围，它是一个长度为2的元组 (min_scale, max_scale)。裁剪区域的大小在 [min_scale <em> 图像大小, max_scale </em> 图像大小] 之间随机选择。</p></li><li><p><code>ratio</code>：控制裁剪区域的宽高比范围，它是一个长度为2的元组 (min_ratio, max_ratio)。裁剪区域的宽高比在 [min_ratio, max_ratio] 之间随机选择。</p></li><li><p><code>interpolation</code>：插值方法，用于调整裁剪后图像的大小。默认值为2，表示使用双线性插值。</p><p><em>注：在图像处理中，将图像从一个尺寸调整为另一个尺寸时，通常需要使用插值方法来计算新尺寸的像素值。</em></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import torchvision.transforms as transforms</span><br><span class="line">from PIL import Image</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"># 定义随机裁剪操作</span><br><span class="line">transformations = transforms.RandomResizedCrop(size=224, scale=(0.08, 1.0), ratio=(3.0/4.0, 4.0/3.0))</span><br><span class="line"></span><br><span class="line"># 使用随机裁剪操作对图像进行处理</span><br><span class="line">img = Image.open(&#x27;example.jpg&#x27;)  # 假设有一张名为 &#x27;example.jpg&#x27; 的图像</span><br><span class="line">processed_img = transformations(img)</span><br><span class="line">plt.imshow(processed_img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="3-torchvision-transforms-RandomHorizontalFlip"><a href="#3-torchvision-transforms-RandomHorizontalFlip" class="headerlink" title="3.torchvision.transforms.RandomHorizontalFlip()"></a>3.torchvision.transforms.RandomHorizontalFlip()</h3><p><strong>torchvision.transforms.RandomHorizontalFlip():</strong>对图像进行随机水平翻转，增加数据集的多样性和提高模型的鲁棒性。</p><p><code>torchvision.transforms.RandomHorizontalFlip(p=0.5)</code> 的参数 <code>p</code> （默认为0.5）控制水平翻转的概率。</p><p>当 <code>p=0.5</code> 时，有50%的概率对图像进行水平翻转。当 <code>p=0</code> 时，不进行翻转；当 <code>p=1</code> 时，100%进行翻转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import torchvision.transforms as transforms</span><br><span class="line"></span><br><span class="line"># 定义随机水平翻转操作</span><br><span class="line">transformations = transforms.RandomHorizontalFlip(p=0.5)</span><br><span class="line"></span><br><span class="line"># 使用随机水平翻转操作对图像进行处理</span><br><span class="line">img = Image.open(&#x27;example.jpg&#x27;)  # 假设有一张名为 &#x27;example.jpg&#x27; 的图像</span><br><span class="line">processed_img = transformations(img)</span><br></pre></td></tr></table></figure><h3 id="4-torchvision-transforms-ToTensor"><a href="#4-torchvision-transforms-ToTensor" class="headerlink" title="4.torchvision.transforms.ToTensor()"></a>4.torchvision.transforms.ToTensor()</h3><p><strong>torchvision.transforms.ToTensor():</strong>用于将 PIL 图像或 NumPy 数组转换为 PyTorch 张量（Tensor）格式，以便在深度学习模型中使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import torchvision.transforms as transforms</span><br><span class="line"></span><br><span class="line"># 定义 ToTensor 操作</span><br><span class="line">transformations = transforms.ToTensor()</span><br><span class="line"></span><br><span class="line"># 使用 ToTensor 操作将 PIL 图像转换为张量</span><br><span class="line">img = Image.open(&#x27;example.jpg&#x27;)  # 假设有一张名为 &#x27;example.jpg&#x27; 的图像</span><br><span class="line">tensor_img = transformations(img)</span><br></pre></td></tr></table></figure><h3 id="5-torchvision-transforms-Normalize"><a href="#5-torchvision-transforms-Normalize" class="headerlink" title="5.torchvision.transforms.Normalize"></a>5.torchvision.transforms.Normalize</h3><p><strong>torchvision.transforms.Normalize:</strong>对图像进行归一化处理，以便模型在训练和推断过程中更好地处理数据</p><h4 id="5-1-计算数据集的均值和标准差"><a href="#5-1-计算数据集的均值和标准差" class="headerlink" title="5.1 计算数据集的均值和标准差"></a>5.1 计算数据集的均值和标准差</h4><p><strong>os.walk(dataset_path)：</strong>用于遍历文件夹的一个函数，它生成一个三元组的迭代器，每次迭代返回一个包含当前<strong>目录路径</strong>、当前目录下所有<strong>子目录名</strong>、当前目录下所有<strong>文件名</strong>的元组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from PIL import Image</span><br><span class="line">import os</span><br><span class="line">import torchvision.transforms as transforms</span><br><span class="line">import torch</span><br><span class="line"></span><br><span class="line">def compute_mean_and_std(dataset_path):</span><br><span class="line">    # 初始化均值和标准差</span><br><span class="line">    mean = torch.zeros(3)</span><br><span class="line">    std = torch.zeros(3)</span><br><span class="line">    num_images = 0</span><br><span class="line"></span><br><span class="line">    # 遍历数据集</span><br><span class="line">    for root, _, files in os.walk(dataset_path):</span><br><span class="line">        for file in files:</span><br><span class="line">            if file.endswith(&quot;.jpg&quot;) or file.endswith(&quot;.png&quot;) or file.endswith(&quot;.jpeg&quot;):</span><br><span class="line">                img_path = os.path.join(root, file)</span><br><span class="line">                img = Image.open(img_path).convert(&quot;RGB&quot;)</span><br><span class="line">                transformations = transforms.ToTensor()</span><br><span class="line">                img = transformations(img)</span><br><span class="line"></span><br><span class="line">                # 计算当前图像的均值和标准差</span><br><span class="line">                mean += torch.mean(img, dim=(1, 2))</span><br><span class="line">                std += torch.std(img, dim=(1, 2))</span><br><span class="line">                num_images += 1</span><br><span class="line"></span><br><span class="line">    # 计算整个数据集的均值和标准差</span><br><span class="line">    mean /= num_images</span><br><span class="line">    std /= num_images</span><br><span class="line"></span><br><span class="line">    return mean.tolist(), std.tolist()</span><br><span class="line"></span><br><span class="line"># 数据集路径</span><br><span class="line">dataset_path = &quot;.\train&quot;</span><br><span class="line"></span><br><span class="line"># 计算均值和标准差</span><br><span class="line">mean, std = compute_mean_and_std(dataset_path)</span><br><span class="line">print(&quot;Mean:&quot;, mean)</span><br><span class="line">print(&quot;Std:&quot;, std)</span><br></pre></td></tr></table></figure><p><em>注：</em></p><p><em>1.表示图像的 Tensor，其维度为 (C, H, W)，其中 C 表示通道数，H 表示图像的高度，W 表示图像的宽度。<strong>dim=(1, 2)</strong> 表示在第 1 和第 2 维度上进行求均值的操作，<strong>torch.mean(img, dim=(1, 2))</strong>将对每个通道的高度和宽度上的所有像素值进行求均值。</em></p><p><em>2.<strong>PIL 图像（NumPy 数组表示）：</strong>在将图像转换为 NumPy 数组时，通常图像中的像素值被映射到 [0, 255] 范围内，方便对图像进行基本的像素级操作，如颜色调整、滤波等。</em></p><p><em>3.<strong>PyTorch 张量</strong>：PyTorch 张量在处理图像时，通常会进行数据归一化处理，图像的像素值会被映射到 [0, 1] 范围内，这可以有效地缩小不同通道之间数值的差异，避免数据在训练过程中产生较大的梯度，导致训练不稳定。（归一化方式是将像素值除以 255）</em></p><h4 id="5-2-torchvision-transforms-Normalize"><a href="#5-2-torchvision-transforms-Normalize" class="headerlink" title="5.2 torchvision.transforms.Normalize"></a>5.2 torchvision.transforms.Normalize</h4><p><code>torchvision.transforms.Normalize(mean, std)</code> 的参数包括：</p><ul><li><code>mean</code>：一个包含三个元素的列表或元组，表示每个通道的均值。对于 RGB 图像，通常是 [R 均值, G 均值, B 均值]。</li><li><code>std</code>：一个包含三个元素的列表或元组，表示每个通道的标准差。对于 RGB 图像，通常是 [R 标准差, G 标准差, B 标准差]</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import torchvision.transforms as transforms</span><br><span class="line"></span><br><span class="line"># 定义归一化操作</span><br><span class="line">mean = [0.4914, 0.4822, 0.4465]</span><br><span class="line">std = [0.2023, 0.1994, 0.2010]</span><br><span class="line">transformations = transforms.Normalize(mean=mean, std=std)</span><br><span class="line"></span><br><span class="line"># 假设 tensor_img 是一个张量，表示一张图像</span><br><span class="line">normalized_img = transformations(tensor_img)</span><br></pre></td></tr></table></figure><h3 id="6-torchvision-transforms-functional-crop"><a href="#6-torchvision-transforms-functional-crop" class="headerlink" title="6.torchvision.transforms.functional.crop"></a>6.torchvision.transforms.functional.crop</h3><p><strong>torchvision.transforms.functional.crop：</strong>从输入图像中裁剪出指定区域的子图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.transforms.functional.crop(img, top, left, height, width)</span><br></pre></td></tr></table></figure><ul><li><code>img</code>：输入的图像，通常是一个 PIL 图像或一个张量。</li><li><code>top</code>：裁剪区域的顶部边界（以像素为单位）。</li><li><code>left</code>：裁剪区域的左边界（以像素为单位）。</li><li><code>height</code>：裁剪区域的高度（以像素为单位）。</li><li><code>width</code>：裁剪区域的宽度（以像素为单位）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crop_rect = (0, 0, 320, 480)</span><br><span class="line">X = torchvision.transforms.functional.crop(test_images, *crop_rect)</span><br><span class="line">#crop_rect 是一个包含四个值的元组 (top, left, height, width)，它定义了要从图像中裁剪的区域的位置和大小</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> torchvision </tag>
            
            <tag> 图像预处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性回归</title>
      <link href="/posts/40997091.html"/>
      <url>/posts/40997091.html</url>
      
        <content type="html"><![CDATA[<h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><h3 id="1-线性回归的从零开始实现"><a href="#1-线性回归的从零开始实现" class="headerlink" title="1.线性回归的从零开始实现"></a>1.线性回归的从零开始实现</h3><h4 id="1-1-构造数据集"><a href="#1-1-构造数据集" class="headerlink" title="1.1 构造数据集"></a>1.1 构造数据集</h4><p>以参数w=[2,−3.4]⊤、b=4.2和噪声项ϵ生成数据集。</p><p>标签：y=Xw+b+ϵ</p><p><strong>torch.normal()：</strong>生成一个服从正态分布的随机张量。</p><p><strong>torch.matmul：</strong>计算两个张量矩阵相乘（可以用利用广播机制进行不同维度的相乘操作）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def synthetic_data(w, b, num_examples):  </span><br><span class="line">    &quot;&quot;&quot;生成 y = Xw + b + 噪声。&quot;&quot;&quot;</span><br><span class="line">    X = torch.normal(0, 1, (num_examples, len(w)))</span><br><span class="line">    #torch.normal()生成一个服从正态分布（均值为0，标准差为1）的随机张量X，大小为(num_examples, len(w))</span><br><span class="line">    #其中num_examples是样本数量，len(w)是特征数量。</span><br><span class="line">    y = torch.matmul(X, w) + b</span><br><span class="line">    #函数通过矩阵乘法计算目标变量y。y是由X和w之间的线性关系构造的，并且加上了偏差项b。</span><br><span class="line">    y += torch.normal(0, 0.01, y.shape)</span><br><span class="line">    #函数为目标变量y添加了一个服从正态分布（均值为0，标准差为0.01）的随机噪声，以模拟真实数据中的噪声。</span><br><span class="line">    return X, y.reshape((-1, 1))</span><br><span class="line"></span><br><span class="line">true_w = torch.tensor([2, -3.4])</span><br><span class="line">true_b = 4.2</span><br><span class="line">features, labels = synthetic_data(true_w, true_b, 1000)</span><br></pre></td></tr></table></figure><h4 id="1-2-观察特征的相关性"><a href="#1-2-观察特征的相关性" class="headerlink" title="1.2 观察特征的相关性"></a>1.2 观察特征的相关性</h4><p>将features张量中第二列的数据作为x轴，labels张量的数据作为y轴，绘制出散点图，散点图的每个点的大小为1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d2l.plt.scatter(features[:,1].detach().numpy(),</span><br><span class="line">                labels.detach().numpy(), 1);#detach()函数用于从计算图中分离出这部分数据，以防止在绘制图形时产生梯度计算</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201638283.png" alt="img"></p><h4 id="1-3-构造一个PyTorch数据迭代器"><a href="#1-3-构造一个PyTorch数据迭代器" class="headerlink" title="1.3 构造一个PyTorch数据迭代器"></a>1.3 构造一个PyTorch数据迭代器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">def data_iter(batch_size, features, labels):#接收批量大小、特征矩阵和标签向量作为输入</span><br><span class="line">    num_examples = len(features)#计算了特征数据的样本数量。</span><br><span class="line">    indices = list(range(num_examples))#创建一个索引列表。</span><br><span class="line">    random.shuffle(indices)# 将样本索引列表打乱，目的是随机化样本的顺序，这样在每个迭代周期中会使用不同的样本顺序，有助于训练模型的泛化能力。</span><br><span class="line">    for i in range(0, num_examples, batch_size):#循环开始，每次增加batch_size个步长进行迭代，直到遍历完所有样本。</span><br><span class="line">        batch_indices = torch.tensor(indices[i:min(i +</span><br><span class="line">                                                   batch_size, num_examples)])</span><br><span class="line">                #从打乱后的索引列表中选择一个批次的索引。</span><br><span class="line">                #注意，最后一个批次可能不足batch_size，因此使用min(i + batch_size, num_examples)来确保不超出数据集的边界。</span><br><span class="line">        yield features[batch_indices], labels[batch_indices]</span><br><span class="line">  </span><br><span class="line">batch_size = 10</span><br><span class="line">for X, y in data_iter(batch_size, features, labels):</span><br><span class="line">    print(X, &#x27;\n&#x27;, y)</span><br><span class="line">    break</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">tensor([[ 0.9374, -0.1930],</span><br><span class="line">        [ 0.1325, -1.0253],</span><br><span class="line">        [ 0.9573,  0.4727],</span><br><span class="line">        [-0.3795,  0.4407],</span><br><span class="line">        [-0.4063,  1.0375],</span><br><span class="line">        [ 0.7656, -1.9743],</span><br><span class="line">        [ 1.4891,  1.4386],</span><br><span class="line">        [-0.9692, -0.4879],</span><br><span class="line">        [ 2.5848,  1.3103],</span><br><span class="line">        [-0.5822,  0.5608]]) </span><br><span class="line"> tensor([[ 6.7309],</span><br><span class="line">        [ 7.9584],</span><br><span class="line">        [ 4.4986],</span><br><span class="line">        [ 1.9576],</span><br><span class="line">        [-0.1413],</span><br><span class="line">        [12.4321],</span><br><span class="line">        [ 2.2723],</span><br><span class="line">        [ 3.9170],</span><br><span class="line">        [ 4.9298],</span><br><span class="line">        [ 1.1197]])</span><br></pre></td></tr></table></figure><h4 id="1-4-初始化模型参数"><a href="#1-4-初始化模型参数" class="headerlink" title="1.4 初始化模型参数"></a>1.4 初始化模型参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w = torch.normal(0, 0.01, size=(2, 1), requires_grad=True)</span><br><span class="line">b = torch.zeros(1, requires_grad=True)</span><br><span class="line">#requires_grad=True:表示这个张量是可训练的，当执行反向传播时，PyTorch会自动计算关于w的梯度，并在优化算法中更新这个张量。</span><br></pre></td></tr></table></figure><h4 id="1-5-定义模型"><a href="#1-5-定义模型" class="headerlink" title="1.5 定义模型"></a>1.5 定义模型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def linreg(X, w, b):  </span><br><span class="line">    &quot;&quot;&quot;线性回归模型。&quot;&quot;&quot;</span><br><span class="line">    return torch.matmul(X, w) + b</span><br></pre></td></tr></table></figure><h4 id="1-6-定义损失函数"><a href="#1-6-定义损失函数" class="headerlink" title="1.6 定义损失函数"></a>1.6 定义损失函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def squared_loss(y_hat, y):  #y_hat：预测值</span><br><span class="line">    &quot;&quot;&quot;均方损失。&quot;&quot;&quot;</span><br><span class="line">    return (y_hat - y.reshape(y_hat.shape))**2 / 2</span><br></pre></td></tr></table></figure><h4 id="1-7-定义优化算法"><a href="#1-7-定义优化算法" class="headerlink" title="1.7 定义优化算法"></a>1.7 定义优化算法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def sgd(params, lr, batch_size):  #params（模型的可训练参数）、lr（学习率）和batch_size（批大小）</span><br><span class="line">    &quot;&quot;&quot;小批量随机梯度下降。&quot;&quot;&quot;</span><br><span class="line">    with torch.no_grad():#上下文管理器，用于包裹在其内部的操作，告诉PyTorch在这个上下文中不要计算梯度</span><br><span class="line">        for param in params:</span><br><span class="line">            param -= lr * param.grad / batch_size#梯度乘以学习率，再除以批大小来更新参数</span><br><span class="line">            param.grad.zero_()#将参数的梯度清零，在PyTorch中，梯度是累积的，需要手动将梯度置零</span><br></pre></td></tr></table></figure><h4 id="1-8-训练过程"><a href="#1-8-训练过程" class="headerlink" title="1.8 训练过程"></a>1.8 训练过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lr = 0.03</span><br><span class="line">num_epochs = 3</span><br><span class="line">net = linreg</span><br><span class="line">loss = squared_loss</span><br><span class="line"></span><br><span class="line">for epoch in range(num_epochs):</span><br><span class="line">    for X, y in data_iter(batch_size, features, labels):</span><br><span class="line">        l = loss(net(X, w, b), y)</span><br><span class="line">        l.sum().backward()# l是向量，用sum转换成标量，再对损失进行反向传播，计算模型参数 w 和 b 的梯度。</span><br><span class="line">        sgd([w, b], lr, batch_size)</span><br><span class="line">    with torch.no_grad():</span><br><span class="line">        train_l = loss(net(features, w, b), labels)</span><br><span class="line">        print(f&#x27;epoch &#123;epoch + 1&#125;, loss &#123;float(train_l.mean()):f&#125;&#x27;)</span><br></pre></td></tr></table></figure><h4 id="1-9-评估训练效果"><a href="#1-9-评估训练效果" class="headerlink" title="1.9 评估训练效果"></a>1.9 评估训练效果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(f&#x27;w的估计误差: &#123;true_w - w.reshape(true_w.shape)&#125;&#x27;)</span><br><span class="line">print(f&#x27;b的估计误差: &#123;true_b - b&#125;&#x27;)</span><br></pre></td></tr></table></figure><h3 id="2-线性回归的简洁实现"><a href="#2-线性回归的简洁实现" class="headerlink" title="2.线性回归的简洁实现"></a>2.线性回归的简洁实现</h3><h4 id="2-1-构造数据集"><a href="#2-1-构造数据集" class="headerlink" title="2.1 构造数据集"></a>2.1 构造数据集</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import torch</span><br><span class="line">from torch.utils import data</span><br><span class="line">from d2l import torch as d2l</span><br><span class="line"></span><br><span class="line">true_w = torch.tensor([2, -3.4])</span><br><span class="line">true_b = 4.2</span><br><span class="line">features, labels = d2l.synthetic_data(true_w, true_b, 1000)</span><br></pre></td></tr></table></figure><h4 id="2-2-构造一个PyTorch数据迭代器"><a href="#2-2-构造一个PyTorch数据迭代器" class="headerlink" title="2.2 构造一个PyTorch数据迭代器"></a>2.2 构造一个PyTorch数据迭代器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def load_array(data_arrays, batch_size, is_train=True):  </span><br><span class="line">    &quot;&quot;&quot;构造一个PyTorch数据迭代器。&quot;&quot;&quot;</span><br><span class="line">    dataset = data.TensorDataset(*data_arrays)#用于将特征数据和标签数据打包成一个数据集对象</span><br><span class="line">    return data.DataLoader(dataset, batch_size, shuffle=is_train)#从数据集中按照批大小 batch_size 加载数据</span><br><span class="line">#shuffle=is_train 表示在训练模式下（is_train=True）将数据打乱顺序</span><br><span class="line"></span><br><span class="line">batch_size = 10</span><br><span class="line">data_iter = load_array((features, labels), batch_size)</span><br><span class="line"></span><br><span class="line">next(iter(data_iter))</span><br></pre></td></tr></table></figure><h4 id="2-3-构建模型"><a href="#2-3-构建模型" class="headerlink" title="2.3 构建模型"></a>2.3 构建模型</h4><p><strong>nn.Sequential：</strong>PyTorch中的一个容器类，它按照顺序组合各种神经网络的层。</p><p><strong>nn.Linear(2, 1)：</strong><code>nn.Linear</code>是一个全连接层（线性层），它接收两个参数：输入特征的数量（输入维度）和输出特征的数量（输出维度）。因此该层将实现一个将输入维度为2的数据映射为输出维度为1的线性变换（线性回归模型）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from torch import nn</span><br><span class="line"></span><br><span class="line">net = nn.Sequential(nn.Linear(2, 1))</span><br><span class="line">#初始化模型参数</span><br><span class="line">net[0].weight.data.normal_(0, 0.01)#net[0]表示模型中的第一个层</span><br><span class="line">net[0].bias.data.fill_(0)</span><br><span class="line"></span><br><span class="line">loss = nn.MSELoss()#定义损失函数</span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=0.03)#实例化SGD实例</span><br></pre></td></tr></table></figure><h4 id="2-4-训练过程"><a href="#2-4-训练过程" class="headerlink" title="2.4 训练过程"></a>2.4 训练过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num_epochs = 3</span><br><span class="line">for epoch in range(num_epochs):</span><br><span class="line">    for X, y in data_iter:</span><br><span class="line">        l = loss(net(X), y)</span><br><span class="line">        trainer.zero_grad()</span><br><span class="line">        l.backward() #pytorch自动对l求sum，无需再求sum</span><br><span class="line">        trainer.step()</span><br><span class="line">    l = loss(net(features), labels)</span><br><span class="line">    print(f&#x27;epoch &#123;epoch + 1&#125;, loss &#123;l:f&#125;&#x27;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 线性回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据预处理</title>
      <link href="/posts/e92b12e5.html"/>
      <url>/posts/e92b12e5.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><h3 id="1-创建csv文件"><a href="#1-创建csv文件" class="headerlink" title="1.创建csv文件"></a>1.创建csv文件</h3><h4 id="1-1-创建目录"><a href="#1-1-创建目录" class="headerlink" title="1.1 创建目录"></a>1.1 创建目录</h4><p><strong>os.makedirs():</strong> 这是一个用于递归创建目录的函数。它接受一个路径作为输入，并创建路径中所有缺失的目录</p><p><strong>exist_ok=True:</strong> 这是os.makedirs()函数的一个可选参数。当设置为True时，如果目标目录已经存在，函数不会引发错误，而是默默地继续执行。</p><p><strong>os.path.join()：</strong>函数来连接两个路径部分：”..”(表示父目录) 和 “data”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">os.makedirs(os.path.join(&#x27;..&#x27;, &#x27;data&#x27;), exist_ok=True)</span><br><span class="line">#创建一个名为&quot;data&quot;的目录，该目录位于当前工作目录的父目录中</span><br><span class="line">data_file = os.path.join(&#x27;..&#x27;, &#x27;data&#x27;, &#x27;house_tiny.csv&#x27;)</span><br><span class="line">#创建一个名为data_file的变量，指向当前工作目录的上一级目录中的&quot;data&quot;目录下的&quot;house_tiny.csv&quot;文件</span><br></pre></td></tr></table></figure><p><em>注：如果目录不存在，它将被创建。这样，代码在运行时，如果”data”目录已经存在，它不会抛出异常，而是继续执行。</em></p><h4 id="1-2-创建新文件"><a href="#1-2-创建新文件" class="headerlink" title="1.2 创建新文件"></a>1.2 创建新文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">with open(data_file, &#x27;w&#x27;) as f:#打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</span><br><span class="line">    f.write(&#x27;NumRooms,Alley,Price\n&#x27;)</span><br><span class="line">    f.write(&#x27;NA,Pave,127500\n&#x27;)</span><br><span class="line">    f.write(&#x27;2,NA,106000\n&#x27;)</span><br><span class="line">    f.write(&#x27;4,NA,178100\n&#x27;)</span><br><span class="line">    f.write(&#x27;NA,NA,140000\n&#x27;)</span><br></pre></td></tr></table></figure><h3 id="2-数据预处理"><a href="#2-数据预处理" class="headerlink" title="2.数据预处理"></a>2.数据预处理</h3><h4 id="2-1-读取文件"><a href="#2-1-读取文件" class="headerlink" title="2.1 读取文件"></a>2.1 读取文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">data = pd.read_csv(data_file)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><h4 id="2-2-数据切片"><a href="#2-2-数据切片" class="headerlink" title="2.2 数据切片"></a>2.2 数据切片</h4><p><strong>iloc方法</strong>用于基于整数位置对数据进行索引和切片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">inputs, outputs = data.iloc[:,0:2], data.iloc[:,2]#iloc方法用于基于整数位置对数据进行索引和切片</span><br><span class="line">print(inputs)</span><br><span class="line">print(outputs)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"> NumRooms Alley</span><br><span class="line">0 NaN Pave</span><br><span class="line">1 2.0 NaN</span><br><span class="line">2 4.0 NaN</span><br><span class="line">3 NaN NaN</span><br><span class="line"></span><br><span class="line">0    127500</span><br><span class="line">1    106000</span><br><span class="line">2    178100</span><br><span class="line">3    140000</span><br><span class="line">Name: Price, dtype: int64</span><br></pre></td></tr></table></figure><h4 id="2-3-缺失值填充"><a href="#2-3-缺失值填充" class="headerlink" title="2.3 缺失值填充"></a>2.3 缺失值填充</h4><p><strong>fillna() 方法</strong>用指定的值（在这里是 inputs.mean() 即每列的均值）替换DataFrame中的缺失值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#对筛选出的数值类型列使用 mean() 方法计算各自列的均值进行填充</span><br><span class="line">inputs = inputs.fillna(inputs.select_dtypes(include=&#x27;number&#x27;).mean())</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">   NumRooms Alley</span><br><span class="line">0       3.0  Pave</span><br><span class="line">1       2.0   NaN</span><br><span class="line">2       4.0   NaN</span><br><span class="line">3       3.0   NaN</span><br></pre></td></tr></table></figure><p><strong>pd.get_dummies()函数</strong>对inputs DataFrame 进行独热编码（One-Hot Encoding）处理。</p><p><strong>dummy_na=True:</strong> 这是pd.get_dummies()函数的一个可选参数。当设置为True时，它会为原始数据中的缺失值创建一个额外的二进制列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inputs = pd.get_dummies(inputs, dummy_na=True)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">   NumRooms  Alley_Pave  Alley_nan</span><br><span class="line">0       3.0        True      False</span><br><span class="line">1       2.0       False       True</span><br><span class="line">2       4.0       False       True</span><br><span class="line">3       3.0       False       True</span><br></pre></td></tr></table></figure><p><em>注：独热编码的过程会将inputs DataFrame  中的分类变量转换成二进制的向量表示。对于每个分类变量，它会为每个类别创建一个新的列，其中类别出现的位置为1，其余位置为0。如果某一行数据的分类变量具有某个类别，则该类别对应的列为1，其他类别对应的列都为0。如果原始数据中有缺失值，独热编码会在对应的缺失值列中标记为1。</em></p><h4 id="2-4-类型转换"><a href="#2-4-类型转换" class="headerlink" title="2.4 类型转换"></a>2.4 类型转换</h4><p>inputs和outputs中的所有条目都是数值类型，可以转换为张量格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">inputs = inputs.astype(&#x27;float64&#x27;)</span><br><span class="line">x, y = torch.tensor(inputs.values), torch.tensor(outputs.values)</span><br><span class="line">x, y</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">(tensor([[3., 1., 0.],</span><br><span class="line">         [2., 0., 1.],</span><br><span class="line">         [4., 0., 1.],</span><br><span class="line">         [3., 0., 1.]], dtype=torch.float64),</span><br><span class="line"> tensor([127500, 106000, 178100, 140000]))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据预处理 </tag>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络(1)</title>
      <link href="/posts/409718da.html"/>
      <url>/posts/409718da.html</url>
      
        <content type="html"><![CDATA[<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><h3 id="1-激活函数"><a href="#1-激活函数" class="headerlink" title="1. 激活函数"></a>1. 激活函数</h3><p>激活函数：作用在于决定如何来激活输入信号的总和。</p><p>如，感知机的数学形式：<img src="https://typoraimg.wangak.cc/2023/img/202310201413373.png" alt="img2"></p><p>其亦可表达为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201413123.png" alt="img3"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201413687.png" alt="img4"></p><p>h(x)函数会将输入信号的总和转换为输出信号，即为激活函数。</p><h4 id="1-1-阶跃函数"><a href="#1-1-阶跃函数" class="headerlink" title="1.1 阶跃函数"></a>1.1 阶跃函数</h4><p><strong>激活函数：</strong>以阈值为界，一旦输入超过阈值，就切换输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#当输入超过0时，输出1，否则输出0的阶跃函数</span><br><span class="line">def step_function(x):</span><br><span class="line">  y = x &gt; 0</span><br><span class="line">  return y.astype(np.int)</span><br><span class="line">  #用astype()方法转换NumPy数组的类型</span><br></pre></td></tr></table></figure><p><strong>阶跃函数的图形</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pylab as plt</span><br><span class="line">def step_function(x):</span><br><span class="line"> return np.array(x &gt; 0, dtype=np.int)</span><br><span class="line">x = np.arange(-5.0, 5.0, 0.1)</span><br><span class="line">y = step_function(x)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.ylim(-0.1, 1.1) # 指定y轴的范围</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201413101.png" alt="img5" style="zoom:50%;"></p><h4 id="1-2-sigmoid函数"><a href="#1-2-sigmoid函数" class="headerlink" title="1.2 sigmoid函数"></a>1.2 sigmoid函数</h4><p><strong>sigmoid函数:</strong> $h(x)={1 \over 1+e^{-x} }$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def sigmoid(x):</span><br><span class="line"> return 1 / (1 + np.exp(-x))</span><br></pre></td></tr></table></figure><p><strong>sigmoid函数的图形</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(-5.0, 5.0, 0.1)</span><br><span class="line">y = sigmoid(x)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.ylim(-0.1, 1.1) # 指定y轴的范围</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>​                                                                <img src="https://typoraimg.wangak.cc/2023/img/202310201413595.png" alt="img6" style="zoom: 50%;"></p><p><em>注：神经网络的激活函数必须使用非线性函数。使用线性函数时，加深神经网络的层数就没有意义了，因为不管如何加深层数，总是存在与之等效的“无隐藏层的神经网络”。</em></p><h4 id="1-3-tanh函数"><a href="#1-3-tanh函数" class="headerlink" title="1.3 tanh函数"></a>1.3 tanh函数</h4><p><strong>tanh函数：</strong>$\LARGE {e^{x}-e^{-x}\over e^{x}+e^{-x} }$</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201413700.png" alt="img11" style="zoom: 50%;"></p><h4 id="1-4-ReLU函数"><a href="#1-4-ReLU函数" class="headerlink" title="1.4 ReLU函数"></a>1.4 ReLU函数</h4><p><strong>ReLU函数</strong>：<img src="https://typoraimg.wangak.cc/2023/img/202310201413423.png" alt="img7"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def relu(x):</span><br><span class="line"> return np.maximum(0, x)</span><br></pre></td></tr></table></figure><p><strong>ReLU函数的图形</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201413022.png" alt="img8" style="zoom: 67%;"></p><p><strong>Leaky ReLU函数:</strong>max(0.1x,x)</p><h3 id="2-恒等函数和-softmax函数"><a href="#2-恒等函数和-softmax函数" class="headerlink" title="2 恒等函数和 softmax函数"></a>2 恒等函数和 softmax函数</h3><p><strong>恒等函数：</strong>将输入按原样输出，对于输入的信息，不加以任何改动地直接输出。</p><p><strong>softmax函数：</strong><script type="math/tex">\large y_k={e^{a_k} \over \sum\limits_{i=1}^ne^{a_i}}</script></p><p>为了防止溢出，可对softmax函数进行如下改进：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201413575.png" alt="img10"></p><p><em>注：其中，$C^{，}$通常使用输入信号中的最大值，来防止溢出。</em></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201413580.png" alt="img9"></p><p><strong><em>注：</em></strong></p><p><em>1.softmax函数的输出通过箭头与所有的输入信号相连，输出层的各个神经元都受到所有输入信号的影响。</em></p><p><em>2.softmax函数将输出的给类别的得分转换成了概率</em></p><h3 id="3-交叉熵损失"><a href="#3-交叉熵损失" class="headerlink" title="3. 交叉熵损失"></a>3. 交叉熵损失</h3><p><strong>交叉熵损失：</strong>用于比较分类器预测分布与真实分布的距离。</p><p><strong>熵：</strong>H(p)=$-\sum p(x)log(p(x))$</p><p><strong>交叉熵：</strong>H(p,q)=$-\sum p(x)log(q(x))$</p><p><strong>相对熵(KL散度)：</strong>KL(p||q)=$-\sum p(x)log({q(x)\over p(x)})$</p><p><strong>三者之间的关系：</strong>H(p,q)=KL(p||q)+H(p)</p><p>p(x):真实分布概率        q(x):分类器预测分布概率</p><p><strong>注：</strong></p><p><strong>1.相对熵(KL散度)用于度量两个分布间的不相似性。</strong></p><p><strong>2.真实分布为one-hot形式时，H(p)=0,用H(p,q)代替KL(p||q),且交叉熵损失可化简为L=$-log(q_j)$,其中j为真实的类别。</strong></p><h3 id="3-参数优化"><a href="#3-参数优化" class="headerlink" title="3. 参数优化"></a>3. 参数优化</h3><p>参数优化：利用损失函数的输出值作为反馈信号来调整分类器的参数。</p><h4 id="3-1-梯度下降算法"><a href="#3-1-梯度下降算法" class="headerlink" title="3.1 梯度下降算法"></a>3.1 梯度下降算法</h4><p>原理：对于最小化优化问题，只需要将参数沿着梯度相反的方向前进一个步长，就可以实现目标函数的下降。</p><p>方向：负梯度方向</p><p>移动：步长(学习率)</p><p><strong>随机梯度下降算法：</strong>每次随机选择一个样本，计算损失并更新梯度。</p><p>缺点：单个样本的训练易受噪声的影响，不是每次迭代都向着整体最优化的方向。</p><p><strong>小批量随机梯度下降：</strong>每次选择m个样本，计算损失并更新梯度。</p><h4 id="3-2-梯度消失与梯度爆炸"><a href="#3-2-梯度消失与梯度爆炸" class="headerlink" title="3.2 梯度消失与梯度爆炸"></a>3.2 梯度消失与梯度爆炸</h4><p><strong>梯度消失：</strong>由于链式法则的乘法性质导致梯度趋向于0。</p><p>注：tanh,sigmoid局部梯度特性不利于网络梯度流的反向传播，尽量选择RelU或Leaky RelU。</p><p><strong>梯度爆炸：</strong>断崖处梯度乘以学习率后是一个非常大得值，从而“飞”出了合理区域，最终导致算法不收敛;</p><p>注：通过限制步长的大小(梯度裁剪)可以避免梯度爆炸。</p><h4 id="3-3-梯度下降算法的问题及改进"><a href="#3-3-梯度下降算法的问题及改进" class="headerlink" title="3.3 梯度下降算法的问题及改进"></a>3.3 梯度下降算法的问题及改进</h4><p><strong>梯度下降算法的问题：</strong>在一个方向上变化迅速而在另一个方向上的变化缓慢，并且通过增大步长不能提高算法的收敛速度。</p><p><strong>动量法：</strong>利用累加历史梯度信息更新梯度。</p><p>步骤：</p><p>1.采样</p><p>2.计算梯度：g</p><p>3.速度更新：v=uv+g(u:动量系数，u=0时为梯度下降算法)</p><p>4.更新权值：w=w-$\varepsilon$v($\varepsilon$:学习率）</p><p><em>注：梯度下降算法在局部最小点与鞍点处的梯度为0，无法通过，而动量法由于动量的存在可以通过，可以找到更优的解）</em></p><p><strong>自适应梯度算法(AdaGrad)：</strong>减小震荡方向的步长，增大平坦方向的步长。</p><p>步骤：</p><p>1.采样</p><p>2.计算梯度：g</p><p>3.累计平方梯度：r=r+g*g (r : 累计变量)</p><p>4.更新权值：w=w-${\large \varepsilon \over \sqrt{r}+\delta}*g$($\delta$:小常数，通常取$10^{-5}$,用于防止除0出错）</p><p><em>注：AdaGrad的一个限制是，随着累计变量的不断增大，导致每个参数的步长(学习率)非常小，这可能会大大减慢搜索进度，并且可能意味着无法找到最优值。</em></p><p><strong>RMSProp：</strong>累计平方梯度：r=$\rho$r+(1-$\rho$)g*g ($\rho$:衰减系数，通常取0.999)</p><p><strong>ADAM:</strong>同时使用动量与自适应梯度的思想</p><p>步骤：</p><p>1.采样</p><p>2.计算梯度：g</p><p>3.累计梯度：v=uv+(1-u)*g(u:动量系数,通常取0.9)</p><p>4.累计平方梯度：r=$\rho$r+(1-$\rho$)g*g </p><p>5.修正偏差：$\large \tilde{v}={v\over 1-u^t}$  ,$\large \tilde{r}={r\over 1-\rho^t}$ (t:迭代系数，该步骤极大缓解了算法初期的冷启动的问题)</p><p>6.更新权值：w=w-${\large \varepsilon \over \sqrt{\tilde{r}}+\delta}*\tilde{v}$</p><p><em>注：动量法等同于修改学习的“方向”，自适应梯度等同于修改“步长”，ADAM等同于修改“步长”和“方向”。</em></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> 激活函数 </tag>
            
            <tag> 交叉熵 </tag>
            
            <tag> 参数优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib</title>
      <link href="/posts/9ebec7b8.html"/>
      <url>/posts/9ebec7b8.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-plot-函数"><a href="#1-plot-函数" class="headerlink" title="1.plot()函数"></a>1.plot()函数</h3><p><strong>plot()函数会根据列表中的数据尝试绘制出有意义的图形</strong></p><p>参数：<img src="https://typoraimg.wangak.cc/2023/img/202310201403789.png" alt="img1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(-6,6,0.1)</span><br><span class="line">#起点：-6，终点：6，步长：0.1</span><br><span class="line">y1 = np.sin(x)</span><br><span class="line">y2 = np.cos(x)</span><br><span class="line">plt.plot(x,y1)</span><br><span class="line">plt.plot(x,y2)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201403827.png" alt="img2"></p><p><strong>plt的title()方法：</strong>添加图标标题</p><p><strong>xlabel()、ylabel()方法：</strong>为每条轴设置标题、大小等参数</p><p><strong>tick_params()方法：</strong>指定刻度标记的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(-6,6,0.1)#起点：-6，终点：6，步长：0.1</span><br><span class="line">y1 = np.sin(x)</span><br><span class="line">y2 = np.cos(x)</span><br><span class="line">plt.plot(x,y1)</span><br><span class="line">plt.plot(x,y2)</span><br><span class="line">plt.title(&quot;Figure 1&quot;,fontsize = 18,color = &quot;red&quot;)</span><br><span class="line">plt.xlabel(&quot;x value&quot;,fontsize = 14)</span><br><span class="line">plt.ylabel(&quot;y value&quot;,fontsize = 14)</span><br><span class="line">plt.tick_params(axis=&quot;both&quot;,labelsize=10)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201403269.png" alt="img3"></p><h3 id="2-图像的显示和读取"><a href="#2-图像的显示和读取" class="headerlink" title="2.图像的显示和读取"></a>2.图像的显示和读取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = plt.imread(&#x27;lena.png&#x27;)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://typoraimg.wangak.cc/2023/img/202310201403862.png" alt="img4"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> matplotlib </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感知机</title>
      <link href="/posts/18592060.html"/>
      <url>/posts/18592060.html</url>
      
        <content type="html"><![CDATA[<h2 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h2><h3 id="感知机的概念"><a href="#感知机的概念" class="headerlink" title="感知机的概念"></a>感知机的概念</h3><p>​        感知机是一种线性分类模型，属于<strong>判别模型</strong>，其使用一个线性方程所对应的超平面，将特征空间分成两部分。</p><p><strong>例：有两个输入的感知机：</strong></p><p>x1、x2是输入信号，y是输出信号，w1、w2是权重。图中的○称为“神经元”或者“节点”。输入信号被送往神经元时，会被分别乘以固定的权重（w1x1、w2x2）。神经元会计算传送过来的信号的总和，当这个总和超过了某个界限值时，才会输出1，否则输出0（二分类）。这也称为“神经元被激活”。这里将这个界限值称为阈值，用符号θ表示。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411985.png" alt="img1"></p><p>用<strong>数学公式</strong>表示为：</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201411463.png" alt="img2"></p><p><em>注：感知机的多个输入信号都有各自固有的权重，权重越大，对应该权重的信号的重要性就越高</em></p><p><strong>单层感知机的局限性：</strong>单层感知机的局限性就在于它只能表示由一条直线分割的空间。（单层感知机无法分离非线性空间）</p><p><strong>多层感知机：</strong>多层感知机可以表示非线性空间<img src="https://typoraimg.wangak.cc/2023/img/202310201412935.png" alt="img3"></p><h3 id="感知机的损失函数"><a href="#感知机的损失函数" class="headerlink" title="感知机的损失函数"></a>感知机的损失函数</h3><p>感知机的损失函数：误分类点到超平面的距离，即$-{1 \over {||w||}}\sum \limits_{x_i\in M} y_i(w*x_i+b)$,其中M为误分类点的集合</p><p><em>注：对于误分类点，$y_i(wx_i+b)$&lt;0</em></p><h3 id="感知机学习算法的原始形式"><a href="#感知机学习算法的原始形式" class="headerlink" title="感知机学习算法的原始形式"></a>感知机学习算法的原始形式</h3><p>感知机学习算法是误分类驱动的，采用随机梯度下降法，不断地极小化目标函数。</p><p><strong>训练过程：</strong></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201412894.png" alt="感知机算法学习步骤"></p><p><strong><em>注：</em></strong></p><p><em>1.当一个实例点被误分类时，调整w,b，使分离超平面向误分类点的一侧移动，以减少误分类点距离超平面的距离。</em></p><p><em>2.其训练过程等价于使用批量大小为1的梯度下降，并使用L(y,x,w)=max(0,-y(w,x))的损失函数。</em></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 感知机 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则化</title>
      <link href="/posts/ce0afb50.html"/>
      <url>/posts/ce0afb50.html</url>
      
        <content type="html"><![CDATA[<h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><h4 id="1-基本公式"><a href="#1-基本公式" class="headerlink" title="1.基本公式"></a>1.基本公式</h4><p><strong>经验风险最小化：</strong>$min{1\over N}\sum\limits_{i=1}^NL(y_i,f(x_i))$<br><strong>正则化项：</strong>$\lambda J(f)$</p><p><strong>L1正则化项：</strong>$||w_1||=|w1|+|w2|+…..+|w_n|$<br><strong>L2正则化项：</strong>$||w_2||=\sqrt [2]{w_1^2+w_2^2+…..+w_n^2}$</p><p><strong>结构风险最小化：</strong>$min{1\over N}\sum_{i=1}^{N}L(y_i,f(x_i)+\lambda J(f)$</p><p>注：其中λ 是正则化参数，用来控制正则化项在整体损失函数中的重要程度。较大的 λ 值会增加对模型复杂度的惩罚，从而更强调正则化的效果。</p><h4 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h4><p><strong>过拟合：</strong>模型过于复杂或过度拟合了训练数据的细节和噪声，导致对新数据的泛化能力不佳。</p><p><strong>欠拟合：</strong>无法在训练数据上达到较好的拟合效果，也不能很好地泛化到新数据。</p><p><strong>正则化：</strong>在经验风险的基础上增添了一个正则化项，用来控制模型的复杂度，可以防止过拟合。通过正则化可以选择出经验风险和模型复杂度同时较小的模型。</p><h4 id="3-常见问题："><a href="#3-常见问题：" class="headerlink" title="3.常见问题："></a>3.常见问题：</h4><h5 id="3-1为什么正则化可以防止过拟合？"><a href="#3-1为什么正则化可以防止过拟合？" class="headerlink" title="3.1为什么正则化可以防止过拟合？"></a>3.1为什么正则化可以防止过拟合？</h5><p>答：正则化等价于对模型的复杂度添加约束条件，其具有相同的解空间。</p><h5 id="3-2为什么L1正则化具有稀疏性？"><a href="#3-2为什么L1正则化具有稀疏性？" class="headerlink" title="3.2为什么L1正则化具有稀疏性？"></a>3.2为什么L1正则化具有稀疏性？</h5><p>答：在最小化损失函数时，L1正则化项会与损失函数一起构成优化问题。从解空间形状的角度分析，，另外，L1正则化在参数空间中形成了一个尖锐的角，使得优化算法更有可能选择参数为零的解（即L1正则化图像与损失函数的等值线的交点更可能位于坐标轴上）。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201415392.png" alt="image-20230710170542545"></p><p>从贝叶斯的观点，所有的正则化都是来自于对参数分布的先验，Laplace先验会导出L1正则化，Gauss先验会导出L2正则化，而Laplace分布取零值的概率较大，所以参数取零值的概率较大，因而L1正则化具有稀疏性。</p><h5 id="3-3推导L1先验分布是Laplace分布"><a href="#3-3推导L1先验分布是Laplace分布" class="headerlink" title="3.3推导L1先验分布是Laplace分布"></a>3.3推导L1先验分布是Laplace分布</h5><p>后验概率：$P(\theta|D)={P(D|\theta)*P(\theta)} \over P(D) $</p><p>要使后验概率最大，即使$P(D|\theta)*P(\theta)$最大</p><p>取log加负号后求其最小值：</p><script type="math/tex; mode=display">-log(P(D|\theta))-log(P(\theta))</script><p>其等价于求$-\sum\limits_{i=1}^NlogP(x_i|\theta)-log(P(\theta))$的最小值</p><p>假设$P(\theta)$满足拉普拉斯分布：</p><script type="math/tex; mode=display">P(\theta)={1 \over {2\lambda}}e^{-|\theta|\over \lambda}</script><p>代入$P(\theta)$后，即求$-\sum\limits_{i=1}^NlogP(x_i|\theta)-log({1 \over {2\lambda}})+{1 \over \lambda}|\theta|$</p><p>其相当于L1正则</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 正则化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy基础</title>
      <link href="/posts/90d07c36.html"/>
      <url>/posts/90d07c36.html</url>
      
        <content type="html"><![CDATA[<h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h3><h4 id="1-np-random-randn函数"><a href="#1-np-random-randn函数" class="headerlink" title="1.np.random.randn函数"></a>1.np.random.randn函数</h4><p>numpy中rand与randn的区别:</p><p>(1).rand是随机生成值在0-1之间的函数。</p><p>(2).randn是随机生成均值为0，方差为1的正态分布上的数值。</p><p><strong>np.random.randn函数不同个数参数的输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">in: x = np.random.randn(3)</span><br><span class="line">    print(x)#输出1行3列的一维数组</span><br><span class="line">out:array([0.87154087, 0.78316833, 0.97669061])</span><br><span class="line"></span><br><span class="line">in: x = np.random.randn(4,3)</span><br><span class="line">    print(x)#输出4行3列的二维数组</span><br><span class="line">out:[[ 0.81536654 -0.06119516  0.23273782]</span><br><span class="line">     [-1.3096832   0.11305955 -0.43735283]</span><br><span class="line">     [-1.68680386 -0.08597495 -1.20287298]</span><br><span class="line">     [-0.30945828 -0.50162275  0.41018841]]</span><br><span class="line">     </span><br><span class="line">in: x = np.random.randn(4,3,2)</span><br><span class="line">    print(x)#输出4个小矩阵，每个小矩阵都是3行2列</span><br><span class="line">out:[[[-0.24571791 -0.51039714]</span><br><span class="line">      [ 0.88810165 -0.94045245]</span><br><span class="line">      [-0.37231775  1.33880112]]</span><br><span class="line"></span><br><span class="line">     [[ 0.09029384 -0.76451493]</span><br><span class="line">      [ 1.25793366  1.04770133]</span><br><span class="line">      [ 0.92711157  1.07891784]]</span><br><span class="line"></span><br><span class="line">     [[ 1.10773856 -0.0084584 ]</span><br><span class="line">      [-0.31300087 -0.80121054]</span><br><span class="line">      [ 0.15738774 -1.12602141]]</span><br><span class="line"></span><br><span class="line">     [[ 0.54273696  1.2454806 ]</span><br><span class="line">      [-0.80644804 -1.00282505]</span><br><span class="line">      [ 0.70669598 -0.45169629]]]</span><br><span class="line">   </span><br><span class="line">#其他情况以此类推</span><br></pre></td></tr></table></figure><h4 id="2-ndarray的创建"><a href="#2-ndarray的创建" class="headerlink" title="2.ndarray的创建"></a>2.ndarray的创建</h4><p>ndarray是一个通用的同构数据多维容器，其中的所有元素必须是相同类型的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">in :data1 = [6, 7.5, 8, 0, 1]</span><br><span class="line">    arr1 = np.array(data1)</span><br><span class="line">    print(arr1)</span><br><span class="line">out:array([6. , 7.5, 8. , 0. , 1. ])#np.array会尝试为新建的这个数组推断出一个较为合适的数据类型。</span><br><span class="line"></span><br><span class="line">in :data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]</span><br><span class="line">    arr2 = np.array(data2)</span><br><span class="line">    print(arr2)</span><br><span class="line">out:[[1 2 3 4]</span><br><span class="line">     [5 6 7 8]]</span><br><span class="line">in :arr1 = np.array([1, 2, 3], dtype=np.float64)#指定创建的array的元素类型</span><br><span class="line">    print(arr1)</span><br><span class="line">out:[1. 2. 3.]</span><br><span class="line"></span><br><span class="line">in :arr2.ndim  #维度大小</span><br><span class="line">out:2</span><br><span class="line"></span><br><span class="line">in :arr2.shape #数组大小</span><br><span class="line">out:(2, 4)</span><br><span class="line"></span><br><span class="line">in :arr2.dtype #元素类型</span><br><span class="line">out:dtype(&#x27;int32&#x27;) </span><br></pre></td></tr></table></figure><p>zeros和ones分别可以创建指定长度或形状的全0或全1数组。</p><p>empty可以创建一个没有任何具体值的数组，通常它返回的都是一些未初始化的垃圾值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in : np.zeros(10)</span><br><span class="line">out: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])</span><br></pre></td></tr></table></figure><p>通过ndarray的astype方法可以明确地将一个数组从一个dtype转换成另一个dtype：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in :arr = np.array([1, 2, 3, 4, 5])</span><br><span class="line">    float_arr = arr.astype(np.float64)</span><br><span class="line">    float_arr.dtype</span><br><span class="line">out:dtype(&#x27;float64&#x27;)</span><br></pre></td></tr></table></figure><h4 id="3-numpy数组的运算"><a href="#3-numpy数组的运算" class="headerlink" title="3.numpy数组的运算"></a>3.numpy数组的运算</h4><p>大小相等的数组之间的任何算术运算及数组与标量的算术运算都会将运算应用到元素级。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In :arr = np.array([[1., 2., 3.], [4., 5., 6.]])</span><br><span class="line">    arr</span><br><span class="line">Out: </span><br><span class="line">array([[ 1.,  2.,  3.],</span><br><span class="line">       [ 4.,  5.,  6.]])</span><br><span class="line"></span><br><span class="line">In : arr * arr</span><br><span class="line">Out: </span><br><span class="line">array([[  1.,   4.,   9.],</span><br><span class="line">       [ 16.,  25.,  36.]])</span><br></pre></td></tr></table></figure><p><strong>矩阵的乘法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in: A = np.array([[1,2], [3,4]])</span><br><span class="line">    B = np.array([[5,6], [7,8]])</span><br><span class="line">    np.dot(A, B)#进行矩阵A与矩阵B的乘法运算</span><br><span class="line">out:</span><br><span class="line">array([[19, 22],</span><br><span class="line">       [43, 50]])</span><br></pre></td></tr></table></figure><h4 id="4-ndarray的切片"><a href="#4-ndarray的切片" class="headerlink" title="4.ndarray的切片"></a>4.ndarray的切片</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">in :arr2d</span><br><span class="line">out:</span><br><span class="line">array([[1, 2, 3],</span><br><span class="line">       [4, 5, 6],</span><br><span class="line">       [7, 8, 9]])</span><br><span class="line">in :arr2d[:2, 1:]</span><br><span class="line">out:</span><br><span class="line">array([[2, 3],</span><br><span class="line">       [5, 6]])</span><br></pre></td></tr></table></figure><h4 id="5-广播"><a href="#5-广播" class="headerlink" title="5.广播"></a>5.广播</h4><p>NumPy中，形状不同的数组之间也可以进行运算。</p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201405108.png" alt="img1"></p><p><img src="https://typoraimg.wangak.cc/2023/img/202310201406185.png" alt="img2"></p><h4 id="6-np-arange-用法"><a href="#6-np-arange-用法" class="headerlink" title="6.np.arange()用法"></a>6.np.arange()用法</h4><p><strong>一个参数时：</strong></p><h5 id="（1）参数值为终点"><a href="#（1）参数值为终点" class="headerlink" title="（1）参数值为终点"></a>（1）参数值为终点</h5><h5 id="（2）起点取默认值0"><a href="#（2）起点取默认值0" class="headerlink" title="（2）起点取默认值0"></a>（2）起点取默认值0</h5><h5 id="（3）步长取默认值1"><a href="#（3）步长取默认值1" class="headerlink" title="（3）步长取默认值1"></a>（3）步长取默认值1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in ：</span><br><span class="line">import numpy </span><br><span class="line">print(numpy.arange(6)) #从0到5,不包括6</span><br><span class="line">out:</span><br><span class="line">[0 1 2 3 4 5]</span><br></pre></td></tr></table></figure><p><strong>两个参数时：</strong></p><h5 id="（1）第一个参数为起点"><a href="#（1）第一个参数为起点" class="headerlink" title="（1）第一个参数为起点"></a>（1）第一个参数为起点</h5><h5 id="（2）第二个参数为终点（不包括）"><a href="#（2）第二个参数为终点（不包括）" class="headerlink" title="（2）第二个参数为终点（不包括）"></a>（2）第二个参数为终点（不包括）</h5><h5 id="（3）步长取默认值1-1"><a href="#（3）步长取默认值1-1" class="headerlink" title="（3）步长取默认值1"></a>（3）步长取默认值1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in: print(numpy.arange(6, 10)) #[6,9)</span><br><span class="line">out:[6 7 8 9]</span><br></pre></td></tr></table></figure><p><strong>三个参数时：</strong></p><h5 id="（1）第一个参数为起点-1"><a href="#（1）第一个参数为起点-1" class="headerlink" title="（1）第一个参数为起点"></a>（1）第一个参数为起点</h5><h5 id="（2）第二个参数为终点（不包括）-1"><a href="#（2）第二个参数为终点（不包括）-1" class="headerlink" title="（2）第二个参数为终点（不包括）"></a>（2）第二个参数为终点（不包括）</h5><h5 id="（3）第三个参数为步长"><a href="#（3）第三个参数为步长" class="headerlink" title="（3）第三个参数为步长"></a>（3）第三个参数为步长</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in: print(np.arange(6,20,1.5))  #步长支持小数</span><br><span class="line">out:</span><br><span class="line">[ 6.   7.5  9.  10.5 12.  13.5 15.  16.5 18.  19.5]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础（2）</title>
      <link href="/posts/c74eb236.html"/>
      <url>/posts/c74eb236.html</url>
      
        <content type="html"><![CDATA[<h2 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h2><h3 id="1-enumerate函数"><a href="#1-enumerate函数" class="headerlink" title="1.enumerate函数"></a>1.enumerate函数</h3><p>用于返回<code>(i, value)</code>元组序列，可以跟踪当前项的序号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (i,value) in enumerate(tup):</span><br><span class="line">    print(str(i)+&quot;:&quot;+value)</span><br></pre></td></tr></table></figure><h3 id="2-sorted函数"><a href="#2-sorted函数" class="headerlink" title="2.sorted函数"></a>2.sorted函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In : sorted([7, 1, 2, 6, 0, 3, 2])</span><br><span class="line">Out: [0, 1, 2, 2, 3, 6, 7]</span><br><span class="line"></span><br><span class="line">In : sorted(&#x27;horse race&#x27;)#对字符串进行排序</span><br><span class="line">Out: [&#x27; &#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;e&#x27;, &#x27;h&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;r&#x27;, &#x27;s&#x27;]</span><br></pre></td></tr></table></figure><p>sorted()函数与sort()函数不同，会返回一个排序列表，而不改变原有序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">in :tup1=[2,6,8,1]</span><br><span class="line">    tup1.sort()</span><br><span class="line">    print(tup1)</span><br><span class="line">out:[1, 2, 6, 8]</span><br><span class="line"></span><br><span class="line">in :tup1=[2,6,8,1]</span><br><span class="line">    tup2=sorted(tup1)</span><br><span class="line">    print(tup2)</span><br><span class="line">    print(tup1)</span><br><span class="line">out:[1, 2, 6, 8]</span><br><span class="line">    [2, 6, 8, 1]</span><br></pre></td></tr></table></figure><p><strong>sort（）可以接受两个参数sort（key,reverse）</strong></p><p>key接受的函数返回值，表示此元素的权值，sort将按照权值大小进行排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in: x=[8,9,0,7,4,5,1,2,3,6]</span><br><span class="line">    def size(a):</span><br><span class="line">        x=10-int(a)</span><br><span class="line">        return x</span><br><span class="line">    x.sort(key=size)</span><br><span class="line">    print(x)</span><br><span class="line">out:[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br></pre></td></tr></table></figure><p>reverse接受的是一个bool类型的值 (Ture or False),表示是否颠倒排列顺序,一般默认的是False</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in :x=[8,9,0,7,4,5,1,2,3,6]</span><br><span class="line">    x.sort(reverse=True)</span><br><span class="line">    print(x)</span><br><span class="line">out:[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br></pre></td></tr></table></figure><p><strong>sort根据关键字排序</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in :l = [[1,2,3],[2,2,1],[2,1,3]]</span><br><span class="line">    l.sort(key = lambda x: (x[0],-x[1]))</span><br><span class="line">    print(l)</span><br><span class="line">out:[[1, 2, 3], [2, 2, 1], [2, 1, 3]]</span><br></pre></td></tr></table></figure><p><u>注：其中key表示按第几个关键字排序，lambda x:后()中的元素表示了关键字的优先级（由高至低），x[0]表示按第一个关键词的升序排列，-x[1]表示按第二个关键词的降序排列</u></p><h3 id="3-zip函数"><a href="#3-zip函数" class="headerlink" title="3.zip函数"></a>3.zip函数</h3><p><code>zip</code>可以将多个列表、元组或其它序列成对组合成一个元组列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In :tup1=1,2,3</span><br><span class="line">    tup2=&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;</span><br><span class="line">    ziped=zip(tup1,tup2)</span><br><span class="line">    list(ziped)</span><br><span class="line">out:[(1, &#x27;a&#x27;), (2, &#x27;b&#x27;), (3, &#x27;c&#x27;)]</span><br></pre></td></tr></table></figure><p>处理任意多的序列，元素的个数取决于最短的序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In :tup1=1,2,3</span><br><span class="line">    tup2=&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;</span><br><span class="line">    tup3=False,True</span><br><span class="line">    ziped=zip(tup1,tup2,tup3)</span><br><span class="line">    list(ziped)</span><br><span class="line">out:[(1, &#x27;a&#x27;, False), (2, &#x27;b&#x27;, True)]</span><br></pre></td></tr></table></figure><p><strong>（1）zip函数的常见用法：同时迭代多个序列</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in :tup1=1,2,3</span><br><span class="line">    tup2=&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;</span><br><span class="line">    for i,(value1,value2) in enumerate(zip(tup1,tup2)):</span><br><span class="line">         print(&#x27;&#123;0&#125;:&#123;1&#125;,&#123;2&#125;&#x27;.format(i,value1,value2))</span><br><span class="line">out:0:1,a</span><br><span class="line">    1:2,b</span><br><span class="line">    2:3,c</span><br></pre></td></tr></table></figure><p><strong>（2）zip函数的常见用法:解压序列</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in :pitchers = [(&#x27;Nolan&#x27;, &#x27;Ryan&#x27;), (&#x27;Roger&#x27;, &#x27;Clemens&#x27;),(&#x27;Schilling&#x27;, &#x27;Curt&#x27;)]</span><br><span class="line">    first_names, last_names = zip(*pitchers)</span><br><span class="line">    print(first_names)</span><br><span class="line">    print(last_names)</span><br><span class="line">out:(&#x27;Nolan&#x27;, &#x27;Roger&#x27;, &#x27;Schilling&#x27;)</span><br><span class="line">    (&#x27;Ryan&#x27;, &#x27;Clemens&#x27;, &#x27;Curt&#x27;)</span><br></pre></td></tr></table></figure><h3 id="4-reversed函数"><a href="#4-reversed函数" class="headerlink" title="4.reversed函数"></a>4.reversed函数</h3><p>用于从后向前迭代序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in :tup = tuple(&#x27;string&#x27;)</span><br><span class="line">    for (i,value) in enumerate(reversed(tup)):#从后向前迭代元组</span><br><span class="line">        print(str(i)+&quot;:&quot;+value,end=&#x27; &#x27;)</span><br><span class="line">out:0:g 1:n 2:i 3:r 4:t 5:s </span><br></pre></td></tr></table></figure><h3 id="5-匿名（lambda）函数"><a href="#5-匿名（lambda）函数" class="headerlink" title="5.匿名（lambda）函数"></a>5.匿名（lambda）函数</h3><p>由单条语句组成，该语句的结果就是返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">in :def apply_to_list(some_list, f):</span><br><span class="line">        return [f(x) for x in some_list]</span><br><span class="line"></span><br><span class="line">    ints = [4, 0, 1, 5, 6]</span><br><span class="line">    apply_to_list(ints, lambda x: x * 2)#&#x27;:&#x27;前为参数,&#x27;:&#x27;后为运算表达式</span><br><span class="line">out:[8, 0, 2, 10, 12]</span><br><span class="line"></span><br><span class="line">in :strings = [&#x27;foo&#x27;, &#x27;card&#x27;, &#x27;bar&#x27;, &#x27;aaaa&#x27;, &#x27;abab&#x27;]</span><br><span class="line">    strings.sort(key=lambda x: len(set(list(x))))#根据不同字母的数量，对strings排序</span><br><span class="line">    print(strings)</span><br><span class="line">out:[&#x27;aaaa&#x27;, &#x27;foo&#x27;, &#x27;abab&#x27;, &#x27;bar&#x27;, &#x27;card&#x27;]</span><br></pre></td></tr></table></figure><h3 id="6-迭代器"><a href="#6-迭代器" class="headerlink" title="6.迭代器"></a>6.迭代器</h3><p><strong>可迭代对象</strong>:可迭代的对象要有_iter_()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#常见的可迭代对象</span><br><span class="line">iterables=[</span><br><span class="line">    &quot;123&quot;,#字符串</span><br><span class="line">    [1,2,3],#列表</span><br><span class="line">    (1,2,3),#元组</span><br><span class="line">    &#123;1:&#x27;a&#x27;,2:&#x27;b&#x27;&#125;,#字典</span><br><span class="line">    &#123;1,2,3&#125;,#集合</span><br><span class="line">]</span><br><span class="line">for iterable in iterables:</span><br><span class="line">    print(type(iterable))</span><br><span class="line">    for x in iterable:</span><br><span class="line">        print(x,end=&#x27;,&#x27;)</span><br><span class="line">    print(&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line">1,2,3,</span><br><span class="line">&lt;class &#x27;list&#x27;&gt;</span><br><span class="line">1,2,3,</span><br><span class="line">&lt;class &#x27;tuple&#x27;&gt;</span><br><span class="line">1,2,3,</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">1,2,</span><br><span class="line">&lt;class &#x27;set&#x27;&gt;</span><br><span class="line">1,2,3,</span><br></pre></td></tr></table></figure><p><strong>迭代器：</strong>有_next<em>()方法的可迭代对象，即迭代器既有_iter\</em>()方法，又有_next_()方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#列表不是迭代器</span><br><span class="line">from collections.abc import Iterator</span><br><span class="line">lst=[1,2,3]</span><br><span class="line">isinstance(lst,Iterator)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">False</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#iter(lst)是迭代器</span><br><span class="line">x=iter(lst)</span><br><span class="line">isinstance(x,Iterator)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">True</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">in: x.__next__()</span><br><span class="line">out:1</span><br><span class="line"></span><br><span class="line">in: x.__next__()</span><br><span class="line">out:2</span><br><span class="line"></span><br><span class="line">in: next(x)</span><br><span class="line">out:3</span><br></pre></td></tr></table></figure><p><strong>自定义迭代器：</strong>为类添加_iter_()方法和_next_()方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#定义一个将字符串反序输出的迭代器</span><br><span class="line">class ReverseIterator:</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = len(data)</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.index &lt;= 0:</span><br><span class="line">            raise StopIteration</span><br><span class="line">        self.index -= 1</span><br><span class="line">        return self.data[self.index]</span><br><span class="line"></span><br><span class="line">r=ReverseIterator(&#x27;abc&#x27;)</span><br><span class="line">for i in r:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">c</span><br><span class="line">b</span><br><span class="line">a</span><br></pre></td></tr></table></figure><h3 id="7-生成器"><a href="#7-生成器" class="headerlink" title="7.生成器"></a>7.生成器</h3><p><strong>生成器</strong>：一种特殊的迭代器,通过函数的方式来定义，使用关键字<strong>yield</strong>来返回值，而不是使用<strong>return</strong>。当生成器函数被调用时，它并不会立即执行函数体，而是返回一个生成器对象，该对象可以用于逐步迭代产生值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def countdown(n):</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        yield n</span><br><span class="line">        n -= 1</span><br><span class="line"></span><br><span class="line"># 使用生成器进行迭代</span><br><span class="line">for num in countdown(5):</span><br><span class="line">    print(num, end=&quot; &quot;)</span><br><span class="line">   </span><br><span class="line">out:</span><br><span class="line">5 4 3 2 1 </span><br></pre></td></tr></table></figure><p><em>注：<strong>yield</strong>语句右边的对象作为next()的返回值，生成器在yield所在的位置暂停，当再次使用next()时继续从该位置继续运行。</em></p><h3 id="8-collections-Counter"><a href="#8-collections-Counter" class="headerlink" title="8.collections.Counter"></a>8.collections.Counter</h3><p><strong>collections.Counter:</strong>是Python标准库中的一个类，用于计数可哈希对象（通常是元素或元素组成的集合）的出现次数。</p><p><strong>collections.Counter是一个字典的子类，提供了方便的计数功能，可以用于各种计数和统计场景</strong></p><h4 id="8-1-创建计数器"><a href="#8-1-创建计数器" class="headerlink" title="8.1 创建计数器"></a>8.1 创建计数器</h4><p>可以通过传入可迭代对象（如列表、元组、字符串等）或字典来创建计数器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line"># 通过列表创建计数器</span><br><span class="line">a= Counter([&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;apple&#x27;])</span><br><span class="line"></span><br><span class="line"># 通过字符串创建计数器</span><br><span class="line">b = Counter(&#x27;hello&#x27;)</span><br><span class="line"></span><br><span class="line"># 通过字典创建计数器</span><br><span class="line">c = Counter(&#123;&#x27;apple&#x27;: 3, &#x27;orange&#x27;: 2, &#x27;banana&#x27;: 1&#125;)</span><br><span class="line">a,b,c</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">(Counter(&#123;&#x27;apple&#x27;: 3, &#x27;orange&#x27;: 1, &#x27;banana&#x27;: 1&#125;),</span><br><span class="line"> Counter(&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 1, &#x27;l&#x27;: 2, &#x27;o&#x27;: 1&#125;),</span><br><span class="line"> Counter(&#123;&#x27;apple&#x27;: 3, &#x27;orange&#x27;: 2, &#x27;banana&#x27;: 1&#125;))</span><br></pre></td></tr></table></figure><h4 id="8-2-计数元素的出现次数"><a href="#8-2-计数元素的出现次数" class="headerlink" title="8.2 计数元素的出现次数"></a>8.2 计数元素的出现次数</h4><p>可以使用<code>elements()</code>方法获取计数器中所有元素的迭代器，也可以使用普通的字典语法或<code>get()</code>方法获取指定元素的出现次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c = Counter(&#x27;abracadabra&#x27;)</span><br><span class="line">print(c)  # Counter(&#123;&#x27;a&#x27;: 5, &#x27;b&#x27;: 2, &#x27;r&#x27;: 2, &#x27;c&#x27;: 1, &#x27;d&#x27;: 1&#125;)</span><br><span class="line"></span><br><span class="line">print(c[&#x27;a&#x27;])  # 5</span><br><span class="line">print(c.get(&#x27;b&#x27;))  # 2</span><br><span class="line"></span><br><span class="line">elements = list(c.elements())  # [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;r&#x27;, &#x27;r&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br></pre></td></tr></table></figure><h4 id="8-3-获取最常见的元素"><a href="#8-3-获取最常见的元素" class="headerlink" title="8.3 获取最常见的元素"></a>8.3 获取最常见的元素</h4><p>可以使用<code>most_common()</code>方法获取计数器中出现频率最高的元素。该方法返回一个列表，其中每个元素是一个元组，包含元素和对应的计数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c = Counter(&#x27;abracadabra&#x27;)</span><br><span class="line">print(c.most_common(2))</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[(&#x27;a&#x27;, 5), (&#x27;b&#x27;, 2)]</span><br></pre></td></tr></table></figure><h4 id="8-4-更新计数器"><a href="#8-4-更新计数器" class="headerlink" title="8.4 更新计数器"></a>8.4 更新计数器</h4><p>可以使用<code>update()</code>方法将另一个计数器、可迭代对象或字典的元素合并到当前计数器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c1 = Counter(&#x27;abracadabra&#x27;)</span><br><span class="line">c2 = Counter(&#x27;alakazam&#x27;)</span><br><span class="line"></span><br><span class="line">c1.update(c2)  # 合并c2中的计数到c1中</span><br><span class="line">print(c1)  # Counter(&#123;&#x27;a&#x27;: 8, &#x27;b&#x27;: 2, &#x27;r&#x27;: 2, &#x27;l&#x27;: 1, &#x27;k&#x27;: 1, &#x27;z&#x27;: 1, &#x27;m&#x27;: 1&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> 生成器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础（1）</title>
      <link href="/posts/d5fb1dd8.html"/>
      <url>/posts/d5fb1dd8.html</url>
      
        <content type="html"><![CDATA[<h3 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h3><h4 id="1-字符串输入：使用input-函数"><a href="#1-字符串输入：使用input-函数" class="headerlink" title="1.字符串输入：使用input()函数"></a>1.字符串输入：使用input()函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x=input()</span><br><span class="line">y=input()</span><br><span class="line">print(x+y)</span><br><span class="line">#输入：5 4</span><br><span class="line"> 输出：54(&quot;+&quot;对于字符串进行拼接)</span><br><span class="line"></span><br><span class="line">name=input(&quot;请输入姓名：&quot;)#input()中添加文本对所要输入的信息进行提示</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure><h4 id="2-列表（list"><a href="#2-列表（list" class="headerlink" title="2.列表（list)"></a>2.列表（list)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span><br><span class="line">print(List)</span><br><span class="line">print(len(List))#获取列表的长度</span><br><span class="line">print(List[-1])#获取列表表尾的元素</span><br><span class="line">print(List[-2])#获取列表倒数第二个元素</span><br><span class="line"></span><br><span class="line">#列表的插入</span><br><span class="line">List.append(&#x27;D&#x27;)#列表尾部插入</span><br><span class="line">List.insert(2,&#x27;F&#x27;)#列表指定位置插入</span><br><span class="line">List.pop()#列表尾部元素删除</span><br><span class="line">List.pop(2)#删除列表指定索引处的元素</span><br><span class="line">print(List)</span><br><span class="line">List.remove(&#x27;A&#x27;)#一次remove()只删除一个，若有多个，要多次使用remove()函数</span><br><span class="line">print(List)</span><br></pre></td></tr></table></figure><h4 id="3-元组-tuple"><a href="#3-元组-tuple" class="headerlink" title="3.元组(tuple)"></a>3.元组(tuple)</h4><p>tuple一旦初始化就不能修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tuple=(2,3,4)#定义元组并初始化</span><br><span class="line">print(tuple)</span><br><span class="line">tuple2=(2,)#定义单元组</span><br><span class="line">tuple3=(2)#由于出现歧义，tuple3为2这个数</span><br><span class="line">print(tuple2,tuple3)</span><br></pre></td></tr></table></figure><h4 id="4-for-…-in…-循环：可以用于遍历元组或列表"><a href="#4-for-…-in…-循环：可以用于遍历元组或列表" class="headerlink" title="4.for ….in….循环：可以用于遍历元组或列表"></a>4.for ….in….循环：可以用于遍历元组或列表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span><br><span class="line">for i in List:#遍历列表</span><br><span class="line">    print(i)</span><br><span class="line">print(list(range(5)))#range(5)生成一个从0开始小于5的整数序列</span><br><span class="line">                     #list()将这个整数序列转换成列表</span><br><span class="line">sum=0</span><br><span class="line">for i in range(101):#计算从0加到100的值</span><br><span class="line">    sum+=i</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><h4 id="5-字典-dict"><a href="#5-字典-dict" class="headerlink" title="5.字典(dict)"></a>5.字典(dict)</h4><p>使用键-值（key-value）存储，具有极快的查找速度</p><h5 id="字典的创建"><a href="#字典的创建" class="headerlink" title="字典的创建"></a>字典的创建</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dict=&#123;&#x27;A&#x27;:1,&#x27;B&#x27;:2,&#x27;C&#x27;:3&#125;#创建字典</span><br><span class="line">Dict[&#x27;A&#x27;]=4#修改key对应的值</span><br><span class="line">print(&#x27;D&#x27; in Dict)#判断字典key是否存在</span><br><span class="line">Dict.pop(&#x27;A&#x27;)#按key删除 或可用：del Dict[&#x27;A&#x27;]</span><br><span class="line">print(Dict)#注：字典中的key是不可变的对象</span><br><span class="line">Dict[&#x27;D&#x27;]=4#向字典中添加键值对</span><br></pre></td></tr></table></figure><h5 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for key,val in Dict.items():#以键值对的形式遍历字典</span><br><span class="line">    print(key,val)</span><br><span class="line">for key in Dict.keys():#遍历字典的键，其中.keys()可省略</span><br><span class="line">    print(key)</span><br><span class="line">for val in Dict.values():#遍历字典中的值</span><br><span class="line">    print(val)</span><br><span class="line">for key in sorted(Dict.keys()):#在遍历前对字典的键的列表排序</span><br><span class="line">    print(key)</span><br><span class="line">for val in set(Dict.values()):#在遍历前对字典的值的列表去重</span><br><span class="line">    print(val)</span><br></pre></td></tr></table></figure><p><strong>dictionary.get(key, default)</strong></p><ul><li><code>dictionary</code> 是要获取值的字典对象。</li><li><code>key</code> 是要查找的键。</li><li><code>default</code> 是一个可选参数，表示如果键在字典中不存在时，返回的默认值。如果不提供 <code>default</code> 参数，默认值为 <code>None</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fruits = &#123;&#x27;apple&#x27;: 3, &#x27;banana&#x27;: 2, &#x27;orange&#x27;: 5&#125;</span><br><span class="line"></span><br><span class="line"># 获取键 &#x27;apple&#x27; 对应的值</span><br><span class="line">print(fruits.get(&#x27;apple&#x27;))  # 输出: 3</span><br><span class="line"></span><br><span class="line"># 获取键 &#x27;grape&#x27; 对应的值，由于 &#x27;grape&#x27; 不在字典中，返回默认值 0</span><br><span class="line">print(fruits.get(&#x27;grape&#x27;, 0))  # 输出: 0</span><br><span class="line"></span><br><span class="line"># 不提供默认值，&#x27;grape&#x27; 不在字典中，返回 None</span><br><span class="line">print(fruits.get(&#x27;grape&#x27;))  # 输出: None</span><br><span class="line"></span><br><span class="line"># 可以省略默认值参数，将返回 None</span><br><span class="line">print(fruits.get(&#x27;kiwi&#x27;))  # 输出: None</span><br></pre></td></tr></table></figure><h4 id="6-集合-set"><a href="#6-集合-set" class="headerlink" title="6.集合(set)"></a>6.集合(set)</h4><p>重复的元素在set中会被自动过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s=set([1,2,2,3,3])#创建一个set，使用list作为输入集合</span><br><span class="line">print(s)#输出&#123;1, 2, 3&#125;，相同的元素被过滤</span><br><span class="line">s.add(4)#向集合中添加元素</span><br><span class="line">s.remove(1)</span><br><span class="line">print(s)#输出&#123;2，3，4&#125;</span><br><span class="line">s2=set([1,2,3])</span><br><span class="line">print(s&amp;s2)#集合取交集</span><br><span class="line">print(s|s2)#集合取并集</span><br></pre></td></tr></table></figure><h4 id="7-字符串（str"><a href="#7-字符串（str" class="headerlink" title="7.字符串（str)"></a>7.字符串（str)</h4><p>str是不可变对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=&#x27;abc&#x27;</span><br><span class="line">print(a.replace(&#x27;a&#x27;,&#x27;A&#x27;))#输出Abc</span><br><span class="line">print(a)#输出abc,不可变对象本身永远是不可变的</span><br></pre></td></tr></table></figure><h4 id="8-函数的默认参数"><a href="#8-函数的默认参数" class="headerlink" title="8.函数的默认参数"></a>8.函数的默认参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def enroll(name, gender, age=6, city=&#x27;Beijing&#x27;):#把年龄和城市设为默认参数</span><br><span class="line">    print(&#x27;name:&#x27;, name)</span><br><span class="line">    print(&#x27;gender:&#x27;, gender)</span><br><span class="line">    print(&#x27;age:&#x27;, age)</span><br><span class="line">    print(&#x27;city:&#x27;, city)</span><br><span class="line"></span><br><span class="line">#只有与默认参数不符的学生才需要提供额外的信息</span><br><span class="line">enroll(&#x27;Bob&#x27;, &#x27;M&#x27;, 7)</span><br><span class="line">enroll(&#x27;Adam&#x27;, &#x27;M&#x27;, city=&#x27;Tianjin&#x27;)#不按顺序提供部分默认参数时，需要把参数名写上</span><br></pre></td></tr></table></figure><h4 id="9-函数的可变参数"><a href="#9-函数的可变参数" class="headerlink" title="9.函数的可变参数"></a>9.函数的可变参数</h4><p>可变参数就是函数传入的参数个数是可变的</p><p><u>注：可变参数通过创建一个元组将传入的参数封装到元组中，即使函数只收到一个值也是如此。</u></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def calc(*numbers):#计算：a*a+b*b+c*c+……</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers:#numbers是元组</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum</span><br><span class="line"></span><br><span class="line">print(calc(1, 2))</span><br><span class="line">nums = [1, 2, 3]</span><br><span class="line">print(calc(*nums))#在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去</span><br></pre></td></tr></table></figure><h4 id="10-函数upper-、title-、lower"><a href="#10-函数upper-、title-、lower" class="headerlink" title="10.函数upper()、title()、lower()"></a>10.函数upper()、title()、lower()</h4><p>upper():全字母大写</p><p>title():首字母大写</p><p>lower():全字母小写</p><p><u>注：以上方法是非永久性改变，不会改变变量的值</u></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cars=[&#x27;audi&#x27;,&#x27;bmw&#x27;,&#x27;subaru&#x27;,&#x27;toyota&#x27;]</span><br><span class="line">for car in cars:</span><br><span class="line">    if car==&#x27;bmw&#x27;:</span><br><span class="line">        print(car.upper())#car为bmw时以大写输出</span><br><span class="line">    else:</span><br><span class="line">        print(car.title())</span><br></pre></td></tr></table></figure><h4 id="11-函数的列表参数"><a href="#11-函数的列表参数" class="headerlink" title="11.函数的列表参数"></a>11.函数的列表参数</h4><p>列表作为参数传给函数，函数可以对列表做出永久性修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def fun(List):</span><br><span class="line">    i=0</span><br><span class="line">    for x in List:</span><br><span class="line">        List[i]=x.lower()</span><br><span class="line">        i+=1</span><br><span class="line">List=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span><br><span class="line">fun(List)</span><br><span class="line">print(List)#输出[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure><p>传入列表的副本，原始列表不做修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def fun(List):</span><br><span class="line">    i=0</span><br><span class="line">    for x in List:</span><br><span class="line">        List[i]=x.lower()</span><br><span class="line">        i+=1</span><br><span class="line">List=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span><br><span class="line">fun(List[:])#切片表示法创建副本</span><br><span class="line">print(List)#输出[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br></pre></td></tr></table></figure><h4 id="12-列表生成式"><a href="#12-列表生成式" class="headerlink" title="12.列表生成式"></a>12.列表生成式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print([x * x for x in range(1, 11) if x % 2 == 0]) #筛选出仅偶数的平方</span><br><span class="line"></span><br><span class="line">print([m + n for m in &#x27;ABC&#x27; for n in &#x27;XYZ&#x27;])#使用两层循环，可以生成全排列</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">print([d for d in os.listdir(&#x27;.&#x27;)])#列出当前目录下的所有文件和目录名</span><br><span class="line"></span><br><span class="line">print([x if x % 2 == 0 else -x for x in range(1, 5)])#生成表达式的if……else……，输出[-1, 2, -3, 4]</span><br></pre></td></tr></table></figure><h4 id="13-split-函数"><a href="#13-split-函数" class="headerlink" title="13.split()函数"></a>13.split()函数</h4><p><strong>split():</strong>通过指定分隔符对字符串进行切片，将字符串切片后的结果存放在列表中。</p><p><strong>str.split(str=””, num=string.count(str))</strong></p><ul><li>str — 分隔符，默认为空白格。</li><li>num — 分割次数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;Line1-abcdef,\nLine2-abc,\nLine4-abcd&quot;</span><br><span class="line">str.split(&#x27;,&#x27;)</span><br><span class="line">out:</span><br><span class="line">[&#x27;Line1-abcdef&#x27;, &#x27;\nLine2-abc&#x27;, &#x27;\nLine4-abcd&#x27;]</span><br><span class="line"></span><br><span class="line">str = &quot;Line1-abcdef \nLine2-abc \nLine4-abcd&quot;</span><br><span class="line">str.split( )</span><br><span class="line">str.split(&#x27; &#x27;, 1 )#分割次数为1次</span><br><span class="line">out:</span><br><span class="line">[&#x27;Line1-abcdef&#x27;, &#x27;Line2-abc&#x27;, &#x27;Line4-abcd&#x27;]#以空白格分割，自动去除回车</span><br><span class="line">[&#x27;Line1-abcdef&#x27;, &#x27;\nLine2-abc \nLine4-abcd&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>rstrip():</strong> 删除字符串末尾的指定字符,默认为空白符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#分割字符串列表</span><br><span class="line">str=[&#x27;1,a\n&#x27;,&#x27;2,b\n&#x27;,&#x27;3,c\n&#x27;]</span><br><span class="line">tokens=[l.rstrip().split(&#x27;,&#x27;) for l in str]</span><br><span class="line">tokens</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">[[&#x27;1&#x27;, &#x27;a&#x27;], [&#x27;2&#x27;, &#x27;b&#x27;], [&#x27;3&#x27;, &#x27;c&#x27;]]</span><br></pre></td></tr></table></figure><h4 id="14-文件操作函数"><a href="#14-文件操作函数" class="headerlink" title="14.文件操作函数"></a>14.文件操作函数</h4><p><strong>os.makedirs():</strong> 这是一个用于递归创建目录的函数。它接受一个路径作为输入，并创建路径中所有缺失的目录</p><p><strong>exist_ok=True:</strong> 这是os.makedirs()函数的一个可选参数。当设置为True时，如果目标目录已经存在，函数不会引发错误，而是默默地继续执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.makedirs(os.path.join(&#x27;..&#x27;, &#x27;data&#x27;), exist_ok=True)#创建一个名为&quot;data&quot;的目录，该目录位于当前工作目录的父目录中</span><br></pre></td></tr></table></figure><p><strong>shutil.copy():</strong>用于将源文件的内容复制到目标文件或目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutil.copy(filename, target_dir)#将filename文件复制到target_dir目录中。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>comments</title>
      <link href="/comments/index.html"/>
      <url>/comments/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
